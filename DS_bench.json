{"problem_id": "numpy_0", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the response curve of a camera based on given intensity samples and their corresponding logarithmic exposures. The response curve is essential for understanding how a camera sensor translates light intensity into pixel values.\nThe implementation should implement a least-squares system  A x = b, x = [ g(0)\u2026g(255) | ln E\u2080 \u2026 ln E_{N-1} ]\u1d40 with a data-fitting term for every sample and a smoothness term for every\nz in 1 to 254, plus one constraint fixing g(128) = 0 to make the system well-posed.\nThe function signature for the main code is as follows:\n\n```python\ndef computeResponseCurve(intensity_samples, log_exposures, smoothing_lambda):\n```\n\n### Constants Used:\n- `z_min`: 0\n- `z_max`: 255\n- `intensity_range`: 255\n\n\n### Input Format:\n- `intensity_samples`: A 2D NumPy array of shape (num_samples, num_images) containing intensity values.\n- `log_exposures`: A list of logarithmic exposure values corresponding to each image.\n- `smoothing_lambda`: A float value that controls the degree of smoothing applied to the response curve.\n\n### Output Format:\n- The function returns a one-dimensional NumPy array representing the response curve of the camera.\n\nInput:\n```python\nintensity_samples = np.array([[100, 150, 200],\n                               [120, 130, 140],\n                               [255, 0, 50]])\nlog_exposures = np.array([-0.5, 0.0, 1.0])\nsmoothing_lambda = 5.0\n```\n\nOutput:\n```python\narray([-3.86030280e+00, -3.84288676e+00, -3.82546449e+00, -3.80802979e+00, -3.79057643e+00, ..., -3.45985091e+00, -3.88820401e+00, -4.31818342e+00])\n```\ntotal length 256", "ground_truth_code": "import numpy as np\n\n\ndef weighting_function(z):\n    if z < 128:\n        return 1.0\n    else:\n        return 1.0 / (1 + (z - 128) ** 2)\n\n\n# main code\ndef computeResponseCurve(intensity_samples, log_exposures, smoothing_lambda):\n\n    (z_min, z_max) = (0, 255)\n    intensity_range = 255\n    num_samples = intensity_samples.shape[0]\n    num_images = len(log_exposures)\n    mat_A = np.zeros((num_images * num_samples + intensity_range, num_samples + intensity_range + 1), dtype=np.float64)\n    mat_b = np.zeros((mat_A.shape[0], 1), dtype=np.float64)\n    k = 0\n    for i in range(num_samples):\n        for j in range(num_images):\n            z_ij = intensity_samples[i, j]\n            w_ij = weighting_function(z_ij)\n            mat_A[k, z_ij] = w_ij\n            mat_A[k, intensity_range + 1 + i] = -w_ij\n            mat_b[k, 0] = w_ij * log_exposures[j]\n            k += 1\n    for z_k in range(z_min + 1, z_max):\n        w_k = weighting_function(z_k)\n        mat_A[k, z_k - 1] = w_k * smoothing_lambda\n        mat_A[k, z_k] = -2 * w_k * smoothing_lambda\n        mat_A[k, z_k + 1] = w_k * smoothing_lambda\n        k += 1\n    mat_A[k, (z_max - z_min) // 2] = 1\n    inv_A = np.linalg.pinv(mat_A)\n    x = np.dot(inv_A, mat_b)\n    g = x[0:intensity_range + 1]\n    return g[:, 0]", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(1, 21)\n        num_images = np.random.randint(1, 11)\n\n        intensity_samples = np.random.randint(0, 256, size=(num_samples, num_images))\n        log_exposures = np.random.uniform(-1.0, 2.0, num_images)\n        smoothing_lambda = np.random.uniform(0.1, 10.0)\n        test_cases.append((intensity_samples, log_exposures, smoothing_lambda,))\n\n    return test_cases"}
{"problem_id": "numpy_1", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes a radiance map from a set of images taken at different exposure times. The function will utilize a response curve and a weighting function to accurately estimate the radiance values for each pixel in the images.\n\nFunction signature:\n```python\ndef computeRadianceMap(images, log_exposure_times, response_curve, weighting_function):\n```\n\nConstant used in the main code:\n- The constant `num_images` represents the total number of images provided as input.\n\nInput format:\n- `images`: A list of 2D numpy arrays (shape: [num_images, height, width]).\n- `log_exposure_times`: A 1D numpy array of length `num_images`.\n- `response_curve`: A 1D numpy array representing the response curve.\n- `weighting_function`: A callable function that takes a pixel intensity and returns a weight.\n\nOutput format:\n- Returns a 2D numpy array (shape: [height, width]) representing the computed radiance map.\n\n**Input:**\n```python\nimages = [\n    np.array([[100, 150], [200, 250]], dtype=np.uint8),\n    np.array([[110, 160], [210, 240]], dtype=np.uint8),\n    np.array([[120, 170], [220, 230]], dtype=np.uint8)\n]\nlog_exposure_times = np.array([-1.0, 0.0, 1.0])\nresponse_curve = np.random.uniform(0, 5, 256)\n\ndef weighting_function(value):\n    return value / 255.0\n```\n\n**Output:**\n```python\nimg_rad_map = computeRadianceMap(images, log_exposure_times, response_curve, weighting_function)\n```\n\n(Note: The actual output `img_rad_map` will be a 2x2 array of float values, which will vary based on the randomly generated `response_curve`.)", "ground_truth_code": "import numpy as np\n\n# main code\ndef computeRadianceMap(images, log_exposure_times, response_curve, weighting_function):\n    img_shape = images[0].shape\n    img_rad_map = np.zeros(img_shape, dtype=np.float64)\n    num_images = len(images)\n    for i in range(img_shape[0]):\n        for j in range(img_shape[1]):\n            g = np.array([response_curve[images[k][i, j]] for k in range(num_images)])\n            w = np.array([weighting_function(images[k][i, j]) for k in range(num_images)])\n            SumW = np.sum(w)\n            if SumW > 0:\n                img_rad_map[i, j] = np.sum(w * (g - log_exposure_times) / SumW)\n            else:\n                img_rad_map[i, j] = g[num_images // 2] - log_exposure_times[num_images // 2]\n    return img_rad_map", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        height = np.random.randint(1, 100)\n        width = np.random.randint(1, 100)\n        num_images = np.random.randint(2, 10)\n        images = [np.random.randint(0, 256, (height, width), dtype=np.uint8) for _ in range(num_images)]\n\n        log_exposure_times = np.random.uniform(-2, 3, num_images)\n        response_curve = np.random.uniform(0, 5, 256)\n\n        def weighting_function(value):\n            return value / 255.0\n\n        test_cases.append((images, log_exposure_times, response_curve, weighting_function))\n    \n    return test_cases\n"}
{"problem_id": "numpy_2", "library": "numpy", "code_problem": "You are tasked with implementing a function that prepares a dataset for training and testing a machine learning model. The function will take a dataset and split it into training and testing sets based on a specified sequence length and a percentage for the training split. The function will also reshape the data into a format suitable for time series analysis.\n\nFunction signature:\n```python\ndef prepare_test_train(data, features, predictions, sequence_length, split_percent=0.9):\n```\n\nConstants used in the main code:\n- `split_percent`: This constant determines the proportion of the dataset to be used for training. It defaults to 0.9, meaning 90% of the data will be used for training and 10% for testing.\n\n\nInput format:\n- `data`: A DataFrame containing the dataset.\n- `features`: A list of strings representing the names of the feature columns.\n- `predictions`: A list of strings representing the names of the prediction columns.\n- `sequence_length`: An integer indicating the length of the sequences to create.\n- `split_percent`: A float indicating the percentage of data to use for training (default is 0.9).\n\nOutput format:\n- The function returns a tuple containing:\n  - `X_train`: A NumPy array of shape (number of training sequences, sequence_length, number of features).\n  - `y_train`: A NumPy array of shape (number of training sequences, number of predictions).\n  - `X_test`: A NumPy array of shape (number of testing sequences, sequence_length, number of features).\n  - `y_test`: A NumPy array of shape (number of testing sequences, number of predictions).\n  - `row`: An integer representing the number of rows used for training.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\ndata = pd.DataFrame({\n    'feature1': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6],\n    'feature2': [1.1, 1.2, 1.3, 1.4, 1.5, 1.6],\n    'target1': [2.1, 2.2, 2.3, 2.4, 2.5, 2.6]\n})\n\nfeatures = ['feature1', 'feature2']\npredictions = ['target1']\nsequence_length = 3\nsplit_percent = 0.8\n```\n\n**Output:**\n```python\n# Expected output\nX_train = np.array([[[0.1, 1.1],\n                      [0.2, 1.2],\n                      [0.3, 1.3]],\n\n                     [[0.2, 1.2],\n                      [0.3, 1.3],\n                      [0.4, 1.4]],\n\n                     [[0.3, 1.3],\n                      [0.4, 1.4],\n                      [0.5, 1.5]]])\n\ny_train = np.array([[2.3],\n                    [2.4],\n                    [2.5]])\n\nX_test = np.array([[[0.4, 1.4],\n                     [0.5, 1.5],\n                     [0.6, 1.6]]])\n\ny_test = np.array([[2.6]])\n\nrow = 3\n```\n\n### Explanation:\n- The input consists of a small DataFrame with 6 rows and 3 columns (2 features and 1 target).\n- The sequence length is set to 3, which means we will create sequences of 3 time steps.\n- The split percentage is set to 0.8, meaning 80% of the sequences will be used for training and the remaining 20% for testing.\n- The output arrays `X_train`, `y_train`, `X_test`, and `y_test` are structured according to the expected shapes after processing the input data through the `prepare_test_train` function.", "ground_truth_code": "import numpy as np\n\n# main code\ndef prepare_test_train(data, features, predictions, sequence_length, split_percent=0.9):\n    num_features = len(features)\n    num_predictions = len(predictions)\n    columns = features + predictions\n    data = data[columns].values\n\n    result = [data[index:index + sequence_length] for index in range(len(data) - sequence_length + 1)]\n    result = np.array(result)\n\n    row = round(split_percent * result.shape[0])\n    train = result[:row, :]\n\n    X_train = np.reshape(train[:, :, :-num_predictions], (train.shape[0], train.shape[1], num_features))\n    y_train = np.reshape(train[:, -1, -num_predictions:], (train.shape[0], num_predictions))\n    X_test = np.reshape(result[row:, :, :-num_predictions], (result.shape[0] - row, result.shape[1], num_features))\n    y_test = np.reshape(result[row:, -1, -num_predictions:], (result.shape[0] - row, num_predictions))\n\n    return X_train, y_train, X_test, y_test, row", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_input = []\n\n    for _ in range(n):\n        num_features = random.randint(2, 10)\n        num_predictions = random.randint(1, 4)\n        features = [f'feature{i + 1}' for i in range(num_features)]\n        predictions = [f'target{i + 1}' for i in range(num_predictions)]\n        sequence_length = random.randint(1, min(10, 10))\n        num_rows = sequence_length + random.randint(0, 100)\n        data = pd.DataFrame(np.random.rand(num_rows, num_features + num_predictions), columns=features + predictions)\n        split_percent = random.uniform(0.5, 0.9)\n        test_input.append((data, features, predictions, sequence_length, split_percent))\n\n    return test_input"}
{"problem_id": "numpy_3", "library": "numpy", "code_problem": "You are tasked with determining whether all elements in a given array `x` fall within the same order of magnitude when considering a specified tolerance. The function should return a boolean value indicating whether the elements of the array are within the same logarithmic scale, adjusted by a delta value.\n\nFunction signature:\n```python\ndef same_log10_order_of_magnitude(x, delta=0.1):\n```\n\nConstant used in the main code:\n- `delta`: This is a floating-point value that represents the tolerance for the order of magnitude comparison. The default value is set to `0.1`.\n\nInput format:\n- The function takes an array-like structure `x` (e.g., a list or a NumPy array) as the first argument and an optional floating-point number `delta` as the second argument.\n\nOutput format:\n- The function returns a boolean value: `True` if all elements in `x` are within the same order of magnitude considering the delta, and `False` otherwise.\n\n```python\n# Input\n([0.1, 0.2, 0.15, 0.12], 0)\n\n# Output\nTrue\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef same_log10_order_of_magnitude(x, delta=0.1):\n    dmin = np.log10(np.min(x) * (1 - delta))\n    dmax = np.log10(np.max(x) * (1 + delta))\n    return np.floor(dmin) == np.floor(dmax)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        delta = random.uniform(0.01, 0.99)\n        size = random.randint(2, 10)\n        if random.choice([True, False]):\n            base = random.uniform(1e-5, 1e5)\n            test_case = [base * (1 + random.uniform(-delta, delta)) for _ in range(size)]\n        else:\n            min_order = random.randint(0, 5)\n            max_order = min_order + random.randint(1, 5)\n            test_case = [random.uniform(10**min_order, 10**max_order) for _ in range(size)]\n        test_case = sorted(test_case)\n        test_cases.append((test_case, delta))\n    \n    return test_cases"}
{"problem_id": "numpy_4", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs a horizontal stretch\u2014-or a compression if the scaling factor is below 1\u2014-on selected nodes within a spatial configuration. The function takes the indices of a target node and its parent node, a scaling factor, the current location matrix, and a connection matrix containing NaNs where no edge exists. It first identifies all nodes connected to both the target and the parent; for each of these nodes, it decomposes their position into components parallel and perpendicular to the line from the parent to the target. The parallel component is left unchanged, while the perpendicular component is multiplied by the scaling factor, effectively stretching or compressing their positions sideways relative to that axis. The updated coordinates are written back into the original location matrix, which the function then returns.\n\nFunction Signature:\n```python\ndef horizental_stretch(node_index: int, parent_node: int, scale: float, location: np.ndarray, connection: np.ndarray) -> np.ndarray:\n```\n\nConstants Used:\n- The constant used in the main code is the scaling factor `scale`, which determines how much the nodes will be stretched.\n\nInput Format:\n- `node_index`: An integer representing the index of the node to be stretched.\n- `parent_node`: An integer representing the index of the parent node.\n- `scale`: A float representing the scaling factor for the stretch transformation.\n- `location`: A 2D NumPy array where each column represents the coordinates of a node.\n- `connection`: A 2D NumPy array representing the connections between nodes, where NaN indicates no connection.\n\nOutput Format:\n- The function returns a 2D NumPy array representing the updated locations of the nodes after the horizontal stretch transformation has been applied.\n\n**Input:**\n```python\nnode_index = 3\nparent_node = 1\nscale = 1.5\nlocation = np.array([[1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0],\n                     [1.0, 2.0, 3.0, 4.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]])\nconnection = np.array([[np.nan, 0.5, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [0.5, np.nan, 0.3, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, 0.3, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan],\n                       [np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan, np.nan]])\n```\n\n**Output:**\n```python\narray([[1.0, 2.0, 3.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0],\n       [1.0, 2.0, 3.0, 5.0, 5.0, 6.0, 7.0, 8.0, 9.0, 10.0]])\n```\n\n### Explanation:\n- The `node_index` is 3, which means we are modifying the location of the 4th node.\n- The `parent_node` is 1, which means we are using the location of the 2nd node as a reference.\n- The `scale` is set to 1.5, indicating a horizontal stretch.\n- The `location` array represents the initial positions of the nodes.\n- The `connection` matrix indicates which nodes are connected, with some connections being defined (e.g., between nodes 1 and 2).\n\nThe output shows the updated locations after applying the horizontal stretch based on the specified parameters.", "ground_truth_code": "import numpy as np\nfrom numpy import linalg as LA\n\n# main code\ndef horizental_stretch(node_index, parent_node, scale, location, connection):\n    up = np.where(~np.isnan(connection[node_index, :]))[0]\n    down = np.where(~np.isnan(connection[:, parent_node]))[0]\n    I = np.intersect1d(up, down)\n    if I.size == 0:\n        return location\n    loc = location[:, parent_node]\n    A = location[:, I] - loc[:, None]\n    if A.shape[1] == 0:\n        return location\n    r = (location[:, node_index] - loc) / LA.norm(location[:, node_index] - loc, 2)\n    r = r.reshape(-1, 1)\n    A_new = scale * A + (1 - scale) * np.dot(r, np.dot(r.T, A))\n    location[:, I] = A_new + loc[:, None]\n    return location", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    num_nodes = 10\n\n    for _ in range(n):\n        connection = np.full((num_nodes, num_nodes), np.nan)\n        for i in range(num_nodes):\n            for j in range(i + 1, num_nodes):\n                if np.random.rand() > 0.7:\n                    connection[i, j] = connection[j, i] = np.random.rand()\n        location = np.random.rand(2, num_nodes) * 10\n        node_index = np.random.randint(0, num_nodes)\n        parent_node = np.random.choice([i for i in range(num_nodes) if i != node_index])\n        scale = np.random.uniform(0.5, 2.0)\n\n        test_cases.append((node_index, parent_node, scale, location.copy(), connection.copy()))\n\n    return test_cases"}
{"problem_id": "numpy_5", "library": "numpy", "code_problem": "You are tasked with generating random unit vectors in three-dimensional space based on a specified distribution for the zenith angles. The function should allow the user to specify the number of vectors to generate, the deviation for the zenith angles, and the type of distribution to use for generating these angles.\n\nFunction signature:\n```python\ndef sample_unit_vectors(n, dev_d, dist_d='vonmises'):\n```\n\nConstant used in the main code:\n- The constant value used in the main code is `2 * np.pi`, which is used to scale the azimuth angles.\n\n\nInput format:\n- The function accepts three parameters:\n  - An integer `n` representing the number of unit vectors to generate.\n  - A float `dev_d` representing the deviation for the zenith angle distribution.\n  - An optional string `dist_d` representing the type of distribution to use for generating the zenith angles.\n\nOutput format:\n- The function returns a NumPy array of shape (n, 3), where each row contains the x, y, and z coordinates of a unit vector.\n\n```python\nInput: (150, 2.3, 'normal')\nOutput: array([[-0.43655352, -0.24806926, -0.8648021 ],\n                [ 0.63294568, -0.57620162, -0.51707974],\n                ...,\n                [ 0.00917223,  0.02954106,  0.99952148]])\n``` \n\n(Note: The actual output will be a 150x3 numpy array with random values based on the input parameters.)", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef sample_unit_vectors(n, dev_d, dist_d='vonmises'):\n    distributions = {\n        'vonmises': np.random.vonmises,\n        'uniform': lambda loc, scale, size: np.random.rand(size) * scale,\n        'normal': np.random.normal\n    }\n\n    zenith = distributions.get(dist_d, np.random.vonmises)(0, dev_d, n)\n    azimuth = np.random.rand(n) * np.pi * 2\n    z = np.cos(zenith)\n    x = np.sin(zenith) * np.cos(azimuth)\n    y = np.sin(zenith) * np.sin(azimuth)\n\n    return np.stack([x, y, z], axis=-1)\n", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    dev_d_values = [random.uniform(0.1, 5.0) for _ in range(n)]\n    distribution_types = ['vonmises', 'uniform', 'normal']\n\n    for i in range(n):\n        n_value = random.randint(1, 1000)\n        dev_d = dev_d_values[i]\n        dist_d = random.choice(distribution_types)\n        test_cases.append((n_value, dev_d, dist_d))\n\n    return test_cases"}
{"problem_id": "numpy_6", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes a given signal represented as a NumPy array. The function should identify and label the peaks and valleys in the signal, and optionally interpolate these points based on specified parameters. The function signature is as follows:\n\n```python\ndef _post_processing(X, Xraw, min_peaks, max_peaks, interpolate, lookahead):\n```\n\n### Constants:\n- `np.nan`: This constant is used to initialize arrays with NaN values, indicating missing or undefined data.\n\n### Input Format:\n- `X`: A NumPy array representing the signal data.\n- `Xraw`: A NumPy array representing the raw signal data.\n- `min_peaks`: A list of tuples, where each tuple contains the indices of the minimum peaks.\n- `max_peaks`: A list of tuples, where each tuple contains the indices of the maximum peaks.\n- `interpolate`: A boolean flag indicating whether to perform interpolation on the peaks and valleys.\n- `lookahead`: An integer specifying the range to look ahead for peak/valley correction.\n\n### Output Format:\n- The function returns a dictionary containing:\n  - `'min_peaks_s'`: A NumPy array of the scaled minimum peaks and their corresponding values.\n  - `'max_peaks_s'`: A NumPy array of the scaled maximum peaks and their corresponding values.\n  - `'xs'`: A NumPy array of indices corresponding to the length of `Xraw`.\n  - `'labx_s'`: An array of labels for segments in `X`.\n  - `'labx'`: An array of labels for segments in `Xraw` (if interpolation is performed).\n  - `'min_peaks'`: A NumPy array of corrected minimum peaks and their corresponding values (if interpolation is performed).\n  - `'max_peaks'`: A NumPy array of corrected maximum peaks and their corresponding values (if interpolation is performed).\n\nInput:\n```python\nX = np.array([1.0, 2.0, 1.5, 3.0, 2.5, 4.0, 3.5])\nXraw = np.array([1.0, 2.0, 1.5, 3.0, 2.5, 4.0, 3.5])\nmin_peaks = [[2, 1.5], [4, 2.5]]\nmax_peaks = [[1, 2.0], [5, 4.0]]\ninterpolate = 1\nlookahead = 2\n```\n\nOutput:\n```python\n{\n    'labx': array([1., 1., 2., 2., 3., 3., 3.]),\n    'labx_s': array([1., 1., 2., 2., 3., 3., 3.]),\n    'max_peaks': array([[1., 2.],[5., 4.]]),\n    'max_peaks_s': array([[1., 2.],[5., 4.]]),\n    'min_peaks': array([[0. , 1. ],[0. , 1. ],[2. , 1.5],[4. , 2.5]]),\n    'min_peaks_s': array([[0. , 1. ],[2. , 1.5],[4. , 2.5],[6. , 3.5]]),\n    'xs': array([0, 1, 2, 3, 4, 5, 6])\n}\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef _post_processing(X, Xraw, min_peaks, max_peaks, interpolate, lookahead):\n    labx_s = np.full(len(X), np.nan)\n    results = {\n        'min_peaks_s': None,\n        'max_peaks_s': None,\n        'xs': np.arange(len(Xraw)),\n        'labx_s': labx_s,\n        'labx': np.full(len(Xraw), np.nan),\n        'min_peaks': None,\n        'max_peaks': None\n    }\n\n    if len(min_peaks) > 0 and len(max_peaks) > 0 and max_peaks[0]:\n        idx_peaks = np.array([p[0] for p in max_peaks], dtype=int)\n        idx_valleys = np.array([p[0] for p in min_peaks], dtype=int)\n        idx_valleys = np.concatenate(([0], idx_valleys, [len(X) - 1]))\n\n        count = 1\n        for i in range(len(idx_valleys) - 1):\n            if idx_valleys[i] != idx_valleys[i + 1]:\n                labx_s[idx_valleys[i]:idx_valleys[i + 1] + 1] = count\n                count += 1\n\n        if interpolate:\n            min_peaks_scaled = np.clip(np.ceil(idx_valleys / len(X) * len(Xraw)).astype(int), 0, len(Xraw) - 1)\n            max_peaks_scaled = np.clip(np.ceil(idx_peaks / len(X) * len(Xraw)).astype(int), 0, len(Xraw) - 1)\n\n            max_peaks_corr = [\n                np.arange(max(peak - lookahead, 0), min(peak + lookahead, len(Xraw)))[np.argmax(Xraw[max(peak - lookahead, 0):min(peak + lookahead, len(Xraw))])]\n                for peak in max_peaks_scaled\n            ]\n            min_peaks_corr = [\n                np.arange(max(peak - lookahead, 0), min(peak + lookahead, len(Xraw)))[np.argmin(Xraw[max(peak - lookahead, 0):min(peak + lookahead, len(Xraw))])]\n                for peak in min_peaks_scaled\n            ]\n\n            labx = np.full(len(Xraw), np.nan)\n            count = 1\n            for i in range(len(min_peaks_scaled) - 1):\n                if min_peaks_scaled[i] != min_peaks_scaled[i + 1]:\n                    labx[min_peaks_scaled[i]:min_peaks_scaled[i + 1] + 1] = count\n                    count += 1\n\n            results.update({\n                'labx': labx,\n                'min_peaks': np.c_[min_peaks_corr, Xraw[min_peaks_corr]],\n                'max_peaks': np.c_[max_peaks_corr, Xraw[max_peaks_corr]]\n            })\n\n        results['min_peaks_s'] = np.c_[idx_valleys, X[idx_valleys]]\n        results['max_peaks_s'] = np.c_[idx_peaks, X[idx_peaks]]\n        results['labx_s'] = labx_s\n\n    return results", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        length = random.randint(5, 100)\n        Xraw = np.random.uniform(-10, 10, size=length)\n        X = np.array(Xraw)\n        num_min_peaks = random.randint(1, length // 4)\n        num_max_peaks = random.randint(1, length // 4)\n        min_peaks_indices = sorted(random.sample(range(length), num_min_peaks))\n        max_peaks_indices = sorted(random.sample(range(length), num_max_peaks))\n\n        while (len(min_peaks_indices) > 1 and\n               any(abs(min_peaks_indices[i] - min_peaks_indices[i - 1]) <= 1 for i in range(1, len(min_peaks_indices)))):\n            min_peaks_indices = sorted(random.sample(range(length), num_min_peaks))\n\n        while (len(max_peaks_indices) > 1 and\n               any(abs(max_peaks_indices[i] - max_peaks_indices[i - 1]) <= 1 for i in range(1, len(max_peaks_indices)))):\n            max_peaks_indices = sorted(random.sample(range(length), num_max_peaks))\n        min_peaks_list = [[idx, X[idx]] for idx in min_peaks_indices]\n        max_peaks_list = [[idx, X[idx]] for idx in max_peaks_indices]\n        interpolate = random.randint(0, 1)\n        lookahead = random.randint(1, 5)\n        test_cases.append((X, Xraw, min_peaks_list, max_peaks_list, interpolate, lookahead))\n\n    return test_cases\n"}
{"problem_id": "numpy_7", "library": "numpy", "code_problem": "You are tasked with implementing a function that converts sequences of characters or labels into their corresponding numerical representations, while also applying padding to ensure that all sequences have a uniform length. This function will be particularly useful in natural language processing tasks where input data needs to be transformed into a format suitable for machine learning models.\n\nFunction signature:\n```python\ndef _doc2ids(label_one_hot: bool, s2_label_dict: dict, data_list: dict, maxlen: int, s2_label: bool, char2idx: dict, ftype: int) -> dict:\n```\n\nConstant used in the main code:\n- The constant value `1` is used as a default index for characters or labels that are not found in the provided dictionaries (`char2idx` or `s2_label_dict`).\n\nInput format:\n- `label_one_hot`: A boolean indicating whether to use one-hot encoding for labels.\n- `s2_label_dict`: A dictionary mapping sequences to their corresponding indices.\n- `data_list`: A dictionary where keys are identifiers and values are lists of sequences.\n- `maxlen`: An integer specifying the maximum length for padding sequences.\n- `s2_label`: A boolean indicating whether to use the `s2_label_dict` for conversion.\n- `char2idx`: A dictionary mapping characters to their corresponding indices.\n- `ftype`: An integer indicating the type of data being processed.\n\nOutput format:\n- The function returns a dictionary where keys are the same as those in `data_list`, and values are NumPy arrays of converted and padded sequences.\n\n**Input:**\n```python\n(\n    True, \n    {'label_0': 1, 'label_1': 2, 'label_2': 3, 'label_3': 4, 'label_4': 5, 'label_5': 6, 'label_6': 7, 'label_7': 8, 'label_8': 9, 'label_9': 10}, \n    {\n        'label': ['0', '1', '2'], \n        'text': ['hello', 'world'], \n        's2': ['label_1', 'label_2']\n    }, \n    10, \n    True, \n    {'a': 2, 'b': 3, 'c': 4, 'd': 5, 'e': 6, 'f': 7, 'g': 8, 'h': 9, 'i': 10, 'j': 11, 'k': 12, 'l': 13, 'm': 14, 'n': 15, 'o': 16, 'p': 17, 'q': 18, 'r': 19, 's': 20, 't': 21, 'u': 22, 'v': 23, 'w': 24, 'x': 25, 'y': 26, 'z': 27}, \n    1\n)\n```\n\n**Output:**\n```python\n{\n    'label': array([[1., 0., 0.],[0., 1., 0.],[0., 0., 1.]]),\n    'text': array([[ 9,  6, 13, 13, 16,  0,  0,  0,  0,  0], [24, 16, 19, 13,  5,  0,  0,  0,  0,  0]]),\n    's2': array([[13,  2,  3,  6, 13,  1,  1,  0,  0,  0], [13,  2,  3,  6, 13,  1,  1,  0,  0,  0]])\n}\n```\n\n### Explanation:\n- The input consists of a boolean for one-hot encoding, a dictionary mapping labels to integers, a data list containing sequences for 'label', 'text', and 's2', a maximum length for padding, a boolean for s2 labels, a character to index mapping, and a file type.\n- The output is a dictionary where each key corresponds to the input fields ('label', 'text', 's2') and the values are numpy arrays representing the processed sequences according to the logic defined in the `_doc2ids` function.", "ground_truth_code": "import numpy as np\n\n\ndef padding(x, maxlen=50, pvalue=0):\n    return x[:maxlen] if len(x) >= maxlen else x + [pvalue] * (maxlen - len(x))\n\n# main code\ndef _doc2ids(label_one_hot, s2_label_dict, data_list, maxlen, s2_label, char2idx, ftype):\n    doc2ids = {}\n\n    for f, seqs in data_list.items():\n        seq2ids = []\n\n        if ftype in {1, 3}:\n            if f == 'label':\n                seq2ids = [int(seq.strip()) for seq in seqs]\n                if label_one_hot:\n                    a = np.array(seq2ids)\n                    b = np.zeros((a.size, a.max() + 1))\n                    b[np.arange(a.size), a] = 1\n                    seq2ids = b\n            else:\n                for seq in seqs:\n                    seq2id = [char2idx.get(c, 1) for c in seq]\n                    seq2id = padding(seq2id, maxlen=maxlen)\n                    seq2ids.append(np.array(seq2id))\n\n        elif ftype == 2:\n            if f == 's2' and s2_label:\n                for seq in seqs:\n                    seq2id = [s2_label_dict.get(seq.strip(), 1) for _ in seq]\n                    seq2id = padding(seq2id, maxlen=maxlen)\n                    seq2ids.append(np.array(seq2id))\n            else:\n                for seq in seqs:\n                    seq2id = [char2idx.get(c, 1) for c in seq]\n                    seq2id = padding(seq2id, maxlen=maxlen)\n                    seq2ids.append(np.array(seq2id))\n\n        doc2ids[f] = np.array(seq2ids)\n\n    return doc2ids", "test_script": "import random\nimport string\n\n\ndef test_case_input_generator(n=200):\n\n    test_cases = []\n\n    for _ in range(n):\n        label_one_hot = random.choice([True, False])\n        s2_label = random.choice([True, False])\n        maxlen = random.randint(10, 100)\n        ftype = random.choice([1, 2, 3])\n\n        char2idx = {c: i + 2 for i, c in enumerate(string.ascii_lowercase)}\n        s2_label_dict = {f'label_{i}': i + 1 for i in range(10)}\n\n        data_list = {}\n        for field in ['label', 'text', 's2']:\n            num_sequences = random.randint(1, 5)\n            if field == 'label':\n                data_list[field] = [str(random.randint(0, 9)) for _ in range(num_sequences)]\n            elif field == 's2':\n                data_list[field] = [\"label_\" + str(random.randint(0, 9)) for _ in range(num_sequences)]\n            else:\n                data_list[field] = [\"\".join(random.choices(string.ascii_lowercase, k=random.randint(5, 20))) for _ in\n                                    range(num_sequences)]\n\n        test_case = (label_one_hot, s2_label_dict, data_list, maxlen, s2_label, char2idx, ftype)\n        test_cases.append(test_case)\n\n    return test_cases\n"}
{"problem_id": "numpy_8", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the previous and next valid indexes for a given array based on a set of virtual indexes. The function should handle edge cases where the virtual indexes are out of bounds or contain NaN values.\n\nFunction signature:\n```python\ndef _get_indexes(arr: np.ndarray, virtual_indexes: np.ndarray, valid_values_count: int) -> tuple[np.ndarray, np.ndarray]:\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\nInput format:\n- `arr`: A NumPy array of any data type.\n- `virtual_indexes`: A NumPy array of floating-point numbers representing the virtual indexes.\n- `valid_values_count`: An integer representing the number of valid values in `arr`.\n\nOutput format:\n- The function returns a tuple containing two NumPy arrays:\n  - The first array contains the calculated previous indexes.\n  - The second array contains the calculated next indexes.\n\n**Input:**\n```python\narr = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], dtype=np.float32)\nvirtual_indexes = np.array([[0.5, 1.5, 2.5], [-1.0, 3.0, np.nan]], dtype=np.float32)\nvalid_values_count = 6\n```\n\n**Output:**\n```python\nprevious_indexes, next_indexes = _get_indexes(arr, virtual_indexes, valid_values_count)\n# previous_indexes: array([[ 0,  1,  2],[ 0,  3, -1]])\n# next_indexes: array([[ 1,  2,  3],[ 0,  4, -1]])\n```\n\n### Explanation:\n- For the first row of `virtual_indexes`, the values `0.5` and `1.5` correspond to indices `0` and `1`, while `2.5` exceeds the valid index range, resulting in `-1`.\n- For the second row, `-1.0` is below the valid index range, so it is set to `0`, while `3.0` exceeds the valid index range, resulting in `-1`, and `np.nan` also results in `-1`.", "ground_truth_code": "import numpy as np\n\n# main code\ndef _get_indexes(arr, virtual_indexes, valid_values_count):\n    previous_indexes = np.asanyarray(np.floor(virtual_indexes))\n    next_indexes = np.asanyarray(previous_indexes + 1)\n    indexes_above_bounds = virtual_indexes >= valid_values_count - 1\n    if indexes_above_bounds.any():\n        previous_indexes[indexes_above_bounds] = -1\n        next_indexes[indexes_above_bounds] = -1\n    indexes_below_bounds = virtual_indexes < 0\n    if indexes_below_bounds.any():\n        previous_indexes[indexes_below_bounds] = 0\n        next_indexes[indexes_below_bounds] = 0\n    if np.issubdtype(arr.dtype, np.inexact):\n        virtual_indexes_nans = np.isnan(virtual_indexes)\n        if virtual_indexes_nans.any():\n            previous_indexes[virtual_indexes_nans] = -1\n            next_indexes[virtual_indexes_nans] = -1\n    previous_indexes = previous_indexes.astype(np.intp)\n    next_indexes = next_indexes.astype(np.intp)\n    return (previous_indexes, next_indexes)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shapes = [(10,), (5, 5), (3, 4, 2), (8,)]\n        shape = shapes[np.random.choice(len(shapes), p=[0.3, 0.3, 0.2, 0.2])]\n        dtype = np.random.choice([np.float32, np.float64, np.int32, np.int64])\n        arr = np.random.random(shape).astype(dtype)\n        valid_values_count = np.random.randint(1, arr.size + 1)\n        virtual_indexes = np.random.uniform(-2, valid_values_count + 2, shape)\n        if np.issubdtype(dtype, np.inexact):\n            nan_mask = np.random.choice([True, False], size=shape, p=[0.1, 0.9])\n            virtual_indexes[nan_mask] = np.nan\n        test_cases.append((arr, virtual_indexes, valid_values_count))\n\n    return test_cases\n"}
{"problem_id": "numpy_9", "library": "numpy", "code_problem": "```python\ndef meshgrid(xi, indexing, sparse, copy_):\n```\n\nIn this code, the function `meshgrid` is designed to generate coordinate matrices from coordinate vectors. The function takes four parameters:\n\n1. `xi`: A list of 1D arrays (or sequences) that represent the coordinates along each dimension.\n2. `indexing`: A string that specifies the indexing convention to use. It can be either 'xy' for Cartesian indexing or 'ij' for matrix indexing.\n3. `sparse`: A boolean that indicates whether to return sparse output or not.\n4. `copy_`: A boolean that determines whether to return copies of the arrays or not.\n\n\n### Constant Used:\n- The constant used in the main code is `1`, which is used to create the shape tuple `s0` and to initialize the `mult_fact` array.\n\n### Input and Output Format:\n- **Input Format**: \n  - The function takes a list of 1D arrays `xi`, a string `indexing`, and two boolean values `sparse` and `copy_`.\n\n- **Output Format**: \n  - The function returns a list of arrays, either as copies or broadcasted arrays, depending on the values of `sparse` and `copy_`.\n\nInput:\n```python\n(\n    [np.array([0.1, 0.2]), np.array([1.0, 2.0])], \n    'xy', \n    False, \n    True\n)\n```\n\nOutput:\n```python\n[\n    np.array([[0.1, 0.2], [0.1, 0.2]]), \n    np.array([[1.0, 1.0], [2.0, 2.0]])\n]\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef meshgrid(xi, indexing, sparse, copy_):\n    ndim = len(xi)\n    s0 = (1,) * ndim\n    output = [np.asanyarray(x).reshape(s0[:i] + (-1,) + s0[i + 1:]) for i, x in enumerate(xi)]\n    shape = [x.size for x in output]\n\n    if indexing == 'xy' and ndim > 1:\n        output[0].shape = (1, -1) + (1,) * (ndim - 2)\n        output[1].shape = (-1, 1) + (1,) * (ndim - 2)\n        shape[0], shape[1] = shape[1], shape[0]\n\n    if sparse:\n        return [x.copy() for x in output] if copy_ else output\n\n    mult_fact = np.ones(shape, dtype=int) if copy_ else None\n    return [x * mult_fact for x in output] if copy_ else np.broadcast_arrays(*output)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        ndim = random.randint(1, 5)\n        xi = [np.random.rand(random.randint(1, 10)) for _ in range(ndim)]\n        indexing = random.choice(['xy', 'ij'])\n        sparse = random.choice([True, False])\n        copy_ = random.choice([True, False])\n\n        test_cases.append((xi, indexing, sparse, copy_))\n\n    return test_cases"}
{"problem_id": "numpy_10", "library": "numpy", "code_problem": "You are tasked with implementing a function that appends values to a given array along a specified axis. The function should handle different dimensions of the input array and ensure that the values are concatenated correctly.\n\nFunction signature:\n```python\ndef append(arr, values, axis):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `-1`, which is used to specify the last axis of the array when the `axis` parameter is set to `None`.\n\n\nInput format:\n- The function takes three parameters:\n  - `arr`: The input array (can be of any shape).\n  - `values`: The values to be appended to the array (can also be of any shape).\n  - `axis`: An integer specifying the axis along which to append the values, or `None` to append along the last axis.\n\nOutput format:\n- The function returns a NumPy array that is the result of appending `values` to `arr` along the specified `axis`. If both `arr` and `values` are empty, it returns `arr` as is.\n\nInput:\n```python\narr = np.array([[1, 2], [3, 4]])\nvalues = np.array([[5, 6]])\naxis = 0\n```\n\nOutput:\n```python\narray([[1, 2],\n       [3, 4],\n       [5, 6]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef append(arr, values, axis):\n    arr = np.asanyarray(arr)\n    if axis is None:\n        arr = arr.ravel() if arr.ndim != 1 else arr\n        values = np.ravel(values)\n        axis = arr.ndim - 1\n    return np.concatenate((arr, values), axis=axis) if arr.size or values.size else arr", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        ndim = np.random.randint(1, 5)\n        shape = tuple(np.random.randint(1, 10, size=ndim))\n        axis = np.random.randint(-ndim, ndim)\n        arr = np.random.randn(*shape)\n        values_shape = list(shape)\n        values_shape[axis] = np.random.randint(1, 10)\n        values = np.random.randn(*values_shape)\n\n        test_cases.append((arr, values, axis))\n\n    return test_cases"}
{"problem_id": "numpy_11", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the binned mode of a given list of numerical values. The binned mode is a statistical measure that identifies the most frequently occurring value within specified bins of a dataset. The function should handle cases where all values are the same and return that value as the mode.\n\nFunction Signature:\n```python\ndef binned_mode(a):\n```\n\nConstant Used:\n- The constant used in the main code is `n_bins`, which is calculated as the ceiling of the square root of the length of the input array.\n\n\nInput Format:\n- The input to the function is a list or array-like structure containing numerical values.\n\nOutput Format:\n- The output of the function is a single numerical value representing the binned mode of the input data.\n\n```python\nInput: np.array([-5.0, -3.0, -1.0, 0.0, 1.0, 3.0, 5.0])\nOutput: 0.0\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef binned_mode(a):\n    a = np.asarray(a).flatten()\n    a_min = np.min(a)\n    a_max = np.max(a)\n\n    if a_min == a_max:\n        return a_min\n\n    n_bins = np.ceil(np.sqrt(len(a)))\n    b = ((a - a_min) / (a_max - a_min) * n_bins).astype(int)\n    b = np.clip(b, 0, n_bins - 1).astype(int)\n\n    idx = np.argmax(np.bincount(b))\n    return np.percentile(a, 100 * float(idx + 0.5) / n_bins)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        array_length = np.random.randint(1, 100)\n        random_array = np.random.uniform(low=-1000, high=1000, size=array_length)\n        test_cases.append(random_array)\n\n    return test_cases\n"}
{"problem_id": "numpy_12", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs a specific type of linear transformation on a dataset. The function will compute a rotation matrix, a scaling factor, and a translation vector based on the input data points. The function signature is as follows:\n\n```python\ndef fit(X, y):\n```\n\n### Constants Used:\n- The constant used in the main code is `1`, which is implicitly used in the calculation of the mean and the normalization of the data.\n\n\n### Input and Output Format:\n- **Input**: The function takes two numpy arrays `X` and `y` as input, where `X` represents the input data points and `y` represents the target data points.\n- **Output**: The function returns three values: a rotation matrix `R`, a scaling factor `c`, and a translation vector `t`. If the input shapes do not match, it returns `(None, None, None)`.\n\nInput:\n```python\nX = np.array([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]])\ny = np.array([[1.5, 2.5], [3.5, 4.5], [5.5, 6.5]])\n```\n\nOutput:\n```python\nR = np.array([[1.00000000e+00, 1.11022302e-16],[1.11022302e-16, 1.00000000e+00]])\nc = 1\nt = np.array([0.5, 0.5])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef fit(X, y):\n    if X.shape != y.shape:\n        return None, None, None\n\n    ca = np.mean(y, axis=0)\n    cb = np.mean(X, axis=0)\n    var_a = np.mean(np.linalg.norm(y - ca, axis=1) ** 2)\n\n    H = (y - ca).T @ (X - cb) / y.shape[0]\n    U, D, VT = np.linalg.svd(H)\n\n    d = np.sign(np.linalg.det(U) * np.linalg.det(VT))\n    S = np.eye(len(D))\n    S[-1, -1] = d\n\n    R = U @ S @ VT\n    c = var_a / np.trace(np.diag(D) @ S)\n    t = ca - c * R @ cb\n\n    return R, c, t", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(2, 100)\n        num_features = np.random.randint(1, 10)\n        X = np.random.randn(num_samples, num_features)\n        y = np.random.randn(num_samples, num_features)\n        if np.random.rand() < 0.1:\n            if np.random.rand() < 0.5:\n                y = np.random.randn(num_samples + np.random.randint(1, 5), num_features)\n            else:\n                y = np.random.randn(num_samples, num_features + np.random.randint(1, 5))\n\n        test_cases.append((X, y))\n\n    return test_cases"}
{"problem_id": "numpy_13", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs an inverse transformation on a set of directional data points. The function will take in a set of positions and directions, and based on specified dimensions and curvature, it will compute new coordinates and directional vectors.\n`inverse_transform(posdirs, xwidth, yheight, rcurv)` takes an *N \u00d7 4* array whose columns hold the slab coordinates and directions *(z, t, \u03bc, \u03c6)*\u2014with \u03c6 expressed in degrees\u2014together with the slab\u2019s horizontal and vertical dimensions (`xwidth`, `yheight`) and, optionally, a curvature radius `rcurv`. For each row it converts *(z, t)* to Cartesian coordinates *(x, y, z)*, computes the associated direction cosines *(dx, dy, dz)*, and, when `rcurv` is supplied, wraps the slab around a cylinder of that radius to rotate both positions and directions accordingly. The function returns an *N \u00d7 6* array in the order *(x, y, z, dx, dy, dz)*.\n\nFunction Signature:\n```python\ndef inverse_transform(posdirs: np.ndarray, xwidth: float, yheight: float, rcurv: Optional[float]) -> np.ndarray:\n```\n\nConstants:\n- The constant used in the main code is `np.pi`, which is utilized to convert angles from degrees to radians.\n\n\nInput Format:\n- `posdirs`: A 2D NumPy array of shape (n, 4) where each row contains the values `[zs, ts, mus, phis]`.\n- `xwidth`: A float representing the width in the x-direction.\n- `yheight`: A float representing the height in the y-direction.\n- `rcurv`: An optional float representing the curvature radius.\n\nOutput Format:\n- A 2D NumPy array of shape (n, 6) where each row contains the transformed values `[xs, ys, zs, dxs, dys, dzs]`.\n\nInput:\n```python\nposdirs = np.array([[100.0, 50.0, 0.5, 30.0],\n                    [200.0, 150.0, 0.8, 45.0],\n                    [300.0, 250.0, 0.3, 60.0],\n                    [400.0, 350.0, 0.9, 90.0]])\nxwidth = 50\nyheight = 100\nrcurv = 200.0\n```\n\nOutput:\n```python\narray([[-2.54392357e+000,  0.00000000e+000,  1.07870746e+002,\n         7.92221270e-002, -4.33012702e-001,  8.97899691e-001],\n       [-9.19395388e+001,  0.00000000e+000,  1.68294197e+002,\n         0.00000000e+000,  0.00000000e+000,  0.00000000e+000],\n       [-1.85852560e+002,  6.75309348e-310,  1.99498997e+002,\n        -6.73617770e-310,  6.75309473e-310,  4.77694993e-311],\n       [-3.14440380e+002, -5.00000000e+001,  2.50056792e+002,\n         1.81394201e-001, -9.00000000e-001, -3.96353559e-001]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef inverse_transform(posdirs, xwidth, yheight, rcurv):\n    (zs, ts, mus, phis) = posdirs.T\n    phis *= np.pi / 180\n    mask0 = ts < yheight\n    mask1 = np.logical_and(ts > yheight, ts < yheight + xwidth)\n    mask2 = np.logical_and(ts > yheight + xwidth, ts < 2 * yheight + xwidth)\n    mask3 = ts > 2 * yheight + xwidth\n    xs = np.empty_like(ts)\n    ys = np.empty_like(ts)\n    xs[mask0] = xwidth / 2\n    ys[mask0] = ts[mask0] - 0.5 * yheight\n    ys[mask1] = yheight / 2\n    xs[mask1] = -ts[mask1] + 1.0 * yheight + 0.5 * xwidth\n    xs[mask2] = -xwidth / 2\n    ys[mask2] = -ts[mask2] + 1.5 * yheight + 1.0 * xwidth\n    ys[mask3] = -yheight / 2\n    xs[mask3] = ts[mask3] - 2.0 * yheight - 1.5 * xwidth\n    dxs = np.empty_like(mus)\n    dys = np.empty_like(mus)\n    dzs = np.empty_like(mus)\n    dxs[mask0] = mus[mask0]\n    dzs[mask0] = np.sqrt(1 - mus[mask0] ** 2) * np.cos(phis[mask0])\n    dys[mask0] = -np.sqrt(1 - mus[mask0] ** 2) * np.sin(phis[mask0])\n    dys[mask1] = mus[mask1]\n    dzs[mask1] = np.sqrt(1 - mus[mask1] ** 2) * np.cos(phis[mask1])\n    dxs[mask1] = np.sqrt(1 - mus[mask1] ** 2) * np.sin(phis[mask1])\n    dxs[mask2] = -mus[mask2]\n    dzs[mask2] = np.sqrt(1 - mus[mask2] ** 2) * np.cos(phis[mask2])\n    dys[mask2] = np.sqrt(1 - mus[mask2] ** 2) * np.sin(phis[mask2])\n    dys[mask3] = -mus[mask3]\n    dzs[mask3] = np.sqrt(1 - mus[mask3] ** 2) * np.cos(phis[mask3])\n    dxs[mask3] = -np.sqrt(1 - mus[mask3] ** 2) * np.sin(phis[mask3])\n    if rcurv is not None:\n        rs = (rcurv + xs) * np.sign(rcurv)\n        angs = zs / rcurv\n        xs = np.sign(rcurv) * rs * np.cos(zs / rcurv) - rcurv\n        zs = rs * np.sin(np.abs(zs / rcurv))\n        dxs2 = dxs\n        dzs2 = dzs\n        dxs = dxs2 * np.cos(angs) - dzs2 * np.sin(angs)\n        dzs = dxs2 * np.sin(angs) + dzs2 * np.cos(angs)\n    return np.stack((xs, ys, zs, dxs, dys, dzs), axis=1)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        xwidth = np.random.randint(1, 1001)\n        yheight = np.random.randint(-1000, 1001)\n\n        num_entries = np.random.randint(1, 1001)\n        zs = np.random.uniform(-1000, 1000, num_entries)\n        ts = np.random.uniform(-1000, 1000, num_entries)\n        mus = np.random.uniform(0, 1, num_entries)\n        phis = np.random.uniform(-360, 360, num_entries)\n\n        posdirs = np.column_stack((zs, ts, mus, phis))\n        rcurv = np.random.choice([None, np.random.uniform(1, 1000)])\n\n        test_cases.append((posdirs, xwidth, yheight, rcurv))\n\n    return test_cases"}
{"problem_id": "numpy_14", "library": "numpy", "code_problem": "You are tasked with implementing a function that simulates the forward pass of a Long Short-Term Memory (LSTM) network. The function will take a sequence of input data and several weight matrices as parameters, and it will compute the output of the LSTM for each time step in the sequence.\n\nFunction signature:\n```python\ndef forward_py(xs, WGI, WGF, WGO, WCI, WIP, WFP, WOP):\n```\n\nConstants used in the main code:\n- The constant values for the clipping in the sigmoid function are -20 and 20.\n\n\nInput format:\n- `xs`: A 2D numpy array of shape (n, ni).\n- `WGI`, `WGF`, `WGO`, `WCI`, `WIP`, `WFP`, `WOP`: 2D numpy arrays of appropriate shapes.\n\nOutput format:\n- A 2D numpy array of shape (n, ns) representing the output of the LSTM for each time step.\n\n**Input:**\n```python\nxs = np.array([[0.5, -1.2]])\nWGI = np.array([[0.1, -0.2, 0.3, 0.4]])\nWGF = np.array([[0.2, -0.1, 0.4, 0.5]])\nWGO = np.array([[0.3, 0.1, -0.4, 0.2]])\nWCI = np.array([[0.4, 0.2, -0.1, 0.3]])\nWIP = np.array([0.1])\nWFP = np.array([0.3])\nWOP = np.array([0.5])\n```\n\n**Output:**\n```python\narray([[0.26099535]])\n```\n\n### Note:\nThe output values are illustrative and may not match the actual output from the function due to the random nature of the weights and inputs. You can run the `forward_py` function with the provided input to get the actual output values.", "ground_truth_code": "import numpy as np\n\n\ndef sigmoid(x):\n    return 1 / (1 + np.exp(np.clip(-x, -20, 20)))\n\n\ndef tanh(x):\n    return np.tanh(x)\n\n# main code\ndef forward_py(xs, WGI, WGF, WGO, WCI, WIP, WFP, WOP):\n    n, ni = xs.shape\n    ns = WGI.shape[0]\n\n    source = np.ones((n, 1 + ni + ns))\n    gix, gfx, gox, cix = np.zeros((4, n, ns))\n    gi, gf, go, ci, state, output = np.zeros((6, n, ns))\n\n    for t in range(n):\n        source[t, 1:1 + ni] = xs[t]\n        if t > 0:\n            source[t, 1 + ni:] = output[t - 1]\n\n        gix[t], gfx[t], gox[t], cix[t] = np.dot(WGI, source[t]), np.dot(WGF, source[t]), np.dot(WGO, source[t]), np.dot(\n            WCI, source[t])\n\n        if t > 0:\n            gix[t] += WIP * state[t - 1]\n            gfx[t] += WFP * state[t - 1]\n\n        gi[t], gf[t], ci[t] = sigmoid(gix[t]), sigmoid(gfx[t]), tanh(cix[t])\n        state[t] = ci[t] * gi[t] + (gf[t] * state[t - 1] if t > 0 else 0)\n        gox[t] += WOP * state[t] if t > 0 else 0\n\n        go[t] = sigmoid(gox[t])\n        output[t] = tanh(state[t]) * go[t]\n\n    return output", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        seq_len = np.random.randint(1, 51)\n        input_size = np.random.randint(1, 21)\n        hidden_size = np.random.randint(1, 21)\n        xs = np.random.randn(seq_len, input_size)\n        WGI = np.random.randn(hidden_size, 1 + input_size + hidden_size)\n        WGF = np.random.randn(hidden_size, 1 + input_size + hidden_size)\n        WGO = np.random.randn(hidden_size, 1 + input_size + hidden_size)\n        WCI = np.random.randn(hidden_size, 1 + input_size + hidden_size)\n        WIP = np.random.randn(hidden_size)\n        WFP = np.random.randn(hidden_size)\n        WOP = np.random.randn(hidden_size)\n        test_cases.append((xs, WGI, WGF, WGO, WCI, WIP, WFP, WOP))\n\n    return test_cases"}
{"problem_id": "numpy_15", "library": "numpy", "code_problem": "You are tasked with implementing a function that pads sequences to a specified length, allowing for truncation and padding options. The function should handle a list of sequences, ensuring that each sequence is either padded with a specified value or truncated to fit the desired length. \n\nFunction signature:\n```python\ndef keras_pad_seqs(sequences, maxlen, dtype, padding, truncating, value):\n```\n\nConstants used in the main code:\n- `value`: This constant is used to fill the padded areas of the sequences.\n\n\nInput format:\n- `sequences`: A list of sequences (each sequence can be a list or array).\n- `maxlen`: An integer specifying the maximum length of the sequences.\n- `dtype`: The desired data type of the output array.\n- `padding`: A string indicating whether to pad 'pre' or 'post'.\n- `truncating`: A string indicating whether to truncate 'pre' or 'post'.\n- `value`: The value to use for padding.\n\nOutput format:\n- The function returns a NumPy array of shape `(num_samples, maxlen) + sample_shape`, containing the padded and truncated sequences.\n\nInput:\n```python\nsequences = [\n    [[1, 2], [3, 4], [5, 6]],  # Length 3\n    [[7, 8]],                  # Length 1\n    [[9, 10], [11, 12]]        # Length 2\n]\nmaxlen = 3\ndtype = np.float32\npadding = 'post'\ntruncating = 'pre'\nvalue = 0.0\n```\n\nOutput:\n```python\narray([[[ 1.,  2.],\n        [ 3.,  4.],\n        [ 5.,  6.]],\n\n       [[ 7.,  8.],\n        [ 0.,  0.],\n        [ 0.,  0.]],\n\n       [[ 9., 10.],\n        [11., 12.],\n        [ 0.,  0.]]], dtype=float32)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef keras_pad_seqs(sequences, maxlen, dtype, padding, truncating, value):\n    num_samples = len(sequences) if hasattr(sequences, '__len__') else 0\n    lengths = [len(x) if hasattr(x, '__len__') else 0 for x in sequences]\n\n    maxlen = np.max(lengths) if maxlen is None else maxlen\n    sample_shape = tuple()\n    for s in sequences:\n        if len(s) > 0:\n            sample_shape = np.asarray(s).shape[1:]\n            break\n\n    x = np.full((num_samples, maxlen) + sample_shape, value, dtype=dtype)\n    for idx, s in enumerate(sequences):\n        if not len(s):\n            continue\n\n        trunc = s[-maxlen:] if truncating == 'pre' else s[:maxlen]\n        trunc = np.asarray(trunc, dtype=dtype)\n\n        if padding == 'post':\n            x[idx, :len(trunc)] = trunc\n        else:\n            x[idx, -len(trunc):] = trunc\n\n    return x", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(1, 10)\n        sequence_lengths = np.random.randint(1, 20, size=num_samples)\n        element_shape = tuple(np.random.randint(1, 5, size=np.random.choice([0, 1])))\n        sequences = [np.random.rand(l, *element_shape).tolist() for l in sequence_lengths]\n        maxlen = np.random.choice([None, np.random.randint(1, max(sequence_lengths) + 1)])\n        dtype = np.random.choice([np.float32, np.int32, np.int64])\n        padding = np.random.choice(['pre', 'post'])\n        truncating = np.random.choice(['pre', 'post'])\n        value = np.random.uniform(-10, 10)\n\n        test_cases.append((sequences, maxlen, dtype, padding, truncating, value))\n\n    return test_cases"}
{"problem_id": "numpy_16", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes a list of points, where each point is represented as a sequence of numerical values. The function should check the order of the values in each point and determine if they are in ascending or descending order. If a point is found to be in descending order, it should be flipped to ascending order. The function will return a modified list of points and a list of indices where the original points were in descending order.\n\nFunction signature:\n```python\ndef _check_points(points: List[List[float]]) -> Tuple[List[np.ndarray], List[int]]:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the data type `float`, which is specified when converting the points to a NumPy array.\n\nInput format:\n- The input to the function is a list of lists, where each inner list contains numerical values representing a point.\n\nOutput format:\n- The output of the function is a tuple containing:\n  - A list of NumPy arrays representing the processed points.\n  - A list of integers representing the indices of the original points that were in descending order.\n\nInput:\n```python\n[\n    [1.0, 2.0, 3.0],        # Ascending\n    [5.0, 4.0, 3.0],        # Descending\n    [10.0, 20.0, 30.0]      # Ascending\n]\n```\n\nOutput:\n```python\n(\n    [\n        array([1., 2., 3.]), \n        array([3., 4., 5.]),  # Flipped from descending to ascending\n        array([10., 20., 30.])\n    ], \n    [1]  # Index of the descending dimension\n)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef _check_points(points):\n    descending_dimensions = []\n    grid = []\n\n    for i, p in enumerate(points):\n        p = np.asarray(p, dtype=float)\n        ascending = np.all(p[1:] > p[:-1])\n        descending = np.all(p[1:] < p[:-1])\n\n        if not ascending and descending:\n            descending_dimensions.append(i)\n            p = np.flip(p)\n\n        p = np.ascontiguousarray(p)\n        grid.append(p)\n\n    return grid, descending_dimensions", "test_script": "from random import randint, uniform\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dimension_count = randint(1, 5)\n        points = []\n        for dim in range(dimension_count):\n            point_length = randint(2, 10)\n            ascending = randint(0, 1) == 0\n\n            if ascending:\n                start = uniform(-1000, 1000)\n                points_for_dimension = [start + i * uniform(1, 10) for i in range(point_length)]\n                points_for_dimension.sort()\n            else:\n                start = uniform(-1000, 1000)\n                points_for_dimension = [start - i * uniform(1, 10) for i in range(point_length)]\n                points_for_dimension.sort(reverse=True)\n            points.append(points_for_dimension)\n\n        test_cases.append(points)\n\n    return test_cases"}
{"problem_id": "numpy_17", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a matrix of expected values for a multivariate normal distribution based on given parameters. The function will take in a correlation matrix, a total time period, a time increment, the number of simulations, and a mean vector. The function will return a 3D array where each slice corresponds to a time step and contains the mean values replicated for the specified number of simulations.\n\nFunction signature:\n```python\ndef generate_eps_MV(cor, T, dt, sims, mu):\n```\n\nConstant used in the main code:\n- `N`: This constant represents the number of time steps calculated as the total time `T` divided by the time increment `dt`.\n\n\nInput format:\n- `cor`: A 2D list or NumPy array representing the correlation matrix.\n- `T`: A float representing the total time period.\n- `dt`: A float representing the time increment.\n- `sims`: An integer representing the number of simulations to run.\n- `mu`: A 1D list or NumPy array representing the mean vector.\n\nOutput format:\n- A 3D NumPy array of shape `(N, sims, m)`, where `N` is the number of time steps, `sims` is the number of simulations, and `m` is the length of the mean vector `mu`. Each slice of the array corresponds to a time step filled with the replicated mean vector.\n\nInput:\n```python\n(\n    [[1.0, 0.5], [0.5, 1.0]],  # cor\n    5.0,                       # T\n    0.1,                       # dt\n    10,                        # sims\n    [0.0, 1.0]                # mu\n)\n```\n\nOutput:\n```python\narray([[[0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.]\n        ...\n        [[0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.],\n        [0., 1.]]])\n```\n\n(Note: the output should be 50*10*2 array)", "ground_truth_code": "import numpy as np\n\n# main code\ndef generate_eps_MV(cor, T, dt, sims, mu):\n    N = int(T / dt)\n\n    cor = np.array(cor) if not isinstance(cor, np.ndarray) else cor\n    mu = np.array(mu) if mu is not None and not isinstance(mu, np.ndarray) else np.zeros(cor.shape[0])\n\n    return np.tile(mu, (N, sims, 1))", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        d = np.random.randint(1, 10)\n        T = np.random.uniform(0.1, 10)\n        dt = np.random.uniform(0.01, 1)\n        sims = np.random.randint(1, 50)\n        A = np.random.randn(d, d)\n        cor = np.dot(A, A.T)\n        np.fill_diagonal(cor, 1)\n        mu = np.random.randn(d)\n\n        test_cases.append((cor.tolist(), T, dt, sims, mu.tolist()))\n\n    return test_cases"}
{"problem_id": "numpy_18", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates matched splines from two input arrays. The function will take two sets of data points and their corresponding velocities, and it will return two new arrays that represent the time-distributed values of the input data points after applying cubic spline interpolation.\n\nFunction signature:\n```python\ndef matched_spline_generate(A: np.ndarray, B: np.ndarray, V_A: np.ndarray, V_B: np.ndarray) -> tuple\n```\n\nConstants used in the main code:\n- The constant used in the main code is the cubic interpolation method specified by `kind='cubic'` in the `interp1d` function.\n\n\nInput format:\n- The function takes four parameters:\n  - `A`: A 1D numpy array of data points.\n  - `B`: A 1D numpy array of data points.\n  - `V_A`: A 1D numpy array representing the velocity corresponding to data points in `A`.\n  - `V_B`: A 1D numpy array representing the velocity corresponding to data points in `B`.\n\nOutput format:\n- The function returns a tuple containing:\n  - `TD_A`: A 2D numpy array where the first column represents time-distributed values for `A` and the second column represents the interpolated values of `A`.\n  - `TD_B`: A 2D numpy array where the first column represents time-distributed values for `B` and the second column represents the interpolated values of `B`.\n\nInput:\n```python\nA = np.array([1.0, 2.0, 3.0, 4.0])\nB = np.array([4.0, 3.0, 2.0, 1.0])\nV_A = np.array([0.5, 0.5, 0.5, 0.5])\nV_B = np.array([0.5, 0.5, 0.5, 0.5])\n```\n\nOutput:\n```python\nTD_A = np.array([[0.  , 1.  ],\n                 [0.25, 2.  ],\n                 [0.5 , 3.  ],\n                 [0.75, 4.  ]])\n                 \nTD_B = np.array([[0.  , 4.  ],\n                 [0.25, 3.  ],\n                 [0.5 , 2.  ],\n                 [0.75, 1.  ]])\n```", "ground_truth_code": "import numpy as np\nfrom scipy.interpolate import interp1d\n\n# main code\ndef matched_spline_generate(A, B, V_A, V_B):\n    if A.size == 0 or B.size == 0 or V_A.size == 0 or V_B.size == 0:\n        return None\n\n    length_A = np.linalg.norm(V_A)\n    length_B = np.linalg.norm(V_B)\n\n    array_a = np.linspace(0, A.size - 1, A.size)\n    array_b = np.linspace(0, B.size - 1, B.size)\n\n    f_a = interp1d(array_a, A, kind='cubic', fill_value=\"extrapolate\")\n    f_b = interp1d(array_b, B, kind='cubic', fill_value=\"extrapolate\")\n\n    limits_a_new = np.linspace(0, A.size - 1, A.size)\n    limits_b_new = np.linspace(0, B.size - 1, B.size)\n\n    A_new = f_a(limits_a_new)\n    B_new = f_b(limits_b_new)\n\n    TD_A = np.column_stack((np.arange(A_new.size) * (length_A / A_new.size), A_new))\n    TD_B = np.column_stack((np.arange(B_new.size) * (length_B / B_new.size), B_new))\n\n    return TD_A, TD_B", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        len_A = np.random.randint(1, 20)\n        len_B = np.random.randint(1, 20)\n        A = np.random.uniform(-100, 100, size=len_A)\n        B = np.random.uniform(-100, 100, size=len_B)\n\n        if len_A < 4:\n            additional_A = np.random.uniform(-100, 100, size=(4 - len_A))\n            A = np.concatenate((A, additional_A))\n        if len_B < 4:\n            additional_B = np.random.uniform(-100, 100, size=(4 - len_B))\n            B = np.concatenate((B, additional_B))\n        V_A = np.random.uniform(0.1, 1.0, size=len(A))\n        V_B = np.random.uniform(0.1, 1.0, size=len(B))\n        test_cases.append((A, B, V_A, V_B))\n\n    return test_cases"}
{"problem_id": "numpy_19", "library": "numpy", "code_problem": "You are tasked with implementing a helper function that prepares the data needed to draw a Mollweide projection.\nThe function constructs a 2-D array of shape (ysize, xsize) (where ysize = xsize // 2) and computes, for every pixel that lies inside the Mollweide ellipse, its spherical coordinates.\nPixel centres are placed at integer coordinates \\((i, j)\\), with \\(i = 0 \\ldots \\text{ysize}-1\\) counting down from the north pole and \\(j = 0 \\ldots \\text{xsize}-1\\) counting eastward. The corresponding plane coordinates of each pixel centre are \\(x_m = (j + 0.5 - \\text{xsize}/2)\\,dx\\) and \\(y_m = (\\text{ysize}/2 - i - 0.5)\\,dy\\), where \\(dx = 2\\sqrt{2}\\,\\pi / \\text{xsize}\\) and \\(dy = \\sqrt{2}\\,\\pi / \\text{xsize}\\). A pixel lies inside the Mollweide ellipse when \\(x_m^{2}/(2\\sqrt{2})^{2} + y_m^{2}/(\\sqrt{2})^{2} \\le 1\\). For every inside pixel, you compute the auxiliary angle \\(\\theta = \\arcsin(y_m / \\sqrt{2})\\), the latitude \\(\\varphi = \\arcsin\\!\\bigl((2\\theta + \\sin 2\\theta)/\\pi\\bigr)\\), and the longitude \\(\\lambda = \\pi x_m / \\bigl(2\\sqrt{2}\\,\\cos\\theta\\bigr)\\). Apply the empirical scale factor \\(k = 1.02\\) **once** to both \\(x_m\\) and \\(y_m\\) before testing membership in the ellipse; this slightly enlarges the mask so it aligns with existing rendering code.\n\nThe function signature is:\n```python\ndef _mollweide_helper(xsize: int) -> tuple:\n```\n\n### Constants:\n- The constant `1.02` is used to adjust the scaling of the coordinates in the projection.\n\n\n### Input and Output Format:\n- **Input**: An integer `xsize` representing the width of the output grid.\n- **Output**: A tuple containing:\n  - A 2D numpy array of shape `(ysize, xsize)` filled with `NaN` values.\n  - A boolean array (mask) indicating the valid points in the projection.\n  - A 1D numpy array of angles `theta`.\n  - A 1D numpy array of angles `phi`.\n\nInput:\n```python\n6\n```\n\nOutput:\n```python\narray([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]])\n\n(array([1, 1, 1, 1]), array([1, 2, 3, 4]))\n\narray([1.57079633, 1.57079633, 1.57079633, 1.57079633])\n\narray([1.9226547 , 0.6408849 , 5.64230041, 4.3605306 ])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef _mollweide_helper(xsize):\n    xsize = int(xsize)\n    ysize = xsize // 2\n    res = np.full(shape=(ysize, xsize), fill_value=np.nan, dtype=np.float64)\n    (xc, yc) = ((xsize - 1) * 0.5, (ysize - 1) * 0.5)\n    (u, v) = np.meshgrid(np.arange(xsize), np.arange(ysize))\n    (u, v) = (2 * (u - xc) / (xc / 1.02), (v - yc) / (yc / 1.02))\n    mask = np.where(u * u * 0.25 + v * v <= 1.0)\n    t1 = v[mask]\n    theta = 0.5 * np.pi - np.arcsin(2 / np.pi * (np.arcsin(t1) + t1 * np.sqrt((1.0 - t1) * (1 + t1))))\n    phi = -0.5 * np.pi * u[mask] / np.maximum(np.sqrt((1 - t1) * (1 + t1)), 1e-06)\n    phi = np.where(phi < 0, phi + 2 * np.pi, phi)\n    return (res, mask, theta, phi)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        xsize = np.random.randint(10, 1000)\n        test_cases.append(xsize)\n\n    return test_cases"}
{"problem_id": "numpy_20", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a specific aerodynamic coefficient based on given lift and moment coefficients at various angles of attack. The function will determine the moment coefficient at zero lift and use it to compute a coefficient related to the aerodynamic center of the airfoil.\n\nFunction signature:\n```python\ndef __CMCoeff(cl_high, cd_high, cm_high, alpha, cl, cm):\n```\n\n### Constants:\n- A small constant `1e-6` is used to check for near-zero values in the calculations.\n\n\n### Input Format:\n- `cl_high`: A float representing the high lift coefficient.\n- `cd_high`: A float representing the high drag coefficient.\n- `cm_high`: A float representing the high moment coefficient.\n- `alpha`: A list of floats representing angles of attack in degrees.\n- `cl`: A list of floats representing lift coefficients corresponding to the angles of attack.\n- `cm`: A list of floats representing moment coefficients corresponding to the angles of attack.\n\n### Output Format:\n- The function returns a float representing the aerodynamic coefficient, or `None` if the conditions for calculation are not met.\n\nInput:\n```python\n(1.75, 0.85, 0.25, [-10, 0, 15], [-0.5, 0.0, 0.8], [-0.3, 0.1, 0.5])\n```\n\nOutput:\n```python\n0.08802639259461692\n```", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef __CMCoeff(cl_high, cd_high, cm_high, alpha, cl, cm):\n    found_zero_lift = False\n    cm0 = 0\n\n    for i in range(len(cm) - 1):\n        if abs(alpha[i]) < 20.0 and cl[i] <= 0 and cl[i + 1] >= 0:\n            denominator = cl[i + 1] - cl[i]\n            if abs(denominator) < 1e-6:\n                continue\n            p = -cl[i] / denominator\n            cm0 = cm[i] + p * (cm[i + 1] - cm[i])\n            found_zero_lift = True\n            break\n\n    if not found_zero_lift:\n        denominator = cl[1] - cl[0]\n        if abs(denominator) < 1e-6:\n            return None\n        p = -cl[0] / denominator\n        cm0 = cm[0] + p * (cm[1] - cm[0])\n\n    alpha_high = np.radians(alpha[-1])\n    XM = (-cm_high + cm0) / (cl_high * np.cos(alpha_high) + cd_high * np.sin(alpha_high))\n\n    if abs(alpha_high - np.pi / 2) < 1e-6:\n        return None\n\n    cmCoef = (XM - 0.25) / np.tan(alpha_high - np.pi / 2)\n    return cmCoef", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_inputs = []\n\n    for _ in range(n):\n        cl_high = round(random.uniform(0.5, 3.0), 2)\n        cd_high = round(random.uniform(0.2, 1.5), 2)\n        cm_high = round(random.uniform(-1.0, 1.0), 2)\n        alpha = sorted(random.sample(range(-10, 40), random.randint(3, 10)))\n\n        cl = [round(random.uniform(-1.0, 1.0), 2) for _ in range(len(alpha))]\n        cm = [round(random.uniform(-1.0, 1.0), 2) for _ in range(len(alpha))]\n\n        zero_lift_index = random.randint(1, len(cl) - 1)\n        cl[zero_lift_index] = 0.0\n        if zero_lift_index > 0 and cl[zero_lift_index - 1] < 0:\n            cl[zero_lift_index - 1] = round(random.uniform(-1.0, -0.01), 2)\n        if zero_lift_index < len(cl) - 1 and cl[zero_lift_index + 1] > 0:\n            cl[zero_lift_index + 1] = round(random.uniform(0.01, 1.0), 2)\n\n        test_inputs.append((cl_high, cd_high, cm_high, alpha, cl, cm))\n\n    return test_inputs\n"}
{"problem_id": "numpy_21", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a new aerodynamic moment coefficient based on various input parameters related to the angle of attack and aerodynamic characteristics of an airfoil. The function will adjust the moment coefficient based on specific conditions related to the angle of attack.\n\nFunction Signature:\n```python\ndef get_cm(i, cm_coef, alpha, cl_ext, cd_ext, alpha_low_deg, alpha_high_deg, cm0):\n```\n\n### Constants:\n- The function uses a lookup dictionary `cm_lookup` to provide specific moment coefficient values for certain angles of attack that exceed the defined limits.\n\n\n### Input Format:\n- `i`: An integer index for accessing elements in the lists.\n- `cm_coef`: A float representing the coefficient used in the moment calculation.\n- `alpha`: A list of floats representing angles of attack in degrees.\n- `cl_ext`: A list of floats representing the lift coefficients corresponding to the angles of attack.\n- `cd_ext`: A list of floats representing the drag coefficients corresponding to the angles of attack.\n- `alpha_low_deg`: A float representing the lower limit of the angle of attack range.\n- `alpha_high_deg`: A float representing the upper limit of the angle of attack range.\n- `cm0`: A float representing the baseline moment coefficient.\n\n### Output Format:\n- The function returns a float value representing the new aerodynamic moment coefficient (`cm_new`).\n\n**Input:**\n```python\ni = 3\ncm_coef = 0.5\nalpha = np.array([-15, 5, 10, 12, -20])\ncl_ext = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\ncd_ext = np.array([0.1, 0.1, 0.2, 0.2, 0.3])\nalpha_low_deg = -10\nalpha_high_deg = 20\ncm0 = 0.0\n```\n\n**Output:**\n```python\ncm_new = 0.0  # Since alpha[3] = 12 is within the range of alpha_low_deg and alpha_high_deg\n```\n\n### Explanation:\nIn this test case, the input parameters are set such that `alpha[3]` (which is 12) falls within the specified range of `alpha_low_deg` (-10) and `alpha_high_deg` (20). Therefore, the output `cm_new` remains equal to `cm0`, which is 0.0.", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_cm(i, cm_coef, alpha, cl_ext, cd_ext, alpha_low_deg, alpha_high_deg, cm0):\n    cm_new = cm0\n\n    if alpha[i] < alpha_low_deg or alpha[i] > alpha_high_deg:\n        if -165 < alpha[i] < 165:\n            if abs(alpha[i]) < 0.01:\n                cm_new = cm0\n            elif alpha[i] > 0:\n                x = cm_coef * np.tan(np.radians(alpha[i]) - np.pi / 2) + 0.25\n                cm_new = cm0 - x * (cl_ext[i] * np.cos(np.radians(alpha[i])) + cd_ext[i] * np.sin(np.radians(alpha[i])))\n            else:\n                x = cm_coef * np.tan(-np.radians(alpha[i]) - np.pi / 2) + 0.25\n                cm_new = -(cm0 - x * (\n                            -cl_ext[i] * np.cos(-np.radians(alpha[i])) + cd_ext[i] * np.sin(-np.radians(alpha[i]))))\n        else:\n            cm_lookup = {\n                165: -0.4, 170: -0.5, 175: -0.25, 180: 0,\n                -165: 0.35, -170: 0.4, -175: 0.2, -180: 0\n            }\n            cm_new = cm_lookup.get(alpha[i], cm0)\n\n    return cm_new", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        array_size = np.random.randint(5, 20)\n        i = np.random.randint(0, array_size)\n\n        cm_coef = np.random.uniform(-1.0, 1.0)\n        alpha = np.random.uniform(-180, 180, size=array_size)\n        cl_ext = np.random.uniform(-2, 2, size=array_size)\n        cd_ext = np.random.uniform(-2, 2, size=array_size)\n\n        alpha_low_deg = np.random.uniform(-10, 10)\n        alpha_high_deg = np.random.uniform(10, 20)\n\n        cm0 = np.random.uniform(-1, 1)\n\n        test_cases.append((i, cm_coef, alpha, cl_ext, cd_ext, alpha_low_deg, alpha_high_deg, cm0))\n\n    return test_cases"}
{"problem_id": "numpy_22", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a 2D Gabor filter, which is commonly used in image processing for texture analysis and feature extraction. The function should be able to create a Gabor filter based on specified parameters such as the width and height of the Gaussian envelope, the center coordinates of the filter, the frequency, orientation, and phase of the wave.\n\nFunction signature:\n```python\ndef gabor2d(gw, gh, gx0, gy0, wfreq, worient, wphase, shape):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `np.pi`, which is the mathematical constant \u03c0.\n\n\nInput format:\n- The function takes the following parameters:\n  - `gw`: Width of the Gaussian envelope.\n  - `gh`: Height of the Gaussian envelope.\n  - `gx0`: X-coordinate of the center of the filter.\n  - `gy0`: Y-coordinate of the center of the filter.\n  - `wfreq`: Frequency of the wave.\n  - `worient`: Orientation of the wave in radians.\n  - `wphase`: Phase offset of the wave.\n  - `shape`: A tuple representing the height and width of the output filter.\n\nOutput format:\n- The function returns a 2D numpy array representing the Gabor filter, which is normalized and centered around zero.\n\nInput:\n```python\ngw = 30\ngh = 40\ngx0 = 25\ngy0 = 20\nwfreq = 2.5\nworient = 1.0\nwphase = 0.5\nshape = (50, 50)\n```\n\nOutput:\n```python\narray([[ 2.66446826e-03, -3.26115647e-03,  8.24432236e-04, ...,\n        -4.55499643e-03,  3.66492530e-03, -3.74417556e-04],\n       ...,\n       [ 6.86472837e-04, -1.51096508e-03,  1.14972746e-03, ...,\n        -1.27641817e-03,  1.78536609e-03, -8.64977664e-04]])\n``` \n\n(Note: The output array values are illustrative and would vary based on the actual computation from the `gabor2d` function.)", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef gabor2d(gw, gh, gx0, gy0, wfreq, worient, wphase, shape):\n    def fastnorm(x):\n        xv = x.ravel()\n        return np.dot(xv, xv) ** (1 / 2.0)\n\n    (height, width) = shape\n    (y, x) = np.mgrid[0:height, 0:width]\n    X = x * np.cos(worient) * wfreq\n    Y = y * np.sin(worient) * wfreq\n    env = np.exp(-np.pi * ((x - gx0) ** 2.0 / gw ** 2.0 + (y - gy0) ** 2.0 / gh ** 2.0))\n    wave = np.exp(1j * (2 * np.pi * (X + Y) + wphase))\n    gabor = np.real(env * wave)\n    gabor -= gabor.mean()\n    gabor /= fastnorm(gabor)\n    return gabor", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        gw = random.randint(1, 100)\n        gh = random.randint(1, 100)\n        height = random.randint(1, 100)\n        width = random.randint(1, 100)\n        gx0 = random.randint(0, width - 1)\n        gy0 = random.randint(0, height - 1)\n        wfreq = random.uniform(-5, 5)\n        worient = random.uniform(0, 2 * np.pi)\n        wphase = random.uniform(0, 2 * np.pi)\n        shape = (height, width)\n        \n        test_cases.append((gw, gh, gx0, gy0, wfreq, worient, wphase, shape))\n        \n    return test_cases"}
{"problem_id": "numpy_23", "library": "numpy", "code_problem": "You are tasked with implementing a function that samples properties based on a conditional distribution derived from a multivariate normal distribution. The function will take in several parameters, including prior means, target values, and covariance matrices, to compute the conditional mean and covariance. The function will then generate a sample from this conditional distribution and apply optional scaling transformations to the sampled properties.\n\nFunction signature:\n```python\ndef sampling_conditional_property(yid, ytarget, n_properties, mu_prior, scaler_std_properties, scaling_type, scaler_properties, cov_prior):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which specifies the number of samples to draw from the multivariate normal distribution.\n\n\nInput format:\n- `yid`: An integer representing the index of the target property.\n- `ytarget`: A float or array representing the target values for the property at index `yid`.\n- `n_properties`: An integer representing the total number of properties.\n- `mu_prior`: A numpy array of prior means for the properties.\n- `scaler_std_properties`: A scaler object for standard transformation.\n- `scaling_type`: A string indicating the type of scaling to apply.\n- `scaler_properties`: A scaler object for additional transformations (can be None).\n- `cov_prior`: A 2D numpy array representing the covariance matrix of the properties.\n\nOutput format:\n- The function returns a numpy array of the sampled and transformed properties.\n\n**Input:**\n```python\nyid = 2\nytarget = np.array([3.5])\nn_properties = 5\nmu_prior = np.array([-1.0, 0.5, 2.0, -2.5, 1.0])\nscaler_std_properties = StandardScaler()\nscaler_std_properties.fit(np.random.uniform(-5.0, 5.0, size=(100, n_properties)))\nscaling_type = 'std'\nscaler_properties = None\ncov_prior = np.array([[1.0, 0.2, 0.1, 0.0, 0.3],\n                      [0.2, 1.0, 0.4, 0.1, 0.2],\n                      [0.1, 0.4, 1.0, 0.3, 0.1],\n                      [0.0, 0.1, 0.3, 1.0, 0.2],\n                      [0.3, 0.2, 0.1, 0.2, 1.0]])\n```\n\n**Output:**\n```python\nproperties = sampling_conditional_property(yid, ytarget, n_properties, mu_prior, scaler_std_properties, scaling_type, scaler_properties, cov_prior)\n# Example output (actual values will vary due to randomness):\n# properties = np.array([-0.91688517, -1.1618051, 3.5, -1.62491398, 0.14121784])\n```\n\nNote: The actual output values will vary each time the function is run due to the randomness involved in sampling from a multivariate normal distribution. The example output provided is illustrative and may not match the actual output from running the function.", "ground_truth_code": "import numpy as np\n\n# main code\ndef sampling_conditional_property(yid, ytarget, n_properties, mu_prior, scaler_std_properties, scaling_type, scaler_properties, cov_prior):\n    id2 = [yid]\n    id1 = np.setdiff1d(np.arange(n_properties), id2)\n    mu1 = mu_prior[id1]\n    mu2 = mu_prior[id2]\n    cov11 = cov_prior[id1][:, id1]\n    cov12 = cov_prior[id1][:, id2]\n    cov22 = cov_prior[id2][:, id2]\n    cov21 = cov_prior[id2][:, id1]\n    cond_mu = np.transpose(mu1.T + np.matmul(cov12, np.linalg.inv(cov22)) * (ytarget - mu2))[0]\n    cond_cov = cov11 - np.matmul(np.matmul(cov12, np.linalg.inv(cov22)), cov21)\n    marginal_sampled = np.random.multivariate_normal(cond_mu, cond_cov, 1)\n    properties = np.zeros(n_properties)\n    properties[id1] = marginal_sampled\n    properties[id2] = ytarget\n    if scaling_type != 'std':\n        properties_notransf = scaler_std_properties.inverse_transform(properties.reshape(1, -1))\n        if scaler_properties is not None:\n            properties = scaler_properties.transform(properties_notransf).reshape(-1)\n        else:\n            properties = properties_notransf.reshape(-1)\n    return properties\n", "test_script": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        n_properties = np.random.randint(2, 11)\n\n        yid = np.random.randint(0, n_properties)\n        ytarget = np.random.uniform(-10.0, 10.0, size=(1,))\n        mu_prior = np.random.uniform(-5.0, 5.0, size=(n_properties,))\n        scaler_std_properties = StandardScaler()\n        random_data = np.random.uniform(-5.0, 5.0, size=(100, n_properties))\n        scaler_std_properties.fit(random_data)\n        scaling_type = np.random.choice(['std', 'not_std'])\n        scaler_properties = None\n        if scaling_type == 'not_std' and np.random.rand() > 0.5:\n            scaler_properties = StandardScaler()\n            random_properties = np.random.uniform(-5.0, 5.0, size=(100, n_properties))\n            scaler_properties.fit(random_properties)\n        random_cov = np.random.rand(n_properties, n_properties)\n        cov_prior = np.matmul(random_cov, random_cov.T)\n\n        test_cases.append((yid, ytarget, n_properties, mu_prior, scaler_std_properties, scaling_type, scaler_properties, cov_prior))\n    \n    return test_cases\n"}
{"problem_id": "numpy_24", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the inverse of a specific matrix derived from two input arrays. The function signature is as follows:\n\n```python\ndef _compute_L_inverse(X: np.ndarray, Y: np.ndarray) -> np.ndarray:\n```\n\n### Constants Used:\n- The constant `3` is used to define the size of a zero matrix in the computation.\n\n\n### Input Format:\n- The function accepts two parameters:\n  - `X`: A 1-dimensional NumPy array of shape `(N,)`.\n  - `Y`: A 1-dimensional NumPy array of shape `(N,)`.\n\n### Output Format:\n- The function returns a 2-dimensional NumPy array representing the inverse of the matrix `L`, with shape `(N + 3, N + 3)`.\n\nInput:\n```python\nX = np.array([[10], [20], [30]])\nY = np.array([[15], [25], [35]])\n```\n\nOutput:\n```python\narray([[ 4.50842200e-04, -9.01684401e-04,  4.50842200e-04,\n         1.89260781e+01,  2.51606445e+00, -4.34855038e+00],\n       [-9.01684401e-04,  1.80336880e-03, -9.01684401e-04,\n        -4.52622818e+01, -3.03410584e+00,  9.38288140e+00],\n       [ 4.50842200e-04, -9.01684401e-04,  4.50842200e-04,\n         1.73942015e+01,  2.89903359e+00, -4.34855038e+00],\n       [ 3.31695180e+01, -9.70890360e+01,  5.42945180e+01,\n         2.30584301e+19,  4.61168602e+18, -4.61168602e+18],\n       [ 6.57500000e+00, -2.00000000e+01,  1.13000000e+01,\n         4.61168602e+18,  9.22337204e+17, -9.22337204e+17],\n       [-6.62500000e+00,  2.00000000e+01, -1.12500000e+01,\n        -4.61168602e+18, -9.22337204e+17,  9.22337204e+17]])\n```", "ground_truth_code": "import numpy as np\nfrom numpy import linalg\n\n# main code\ndef _compute_L_inverse(X, Y):\n    N = X.shape[0]\n    Xmat = np.tile(X, (1, N))\n    Ymat = np.tile(Y, (1, N))\n    P_dist_squared = np.power(Xmat - Xmat.transpose(1, 0), 2) + np.power(Ymat - Ymat.transpose(1, 0), 2)\n    P_dist_squared[P_dist_squared == 0] = 1\n    K = np.multiply(P_dist_squared, np.log(P_dist_squared))\n    O = np.ones([N, 1], dtype=np.float32)\n    Z = np.zeros([3, 3], dtype=np.float32)\n    P = np.concatenate([O, X, Y], axis=1)\n    first = np.concatenate((K, P), axis=1)\n    second = np.concatenate((P.transpose(1, 0), Z), axis=1)\n    L = np.concatenate((first, second), axis=0)\n    Li = linalg.inv(L)\n    return Li", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    def create_unique_points(num_points):\n        X = np.random.rand(num_points, 1) * 100\n        Y = np.random.rand(num_points, 1) * 100\n        return X, Y\n\n    X1, Y1 = create_unique_points(3)\n    test_cases.append((X1, Y1))\n\n    for _ in range(n - 1):\n        num_points = np.random.randint(2, 50)\n        X_random, Y_random = create_unique_points(num_points)\n        test_cases.append((X_random, Y_random))\n\n    return test_cases[:n]\n"}
{"problem_id": "numpy_25", "library": "numpy", "code_problem": "You are tasked with creating a function that generates two Gaussian maps: one for magnitude and one for phase. The function should take in parameters that define the size of the maps, as well as the maximum values and standard deviations for both the magnitude and phase distributions.\n\nFunction Signature:\n```python\ndef generate_gaussian_map(size, mag_max, mag_sigma, phase_max, phase_sigma):\n```\n\nConstants Used:\n- The constant used in the main code is `2`, which is part of the Gaussian function formula.\n\n\nInput Format:\n- The function takes a tuple `size` of two integers, followed by four floating-point numbers: `mag_max`, `mag_sigma`, `phase_max`, and `phase_sigma`.\n\nOutput Format:\n- The function returns a tuple containing two 2D numpy arrays: the first array represents the magnitude map, and the second array represents the phase map.\n\nInput:\n```python\n((10, 10), 1.0, 1.0, 1.0, 1.0)\n```\n\nOutput:\n```python\n(\n    array([[1.60522806e-09, 8.76424822e-08, 1.76034631e-06, 1.30072977e-05, 3.53575009e-05,\n            3.53575009e-05, 1.30072977e-05, 1.76034631e-06, 8.76424822e-08, 1.60522806e-09],\n            ...\n            [1.60522806e-09, 8.76424822e-08, 1.76034631e-06, 1.30072977e-05, 3.53575009e-05,\n            3.53575009e-05, 1.30072977e-05, 1.76034631e-06, 8.76424822e-08, 1.60522806e-09]]),\n    array([[1.60522806e-09, 8.76424822e-08, 1.76034631e-06, 1.30072977e-05, 3.53575009e-05,\n            3.53575009e-05, 1.30072977e-05, 1.76034631e-06, 8.76424822e-08, 1.60522806e-09]\n           ...\n           [1.60522806e-09, 8.76424822e-08, 1.76034631e-06, 1.30072977e-05, 3.53575009e-05, \n            3.53575009e-05, 1.30072977e-05, 1.76034631e-06, 8.76424822e-08, 1.60522806e-09]])\n)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef generate_gaussian_map(size, mag_max, mag_sigma, phase_max, phase_sigma):\n    py = np.arange(size[0]) - (size[0] - 1.0) / 2\n    px = np.arange(size[1]) - (size[1] - 1.0) / 2\n    (pxx, pyy) = np.meshgrid(px, py)\n    map_mag = mag_max * np.exp(-(pxx ** 2 + pyy ** 2) / (2 * mag_sigma ** 2))\n    map_phase = phase_max * np.exp(-(pxx ** 2 + pyy ** 2) / (2 * phase_sigma ** 2))\n    return (map_mag, map_phase)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        height = random.randint(0, 100)\n        width = random.randint(0, 100)\n        size = (height, width)\n\n        mag_max = random.uniform(-10.0, 10.0)\n        phase_max = random.uniform(-10.0, 10.0)\n\n        mag_sigma = random.uniform(0.1, 10.0)\n        phase_sigma = random.uniform(0.1, 10.0)\n        \n        test_cases.append((size, mag_max, mag_sigma, phase_max, phase_sigma))\n\n    test_cases.append(((10, 10), 1.0, 1.0, 1.0, 1.0))\n    test_cases.append(((20, 20), 2.0, 0.5, 2.0, 0.5))\n    test_cases.append(((5, 5), 0.0, 1.0, 0.0, 1.0))\n    test_cases.append(((50, 50), 5.0, 10.0, 3.0, 2.0))\n    test_cases.append(((1, 1), 1.0, 0.1, 1.0, 0.1))\n    test_cases.append(((30, 30), -1.0, 0.5, -1.0, 1.5))\n    test_cases.append(((15, 25), 4.0, 2.0, 5.0, 2.5))\n    test_cases.append(((100, 100), 3.0, 5.0, 4.0, 0.5))\n    test_cases.append(((0, 0), 1.0, 1.0, 1.0, 1.0))\n    test_cases.append(((10, 10), 10.0, 2.0, 5.0, 5.0))\n\n    return test_cases[:n]"}
{"problem_id": "numpy_26", "library": "numpy", "code_problem": "You are tasked with implementing a function that corrects the results of a k-nearest neighbors (k-NN) query by ensuring that the reference index is included in the output. The function should take in the indices and distances of the k-nearest neighbors and adjust them if the reference index is not the first element in the list of neighbors.\n\nFunction signature:\n```python\ndef fix_knn_query(indices: np.ndarray, distances: np.ndarray, ref_idx: np.ndarray) -> tuple:\n```\n\nConstant used in the main code:\n- The constant `1` is used to slice the `indices` and `distances` arrays, effectively removing the first column which contains the reference index.\n\nInput format:\n- `indices`: A 2D numpy array where each row contains the indices of the k-nearest neighbors for a given reference point.\n- `distances`: A 2D numpy array where each row contains the distances corresponding to the indices of the k-nearest neighbors.\n- `ref_idx`: A 1D numpy array containing the reference index for each row in the `indices` array.\n\nOutput format:\n- The function returns a tuple consisting of:\n  - A 2D numpy array of adjusted indices.\n  - A 2D numpy array of adjusted distances.\n  - An integer representing the number of mismatches found.\n\nInput:\n```python\nindices = np.array([[0, 2, 1],\n                    [1, 0, 3],\n                    [2, 1, 0]])\ndistances = np.array([[0.0, 0.5, 0.7],\n                      [0.0, 0.6, 0.8],\n                      [0.0, 0.4, 0.9]])\nref_idx = np.array([0, 1, 2])\n```\n\nOutput:\n```python\n(fixed_ind, fixed_dist, n_mis) = fix_knn_query(indices, distances, ref_idx)\n# fixed_ind = array([[2, 1],\n#                    [0, 3],\n#                    [1, 0]])\n# fixed_dist = array([[0.5, 0.7],\n#                     [0.6, 0.8],\n#                     [0.4, 0.9]])\n# n_mis = 0\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef fix_knn_query(indices, distances, ref_idx):\n    (fixed_ind, fixed_dist) = (indices.copy()[:, 1:], distances.copy()[:, 1:])\n    mis_idx = indices[:, 0].reshape(1, -1)[0] != ref_idx\n    n_mis = mis_idx.sum()\n    if n_mis > 0:\n        for (n, i, j, k) in zip(np.where(mis_idx)[0], ref_idx[mis_idx], indices[mis_idx], distances[mis_idx]):\n            p = np.where(j == i)[0]\n            if len(p) > 0:\n                p = p[0]\n                j = np.array(list(j[:p]) + list(j[p + 1:]))\n                k = np.array(list(k[:p]) + list(k[p + 1:]))\n            else:\n                j = j[:-1]\n                k = k[:-1]\n            fixed_ind[n] = j\n            fixed_dist[n] = k\n    return (fixed_ind, fixed_dist, n_mis)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        m = np.random.randint(11, 1001)\n        k = np.random.randint(2, 11)\n        indices = np.zeros((m, k), dtype=int)\n        for i in range(m):\n            ref_index = i\n            neighbors = np.random.choice(np.arange(m), size=min(k - 1, m), replace=False).tolist()\n            neighbors.append(ref_index)\n            np.random.shuffle(neighbors)\n            indices[i] = neighbors\n        distances = np.random.random(size=(m, k))\n        ref_idx = np.array([i for i in range(m)])\n        test_cases.append((indices, distances, ref_idx))\n\n    return test_cases\n"}
{"problem_id": "numpy_27", "library": "numpy", "code_problem": "```python\ndef weighted_mode(a, w, axis=0):\n```\n\nIn this function, `weighted_mode`, the goal is to compute the weighted mode of an array `a` along a specified axis, using weights provided in the array `w`. The function handles cases where the input arrays may not have the same shape and allows for the computation of the mode across different dimensions of the array.\n\n### Input and Output Format:\n- **Input**: \n  - `a`: A numpy array of values for which the weighted mode is to be calculated.\n  - `w`: A numpy array of weights corresponding to the values in `a`.\n  - `axis`: An integer specifying the axis along which to compute the mode (default is `0`).\n\n- **Output**: \n  - A tuple containing:\n    - The weighted mode of the array `a`.\n    - An array of counts corresponding to the weighted mode.\n\nInput:\n```python\na = np.array([[1, 2, 2], [3, 1, 2]])\nw = np.array([[0.5, 1.0, 1.5], [2.0, 0.5, 1.0]])\naxis = 0\n```\n\nOutput:\n```python\n(mostfrequent, counts) = (array([[3., 2., 2.]]), array([[2. , 1. , 2.5]]))\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef weighted_mode(a, w, axis=0):\n    if axis is None:\n        a = np.ravel(a)\n        w = np.ravel(w)\n        axis = 0\n    else:\n        a = np.asarray(a)\n        w = np.asarray(w)\n        axis = axis\n    if a.shape != w.shape:\n        w = np.zeros(a.shape, dtype=w.dtype) + w\n    scores = np.unique(np.ravel(a))\n    testshape = list(a.shape)\n    testshape[axis] = 1\n    oldmostfreq = np.zeros(testshape)\n    oldcounts = np.zeros(testshape)\n    for score in scores:\n        template = np.zeros(a.shape)\n        ind = a == score\n        template[ind] = w[ind]\n        counts = np.expand_dims(np.sum(template, axis), axis)\n        mostfrequent = np.where(counts > oldcounts, score, oldmostfreq)\n        oldcounts = np.maximum(counts, oldcounts)\n        oldmostfreq = mostfrequent\n    return (mostfrequent, oldcounts)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_dims = np.random.randint(1, 5)\n        shape = tuple(np.random.randint(1, 11, size=num_dims))\n        a = np.random.randint(0, 10, size=shape)\n        w = np.random.uniform(0.1, 10.0, size=shape)\n        axis = np.random.choice(range(num_dims))\n\n        test_cases.append((a, w, axis))\n\n    return test_cases"}
{"problem_id": "numpy_28", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates synthetic datasets based on different specified distributions. The function should create datasets in the following shapes:\n\n* **Gaussian** \u2013 a standard 2-D Gaussian centred at (0, 0) with identity covariance.  \n* **Mixture of Gaussians (MoG)** \u2013 **eight** Gaussian components with their means equally spaced on a circle of radius 0.8, each perturbed by isotropic noise \u03c3 = 0.08; the entire sample is finally scaled by 1.5.  \n* **Concentric circles** \u2013 **three** rings of radii 0.9, 0.6 and 0.3, each corrupted by Gaussian noise \u03c3 = 0.01 and then scaled by 1.5.  \n* **Single circle** \u2013 one ring of radius 0.9 with no added noise.  \n* **Checkerboard** \u2013 eight square blocks produced by sampling inside 0.45-side squares and then scaling all coordinates by 3.0 (effective square side \u2248 1.35), giving an alternating checkerboard-style pattern.  \n* **Grid** \u2013 a fixed 4 \u00d7 4 lattice over [-1, 1]\u00b2 (raw spacing \u2248 0.667, which becomes \u2248 0.533 after a 0.8 scale factor), with isotropic noise \u03c3 = 0.05 and an additional global scale of 1.5.\n\nThe generated datasets will be returned as 2-D `torch.Tensor`s and are intended for testing machine-learning algorithms.\n\nFunction signature:\n```python\ndef toy_generator(dataset: str, N: int) -> torch.Tensor:\n```\n\n### Constants Used:\n- The constant `1.5` is used to scale the generated data points in certain distributions.\n- The constant `0.8` is used to scale the positions of points in the mixture of Gaussians and grid distributions.\n- The constant `0.9` is used to scale the points in the circles and checkerboard distributions.\n- The constant `0.05` is used to add noise in the grid distribution.\n- The constant `0.01` is used to add noise in the circles distribution.\n\n\n### Input and Output Format:\n- **Input Format**:\n  - `dataset`: A string that can be one of the following: 'gaussian', 'mog', 'circles', 'circle', 'checker', 'grid'.\n  - `N`: An integer representing the number of data points to generate.\n\n- **Output Format**:\n  - Returns a `torch.Tensor` containing the generated data points in 2D space. The shape of the tensor will be `(N, 2)`, where `N` is the number of points generated.\n\nInput: `('mog', 50)`\n\nOutput: \n```\ntensor([[ 6.8940e-01,  8.8122e-01],\n        [-7.2838e-02,  1.1385e+00],\n        [-8.3544e-01, -1.0019e+00],\n        ...,\n        [-1.2752e+00, -7.4301e-02],\n        [ 1.3857e-01,  9.4127e-01],\n        [-6.6874e-01,  8.8420e-01]])\n``` \n\n(Note: The actual output will vary due to the randomness in the data generation process.)", "ground_truth_code": "import numpy as np\nimport torch\nimport torch.nn.functional as F\nimport math\n\n# main code\ndef toy_generator(dataset, N):\n    if dataset == 'gaussian':\n        X = torch.randn(size=[N, 2]).float()\n    elif dataset == 'mog':\n        angles = np.linspace(0, 14 * np.pi / 8, 8)\n        X1 = 0.8 * np.cos(angles).reshape(-1, 1)\n        X2 = 0.8 * np.sin(angles).reshape(-1, 1)\n        X = np.concatenate([X1, X2], axis=1)\n        X = X[:, None] + 0.08 * np.random.normal(size=[X.shape[0], N, X.shape[1]])\n        X = X.reshape(8 * N, 2)\n        X = X[np.random.permutation(X.shape[0])[:N]]\n        X = 1.5 * torch.tensor(X).float()\n    elif dataset == 'circles':\n        X1 = 0.9 * F.normalize(torch.randn(size=[N, 2]))\n        X2 = 0.6 * F.normalize(torch.randn(size=[N, 2]))\n        X3 = 0.3 * F.normalize(torch.randn(size=[N, 2]))\n        X = torch.cat([X1, X2, X3], dim=0)\n        X = X + 0.01 * torch.randn_like(X)\n        X = X[torch.randperm(X.shape[0])][:N]\n        X = 1.5 * X.float()\n    elif dataset == 'circle':\n        X = 0.9 * F.normalize(torch.randn(size=[N, 2]))\n        X = X.float()\n    elif dataset == 'checker':\n        corners = torch.tensor([[-1, 0.5], [0, 0.5], [-0.5, 0], [0.5, 0.0], [-1, -0.5], [0, -0.5], [-0.5, -1], [0.5, -1]])\n        X = 0.9 * torch.cat([corner.reshape(1, 2) + 0.5 * torch.rand(size=[N, 2]) for corner in corners], dim=0).float()\n        X = X[torch.randperm(X.shape[0])][:N]\n        X = 3.0 * X.float()\n    elif dataset == 'grid':\n        x = np.linspace(-1, 1, 4)\n        y = np.linspace(-1, 1, 4)\n        (X, Y) = np.meshgrid(x, y)\n        M = np.concatenate([X.reshape(-1, 1), Y.reshape(-1, 1)], axis=1) * 0.8\n        n = math.ceil(N / M.shape[0])\n        S = M[:, None] + 0.05 * np.random.normal(size=[M.shape[0], n, 2])\n        S = S.reshape(-1, 2)\n        S = S[np.random.permutation(S.shape[0])][:N]\n        X = 1.5 * torch.tensor(S).float()\n    return X", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    valid_datasets = ['gaussian', 'mog', 'circles', 'circle', 'checker', 'grid']\n    \n    test_cases = []\n    for _ in range(n):\n        dataset = random.choice(valid_datasets)\n        N = random.randint(1, 1000)\n        test_cases.append((dataset, N))\n    \n    return test_cases"}
{"problem_id": "numpy_29", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a random rotation matrix in three-dimensional space. The function should take a single parameter that specifies the maximum angle of rotation. The rotation matrix is constructed using a randomly generated axis of rotation and a random angle within the specified limit.\n\nFunction signature:\n```python\ndef random_rotation(max_angle: float) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the identity matrix, represented as `np.eye(3)`.\n\nInput format:\n- A single floating-point number `max_angle`, which represents the maximum angle of rotation in radians.\n\nOutput format:\n- A 3x3 numpy array representing the rotation matrix.\n\nInput:\n```python\n2\n``` \n\nOutput:\n```python\narray([[ 0.71660635, -0.69541848, -0.05355814],\n       [ 0.69069525,  0.69685972,  0.19320093],\n       [-0.09703298, -0.17544137,  0.97969634]])\n```\n\n(Note: The output matrix will vary each time the function is called due to the randomness in the rotation axis and angle.)", "ground_truth_code": "import numpy as np\n\n# main code\ndef random_rotation(max_angle):\n    axis = np.random.randn(3)\n    axis /= np.linalg.norm(axis)\n    angle = np.random.rand() * max_angle\n    A = np.array([[0, -axis[2], axis[1]], [axis[2], 0, -axis[0]], [-axis[1], axis[0], 0]])\n    R = np.eye(3) + np.sin(angle) * A + (1 - np.cos(angle)) * np.dot(A, A)\n    return R\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        max_angle = np.random.uniform(0, np.pi)\n        test_cases.append(max_angle)\n    return test_cases"}
{"problem_id": "numpy_30", "library": "numpy", "code_problem": "You are tasked with implementing a function that identifies the indices of relative extrema (local maxima or minima) in a given array. The function should be able to handle both one-dimensional and two-dimensional arrays and should allow for the identification of extrema with specific conditions.\n\nFunction signature:\n```python\ndef idxsOfRelativeExtrema(x, maxima, allowEq, axis):\n```\n\n### Constants:\n- The constant used in the main code is `pad`, which is set to `-np.inf` if `maxima` is `True` and `np.inf` if `maxima` is `False`.\n\n### Input Format:\n- The function takes four parameters:\n  - `x`: A one-dimensional or two-dimensional array of numerical values.\n  - `maxima`: A boolean indicating whether to find maxima (`True`) or minima (`False`).\n  - `allowEq`: A boolean indicating whether to allow equal values in the comparison.\n  - `axis`: An integer indicating the axis along which to find the extrema (0 for rows, 1 for columns).\n\n### Output Format:\n- The function returns a NumPy array containing the indices of the relative extrema found in the input array.\n\nInput:\n```python\nx = [1, 3, 2, 5, 4]\nmaxima = True\nallowEq = False\naxis = 0\n```\n\nOutput:\n```python\narray([1, 3])\n```", "ground_truth_code": "import numpy as np\nfrom scipy import signal\n\n# main code\ndef idxsOfRelativeExtrema(x, maxima, allowEq, axis):\n    if len(x) == 0:\n        return np.empty(1)\n    if len(x) == 1:\n        return np.zeros(1)\n\n    x = np.asarray(x)\n    pad = -np.inf if maxima else np.inf\n\n    func = (\n        np.greater_equal if maxima and allowEq else\n        np.greater if maxima else\n        np.less_equal if allowEq else\n        np.less\n    )\n\n    if len(x.shape) == 1:\n        x = np.r_[x, pad]\n        return signal.argrelextrema(x, func, mode='wrap')[0]\n\n    if axis == 0:\n        pad = np.full((1, x.shape[1]), pad)\n        x = np.vstack((x, pad))\n        return signal.argrelextrema(x, func, mode='wrap', axis=axis)\n\n    if axis == 1:\n        pad = np.full((x.shape[0], 1), pad)\n        x = np.hstack((x, pad))\n        return signal.argrelextrema(x, func, mode='wrap', axis=axis)\n\n    return np.array([])", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        is_1d = random.choice([True, False])\n\n        if is_1d:\n            length = random.randint(0, 100)\n            if length == 0:\n                x = []\n            else:\n                x = [random.uniform(-100, 100) for _ in range(length)]\n            maxima = random.choice([True, False])\n            allowEq = random.choice([True, False])\n            test_cases.append((x, maxima, allowEq, 0))\n        else:\n            rows = random.randint(1, 10)\n            cols = random.randint(1, 10)\n            x = np.random.uniform(-100, 100, (rows, cols))\n            maxima = random.choice([True, False])\n            allowEq = random.choice([True, False])\n            test_cases.append((x, maxima, allowEq, 0))\n\n    return test_cases"}
{"problem_id": "numpy_31", "library": "numpy", "code_problem": "You are tasked with implementing **`mrsr(X, T, kmax)`**, which selects **up to `kmax` column indices** from the predictor matrix **`X (n \u00d7 m)`** that, together, best explain the target matrix **`T (n \u00d7 p)`**.  \nThe routine follows a multivariate stepwise-regression (MRSR) procedure: it iteratively adds the feature whose inclusion maximizes a correlation-based criterion, updates the regression fit, and returns the chosen feature indices (`None` if no valid selection is possible).\n\nThe function signature is as follows:\n\n```python\ndef mrsr(X: np.ndarray, T: np.ndarray, kmax: int) -> Optional[np.ndarray]:\n```\n\n### Constants Used:\n- A small constant `1e-8` is used to avoid division by zero in the calculations.\n\n\n### Input Format:\n- `X`: A 2D numpy array of shape `(n, m)` representing the dataset.\n- `T`: A 2D numpy array of shape `(n, p)` representing the target matrix.\n- `kmax`: An integer representing the maximum number of features to select.\n\n### Output Format:\n- Returns a 1D numpy array of indices of the selected features from `X`, or `None` if no features are selected.\n\n**Input:**\n```python\nX = np.array([[0.5, -0.2, 0.1],\n              [-0.3, 0.4, 0.6],\n              [0.2, -0.1, -0.5]])\n\nT = np.array([[0.1],\n              [-0.4],\n              [0.3]])\n\nkmax = 2\n```\n\n**Output:**\n```python\narray([2, 0])\n```\n", "ground_truth_code": "import numpy as np\n\n# main code\ndef mrsr(X, T, kmax):\n    (n, m) = X.shape\n    (n, p) = T.shape\n    kmax = min(kmax, m)\n\n    if m == 0 or p == 0:\n        return None\n\n    i1 = np.array([], dtype=np.int32)\n    i2 = np.arange(m).astype(np.int32)\n    XT = np.dot(X.T, T)\n    XX = np.zeros([m, m])\n    S = np.ones([2 ** p, p])\n    S[0:2 ** (p - 1), 0] = -1\n\n    for j in np.arange(1, p):\n        S[:, j] = np.concatenate((S[np.arange(1, 2 ** p, 2), j - 1], S[np.arange(1, 2 ** p, 2), j - 1]))\n\n    A = np.transpose(XT)\n    cmax = np.amax(abs(A).sum(0), 0)\n    cind = np.argmax(abs(A).sum(0), 0)\n    A = np.delete(A, cind, 1)\n\n    ind = int(i2[cind])\n    i2 = np.delete(i2, cind)\n    i1 = np.append(i1, ind)\n\n    Xi2 = X.copy(order='F')\n    Xi2[:, cind:-1] = Xi2[:, cind + 1:]\n    Xi2 = Xi2[:, :-1]\n\n    Xi1 = X[:, ind].reshape((n, 1))\n    XX[np.ix_([ind], [ind])] = np.dot(X[:, ind], X[:, ind])\n    invXX = 1 / XX[ind, ind] if XX[ind, ind] != 0 else 1e-8\n    Wols = invXX * XT[ind, :]\n    Yols = np.dot(Xi1, np.reshape(Wols, (1, -1)))\n\n    B = np.dot(Yols.T, Xi2)\n    denominator = cmax + np.dot(S, B)\n    denominator[denominator == 0] = 1e-8\n    G = (cmax + np.dot(S, A)) / denominator\n\n    valid_G = G[G >= 0]\n    if valid_G.size == 0:\n        return None\n    g = valid_G.min()\n    Y = g * Yols\n\n    for k in np.arange(2, kmax + 1):\n        A = np.dot((T - Y).T, Xi2)\n        cmax = np.amax(abs(A).sum(0), 0)\n        cind = np.argmax(abs(A).sum(0), 0)\n        A = np.delete(A, cind, 1)\n\n        if i2.size == 0:\n            break\n\n        ind = int(i2[cind])\n        i2 = np.delete(i2, cind)\n        i1 = np.append(i1, ind)\n\n        Xi1 = np.hstack((Xi1, X[:, ind].reshape((-1, 1))))\n        xX = np.dot(X[:, ind].T, Xi1)\n        XX[np.ix_([ind], i1)] = xX\n        XX[np.ix_(i1, [ind])] = np.reshape(xX, (i1.size, -1))\n\n        v3 = XX.take(i1, axis=0).take(i1, axis=1)\n        invXX = np.linalg.pinv(v3)\n\n        Wols = np.dot(invXX, XT.take(i1, axis=0))\n        Yols = np.dot(Xi1, Wols)\n\n        Xi2[:, cind:-1] = Xi2[:, cind + 1:]\n        Xi2 = Xi2[:, :-1]\n\n        B = np.dot((Yols - Y).T, Xi2)\n        denominator = cmax + S.dot(B)\n        denominator[denominator == 0] = 1e-8\n        G = (cmax + S.dot(A)) / denominator\n\n        valid_G = G[G >= 0]\n        if valid_G.size == 0:\n            return None\n        g = valid_G.min()\n\n        if k == kmax:\n            Y = Yols\n        else:\n            Y = (1 - g) * Y + g * Yols\n\n    return i1 if len(i1) > 0 else None", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = np.random.randint(1, 101)\n        n_regressors = np.random.randint(1, 51)\n        n_targets = np.random.randint(1, 16)\n\n        if n_regressors == 0 or n_targets == 0:\n            continue\n\n        X = np.random.rand(n_samples, n_regressors) * 2 - 1\n        X -= np.mean(X, axis=0)\n        std_X = np.std(X, axis=0, ddof=1)\n        std_X[std_X == 0] = 1e-8\n        X /= std_X\n\n        T = np.random.rand(n_samples, n_targets) * 2 - 1\n        T -= np.mean(T, axis=0)\n        std_T = np.std(T, axis=0, ddof=1)\n        std_T[std_T == 0] = 1e-8\n        T /= std_T\n\n        kmax = np.random.randint(1, n_regressors + 1)\n\n        if np.random.rand() < 0.1:\n            X = np.zeros((n_samples, n_regressors))\n            T = np.zeros((n_samples, n_targets))\n            kmax = 1\n\n        test_cases.append((X, T, kmax))\n\n    return test_cases\n"}
{"problem_id": "numpy_32", "library": "numpy", "code_problem": "```python\ndef find_superpixel_3d(Yt: np.ndarray, num_plane: int, cut_off_point: float, length_cut: int, eight_neighbours: bool) -> tuple:\n```\n\nIn this function, the goal is to identify and label superpixels in a 3D array representing an image or a volume of data. The function takes in a 5-dimensional array `Yt`, which is reshaped and processed to extract meaningful connections between neighboring pixels based on their statistical properties.\n\n### Constants Used:\n- `cut_off_point`: A float value that serves as a threshold for determining significant correlations between neighboring pixels.\n- `length_cut`: An integer that specifies the minimum size of connected components to be considered valid superpixels.\n\n\n### Input Format:\n- `Yt`: A 5D numpy array representing the input data.\n- `num_plane`: An integer indicating the number of planes in the 3D representation.\n- `cut_off_point`: A float threshold for correlation significance.\n- `length_cut`: An integer specifying the minimum size of connected components.\n- `eight_neighbours`: A boolean indicating whether to consider diagonal neighbors.\n\n### Output Format:\n- A tuple containing:\n  - A 3D numpy array with labeled superpixels.\n  - An integer representing the count of valid superpixels.\n  - A list of connected components.\n  - A numpy array of the random permutation used for labeling.\n\nInput:\n```python\nYt = np.array([[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], \n                [[0.7, 0.8, 0.9], [0.1, 0.2, 0.3]], \n                [[0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]])\nnum_plane = 2\ncut_off_point = 0.1\nlength_cut = 1\neight_neighbours = True\n```\n\nOutput:\n```python\n(connect_mat_1, idx, comps, permute_col) = (\n    array([[1, 1],\n           [1, 1],\n           [1, 1]]), \n    1, \n    [{0, 1, 2, 3, 4, 5}],\n    array([1])\n)\n```", "ground_truth_code": "import numpy as np\nimport networkx as nx\n\n# main code\ndef find_superpixel_3d(Yt, num_plane, cut_off_point, length_cut, eight_neighbours):\n    dims = Yt.shape\n    Yt_3d = Yt.reshape(dims[0], int(dims[1] / num_plane), num_plane, dims[2], order='F')\n    dims = Yt_3d.shape\n    ref_mat = np.arange(np.prod(dims[:-1])).reshape(dims[:-1], order='F')\n    w_mov = (Yt_3d.transpose(3, 0, 1, 2) - np.mean(Yt_3d, axis=3)) / np.std(Yt_3d, axis=3)\n    w_mov[np.isnan(w_mov)] = 0\n    rho_v = np.mean(np.multiply(w_mov[:, :-1, :], w_mov[:, 1:, :]), axis=0)\n    rho_h = np.mean(np.multiply(w_mov[:, :, :-1], w_mov[:, :, 1:]), axis=0)\n    if eight_neighbours:\n        rho_l = np.mean(np.multiply(w_mov[:, 1:, :-1], w_mov[:, :-1, 1:]), axis=0)\n        rho_r = np.mean(np.multiply(w_mov[:, :-1, :-1], w_mov[:, 1:, 1:]), axis=0)\n    rho_u = np.mean(np.multiply(w_mov[:, :, :, :-1], w_mov[:, :, :, 1:]), axis=0)\n    rho_v = np.concatenate([rho_v, np.zeros([1, rho_v.shape[1], num_plane])], axis=0)\n    rho_h = np.concatenate([rho_h, np.zeros([rho_h.shape[0], 1, num_plane])], axis=1)\n    if eight_neighbours:\n        rho_r = np.concatenate([rho_r, np.zeros([rho_r.shape[0], 1, num_plane])], axis=1)\n        rho_r = np.concatenate([rho_r, np.zeros([1, rho_r.shape[1], num_plane])], axis=0)\n        rho_l = np.concatenate([np.zeros([rho_l.shape[0], 1, num_plane]), rho_l], axis=1)\n        rho_l = np.concatenate([rho_l, np.zeros([1, rho_l.shape[1], num_plane])], axis=0)\n    rho_u = np.concatenate([rho_u, np.zeros([rho_u.shape[0], rho_u.shape[1], 1])], axis=2)\n    temp_v = np.where(rho_v > cut_off_point)\n    A_v = ref_mat[temp_v]\n    B_v = ref_mat[temp_v[0] + 1, temp_v[1], temp_v[2]]\n    temp_h = np.where(rho_h > cut_off_point)\n    A_h = ref_mat[temp_h]\n    B_h = ref_mat[temp_h[0], temp_h[1] + 1, temp_h[2]]\n    temp_u = np.where(rho_u > cut_off_point)\n    A_u = ref_mat[temp_u]\n    B_u = ref_mat[temp_u[0], temp_u[1], temp_u[2] + 1]\n    if eight_neighbours:\n        temp_l = np.where(rho_l > cut_off_point)\n        A_l = ref_mat[temp_l]\n        B_l = ref_mat[temp_l[0] + 1, temp_l[1] - 1, temp_l[2]]\n        temp_r = np.where(rho_r > cut_off_point)\n        A_r = ref_mat[temp_r]\n        B_r = ref_mat[temp_r[0] + 1, temp_r[1] + 1, temp_r[2]]\n        A = np.concatenate([A_v, A_h, A_l, A_r, A_u])\n        B = np.concatenate([B_v, B_h, B_l, B_r, B_u])\n    else:\n        A = np.concatenate([A_v, A_h, A_u])\n        B = np.concatenate([B_v, B_h, B_u])\n    G = nx.Graph()\n    G.add_edges_from(list(zip(A, B)))\n    comps = list(nx.connected_components(G))\n    connect_mat = np.zeros(np.prod(dims[:-1]))\n    idx = 0\n    for comp in comps:\n        if len(comp) > length_cut:\n            idx = idx + 1\n    permute_col = np.random.permutation(idx) + 1\n    ii = 0\n    for comp in comps:\n        if len(comp) > length_cut:\n            connect_mat[list(comp)] = permute_col[ii]\n            ii = ii + 1\n    connect_mat_1 = connect_mat.reshape(Yt.shape[:-1], order='F')\n    return (connect_mat_1, idx, comps, permute_col)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        d1 = np.random.randint(1, 20)\n        num_plane = np.random.randint(1, min(d1*2, 20))\n        d2 = np.random.randint(num_plane, 40)\n        T = np.random.randint(1, 20)\n        Yt = np.random.rand(d1, d2 * num_plane, T)\n        cut_off_point = np.random.uniform(0, 1)\n        length_cut = np.random.randint(1, 10)\n        eight_neighbours = np.random.choice([True, False])\n        test_cases.append((Yt, num_plane, cut_off_point, length_cut, eight_neighbours))\n    \n    return test_cases\n\n"}
{"problem_id": "numpy_33", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs spatial-temporal initialization for a given dataset. The function will utilize Non-negative Matrix Factorization (NMF) to decompose the input data and optionally apply Truncated Singular Value Decomposition (SVD) to extract background components. \nThe `spatial_temporal_ini` routine begins by flattening the two spatial dimensions of the 3-D data array `Yt`, converting it into a pixels-by-time matrix. It then iterates through each pixel group in `comps` that exceeds the `length_cut`, applying a one-component Non-negative Matrix Factorization (NMF) with custom initialisation to capture each group\u2019s spatial loadings and temporal signature, which are stored in `U_mat` and `V_mat`, respectively. If background extraction is requested (`bg > 0`), the function gathers all pixels not assigned to any component, mean-centres their activity, and uses Truncated Singular Value Decomposition (SVD) to distil up to `bg` background patterns, saving their spatial structures in `bg_u` and temporal traces in `bg_v`; otherwise, both background outputs are `None`. The function ultimately returns a tuple `(V_mat, U_mat, bg_v, bg_u)`, providing temporal and spatial factors for both foreground components and, optionally, background patterns.\n\nThe function signature is as follows:\n\n```python\ndef spatial_temporal_ini(Yt, comps, idx, length_cut, bg):\n```\n\n### Constants:\n- The constant `bg` is used to determine the number of background components to extract when the background option is enabled.\n\n\n### Input Format:\n- `Yt`: A 3D numpy array representing the spatial-temporal data.\n- `comps`: A list of lists, where each inner list contains indices corresponding to spatial locations.\n- `idx`: An integer representing the number of components to extract.\n- `length_cut`: An integer threshold for the minimum length of components to be considered.\n- `bg`: An integer indicating how to extract background components.\n\n### Output Format:\n- The function returns a tuple containing:\n  - `V_mat`: A 2D numpy array of shape (T, idx).\n  - `U_mat`: A 2D numpy array of shape (number of spatial locations, idx).\n  - `bg_v`: A 2D numpy array of shape (number of background components, bg) or `None`.\n  - `bg_u`: A 2D numpy array of shape (number of spatial locations, bg) or `None`.\n\n**Input:**\n```python\nYt = np.array([[[0.1, 0.2], [0.3, 0.4]], \n                [[0.5, 0.6], [0.7, 0.8]], \n                [[0.9, 1.0], [1.1, 1.2]]])\n\ncomps = [[0, 1], [2]]\nidx = 2\nlength_cut = 1\nbg = 1\n```\n\n**Output:**\n```python\narray([[0.31369127, 0.        ],\n       [0.38972885, 0.        ]])\n\narray([[0.43675162, 0.        ],\n       [1.56091618, 0.        ],\n       [0.        , 0.        ],\n       [0.        , 0.        ],\n       [0.        , 0.        ],\n       [0.        , 0.        ]])\n\narray([[-0.70710678],\n       [ 0.70710678]])\n\narray([[0.],\n       [0.],\n       [0.],\n       [0.],\n       [0.],\n       [0.]])\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.decomposition import TruncatedSVD, NMF\n\n# main code\ndef spatial_temporal_ini(Yt, comps, idx, length_cut, bg):\n    dims = Yt.shape\n    T = dims[2]\n    Yt_r = Yt.reshape(np.prod(dims[:2]), T, order='F')\n    ii = 0\n    U_mat = np.zeros([np.prod(dims[:2]), idx])\n    V_mat = np.zeros([T, idx])\n\n    for comp in comps:\n        if len(comp) > length_cut:\n            y_temp = Yt_r[list(comp), :]\n            model = NMF(n_components=1, init='custom')\n            U_mat[list(comp), ii] = model.fit_transform(\n                y_temp,\n                W=y_temp.mean(axis=1, keepdims=True),\n                H=y_temp.mean(axis=0, keepdims=True)\n            )[:, 0]\n            V_mat[:, ii] = model.components_\n            ii += 1\n\n    if bg:\n        bg_comp_pos = np.where(U_mat.sum(axis=1) == 0)[0]\n        y_temp = Yt_r[bg_comp_pos, :]\n        bg_u = np.zeros([Yt_r.shape[0], bg])\n        y_temp = y_temp - y_temp.mean(axis=1, keepdims=True)\n\n        bg = min(bg, y_temp.shape[1])\n\n        if y_temp.shape[1] > 1 and y_temp.shape[0] > 0:\n            svd = TruncatedSVD(n_components=bg, n_iter=7, random_state=0)\n            bg_u = np.zeros([Yt_r.shape[0], bg])\n            bg_v = svd.fit(y_temp).components_.T\n            bg_v = bg_v - bg_v.mean(axis=0, keepdims=True)\n        elif y_temp.shape[0] > 0:\n            bg_u[bg_comp_pos, :] = y_temp\n            bg_v = np.zeros((1, bg))\n        else:\n            bg_u = None\n            bg_v = None\n\n    else:\n        bg_v = None\n        bg_u = None\n\n    return (V_mat, U_mat, bg_v, bg_u)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        height = np.random.randint(1, 51)\n        width = np.random.randint(1, 51)\n        time = np.random.randint(2, 21)\n        Yt = np.random.rand(height, width, time)\n\n        num_components = np.random.randint(1, min(10, height * width))\n        comps = []\n\n        available_indices = list(range(height * width))\n        for _ in range(num_components):\n            if len(available_indices) > 0:\n                comp_size = np.random.randint(1, min(11, len(available_indices) + 1))\n                comp = np.random.choice(available_indices, comp_size, replace=False).tolist()\n                comps.append(comp)\n                available_indices = [i for i in available_indices if i not in comp]\n\n        idx = max(len(comps), 1)\n        length_cut = np.random.randint(0, max((len(comp) for comp in comps), default=1) + 1)\n        bg = np.random.choice([True, False])\n        bg_count = np.random.randint(1, 6) if bg else 0\n\n        test_cases.append((Yt, comps, idx, length_cut, bg_count))\n\n    return test_cases"}
{"problem_id": "numpy_34", "library": "numpy", "code_problem": "You are tasked with implementing a function that prepares matrices for further analysis based on input data and specified parameters. The function will manipulate and normalize matrices derived from a given dataset, ensuring that the output is suitable for subsequent operations.\n\nFunction signature:\n```python\ndef prepare_iteration(Yd: np.ndarray, permute_col: list, pure_pix: list, U_mat: np.ndarray, V_mat: np.ndarray, more: bool) -> tuple\n```\n\n### Constants:\n- The constant `T` represents the third dimension of the input array `Yd`, which is the number of time points or observations.\n\n### Input Format:\n- `Yd`: A 3D numpy array of shape (m, n, T) where m and n are spatial dimensions and T is the number of time points.\n- `permute_col`: A list of column indices to be permuted.\n- `pure_pix`: A list of pure pixel indices to be considered.\n- `U_mat`: A 2D numpy array of shape (p, q) representing the first matrix.\n- `V_mat`: A 2D numpy array of shape (p, q) representing the second matrix.\n- `more`: A boolean flag indicating whether to return additional normalization data.\n\n### Output Format:\n- Returns a tuple containing:\n  - `U_mat`: The processed U matrix.\n  - `V_mat`: The processed V matrix.\n  - If `more` is `True`, also returns:\n    - `B_mat`: The median matrix of `Yd`.\n    - `normalize_factor`: The normalization factor.\n  - `brightness_rank`: The rank of brightness values.\n\n**Input:**\n```python\nYd = np.array([[[ 0.1,  0.2,  0.3],\n                 [ 0.4,  0.5,  0.6]],\n                \n                [[ 0.7,  0.8,  0.9],\n                 [ 1.0,  1.1,  1.2]]])\n\npermute_col = [1, 0]\npure_pix = [0, 1]\nU_mat = np.array([[0.5, 0.6],\n                  [0.7, 0.8]])\nV_mat = np.array([[0.1, 0.2],\n                  [0.3, 0.4]])\nmore = True\n```\n\n**Output:**\n```python\n(U_mat, V_mat, B_mat, normalize_factor, brightness_rank)\n```\nWhere:\n- `U_mat` and `V_mat` are transformed matrices based on the input.\n- `B_mat` is the median of `Yd` across the first axis.\n- `normalize_factor` is the standard deviation of `Yd` multiplied by the number of time steps `T`.\n- `brightness_rank` is the rank of brightness values.\n\n**Expected Output Values:**\n```python\n# Example output values (actual values may vary due to randomness)\narray([[0.6       , 0.58123819],\n       [0.8       , 0.81373347]])\n\narray([[0.2       , 0.08602325],\n       [0.4       , 0.25806976]])\n\narray([[0.2],\n       [0.8],\n       [0.5],\n       [1.1]])\n\narray([[0.24494897],\n       [0.24494897],\n       [0.24494897],\n       [0.24494897]])\n\narray([0, 1])\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as ss\n\n# main code\ndef prepare_iteration(Yd, permute_col, pure_pix, U_mat, V_mat, more):\n    dims = Yd.shape\n    T = dims[2]\n    Yd = Yd.reshape(np.prod(dims[:-1]), -1, order='F')\n    permute_col = list(permute_col)\n    pos = [permute_col.index(x) for x in pure_pix if x in permute_col]\n\n    if not pos:\n        return None\n\n    max_pos = max(pos)\n    if max_pos >= U_mat.shape[1]:\n        pos = [p for p in pos if p < U_mat.shape[1]]\n        if not pos:\n            return None\n\n    U_mat = U_mat[:, pos]\n    V_mat = V_mat[:, pos]\n\n    u_max = U_mat.max(axis=0)\n    v_max = V_mat.max(axis=0)\n    brightness = u_max * v_max\n    brightness_arg = np.argsort(-brightness)\n    brightness_rank = U_mat.shape[1] - ss.rankdata(brightness, method='ordinal')\n\n    U_mat = U_mat[:, brightness_arg]\n    V_mat = V_mat[:, brightness_arg]\n    temp = np.sqrt((U_mat ** 2).sum(axis=0, keepdims=True))\n    V_mat = V_mat * temp\n    U_mat = U_mat / temp\n\n    if more:\n        normalize_factor = np.std(Yd, axis=1, keepdims=True) * T\n        B_mat = np.median(Yd, axis=1, keepdims=True)\n        return (U_mat, V_mat, B_mat, normalize_factor, brightness_rank)\n    else:\n        return (U_mat, V_mat, brightness_rank)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        H = np.random.randint(5, 20)\n        W = np.random.randint(5, 20)\n        T = np.random.randint(3, 10)\n\n        Yd = np.random.randn(H, W, T)\n        permute_col = np.random.permutation(W).tolist()\n\n        if not permute_col:\n            continue\n\n        pure_pix = random.sample(permute_col, k=np.random.randint(1, W))\n\n        U_mat = np.random.randn(H, len(pure_pix))\n        V_mat = np.random.randn(W, len(pure_pix))\n\n        more = random.choice([True, False])\n        test_cases.append((Yd, permute_col, pure_pix, U_mat, V_mat, more))\n\n    return test_cases"}
{"problem_id": "numpy_35", "library": "numpy", "code_problem": "You are tasked with implementing a function that analyzes the correlation between different datasets and returns the indices of the most significant features based on a specified threshold. The function will utilize a custom correlation coefficient calculation to determine the relationships between the datasets.\n\nFunction signature:\n```python\ndef match_comp(rlt, rlt_lasso_Ydc, rlt_lasso_Yrawc, rlt_a, rlt_lasso_Yda, rlt_lasso_Yrawa, th):\n```\n\nConstants used in the main code:\n- The constant `th` represents the threshold value used to filter significant correlations.\n\nInput format:\n- The function takes the following parameters:\n  - `rlt`: A 2D numpy array representing the main dataset.\n  - `rlt_lasso_Ydc`: A 2D numpy array for the first dataset used in correlation analysis.\n  - `rlt_lasso_Yrawc`: A 2D numpy array for the second dataset used in correlation analysis.\n  - `rlt_a`: A 2D numpy array representing additional data for feature analysis.\n  - `rlt_lasso_Yda`: A 2D numpy array for the first dataset used in feature significance determination.\n  - `rlt_lasso_Yrawa`: A 2D numpy array for the second dataset used in feature significance determination.\n  - `th`: A float representing the threshold for filtering significant correlations.\n\nOutput format:\n- The function returns a tuple of two numpy arrays:\n  - The first array contains the indices of the most significant features for the first dataset.\n  - The second array contains the indices of the most significant features for the second dataset.\n\n**Input:**\n```python\nrlt = np.array([[0.5, -0.2, 0.1],\n                [0.3, 0.4, -0.5],\n                [-0.1, 0.2, 0.3],\n                [0.6, -0.4, 0.2]])\n\nrlt_lasso_Ydc = np.array([[0.1, 0.2, 0.3, 0.4],\n                          [0.5, 0.6, 0.7, 0.8]])\n\nrlt_lasso_Yrawc = np.array([[0.2, 0.1, 0.4, 0.3],\n                             [0.6, 0.5, 0.8, 0.7]])\n\nrlt_a = np.array([[1, 0, 0],\n                  [0, 1, 0],\n                  [0, 0, 1],\n                  [1, 1, 0]])\n\nrlt_lasso_Yda = np.array([[0.1, 0.2],\n                           [0.3, 0.4],\n                           [0.5, 0.6],\n                           [0.7, 0.8]])\n\nrlt_lasso_Yrawa = np.array([[0.2, 0.1],\n                             [0.4, 0.3],\n                             [0.6, 0.5],\n                             [0.8, 0.7]])\n\nth = 0.3\n```\n\n**Output:**\n```python\norder_Yd = np.array([-9223372036854775808, -9223372036854775808, -9223372036854775808])\n\norder_Yraw = np.array([-9223372036854775808, -9223372036854775808, -9223372036854775808])\n```\n\n### Note:\nThe actual output values for `order_Yd` and `order_Yraw` will depend on the specific random values generated in the input arrays. The example output provided here is illustrative and may not match the actual output from running the function with the given input.", "ground_truth_code": "import numpy as np\n\n# main code\ndef match_comp(rlt, rlt_lasso_Ydc, rlt_lasso_Yrawc, rlt_a, rlt_lasso_Yda, rlt_lasso_Yrawa, th):\n    def vcorrcoef2(X, y):\n        Xm = np.reshape(np.mean(X, axis=1), (X.shape[0], 1))\n        ym = np.mean(y, keepdims=True)\n\n        y = np.reshape(y, (-1, 1))\n\n        r_num = np.sum((X - Xm) * (y - ym), axis=1)\n        r_den = np.sqrt(np.sum((X - Xm) ** 2, axis=1) * np.sum((y - ym) ** 2))\n        r = r_num / r_den\n        return r\n\n    K = rlt.shape[1]\n    order_Yd = np.zeros([K])\n    order_Yraw = np.zeros([K])\n    for ii in range(K):\n        temp = vcorrcoef2(rlt_lasso_Ydc.T, rlt[:, ii])\n        temp2 = vcorrcoef2(rlt_lasso_Yrawc.T, rlt[:, ii])\n        pos = np.argsort(-temp)[:sum(temp > th)]\n        pos2 = np.argsort(-temp2)[:sum(temp2 > th)]\n        if len(pos) > 0:\n            spa_temp = np.where(np.matmul(rlt_a[:, [ii]].T, rlt_lasso_Yda[:, pos]) > 0)[1]\n            if len(spa_temp) > 0:\n                order_Yd[ii] = int(pos[spa_temp[0]])\n            else:\n                order_Yd[ii] = np.nan\n        else:\n            order_Yd[ii] = np.nan\n        if len(pos2) > 0:\n            spa_temp2 = np.where(np.matmul(rlt_a[:, [ii]].T, rlt_lasso_Yrawa[:, pos2]) > 0)[1]\n            if len(spa_temp2) > 0:\n                order_Yraw[ii] = int(pos2[spa_temp2[0]])\n            else:\n                order_Yraw[ii] = np.nan\n        else:\n            order_Yraw[ii] = np.nan\n    order_Yd = np.asarray(order_Yd, dtype=int)\n    order_Yraw = np.asarray(order_Yraw, dtype=int)\n    return (order_Yd, order_Yraw)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(5, 20)\n        num_features = np.random.randint(3, 10)\n        num_lasso = np.random.randint(3, 10)\n        rlt = np.random.randn(num_samples, num_features)\n        rlt_lasso_Ydc = np.random.randn(num_lasso, num_samples)\n        rlt_lasso_Yrawc = np.random.randn(num_lasso, num_samples)\n        rlt_a = np.random.randn(num_samples, num_features)\n        rlt_lasso_Yda = np.random.randn(num_samples, num_lasso)\n        rlt_lasso_Yrawa = np.random.randn(num_samples, num_lasso)\n        th = np.random.uniform(0.1, 0.9)\n        test_cases.append((rlt, rlt_lasso_Ydc, rlt_lasso_Yrawc, rlt_a, rlt_lasso_Yda, rlt_lasso_Yrawa, th))\n\n    return test_cases"}
{"problem_id": "numpy_36", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs a non-negative least-squares (NNLS) optimisation and, only when the initial fit already lies within a specified noise tolerance, greedily simplifies the model by eliminating variables. The function accepts a design matrix **X \u2208 \u211d\u1d50\u02e3\u207f**, a target vector **Yp \u2208 \u211d\u1d50**, and a scalar noise threshold **noise**. It first solves the NNLS problem **min \u2016X w \u2013 Yp\u2016\u2082  subject to w \u2265 0**, yielding the weight vector **W_lam** and the squared residual-sum-of-squares (RSS). If this RSS exceeds **noise**, the routine stops and returns **W_lam** unchanged. Otherwise, it repeatedly examines each currently positive coefficient (excluding the final entry), temporarily zeroes the corresponding column of **X**, re-solves the NNLS problem, and checks whether the squared RSS remains below the noise threshold. Among the removable coefficients, it discards the one whose exclusion produces the smallest RSS, then iterates this elimination process until no further coefficient can be removed without the squared RSS exceeding **noise**. The function finally returns the pruned, non-negative weight vector that maintains the desired fit quality while dropping the least essential variables.\n\nFunction signature:\n```python\ndef nnls_L0(X, Yp, noise):\n```\n\nConstants used in the main code:\n- The variable `noise` is used as a threshold to determine whether the residual sum of squares (RSS) is acceptable.\n\nInput format:\n- `X`: A 2D numpy array representing the design matrix.\n- `Yp`: A 1D numpy array representing the target vector.\n- `noise`: A float representing the threshold for acceptable residuals.\n\nOutput format:\n- Returns a 1D numpy array containing the weights `W_lam` after the NNLS optimization and variable elimination process.\n\n**Input:**\n```python\nX = np.array([[1, 2], [3, 4]])\nYp = np.array([5, 6])\nnoise = 10.0\n```\n\n**Output:**\n```python\nW_lam = np.array([0. , 1.7])\n```\n\n### Explanation:\nIn this test case, the input matrix `X` has two rows and two columns, and the target vector `Yp` has two elements. The noise level is set to 10.0. The expected output `W_lam` is a weight vector that the `nnls_L0` function will compute based on the non-negative least squares optimization. The actual output may vary depending on the optimization process, but it should be a non-negative array of weights.", "ground_truth_code": "import numpy as np\nimport scipy\n\n# main code\ndef nnls_L0(X, Yp, noise):\n    W_lam, RSS = scipy.optimize.nnls(X, np.ravel(Yp))\n    RSS = RSS ** 2\n\n    if RSS > noise:\n        return W_lam\n\n    while True:\n        eliminate = []\n        indices = np.where(W_lam[:-1] > 0)[0]\n\n        for i in indices:\n            mask = W_lam > 0\n            mask[i] = False\n            Wtmp, tmp = scipy.optimize.nnls(X * mask, np.ravel(Yp))\n\n            if tmp ** 2 < noise:\n                eliminate.append([i, tmp])\n\n        if not eliminate:\n            return W_lam\n\n        min_index = np.argmin(np.array(eliminate)[:, 1])\n        W_lam[eliminate[min_index][0]] = 0", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    test_cases.append((np.array([[1]]), np.array([1]), 0.0))\n    test_cases.append((np.array([[0, 0], [0, 0]]), np.array([0, 0]), 0.0))\n    test_cases.append((np.array([[1, 2], [3, 4]]), np.array([5, 6]), 10.0))\n    test_cases.append((np.random.rand(100, 5), np.random.rand(100), 1.0))\n    test_cases.append((np.array([[1, 4], [2, 8]]), np.array([3, 10]), 1e-6))\n    test_cases.append((np.random.rand(1000, 50), np.random.rand(1000), 5.0))\n    test_cases.append((np.array([[1, 1, 1], [1, 1, 1]]), np.array([3, 3]), 0.1))\n    test_cases.append((np.random.rand(10, 10), np.random.choice([0, 1, 2, 3], size=10), 0.5))\n    test_cases.append((np.array([[1000, 2000], [3000, 4000]]), np.array([5000, 6000]), 100.0))\n    test_cases.append((np.array([[1, 2], [3, 4]]), np.array([-1, -2]), 0.5))\n    while len(test_cases) < n:\n        rows = np.random.randint(1, 20)\n        cols = np.random.randint(1, 10)\n\n        X = np.random.rand(rows, cols)\n        Yp = np.random.rand(rows)\n        noise = np.random.uniform(0.0, 10.0)\n\n        test_cases.append((X, Yp, noise))\n\n    return test_cases"}
{"problem_id": "numpy_37", "library": "numpy", "code_problem": "You are tasked with implementing a function that fits an ellipse within a given bounding box (BB) defined by its corner coordinates. The function should compute the parameters of the ellipse that best fits within the specified bounding box.\n\nFunction signature:\n```python\ndef fit_one_ellipse_in_bb(bb):\n```\n\nConstant used in the main code:\n- The constant `1` is used in the construction of the matrix representing the ellipse's characteristics.\n\nInput format:\n- The input to the function is a list or array `bb` of four elements representing the coordinates of the bounding box in the format [x_min, y_min, x_max, y_max].\n\nOutput format:\n- The output of the function is a 3x3 numpy array representing the covariance matrix of the fitted ellipse.\n\nInput: `np.array([-10, -20, 10, 20])`  \nOutput: `np.array([[100.,   0.,   0.], [  0., 400.,   0.], [  0.,   0.,  -1.]])`", "ground_truth_code": "import numpy as np\n\n# main code\ndef fit_one_ellipse_in_bb(bb):\n    width = abs(bb[2] - bb[0]) / 2\n    height = abs(bb[3] - bb[1]) / 2\n    Ccn = np.vstack((np.hstack((np.diag((1 / width ** 2, 1 / height ** 2)), np.zeros((2, 1)))), np.array((0, 0, -1))))\n    centre = np.array(((bb[0] + bb[2]) / 2, (bb[1] + bb[3]) / 2))\n    P = np.vstack((np.hstack((np.eye(2, 2), centre.reshape(2, 1))), np.array((0, 0, 1))))\n    Cinv = P.dot(np.linalg.inv(Ccn)).dot(P.transpose())\n    Cinv = 0.5 * (Cinv + Cinv.transpose())\n    C = Cinv / Cinv[2, 2]\n    C = C * np.sign(C[0, 0] + C[1, 1])\n    return C", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        min_x, min_y = np.random.uniform(-100, 100, size=2)\n        max_x, max_y = min_x + np.random.uniform(1, 50), min_y + np.random.uniform(1, 50)\n        bb = np.array([min_x, min_y, max_x, max_y])\n\n        test_cases.append(bb)\n    return test_cases\n"}
{"problem_id": "numpy_38", "library": "numpy", "code_problem": "You are tasked with implementing find_superpixel_3d(Yt, num_plane, cut_off_point, length_cut, length_max, eight_neighbours=True), a function that identifies and labels connected components (\u201csuperpixels\u201d) in a 3-D array that represents a stack of planes through time. The function analyzes the spatial (vertical, horizontal and optional diagonal) and inter-plane relationships between neighbouring elements, linking voxels whose pair-wise correlation exceeds cut_off_point into an undirected graph and keeping only those connected components whose size falls between length_cut and length_max.\n\nFunction Signature:\n```python\ndef find_superpixel_3d(Yt: np.ndarray, num_plane: int, cut_off_point: float, length_cut: int, length_max: int, eight_neighbours: bool = True) -> tuple:\n```\n\nConstants:\n- The constant `cut_off_point` is used to determine the threshold for connectivity between neighboring elements in the 3D array.\n\n\nInput Format:\n- `Yt`: A 3D numpy array of shape (D1, D2, D3).\n- `num_plane`: An integer representing the number of planes in the second dimension.\n- `cut_off_point`: A float representing the threshold for connectivity.\n- `length_cut`: An integer representing the minimum size of components to consider.\n- `length_max`: An integer representing the maximum size of components to consider.\n- `eight_neighbours`: A boolean indicating whether to consider diagonal neighbors.\n\nOutput Format:\n- A tuple containing:\n  - A 2D numpy array of labeled superpixels.\n  - An integer representing the number of valid components.\n  - A list of connected components.\n  - A numpy array of the permutation of labels.\n\nInput:\n```python\nYt = np.array([[[0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9],\n                [0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9]],\n               \n               [[0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9],\n                [0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9]]])\nnum_plane = 2\ncut_off_point = 0.1\nlength_cut = 1\nlength_max = 5\neight_neighbours = True\n```\n\nOutput:\n```python\narray([[0., 0., 0., 0., 0., 0.],\n       [0., 0., 0., 0., 0., 0.]])\n0\n[{0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11}]\narray([], dtype=int64)\n```", "ground_truth_code": "import numpy as np\nimport networkx as nx\n\n# main code\ndef find_superpixel_3d(Yt, num_plane, cut_off_point, length_cut, length_max, eight_neighbours=True):\n    dims = Yt.shape\n    Yt_3d = Yt.reshape(dims[0], int(dims[1] / num_plane), num_plane, dims[2], order='F')\n    dims = Yt_3d.shape\n    ref_mat = np.arange(np.prod(dims[:-1])).reshape(dims[:-1], order='F')\n    w_mov = (Yt_3d.transpose(3, 0, 1, 2) - np.mean(Yt_3d, axis=3)) / np.std(Yt_3d, axis=3)\n    w_mov[np.isnan(w_mov)] = 0\n    rho_v = np.mean(np.multiply(w_mov[:, :-1, :], w_mov[:, 1:, :]), axis=0)\n    rho_h = np.mean(np.multiply(w_mov[:, :, :-1], w_mov[:, :, 1:]), axis=0)\n    if eight_neighbours:\n        rho_l = np.mean(np.multiply(w_mov[:, 1:, :-1], w_mov[:, :-1, 1:]), axis=0)\n        rho_r = np.mean(np.multiply(w_mov[:, :-1, :-1], w_mov[:, 1:, 1:]), axis=0)\n    rho_u = np.mean(np.multiply(w_mov[:, :, :, :-1], w_mov[:, :, :, 1:]), axis=0)\n    rho_v = np.concatenate([rho_v, np.zeros([1, rho_v.shape[1], num_plane])], axis=0)\n    rho_h = np.concatenate([rho_h, np.zeros([rho_h.shape[0], 1, num_plane])], axis=1)\n    if eight_neighbours:\n        rho_r = np.concatenate([rho_r, np.zeros([rho_r.shape[0], 1, num_plane])], axis=1)\n        rho_r = np.concatenate([rho_r, np.zeros([1, rho_r.shape[1], num_plane])], axis=0)\n        rho_l = np.concatenate([np.zeros([rho_l.shape[0], 1, num_plane]), rho_l], axis=1)\n        rho_l = np.concatenate([rho_l, np.zeros([1, rho_l.shape[1], num_plane])], axis=0)\n    rho_u = np.concatenate([rho_u, np.zeros([rho_u.shape[0], rho_u.shape[1], 1])], axis=2)\n    temp_v = np.where(rho_v > cut_off_point)\n    A_v = ref_mat[temp_v]\n    B_v = ref_mat[temp_v[0] + 1, temp_v[1], temp_v[2]]\n    temp_h = np.where(rho_h > cut_off_point)\n    A_h = ref_mat[temp_h]\n    B_h = ref_mat[temp_h[0], temp_h[1] + 1, temp_h[2]]\n    temp_u = np.where(rho_u > cut_off_point)\n    A_u = ref_mat[temp_u]\n    B_u = ref_mat[temp_u[0], temp_u[1], temp_u[2] + 1]\n    if eight_neighbours:\n        temp_l = np.where(rho_l > cut_off_point)\n        A_l = ref_mat[temp_l]\n        B_l = ref_mat[temp_l[0] + 1, temp_l[1] - 1, temp_l[2]]\n        temp_r = np.where(rho_r > cut_off_point)\n        A_r = ref_mat[temp_r]\n        B_r = ref_mat[temp_r[0] + 1, temp_r[1] + 1, temp_r[2]]\n        A = np.concatenate([A_v, A_h, A_l, A_r, A_u])\n        B = np.concatenate([B_v, B_h, B_l, B_r, B_u])\n    else:\n        A = np.concatenate([A_v, A_h, A_u])\n        B = np.concatenate([B_v, B_h, B_u])\n    G = nx.Graph()\n    G.add_edges_from(list(zip(A, B)))\n    comps = list(nx.connected_components(G))\n    connect_mat = np.zeros(np.prod(dims[:-1]))\n    idx = 0\n    for comp in comps:\n        if len(comp) > length_cut and len(comp) < length_max:\n            idx = idx + 1\n    permute_col = np.random.permutation(idx) + 1\n    ii = 0\n    for comp in comps:\n        if len(comp) > length_cut and len(comp) < length_max:\n            connect_mat[list(comp)] = permute_col[ii]\n            ii = ii + 1\n    connect_mat_1 = connect_mat.reshape(Yt.shape[:-1], order='F')\n    return (connect_mat_1, idx, comps, permute_col)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        d1 = np.random.randint(1, 11)\n        num_plane = np.random.randint(1, 6)\n        d2 = np.random.randint(1, 11)\n        T = np.random.randint(1, 11)\n\n        Yt_shape = (d1, d2 * num_plane, T)\n        Yt = np.random.rand(*Yt_shape)\n        cut_off_point = np.random.uniform(0, 1)\n        length_cut = np.random.randint(1, 10)\n        length_max = np.random.randint(length_cut + 1, 20)\n        eight_neighbours = np.random.choice([True, False])\n        test_cases.append((Yt, num_plane, cut_off_point, length_cut, length_max, eight_neighbours))\n\n    return test_cases\n"}
{"problem_id": "numpy_39", "library": "numpy", "code_problem": "```python\ndef prepare_iteration(Yd, permute_col, pure_pix, U_mat, V_mat, remove, more):\n```\n\nIn this function, the goal is to prepare matrices `U_mat` and `V_mat` based on the input data `Yd`, while also considering specific parameters for permutation and removal of columns. The function utilizes a constant defined as `order`, which is derived from the sorted indices of brightness values.\n\n\n### Input and Output Format:\n- **Input**: \n  - `Yd`: A multi-dimensional array.\n  - `permute_col`: A list of column names or identifiers.\n  - `pure_pix`: A list of pure pixel identifiers.\n  - `U_mat`: A 2D array representing the first matrix.\n  - `V_mat`: A 2D array representing the second matrix.\n  - `remove`: An integer indicating the number of columns to remove.\n  - `more`: A boolean flag indicating whether to return additional statistics.\n\n- **Output**: \n  - If `more` is true: Returns a tuple containing `U_mat`, `V_mat`, the median of `Yd`, the scaled standard deviation of `Yd`, and the brightness rank.\n  - If `more` is false: Returns a tuple containing `U_mat`, `V_mat`, and the brightness rank.\n\n**Input:**\n```python\nYd = np.array([[0.5, 1.2, -0.3], [0.1, 0.4, 0.6], [1.0, -1.0, 0.0]])\npermute_col = [2, 0, 1]\npure_pix = [0, 1]\nU_mat = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]])\nV_mat = np.array([[0.7, 0.8, 0.9], [1.0, 1.1, 1.2]])\nremove = 1\nmore = True\n```\n\n**Output:**\n```python\narray([], shape=(3, 0), dtype=float64)\narray([], shape=(2, 0), dtype=float64)\narray([[0.5],[0.4],[0. ]])\narray([[1.83847763],[0.6164414 ],[2.44948974]])\narray([0])\n```\n\nWhere:\n- `U_mat` and `V_mat` are modified matrices after processing.\n- `np.median(Yd, axis=1, keepdims=True)` computes the median of `Yd` along the specified axis.\n- `np.std(Yd, axis=1, keepdims=True) * Yd.shape[1]` computes the standard deviation of `Yd` scaled by the number of samples.\n- `brightness_rank` is the rank of the brightness values calculated from the modified `U_mat` and `V_mat`.\n\n### Note:\nThe actual numerical output will depend on the random values generated for `Yd`, `U_mat`, and `V_mat`. You can run the ground truth code with the provided input to get the exact output values.", "ground_truth_code": "import numpy as np\nimport scipy.stats as ss\n\n# main code\ndef prepare_iteration(Yd, permute_col, pure_pix, U_mat, V_mat, remove, more):\n    Yd = Yd.reshape(-1, Yd.shape[-1], order='F')\n    pos = np.array([permute_col.index(x) for x in pure_pix])\n    pos = pos[pos < U_mat.shape[1]]\n\n    U_mat, V_mat = U_mat[:, pos], V_mat[:, pos]\n\n    brightness = U_mat.max(axis=0) * V_mat.max(axis=0)\n    brightness_rank = U_mat.shape[1] - ss.rankdata(brightness, method='ordinal')\n\n    order = np.argsort(-brightness)\n    U_mat, V_mat = U_mat[:, order], V_mat[:, order]\n\n    if remove > 0:\n        U_mat, V_mat = U_mat[:, :-remove], V_mat[:, :-remove]\n\n    norm_factor = np.linalg.norm(U_mat, axis=0, keepdims=True)\n    U_mat, V_mat = U_mat / norm_factor, V_mat * norm_factor\n\n    if more:\n        return U_mat, V_mat, np.median(Yd, axis=1, keepdims=True), np.std(Yd, axis=1, keepdims=True) * Yd.shape[\n            1], brightness_rank\n    return U_mat, V_mat, brightness_rank", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        num_features = random.randint(5, 20)\n        rank = random.randint(2, num_features)\n        Yd = np.random.randn(num_samples, num_features)\n        permute_col = list(range(num_features))\n        random.shuffle(permute_col)\n        pure_pix = random.sample(permute_col, random.randint(1, num_features))\n        U_mat = np.random.randn(num_samples, rank)\n        V_mat = np.random.randn(rank, num_features)\n        remove = random.randint(0, min(rank - 1, num_features - 1))\n        more = random.choice([True, False])\n        test_cases.append((Yd, permute_col, pure_pix, U_mat, V_mat, remove, more))\n\n    return test_cases"}
{"problem_id": "numpy_40", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a mask for a given set of correlation images based on specified criteria. The function will analyze the correlation images and apply a series of operations to create a binary mask that indicates the presence of significant features.\n\nFunction Signature:\n```python\ndef make_mask(corr_img_all_r: np.ndarray, corr: float, mask_a: np.ndarray, num_plane: int, times: int, max_allow_neuron_size: float) -> np.ndarray:\n```\n\nConstants Used:\n- The constant `s` is defined as a 3x3 array of ones, which is used as the structure for labeling connected components in the correlation images.\n\n\nInput Format:\n- `corr_img_all_r`: A 4D numpy array representing the correlation images.\n- `corr`: A float value representing the initial correlation threshold.\n- `mask_a`: A 4D numpy array representing the initial mask.\n- `num_plane`: An integer representing the number of planes in the data.\n- `times`: An integer representing the maximum number of iterations for adjusting the correlation threshold.\n- `max_allow_neuron_size`: A float representing the maximum allowed size for a neuron component.\n\nOutput Format:\n- The function returns a 2D numpy array representing the final binary mask after processing the correlation images.\n\n**Input:**\n```python\ncorr_img_all_r = np.array([[[0.7], [0.8]]])\n\ncorr = 0.6\nmask_a = np.array([[0], [0]])\n\nnum_plane = 2\ntimes = 9\nmax_allow_neuron_size = 0.6\n```\n\n**Output:**\n```python\narray([[0],[0]])\n```", "ground_truth_code": "import numpy as np\nimport scipy\n\n# main code\ndef make_mask(corr_img_all_r, corr, mask_a, num_plane, times, max_allow_neuron_size):\n    s = np.ones([3, 3])\n    unit_length = int(mask_a.shape[0] / num_plane)\n    dims = corr_img_all_r.shape\n    corr_img_all_r = corr_img_all_r.reshape(dims[0], int(dims[1] / num_plane), num_plane, -1, order='F')\n    mask_a = mask_a.reshape(corr_img_all_r.shape, order='F')\n    corr_ini = corr\n    for ii in range(mask_a.shape[-1]):\n        for kk in range(num_plane):\n            jj = 0\n            corr = corr_ini\n            if mask_a[:, :, kk, ii].sum() > 0:\n                while jj <= times:\n                    (labeled_array, num_features) = scipy.ndimage.measurements.label(corr_img_all_r[:, :, kk, ii] > corr, structure=s)\n                    (u, indices, counts) = np.unique(labeled_array * mask_a[:, :, kk, ii], return_inverse=True, return_counts=True)\n                    if len(u) == 1:\n                        labeled_array = np.zeros(labeled_array.shape)\n                        if corr == 0 or corr == 1:\n                            break\n                        else:\n                            corr = np.maximum(0, corr - 0.1)\n                            jj = jj + 1\n                    else:\n                        if num_features > 1:\n                            c = u[1:][np.argmax(counts[1:])]\n                            labeled_array = labeled_array == c\n                            del c\n                        if labeled_array.sum() / unit_length < max_allow_neuron_size or corr == 1 or corr == 0:\n                            break\n                        else:\n                            corr = np.minimum(1, corr + 0.1)\n                            jj = jj + 1\n                mask_a[:, :, kk, ii] = labeled_array\n    mask_a = (mask_a * 1).reshape(unit_length * num_plane, -1, order='F')\n    return mask_a", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_plane = np.random.randint(1, 10)\n        height = np.random.randint(10, 100)\n        width = np.random.randint(10, 100)\n        depth = np.random.randint(1, 10)\n\n        corr_img_all_r = np.random.rand(height, width * num_plane, depth)\n        mask_a = np.random.randint(0, 2, size=(height * num_plane, width * depth))\n        corr = np.random.uniform(0, 1)\n        times = np.random.randint(1, 10)\n        max_allow_neuron_size = np.random.uniform(0.01, 1.0)\n        test_cases.append((corr_img_all_r, corr, mask_a, num_plane, times, max_allow_neuron_size))\n\n    return test_cases"}
{"problem_id": "numpy_41", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs Non-negative Matrix Factorization (NMF) with Lasso regularization. The function should decompose a given 3D data array into spatial and temporal components, along with a bias term. It also tracks the reconstruction error over iterations. The function uses Lasso regression from the scikit-learn library to enforce sparsity and non-negativity constraints.\n\nFunction Signature:\n```python\ndef vanilla_nmf_lasso(Yd, num_component, maxiter, tol, penalty_param, c):\n```\n\nConstants used in the main code:\n- The constant `maxiter` specifies the maximum number of iterations for the optimization process.\n- The constant `tol` defines the tolerance level for convergence, determining when to stop the iterations based on the change in the reconstruction error.\n\n\nInput Format:\n- `Yd`: A 3D numpy array representing the data to be factorized.\n- `num_component`: An integer specifying the number of components for the factorization.\n- `maxiter`: An integer indicating the maximum number of iterations for the optimization.\n- `tol`: A float representing the tolerance for convergence.\n- `penalty_param`: A float that sets the Lasso regularization parameter.\n- `c`: A 2D numpy array or None, representing the initial matrix for components. If None, it is randomly initialized.\n\nOutput Format:\n- The function returns a dictionary with the following keys:\n  - `'a'`: The spatial component matrix (pixels \u00d7 num_component).\n  - `'c'`: The temporal component matrix (time \u00d7 num_component).\n  - `'b'`: The bias term.\n  - `'res'`: An array of reconstruction errors over iterations.\n  - `'corr_img_all_r'`: A 3D array of correlation images reshaped to the original dimensions.\n\n**Input:**\n```python\nYd = np.array([[[0.5, 0.2, 0.1], [0.3, 0.4, 0.6]], \n                [[0.7, 0.8, 0.5], [0.2, 0.1, 0.3]]])\nnum_component = 2\nmaxiter = 50\ntol = 1e-4\npenalty_param = 1.0\nc = None\n```\n\n**Output:**\n```python\n{\n    'a': np.array([[0.5, 0.0], [0.0, 0.4]]),\n    'c': np.array([[0.6, 0.3], [0.2, 0.1], [0.1, 0.0]]),\n    'b': np.array([[0.0], [0.0]]),\n    'res': np.array([0.1, 0.05, ...]),  # Example residuals over iterations\n    'corr_img_all_r': np.array([[[0.9, 0.1], [0.2, 0.3]], \n                                 [[0.4, 0.5], [0.1, 0.0]]])\n}\n```\n\n### Note:\n- The actual numerical values in the output will depend on the random initialization and the specific implementation of the algorithm. The output arrays are illustrative and may not represent the exact output of the function when run with the given input.\n- The data matrix is internally reshaped from (height \u00d7 width \u00d7 time) to (pixels \u00d7 time) for factorization, and reshaped back for corr_img_all_r.", "ground_truth_code": "from sklearn import linear_model\nimport numpy as np\n\n\n# main code\ndef vanilla_nmf_lasso(Yd, num_component, maxiter, tol, penalty_param, c):\n    def vcorrcoef2(X, y):\n        Xm = np.reshape(np.mean(X, axis=1), (X.shape[0], 1))\n        ym = np.mean(y)\n        r_num = np.sum((X - Xm) * (y - ym), axis=1)\n        r_den = np.sqrt(np.sum((X - Xm) ** 2, axis=1) * np.sum((y - ym) ** 2))\n        r = r_num / r_den\n        return r\n\n    if Yd.min() < 0:\n        Yd -= Yd.min(axis=2, keepdims=True)\n    y0 = Yd.reshape(np.prod(Yd.shape[:2]), -1, order='F')\n    if c is None:\n        c = np.random.rand(y0.shape[1], num_component)\n        c = c * np.sqrt(y0.mean() / num_component)\n    clf_c = linear_model.Lasso(alpha=penalty_param / (2 * y0.shape[0]), positive=True, fit_intercept=False)\n    clf_a = linear_model.Lasso(alpha=penalty_param / (2 * y0.shape[1]), positive=True, fit_intercept=True)\n    res = np.zeros(maxiter)\n    for iters in range(maxiter):\n        temp = clf_a.fit(c, y0.T)\n        a = temp.coef_\n        b = temp.intercept_\n        b = b.reshape(b.shape[0], 1, order='F')\n        c = clf_c.fit(a, y0 - b).coef_\n        b = np.maximum(0, y0.mean(axis=1, keepdims=True) - (a * c.mean(axis=0, keepdims=True)).sum(axis=1, keepdims=True))\n        res[iters] = np.linalg.norm(y0 - np.matmul(a, c.T) - b, 'fro') ** 2 + penalty_param * (abs(a).sum() + abs(c).sum())\n        if iters > 0 and abs(res[iters] - res[iters - 1]) / res[iters - 1] <= tol:\n            break\n    temp = np.sqrt((a ** 2).sum(axis=0, keepdims=True))\n    c = c * temp\n    a = a / temp\n    a_max = a.max(axis=0)\n    c_max = c.max(axis=0)\n    brightness = a_max * c_max\n    brightness_rank = np.argsort(-brightness)\n    a = a[:, brightness_rank]\n    c = c[:, brightness_rank]\n    corr_img_all_r = a.copy()\n    for ii in range(a.shape[1]):\n        corr_img_all_r[:, ii] = vcorrcoef2(y0, c[:, ii])\n    corr_img_all_r = corr_img_all_r.reshape(Yd.shape[0], Yd.shape[1], -1, order='F')\n    return {'a': a, 'c': c, 'b': b, 'res': res, 'corr_img_all_r': corr_img_all_r}", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = (np.random.randint(5, 20), np.random.randint(5, 20), np.random.randint(3, 10))\n        Yd = np.abs(np.random.randn(*shape))\n        num_component = np.random.randint(1, min(shape[0], shape[1]))\n        maxiter = np.random.randint(10, 100)\n        tol = np.random.uniform(1e-6, 1e-2)\n        penalty_param = np.random.uniform(0.1, 10)\n        c = None if np.random.rand() < 0.5 else np.random.rand(shape[2], num_component)\n\n        test_cases.append((Yd, num_component, maxiter, tol, penalty_param, c))\n\n    return test_cases"}
{"problem_id": "numpy_42", "library": "numpy", "code_problem": "You are tasked with implementing a function that identifies outliers in a dataset based on the Median Absolute Deviation (MAD) method. The function will determine which elements in the input array are considered outliers by comparing their modified Z-scores against a specified threshold.\n\nFunction signature:\n```python\ndef fit(x, _is_fitted, threshold):\n```\n\nConstant used in the main code:\n- The constant `0.6745` is used in the calculation of the modified Z-score, which is derived from the properties of the normal distribution.\n\n\nInput format:\n- The input `x` can be a list or an array-like structure containing numeric values.\n- The input `_is_fitted` is a placeholder parameter and does not affect the function's output.\n- The input `threshold` is a numeric value that sets the cutoff for identifying outliers.\n\nOutput format:\n- The output is a boolean array of the same length as the input `x`, where each element indicates whether the corresponding element in `x` is an outlier (`True`) or not (`False`).\n\nInput:\n```python\nx = [0.5, -1.2, 0.3, 1.5, -0.7]\n_is_fitted = True\nthreshold = 1.0\n```\n\nOutput:\n```python\narray([False, True, False, False, False])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef fit(x, _is_fitted, threshold):\n    x = np.asarray(x)\n    median = np.median(x)\n    mad = np.median(np.abs(x - median))\n    m_z_score = 0.6745 * (x - median) / mad\n    support = np.abs(m_z_score) > threshold\n\n    return support", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(5, 100)\n        x = np.random.normal(loc=0, scale=np.random.uniform(0.1, 10), size=size).tolist()\n\n        if np.median(np.abs(np.array(x) - np.median(x))) == 0:\n            x[0] += 0.01\n\n        _is_fitted = bool(np.random.choice([True, False]))\n        threshold = np.random.uniform(0.1, 5.0)\n        test_cases.append((x, _is_fitted, threshold))\n\n    return test_cases"}
{"problem_id": "numpy_43", "library": "numpy", "code_problem": "You are tasked with simulating multivariate data based on a mathematical model that uses sine and cosine functions to define the means and covariance of a bivariate normal distribution. The goal is to generate a set of random samples from this distribution for a given input.\n\nFunction Signature:\n```python\ndef simulate_data(x: np.ndarray, N: int) -> tuple:\n```\n\nConstant Used:\n- The constant values used in the calculations are `0.01`, `0.25`, `2.5`, `1.5`, `3.5`, and `0.5`.\n\n\nInput Format:\n- The function expects a NumPy array `x` and an integer `N`.\n\nOutput Format:\n- The function returns a tuple consisting of:\n  - A NumPy array `x`.\n  - A NumPy array of shape `(N, 2)` containing the generated random samples.\n  - A list of `N` multivariate normal distribution objects.\n\nInput:\n```python\nx = np.array([0.1, 0.5, 0.9])\nN = 3\n```\n\nOutput:\n```python\n(array([0.1, 0.5, 0.9]), \narray([[-0.12152835,  0.79120996],[ 0.73230592, -0.04253565], [ 0.65020621, -1.8579859 ]])\n[<scipy.stats._multivariate.multivariate_normal_frozen object at 0x...>, <scipy.stats._multivariate.multivariate_normal_frozen object at 0x...>, <scipy.stats._multivariate.multivariate_normal_frozen object at 0x...>])\n```\n\n(Note: The actual output values will vary due to the randomness in the simulation process.)", "ground_truth_code": "import numpy as np\nfrom scipy.stats import multivariate_normal\n\n# main code\ndef simulate_data(x, N):\n    means = np.zeros((N, 2))\n    means[:, 0] = np.sin(2.5 * x) * np.sin(1.5 * x)\n    means[:, 1] = np.cos(3.5 * x) * np.cos(0.5 * x)\n    cov = np.zeros((N, 2, 2))\n    cov[:, 0, 0] = 0.01 + 0.25 * (1 - np.sin(2.5 * x)) ** 2\n    cov[:, 1, 1] = 0.01 + 0.25 * (1 - np.cos(2.5 * x)) ** 2\n    corr = np.sin(2.5 * x) * np.cos(0.5 * x)\n    off_diag = corr * np.sqrt(cov[:, 0, 0] * cov[:, 1, 1])\n    cov[:, 0, 1] = off_diag\n    cov[:, 1, 0] = off_diag\n    scipy_dists = [multivariate_normal(mean=means[i, :], cov=cov[i, :, :]) for i in range(N)]\n    rvs = np.array([dist.rvs(1) for dist in scipy_dists])\n    return (x, rvs, scipy_dists)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        N = np.random.randint(10, 100)\n        x = np.random.rand(N) * np.pi\n\n        test_cases.append((x, N))\n    return test_cases\n"}
{"problem_id": "numpy_44", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the gradient of a scalar field defined over a triangular mesh. The function will take in the vertices of the mesh, the connectivity of the triangles, the scalar values at the vertices, and optionally a set of points where the gradient should be evaluated. If no points are provided, the function will generate a grid of points within the bounding box of the mesh.\n\nFunction Signature:\n```python\ndef ComputeGradient(p: np.ndarray, t: np.ndarray, u: np.ndarray, poi: np.ndarray, num: int) -> np.ndarray:\n```\n\nConstants Used:\n- `eps = 1e-06`: A small value used to avoid numerical issues when generating grid points.\n\n\nInput Format:\n- `p`: A 2D numpy array of shape (n, 2) where n is the number of vertices.\n- `t`: A 2D numpy array of shape (m, 3) where m is the number of triangles.\n- `u`: A 1D numpy array of length n.\n- `poi`: A 2D numpy array of shape (k, 2) where k is the number of points (can be None or empty).\n- `num`: An integer representing the number of grid points to generate.\n\nOutput Format:\n- Returns a numpy array of shape (4, k) if points are found, where the first two rows contain the x and y coordinates, and the last two rows contain the gradients in the x and y directions, respectively. If no points are found, returns ([], [], [], []).\n\n**Input:**\n```python\np = np.array([[0.0, 0.0], [1.0, 0.0], [0.0, 1.0], [1.0, 1.0]])\nt = np.array([[0, 1, 2], [1, 3, 2]])\nu = np.array([0.5, 1.0, 0.0, 0.8])\npoi = None\nnum = 5\n```\n\n**Output:**\n```python\narray([[ 1.000000e-06,  2.500005e-01,  5.000000e-01,  7.499995e-01,\n         9.999990e-01,  1.000000e-06,  2.500005e-01,  5.000000e-01,\n         7.499995e-01,  9.999990e-01,  1.000000e-06,  2.500005e-01,\n         5.000000e-01,  7.499995e-01,  9.999990e-01,  1.000000e-06,\n         2.500005e-01,  5.000000e-01,  7.499995e-01,  9.999990e-01,\n         1.000000e-06,  2.500005e-01,  5.000000e-01,  7.499995e-01,\n         9.999990e-01],\n         ...\n       [-5.000000e-01, -5.000000e-01, -5.000000e-01, -5.000000e-01,\n        -5.000000e-01, -5.000000e-01, -5.000000e-01, -5.000000e-01,\n        -5.000000e-01, -2.000000e-01, -5.000000e-01, -5.000000e-01,\n        -5.000000e-01, -2.000000e-01, -2.000000e-01, -5.000000e-01,\n        -5.000000e-01, -2.000000e-01, -2.000000e-01, -2.000000e-01,\n        -5.000000e-01, -2.000000e-01, -2.000000e-01, -2.000000e-01,\n        -2.000000e-01]])\n```\n\n", "ground_truth_code": "import numpy as np\n\n# main code\ndef ComputeGradient(p, t, u, poi, num):\n    if poi is None or len(poi) == 0:\n        eps = 1e-06\n        h1 = np.linspace(min(p[:, 0]) + eps, max(p[:, 0]) - eps, num)\n        h2 = np.linspace(min(p[:, 1]) + eps, max(p[:, 1]) - eps, num)\n        h1, h2 = np.meshgrid(h1, h2)\n        h1 = h1.reshape(num * num, 1)\n        h2 = h2.reshape(num * num, 1)\n        points = np.hstack((h1, h2))\n    else:\n        points = np.array(poi)\n\n    a1 = p[t[:, 1], 0] * p[t[:, 2], 1] - p[t[:, 1], 1] * p[t[:, 2], 0]\n    a2 = p[t[:, 2], 0] * p[t[:, 0], 1] - p[t[:, 2], 1] * p[t[:, 0], 0]\n    b1 = p[t[:, 1], 1] - p[t[:, 2], 1]\n    b2 = p[t[:, 2], 1] - p[t[:, 0], 1]\n    c1 = p[t[:, 2], 0] - p[t[:, 1], 0]\n    c2 = p[t[:, 0], 0] - p[t[:, 2], 0]\n    delta = 0.5 * (b1 * c2 - b2 * c1)\n\n    XYUV = []\n    for x in points:\n        ksi = 0.5 / delta * (a1 + b1 * x[0] + c1 * x[1])\n        eta = 0.5 / delta * (a2 + b2 * x[0] + c2 * x[1])\n        element = np.where((ksi >= 0) & (eta >= 0) & (eta + ksi - 1 <= 0))[0]\n\n        if len(element) > 0:\n            element = element[0]\n            bb1 = b1[element]\n            bb2 = b2[element]\n            cc1 = c1[element]\n            cc2 = c2[element]\n            dd = delta[element]\n\n            u1, u2, u3 = u[t[element, 0]], u[t[element, 1]], u[t[element, 2]]\n            gx = 0.5 / dd * (bb1 * u1 + bb2 * u2)\n            gy = 0.5 / dd * (cc1 * u1 + cc2 * u2)\n\n            XYUV.append([x[0], x[1], gx, gy])\n\n    return np.array(XYUV).T if XYUV else ([], [], [], [])", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(3, 20)\n        p = np.random.rand(num_points, 2)\n        num_triangles = np.random.randint(1, num_points - 1)\n        t = np.random.randint(0, num_points, (num_triangles, 3))\n        t[:, 1] = (t[:, 0] + 1) % num_points\n        t[:, 2] = (t[:, 1] + 1) % num_points\n        u = np.random.rand(num_points)\n        if np.random.rand() > 0.5:\n            poi = np.random.rand(np.random.randint(1, 10), 2)\n        else:\n            poi = None\n        num = np.random.randint(5, 50)\n        test_cases.append((p, t, u, poi, num))\n\n    return test_cases"}
{"problem_id": "numpy_45", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates points and vertices for circular segments based on specified parameters. The function will calculate the coordinates of points along the circumference of a circle and determine the connections (vertices) between these points.\n\nFunction signature:\n```python\ndef CircleSegments(middle: tuple, radius: float, num_points: int, a_min: float, a_max: float, edge_length: float) -> tuple\n```\n\nConstants used in the main code:\n- The constant value `5` is used to ensure that at least 5 points are generated if the calculated number of points is less than 5.\n\n\nInput format:\n- `middle`: A tuple of two floats (x, y).\n- `radius`: A float.\n- `num_points`: An integer.\n- `a_min`: A float.\n- `a_max`: A float.\n- `edge_length`: A float.\n\nOutput format:\n- A tuple containing:\n  - A list of tuples, where each tuple represents the (x, y) coordinates of a point.\n  - A list of tuples, where each tuple represents a pair of indices indicating the vertices connecting the points.\n\nInput:\n```python\nmiddle = (2.5, -3.0)\nradius = 4.0\nnum_points = 10\na_min = 0.0\na_max = 3.14159\nedge_length = 1.0\n```\n\nOutput:\n```python\n(points, vertices) = (\n    [(6.5, -3.0), (6.363703534089371, -1.9647246739802469), (5.964102499667347, -1.0000015320509772), (5.3284290011169055, -0.17157475162576974), (4.500003064100781, 0.46409984607653687), (3.5352804523609738, 0.8637021604879505), (2.500005307179587, 0.9999999999964793), (1.4647298003232896, 0.8637049076839891), (0.5000061282062562, 0.4641051532520586), (-0.32842149562657585, -0.17156724614539876), (-0.9640971924796289, -0.9999923397509813), (-1.3637007868797286, -1.9647144212996277), (-1.499999999985917, -2.9999893856408266)],\n    [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8), (8, 9), (9, 10), (10, 11), (11, 12)]\n)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef CircleSegments(middle, radius, num_points, a_min, a_max, edge_length):\n    number_points = max(num_points, 5)\n    if edge_length > 0:\n        number_points = int(np.floor(abs(radius / edge_length * (a_max - a_min)))) + 1\n        if number_points < 5:\n            number_points = 5\n    delta = (a_max - a_min) / number_points\n    closed = False\n    if abs(abs(a_max - a_min) - 2 * np.pi) < 0.1 * abs(delta):\n        closed = True\n    t = np.linspace(a_min, a_max, number_points, not closed)\n    points = [(middle[0] + radius * np.cos(angle), middle[1] + radius * np.sin(angle)) for angle in t]\n    vertices = [(j, j + 1) for j in range(0, len(points) - 1, 1)]\n    if closed:\n        vertices += [(len(points) - 1, 0)]\n    return (points, vertices)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        middle = (random.uniform(-10, 10), random.uniform(-10, 10))\n        radius = random.uniform(0, 10)\n        num_points = random.randint(0, 100)\n        a_min = random.uniform(0, 2 * np.pi)\n        a_max = random.uniform(a_min, 2 * np.pi)\n        edge_length = random.uniform(-1, 5)\n        test_cases.append((middle, radius, num_points, a_min, a_max, edge_length))\n\n    return test_cases"}
{"problem_id": "numpy_46", "library": "numpy", "code_problem": "You are tasked with creating a function that generates a series of points along a straight line segment defined by two endpoints, as well as the indices of the vertices connecting these points. The function should take into account a specified edge length to determine how many points to generate along the line segment.\n\nFunction signature:\n```python\ndef LineSegments(P1: tuple, P2: tuple, num_points: int, edge_length: float) -> tuple\n```\n\n### Constants:\n- The constant used in the main code is `5`, which is the default number of points generated if the calculated number of points is less than or equal to 1.\n\n\n### Input Format:\n- The function accepts four parameters: two tuples for the endpoints, an integer for the number of points, and a float for the edge length.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A list of tuples representing the coordinates of the points along the line segment.\n  - A list of tuples representing the indices of the vertices connecting the points.\n\nInput:\n```python\nP1 = [10.5, -20.3]\nP2 = [30.2, 15.7]\nnum_points = 10\nedge_length = 5.0\n```\n\nOutput:\n```python\n(points, vertices) = (\n    [(10.5, -20.3), (12.9625, -15.8), (15.425, -11.3), (17.8875, -6.800000000000001), (20.35, -2.3000000000000007), (22.8125, 2.1999999999999993), (25.275, 6.699999999999999), (27.7375, 11.2), (30.2, 15.7)],\n    [(0, 1), (1, 2), (2, 3), (3, 4), (4, 5), (5, 6), (6, 7), (7, 8)]\n)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef LineSegments(P1, P2, num_points, edge_length):\n    number_points = num_points\n    if edge_length > 0:\n        p1 = np.array(P1)\n        p2 = np.array(P2)\n        number_points = int(np.floor(np.sqrt(np.sum((p2 - p1) ** 2)) / edge_length)) + 1\n        if number_points <= 1:\n            number_points = 5\n    t = np.linspace(0, 1, number_points)\n    points = [(P1[0] + param * (P2[0] - P1[0]), P1[1] + param * (P2[1] - P1[1])) for param in t]\n    vertices = [(j, j + 1) for j in range(0, len(points) - 1, 1)]\n    return (points, vertices)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        P1 = np.random.uniform(-100, 100, size=2).tolist()\n        P2 = np.random.uniform(-100, 100, size=2).tolist()\n        num_points = np.random.randint(2, 50)\n        edge_length = np.random.uniform(0.1, 50)\n        test_cases.append((P1, P2, num_points, edge_length))\n\n    return test_cases"}
{"problem_id": "numpy_47", "library": "numpy", "code_problem": "You are tasked with implementing a function that finds the indices of elements in one array that match the elements in another array. The function should handle the input arrays efficiently, even if they are not sorted. \n\nFunction signature:\n```python\ndef argmatch(a, b):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0`, which is used in the `np.clip` function to ensure that the indices do not go below zero.\n\nInput format:\n- The function takes two inputs, `a` and `b`, which can be lists or arrays of numerical values.\n\nOutput format:\n- The function returns an array of indices corresponding to the positions of elements in `a` that match the elements in `b`. If there are no matches, it returns `None`.\n\n```python\nInput: ([1, 3, 5, 7, 9], [2, 3, 6, 8])\nOutput: array([1, 1, 3, 4])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef argmatch(a, b):\n    a = np.asarray(a)\n    b = np.asarray(b)\n    ii = np.argsort(a)\n    jj = np.argsort(b)\n    kk = np.searchsorted(a[ii], b[jj])\n    kk = np.clip(kk, 0, len(ii) - 1)\n    match_indices = ii[kk[np.argsort(jj)]]\n\n    return match_indices if match_indices.size > 0 else None", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_a = np.random.randint(1, 101)\n        size_b = np.random.randint(1, 101)\n\n        a = np.sort(np.random.choice(range(1000), size=size_a, replace=False))\n        b = np.sort(np.random.choice(range(1000), size=size_b, replace=False))\n\n        test_cases.append((a.tolist(), b.tolist()))\n    return test_cases"}
{"problem_id": "numpy_48", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes an expanding power series based on a given input size and a specified power parameter. The function should also have the capability to reverse the order of the computed values based on a boolean flag.\n\nFunction Signature:\n```python\ndef compute_expanding_power(n: int, power_lambda: float, reverse_columns: bool) -> np.ndarray:\n```\n\nConstant Used:\n- The constant used in the main code is `0.0`, which is assigned to the first element of the array `a`.\n\n\nInput Format:\n- The function takes three parameters:\n  - An integer `n` (the number of elements).\n  - A float `power_lambda` (the power parameter).\n  - A boolean `reverse_columns` (indicating whether to reverse the output).\n\nOutput Format:\n- The function returns a NumPy array of shape `(n,)` containing the computed values of the expanding power series.\n\n```python\nInput: (5, 2.0, False)\nOutput: array([1. , 2. , 4. ,  8. , 16. ])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef compute_expanding_power(n, power_lambda, reverse_columns) :\n    a = np.log(power_lambda) * np.ones(n)\n    a[0] = 0.0\n    b = np.exp(np.cumsum(a))\n    if reverse_columns:\n        b = b[::-1]\n    return b", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_value = random.randint(0, 1000)\n        power_lambda_value = random.uniform(-1000.0, 1000.0)\n        reverse_columns_value = random.choice([True, False])\n        test_cases.append((n_value, power_lambda_value, reverse_columns_value))\n\n    return test_cases"}
{"problem_id": "numpy_49", "library": "numpy", "code_problem": "```python\ndef tsem(a, limits, inclusive, axis, ddof):\n```\n\nThe function `tsem` calculates the standard error of the mean (SEM) for a given array of data, while optionally applying limits to mask certain values based on specified criteria. The function takes the following parameters:\n\n- `a`: An array-like structure containing numerical data.\n- `limits`: A tuple of two values representing the lower and upper limits for masking the data. If `None`, no masking is applied.\n- `inclusive`: A tuple of two boolean values indicating whether the lower and upper limits should be inclusive or exclusive.\n- `axis`: The axis along which to compute the SEM. If `None`, the SEM is computed over the entire array.\n- `ddof`: The delta degrees of freedom used in the calculation of the variance.\n\n### Constant Used:\n- The constant used in the main code is `np.nan`, which is returned when there are no valid values to compute the SEM.\n\n### Input and Output Format:\n- **Input Format**: The function takes an array-like input `a`, a tuple `limits`, a tuple `inclusive`, an integer `axis`, and an integer `ddof`.\n- **Output Format**: The function returns a float representing the standard error of the mean, or `np.nan` if the calculation cannot be performed.\n\nInput:\n```python\na = np.array([-1.5, -2.3, 0.5, 1.2, 3.4])\nlimits = (-2.0, 2.0)\ninclusive = (True, False)\naxis = None\nddof = 1\n```\n\nOutput:\n```python\n0.8089774066341066\n```", "ground_truth_code": "from numpy import ma\nimport numpy as np\n\n\ndef _mask_to_limits(a, limits, inclusive):\n    lower_limit, upper_limit = limits\n    lower_include, upper_include = inclusive\n    am = ma.MaskedArray(a)\n\n    if lower_limit is not None:\n        am = ma.masked_less(am, lower_limit) if lower_include else ma.masked_less_equal(am, lower_limit)\n\n    if upper_limit is not None:\n        am = ma.masked_greater(am, upper_limit) if upper_include else ma.masked_greater_equal(am, upper_limit)\n\n    return am\n\n# main code\ndef tsem(a, limits, inclusive, axis, ddof):\n    a = np.asarray(a).ravel()\n\n    if limits is None:\n        return a.std(ddof=ddof) / np.sqrt(a.size) if a.size > 0 else np.nan\n\n    am = _mask_to_limits(a, limits, inclusive)\n\n    if am.count() == 0:\n        return np.nan\n\n    sd = np.sqrt(np.ma.var(am, ddof=ddof, axis=axis))\n    return sd / np.sqrt(am.count())", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(1, 1001)\n        a = np.random.randn(size)\n\n        lower_limit = np.random.choice([None, np.random.uniform(-5, 0)])\n        upper_limit = np.random.choice([None, np.random.uniform(0, 5)])\n        limits = (lower_limit, upper_limit)\n\n        inclusive = (np.random.choice([True, False]), np.random.choice([True, False]))\n\n        axis = None\n\n        ddof = np.random.randint(0, 11)\n\n        test_cases.append((a, limits, inclusive, axis, ddof))\n\n    return test_cases\n\n"}
{"problem_id": "numpy_50", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes a dataset and evaluates its success based on certain criteria. The function will compute a mean value of the data, a success ratio, and the count of successful entries, while handling various input types and conditions.\n\nFunction Signature:\n```python\ndef sp1(data, maxvalue, issuccessful):\n```\n\nConstants:\n- `np.nan`: This constant is used to represent \"Not a Number\" values in the dataset.\n\nInput Format:\n- `data`: A list, tuple, or numpy array containing numerical values, which may include NaN values.\n- `maxvalue`: A numerical value that serves as the upper limit for filtering the data.\n- `issuccessful`: A list, tuple, or numpy array of boolean values indicating the success of each corresponding entry in `data`. This parameter can also be `None`.\n\nOutput Format:\n- The function returns a tuple containing three values:\n  - A float representing the adjusted mean of the successful data or `np.inf` if there are no successful entries.\n  - A float representing the success ratio.\n  - An integer representing the count of successful entries.\n\nInput:\n```python\n(data=[3.5, 7.2, np.nan, -2.1, 5.0], maxvalue=10.0, issuccessful=[True, False, None, True, True])\n```\n\nOutput:\n```python\n(2.8444444444444446, 0.75, 3)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef sp1(data, maxvalue, issuccessful):\n    if not isinstance(data, (list, tuple, np.ndarray)):\n        return (np.nan, np.nan, np.nan)\n\n    if issuccessful is not None and not isinstance(issuccessful, (list, tuple, np.ndarray)):\n        return (np.nan, np.nan, np.nan)\n\n    if issuccessful is not None and len(issuccessful) != len(data):\n        return (np.nan, np.nan, np.nan)\n\n    if issuccessful is not None:\n        issuccessful = [issuccessful[i] for i in range(len(issuccessful)) if not np.isnan(data[i])]\n\n    dat = [d for d in data if not np.isnan(d)]\n    N = len(dat)\n\n    if N == 0:\n        return (np.nan, np.nan, np.nan)\n\n    if issuccessful is not None:\n        dat = [dat[i] for i in range(len(dat)) if issuccessful[i]]\n    else:\n        dat = [d for d in dat if d < maxvalue]\n\n    succ = float(len(dat)) / N\n\n    return (np.inf, 0.0, 0) if succ == 0 else (np.mean(dat) / succ, succ, len(dat))", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(1, 20)\n        data = np.random.uniform(-10, 10, size=length)\n\n        num_nans = np.random.randint(0, max(1, length // 2))\n        data[np.random.choice(length, size=num_nans, replace=False)] = np.nan\n\n        maxvalue = np.random.uniform(1, 20)\n\n        if np.random.rand() > 0.3:\n            issuccessful = np.random.choice([True, False], size=length).tolist()\n        else:\n            issuccessful = None\n\n        test_cases.append((data.tolist(), maxvalue, issuccessful))\n\n    return test_cases"}
{"problem_id": "numpy_51", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes a dataset to compute specific statistics based on the values present in the dataset and certain conditions. The function signature is as follows:\n\n```python\ndef sp(data, maxvalue, issuccessful, allowinf):\n```\n\n### Constants:\n- `np.nan`: This constant from the NumPy library represents a \"Not a Number\" value, which is used to denote missing or undefined values in the dataset.\n\n\n### Input Format:\n- `data`: A list or array-like structure containing numerical values, which may include NaN values.\n- `maxvalue`: A numerical threshold used to filter successful data points.\n- `issuccessful`: A list or array-like structure of boolean values indicating the success status of each corresponding entry in `data`.\n- `allowinf`: A boolean value that determines whether to allow the result to be infinite.\n\n### Output Format:\nThe function returns a tuple containing:\n- A numerical value representing the computed result (or `np.nan`).\n- A float representing the success rate.\n- An integer representing the count of successful data points.\n\nInput:\n```python\ndata = [12.5, np.nan, 45.3, 78.1, np.nan, -20.0]\nmaxvalue = 50.0\nissuccessful = [True, False, True, True, False, True]\nallowinf = False\n```\n\nOutput:\n```python\n(28.974999999999998, 1.0, 4)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef sp(data, maxvalue, issuccessful, allowinf):\n    if not hasattr(data, '__iter__'):\n        return (np.nan, np.nan, np.nan)\n\n    if issuccessful is not None and (not hasattr(issuccessful, '__iter__') or len(issuccessful) != len(data)):\n        issuccessful = None\n\n    if issuccessful is not None:\n        issuccessful = [issuccessful[i] for i in range(len(issuccessful)) if not np.isnan(data[i])]\n\n    dat = [d for d in data if not np.isnan(d)]\n    N = len(dat)\n\n    if N == 0:\n        return (np.nan, np.nan, np.nan)\n\n    dat.sort()\n\n    if issuccessful is not None:\n        succdat = [dat[i] for i in range(len(dat)) if issuccessful[i]]\n    else:\n        succdat = [d for d in dat if d < maxvalue]\n\n    succ = len(succdat) / N if N > 0 else 0\n\n    if succ == 0:\n        res = np.sum(dat) if not allowinf else np.inf\n    else:\n        res = np.sum(dat) / len(succdat) if len(succdat) > 0 else np.nan\n\n    return (res, succ, len(succdat))", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        size = np.random.randint(0, 20)\n\n        data = np.random.uniform(-100, 100, size).tolist()\n        if size > 0:\n            nan_indices = np.random.choice(size, size // 3, replace=False)\n            for i in nan_indices:\n                data[i] = np.nan\n\n        maxvalue = np.random.uniform(-50, 150)\n        if np.random.rand() < 0.5:\n            issuccessful = np.random.choice([True, False], size).tolist()\n        else:\n            issuccessful = None\n        allowinf = bool(np.random.randint(0, 2))\n        test_cases.append((data, maxvalue, issuccessful, allowinf))\n\n    return test_cases"}
{"problem_id": "numpy_52", "library": "numpy", "code_problem": "You are tasked with implementing a function that determines the best algorithm indices based on the expected run time (ERT) and final function values from a set of datasets. The function will analyze the performance of different algorithms across multiple targets and return the indices of the best-performing algorithms for each target.\n\nFunction signature:\n```python\ndef best_alg_indices(ert_ars, median_finalfunvals, datasets, targets):\n```\n\nConstant used in the main code:\n- `None`: This constant is used to check if the `ert_ars` or `median_finalfunvals` parameters are provided or need to be computed.\n\n\nInput format:\n- `ert_ars`: A 2D array or `None` (optional) representing the expected run times for different algorithms across multiple targets.\n- `median_finalfunvals`: A list or `None` (optional) representing the median final function values for each dataset.\n- `datasets`: A list of dataset objects, each having methods `detERT` and `finalfunvals`.\n- `targets`: A list of target values to be used in the `detERT` method.\n\nOutput format:\n- The function returns a 1D NumPy array containing the indices of the best algorithms for each target.\n\n**Input:**\n```python\nert_ars = None\nmedian_finalfunvals = None\ndatasets = [\n    MockDataset(num_targets=3, num_algorithms=4),\n    MockDataset(num_targets=3, num_algorithms=4),\n    MockDataset(num_targets=3, num_algorithms=4)\n]\ntargets = np.array([0.1, 0.5, 0.9])\n```\n\n**Output:**\n```python\narray([[1, 1, 0], [2, 1, 2], [2, 0, 0], [2, 2, 0]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef best_alg_indices(ert_ars, median_finalfunvals, datasets, targets):\n    ert_ars = np.asarray([ds.detERT(targets) for ds in datasets] if ert_ars is None else ert_ars)\n    best_alg_idx = ert_ars.argsort(0)[0, :]\n    for (itarget, vals) in enumerate(ert_ars.T):\n        if not np.any(np.isfinite(vals)):\n            if median_finalfunvals is None:\n                median_finalfunvals = [np.median(ds.finalfunvals) for ds in datasets]\n            best_alg_idx[itarget] = np.argsort(median_finalfunvals)[0]\n    return best_alg_idx", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    class MockDataset:\n        def __init__(self, num_targets, num_algorithms):\n            self.num_targets = num_targets\n            self.num_algorithms = num_algorithms\n            self.finalfunvals = np.random.rand(num_algorithms)\n\n        def detERT(self, targets):\n            return np.random.rand(self.num_algorithms, len(targets))\n\n    test_cases = []\n    for _ in range(n):\n        num_algorithms = np.random.randint(2, 10)\n        num_targets = np.random.randint(1, 10)\n\n        ert_ars = np.random.rand(num_algorithms, num_targets) if np.random.rand() > 0.5 else None\n        median_finalfunvals = np.random.rand(num_algorithms) if np.random.rand() > 0.5 else None\n        datasets = [MockDataset(num_targets, num_algorithms) for _ in range(num_algorithms)]\n        targets = np.random.rand(num_targets)\n\n        test_cases.append((ert_ars, median_finalfunvals, datasets, targets))\n\n    return test_cases\n"}
{"problem_id": "numpy_53", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the balanced realization of a linear time-invariant (LTI) system. The function will utilize the discrete Lyapunov equation to derive the necessary transformations for the system matrices. The function signature is as follows:\n\n```python\ndef balreal_direct_py(A, B, C, DLTI, Schur, full_outputs):\n```\n\n### Constants:\n- The constant used in the main code is `scalg`, which refers to the `scipy.linalg` module that provides functions for linear algebra operations.\n\n\n### Input and Output Format:\n- **Input**: The function accepts the following parameters:\n  - `A`: A matrix representing the system dynamics.\n  - `B`: A matrix representing the input matrix.\n  - `C`: A matrix representing the output matrix.\n  - `DLTI`: A boolean indicating if the system is discrete-time.\n  - `Schur`: A boolean indicating if Schur decomposition should be used.\n  - `full_outputs`: A boolean indicating if full outputs are required.\n\n- **Output**: The function returns a tuple containing:\n  - The singular values of the transformation matrix.\n  - The transformation matrix `T`.\n  - The inverse transformation matrix `Tinv`.\n  - If `full_outputs` is `True`, it also returns additional matrices: `U`, `Vt`, `Qc`, and the transpose of `Qot`.\n\nInput:\n```python\nA = np.array([[0.5, 0.1], [0.2, 0.3]])\nB = np.array([[1.0], [0.0]])\nC = np.array([[0.0, 1.0]])\nDLTI = True\nSchur = False\nfull_outputs = False\n```\n\nOutput:\n```python\n(array([0.43985838, 0.18864155]),\narray([[-1.56800178,  1.20773738], [-0.3602644 , -0.3602644 ]]),\narray([[-0.3602644 , -1.20773738], [ 0.3602644 , -1.56800178]]))\n``` \n\n(Note: The actual numerical values of `hsv`, `T`, and `Tinv` will depend on the specific implementation and the random values generated for `A`, `B`, and `C`.)", "ground_truth_code": "import scipy.linalg as scalg\nimport numpy as np\n\n# main code\ndef balreal_direct_py(A, B, C, DLTI, Schur, full_outputs):\n    sollyap = scalg.solve_discrete_lyapunov if DLTI else scalg.solve_lyapunov\n\n    if not isinstance(A, np.ndarray):\n        A = getattr(A, \"todense\", lambda: np.array([]))()\n\n    if A.size == 0:\n        return None\n\n    if Schur:\n        Atri, U = scalg.schur(A)\n        BBtri = U.T @ B @ B.T @ U\n        CCtri = U.T @ C.T @ C @ U\n        Wctri = sollyap(Atri, BBtri)\n        Wotri = sollyap(Atri.T, CCtri)\n        Wc = U @ Wctri @ U.T\n        Wo = U @ Wotri @ U.T\n    else:\n        Wc = sollyap(A, B @ B.T)\n        Wo = sollyap(A.T, C.T @ C)\n\n    Uc, Sc, Vc = scalg.svd(Wc)\n    Uo, So, Vo = scalg.svd(Wo)\n\n    Sc = np.sqrt(np.diag(Sc))\n    So = np.sqrt(np.diag(So))\n    Qc = Uc @ Sc\n    Qot = So @ Vo\n    H = Qot @ Qc\n\n    U, hsv, Vt = scalg.svd(H)\n    S = np.sqrt(np.diag(hsv))\n    Tinv = scalg.inv(S) @ U.T @ Qot\n    T = Qc @ Vt.T @ scalg.inv(S)\n\n    return (hsv, T, Tinv) if not full_outputs else (hsv, U, Vt, Qc, Qot.T)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dim = np.random.randint(2, 10)\n\n        A = np.random.randn(dim, dim)\n\n        B = np.random.randn(dim, np.random.randint(1, dim + 1))\n        C = np.random.randn(np.random.randint(1, dim + 1), dim)\n\n        DLTI = np.random.choice([True, False])\n        Schur = np.random.choice([True, False])\n        full_outputs = np.random.choice([True, False])\n\n        test_cases.append((A, B, C, DLTI, Schur, full_outputs))\n\n    return test_cases"}
{"problem_id": "numpy_54", "library": "numpy", "code_problem": "You are tasked with implementing a function that fits a sphere to a set of 3D points. The function should calculate the radius and the center coordinates of the sphere that best fits the given points using the least squares method.\n\nFunction signature:\n```python\ndef sphereFit(spX, spY, spZ):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used to populate the last column of the matrix `A`.\n\n### Input Format:\n- The function takes three parameters:\n  - `spX`: A list or array of x-coordinates of the points.\n  - `spY`: A list or array of y-coordinates of the points.\n  - `spZ`: A list or array of z-coordinates of the points.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A float representing the radius of the fitted sphere.\n  - Three floats representing the x, y, and z coordinates of the center of the sphere, respectively.\n\nInput:\n```python\nspX = [1.0, 2.0, 3.0, 4.0]\nspY = [1.0, 2.0, 3.0, 4.0]\nspZ = [1.0, 2.0, 3.0, 4.0]\n```\n\nOutput:\n```python\n(1.936491673103715, array([2.5]), array([2.5]), array([2.5]))\n```", "ground_truth_code": "import numpy as np\nimport math\n\n# main code\ndef sphereFit(spX, spY, spZ):\n    spX = np.array(spX)\n    spY = np.array(spY)\n    spZ = np.array(spZ)\n    A = np.zeros((len(spX), 4))\n    A[:, 0] = spX * 2\n    A[:, 1] = spY * 2\n    A[:, 2] = spZ * 2\n    A[:, 3] = 1\n    f = np.zeros((len(spX), 1))\n    f[:, 0] = spX * spX + spY * spY + spZ * spZ\n    (C, residules, rank, singval) = np.linalg.lstsq(A, f)\n    t = C[0] * C[0] + C[1] * C[1] + C[2] * C[2] + C[3]\n    radius = math.sqrt(t)\n    return (radius, C[0], C[1], C[2])", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_points = random.randint(4, 20)\n        spX = [random.uniform(-100.0, 100.0) for _ in range(num_points)]\n        spY = [random.uniform(-100.0, 100.0) for _ in range(num_points)]\n        spZ = [random.uniform(-100.0, 100.0) for _ in range(num_points)]\n\n        if len(set(zip(spX, spY, spZ))) == 1:\n            spZ[1] += 1\n        \n        test_cases.append((spX, spY, spZ))\n    \n    return test_cases\n"}
{"problem_id": "numpy_55", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes a given structure of neuronal data represented in a specific format known as SWC (Standardized Wireframe Connectivity). The function will standardize the coordinates of the neuronal structure, apply Principal Component Analysis (PCA) for rotation if specified, and adjust the properties of the soma (the cell body of the neuron) based on certain conditions. The function signature is as follows:\n\n```python\ndef get_standardized_swc(swc: pd.DataFrame, scaling: float, soma_radius: float, soma_center: bool, pca_rot: bool) -> pd.DataFrame:\n```\n\n### Constants:\n- The function uses a constant value of `-1` to denote the parent of the soma in the SWC structure.\n\n\n### Input Format:\n- `swc`: A pandas DataFrame containing columns `n`, `type`, `x`, `y`, `z`, `radius`, and `parent`.\n- `scaling`: A float representing the scaling factor for the coordinates.\n- `soma_radius`: A float representing the radius threshold for identifying soma.\n- `soma_center`: A boolean indicating whether to center the soma.\n- `pca_rot`: A boolean indicating whether to apply PCA rotation.\n\n### Output Format:\n- The function returns a pandas DataFrame that represents the modified SWC structure after applying the specified transformations and adjustments.\n\n**Input:**\n```python\nswc = pd.DataFrame({\n    'n': [1, 2, 3, 4],\n    'type': [0, 1, 0, 1],\n    'x': [100, 200, 300, 400],\n    'y': [100, 200, 300, 400],\n    'z': [100, 200, 300, 400],\n    'radius': [1.0, 2.0, 1.5, 2.5],\n    'parent': [-1, 1, 1, 2]\n})\n\nsoma_radius = 2.0\nscaling = 2.0\nsoma_center = True\npca_rot = False\n```\n\n**Output:**\n```python\npd.DataFrame({\n    'n': [1, 2, 3],\n    'type': [0, 1, 0],\n    'x': [0.0, 0.0, 100.0],\n    'y': [0.0, 0.0, 100.0],\n    'z': [0.0, 0.0, 100.0],\n    'radius': [0.5, 1.0, 0.75],\n    'parent': [-1, 1, 1]\n})\n```", "ground_truth_code": "from sklearn.decomposition import PCA\nimport numpy as np\nimport pandas as pd\nfrom scipy.spatial import ConvexHull\n\n# main code\ndef get_standardized_swc(swc, scaling, soma_radius, soma_center, pca_rot):\n    if scaling is None or not isinstance(scaling, (int, float)) or scaling <= 0:\n        return swc\n\n    if swc[['x', 'y', 'z', 'radius']].isnull().any().any():\n        return swc\n\n    swc[['x', 'y', 'z', 'radius']] /= scaling\n\n    if pca_rot:\n        pca = PCA(copy=True)\n        pc = swc[['x', 'y']].to_numpy()\n        pca.fit(pc)\n        result = np.matmul(pc, pca.components_.T)\n        swc[['x', 'y']] = result\n\n    if soma_radius:\n        swc.loc[swc['radius'] >= soma_radius, 'type'] = 1\n\n    sp = swc[swc['type'] == 1]\n    if sp.shape[0] > 1:\n        root_id = np.min(sp['n'].values)\n        if sp.shape[0] > 3:\n            convex_hull = ConvexHull(sp[['x', 'y', 'z']].values, qhull_options='QJ')\n            centroid = np.mean(convex_hull.points, axis=0)\n            rad = np.max(np.linalg.norm(convex_hull.points - centroid, axis=1))\n        else:\n            centroid = sp[['x', 'y', 'z']].mean().to_numpy()\n            rad = sp['radius'].mean()\n\n        connection_locations = swc[swc['parent'].isin(sp['n']) & ~swc['n'].isin(sp['n'])]['n'].values\n        swc.loc[swc['n'].isin(connection_locations), 'parent'] = root_id\n\n        swc = swc.drop(sp.index)\n\n        soma_dict = {'n': int(root_id), 'type': 1, 'x': centroid[0], 'y': centroid[1], 'z': centroid[2], 'radius': rad, 'parent': -1}\n        swc = pd.concat([swc, pd.DataFrame([soma_dict])], ignore_index=True).sort_values('n')\n\n    if soma_center:\n        root_id = swc.loc[swc['parent'] == -1, 'n'].min()\n        centroid = swc.loc[swc['n'] == root_id, ['x', 'y', 'z']].values.flatten()\n        swc[['x', 'y', 'z']] -= centroid\n\n    return swc\n", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_nodes = np.random.randint(2, 1001)\n        node_ids = np.arange(1, num_nodes + 1)\n        types = np.random.choice([0, 1], size=num_nodes, p=[0.8, 0.2])\n        types[np.random.randint(0, num_nodes)] = 1\n        x_coords = np.random.uniform(-1000.0, 1000.0, size=num_nodes)\n        y_coords = np.random.uniform(-1000.0, 1000.0, size=num_nodes)\n        z_coords = np.random.uniform(-1000.0, 1000.0, size=num_nodes)\n        radii = np.random.uniform(0.1, 10.0, size=num_nodes)\n\n        if num_nodes > 1:\n            parents = np.random.choice(node_ids[:-1], size=num_nodes - 1, replace=True)\n        else:\n            parents = []\n        parents = np.insert(parents, 0, -1)\n\n        swc_df = pd.DataFrame({\n            'n': node_ids,\n            'type': types,\n            'x': x_coords,\n            'y': y_coords,\n            'z': z_coords,\n            'radius': radii,\n            'parent': parents\n        })\n\n        scaling = np.random.uniform(0.01, 10.0) if np.random.rand() > 0.1 else None\n        soma_radius_options = [None] + list(np.round(np.random.uniform(0.1, 5.0, size=5), 2).tolist())\n        soma_radius = np.random.choice(soma_radius_options)\n        soma_center = np.random.choice([True, False])\n        pca_rot = np.random.choice([True, False])\n        test_cases.append((swc_df, soma_radius, scaling, soma_center, pca_rot))\n    return test_cases"}
{"problem_id": "numpy_56", "library": "numpy", "code_problem": "You are tasked with implementing a function that finds the indices of the nearest values in a sorted array for a given set of target values. The function should efficiently determine the closest elements in the array to each of the specified values.\n\nFunction signature:\n```python\ndef find_nearest(array, values):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `len(array)`, which represents the length of the input array.\n\nInput format:\n- The function takes two parameters:\n  - `array`: A list of sorted numbers (e.g., integers or floats).\n  - `values`: A list of target numbers (e.g., integers or floats).\n\nOutput format:\n- The function returns a list of integers, where each integer represents the index of the nearest element in the `array` corresponding to each value in `values`.\n\nInput:\n```python\n(array([-10, -5, 0, 3, 7, 15]), array([-8, 1, 10]))\n```\n\nOutput:\n```python\narray([0, 2, 4])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef find_nearest(array, values):\n    array = np.array(array)\n    idxs = np.searchsorted(array, values, side='left')\n    prev_idx_is_less = (idxs == len(array)) | (np.fabs(values - array[np.maximum(idxs - 1, 0)]) < np.fabs(values - array[np.minimum(idxs, len(array) - 1)]))\n    idxs[prev_idx_is_less] -= 1\n    return idxs", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        array_size = np.random.randint(1, 51)\n        array = np.sort(np.random.choice(range(-1000, 1000), size=array_size, replace=False))\n        values_size = np.random.randint(1, 21)\n        values = np.random.choice(range(-1000, 1000), size=values_size, replace=True)\n        test_cases.append((array, values))\n\n    return test_cases\n"}
{"problem_id": "numpy_57", "library": "numpy", "code_problem": "You are tasked with generating a brown noise signal, which is a type of noise that has a power density that decreases with increasing frequency. The goal is to create a function that generates a specified number of samples of brown noise.\n\nFunction Signature:\n```python\ndef generate_brown_noise(num_samples):\n```\n\nConstant Used:\n- The constant used in the main code is the standard deviation of the normal distribution, which is set to 1.\n\nInput Format:\n- The input to the function is a single integer `num_samples`, which specifies the number of samples to generate.\n\nOutput Format:\n- The output of the function is a NumPy array containing the generated brown noise samples, normalized to the range of -1 to 1.\n\nInput: 500 \nOutput: array([-0.75518554, -0.77870108, -0.7336426 , ..., 1.        ,  0.96869381,  0.90109187])", "ground_truth_code": "import numpy as np\n\n# main code\ndef generate_brown_noise(num_samples):\n    brown_noise = np.cumsum(np.random.normal(0, 1, num_samples))\n    brown_noise -= np.mean(brown_noise)\n    brown_noise /= np.max(np.abs(brown_noise))\n    return brown_noise", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(1, 10000)\n        test_cases.append((num_samples,))\n    return test_cases"}
{"problem_id": "numpy_58", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates equalized noise from a given white noise signal. The function will apply a series of band-pass filters to the white noise, adjusting the amplitude of each band according to specified decibel levels. \n\nThe function signature is as follows:\n```python\ndef generate_equalized_noise(white_noise, num_bands, sample_rate, db):\n```\n\n### Constants:\n- The constant used in the main code is `8000`, which is subtracted from half of the sample rate to determine the upper frequency limit for the central frequencies of the bands.\n\n### Input and Output Format:\n- **Input**: \n  - `white_noise`: A 1D numpy array of floats.\n  - `num_bands`: An integer.\n  - `sample_rate`: An integer.\n  - `db`: A list or numpy array of floats.\n\n- **Output**: \n  - A 1D numpy array of floats representing the equalized noise.\n\nInput:\n```python\nwhite_noise = np.array([-0.123, 0.456, -0.789, 0.012, 0.345], dtype=np.float32)\nnum_bands = 3\nsample_rate = 44100\ndb = np.array([-10.0, 5.0, 0.0], dtype=np.float32)\n```\n\nOutput:\n```python\narray([-0.16292864,  0.58864366, -1.        , -0.04727377,  0.40849903])\n```", "ground_truth_code": "import numpy as np\nfrom scipy import signal\n\n\n# main code\ndef generate_equalized_noise(white_noise, num_bands, sample_rate, db):\n    upper_freq = max(100, sample_rate / 2 - 8000)\n    central_freqs = np.geomspace(100, upper_freq, num_bands)\n\n    for i in range(num_bands):\n        (b, a) = signal.iirpeak(central_freqs[i], 1, fs=sample_rate)\n        adjust_noise = signal.lfilter(b, a, white_noise)\n        res_noise = white_noise - adjust_noise\n        adjust_noise *= 10 ** (db[i] / 20)\n        white_noise = res_noise + adjust_noise\n\n    white_noise /= np.max(np.abs(white_noise))\n    return white_noise", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        sample_rate = np.random.choice([16000, 22050, 32000, 44100, 48000, 88200, 96000])\n        num_bands = np.random.randint(2, 11)\n        white_noise_length = np.random.randint(1000, 50001)\n        white_noise = np.random.randn(white_noise_length).astype(np.float32)\n        db = np.random.uniform(-20, 20, num_bands).astype(np.float32)\n        test_cases.append((white_noise, num_bands, sample_rate, db))\n\n    return test_cases"}
{"problem_id": "numpy_59", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the confidence intervals for a set of probabilities. The function will take in a list of probabilities, their associated weights, a significance level for the confidence interval, and the number of bins for the output. The function will return the x-values of the confidence intervals along with the lower and upper bounds of the confidence intervals.\n\nFunction signature:\n```python\ndef get_ci(p, p_weights, ci_alpha, nbins):\n```\n\nConstants used in the main code:\n- The constant `len(p)` is used to normalize the weights and to determine the total number of probabilities.\n\nInput format:\n- The function takes four parameters: a list or array of probabilities (`p`), a list or array of weights (`p_weights`), a float for the significance level (`ci_alpha`), and an integer for the number of bins (`nbins`).\n\nOutput format:\n- The function returns a tuple containing three elements: \n  - An array of x-values for the confidence intervals,\n  - A float representing the lower bound of the confidence interval,\n  - A float representing the upper bound of the confidence interval.\n\nInput:\n```python\np = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\np_weights = np.array([1., 2., 1., 1., 1.])\nci_alpha = 0.05\nnbins = 10\n```\n\nOutput:\n```python\n(array([-0.        , -0.        ,  0.07918125,  0.17609126,  0.17609126,\n        0.17609126,  0.30103   ,  0.30103   ,  0.30103   ,  0.77815125]), \narray([0.00219908, 0.00219908, 0.01833468, 0.05092531, 0.05092531,\n       0.05092531, 0.10205234, 0.10205234, 0.10205234, 0.31884187]), \narray([0.320412  , 0.320412  , 0.50701633, 0.72749218, 0.72749218,\n       0.72749218, 1.02507251, 1.02507251, 1.02507251, 2.6585504 ]))\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as sstats\n\n# main code\ndef get_ci(p, p_weights, ci_alpha, nbins):\n    if p_weights is None:\n        p_weights = np.ones(len(p))\n    p_weights *= len(p) / sum(p_weights)\n    i = np.argsort(p)\n    p = p[i]\n    p_weights = p_weights[i]\n    cum_p_weights = np.cumsum(p_weights)\n    y = np.logspace(np.log10(p[-1]), np.log10(p[0]), nbins)\n    i = np.searchsorted(p, y, side='left')\n    i[0] = len(p) - 1\n    i[-1] = 0\n    beta_a = cum_p_weights[i]\n    beta_b = len(p) + 1 - beta_a\n    lower_ci = -np.log10(sstats.beta.ppf(1 - ci_alpha / 2, beta_a, beta_b))\n    upper_ci = -np.log10(sstats.beta.ppf(ci_alpha / 2, beta_a, beta_b))\n    x_ci = -np.log10(beta_a / len(p))\n    return (x_ci, lower_ci, upper_ci)", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_p = np.random.randint(10, 1000)\n        p = np.sort(np.random.rand(num_p))\n        if np.random.rand() > 0.2:\n            p_weights = np.random.rand(num_p)\n        else:\n            p_weights = None\n        ci_alpha = np.random.uniform(0.01, 0.2)\n        nbins = np.random.randint(5, 100)\n\n        test_cases.append((p, p_weights, ci_alpha, nbins))\n\n    return test_cases"}
{"problem_id": "numpy_60", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the sum of squared errors (SSE) for a set of linear equations defined by different slopes and intercepts. The function will take in two lists representing the x and y coordinates of data points, as well as two lists of potential slopes and intercepts. The goal is to evaluate how well each linear equation fits the data points by computing the SSE for each combination of slope and intercept.\n\nFunction signature:\n```python\ndef draw_hill(x, y, a, b):\n```\n\nConstants used in the main code:\n- The constant `2` is used in the calculation of the average SSE.\n\n\nInput format:\n- The function takes four parameters:\n  - `x`: A list of x-coordinates (data points).\n  - `y`: A list of y-coordinates (data points).\n  - `a`: A list of potential slopes.\n  - `b`: A list of potential intercepts.\n\nOutput format:\n- The function returns a list containing:\n  - A 2D array of slopes.\n  - A 2D array of intercepts.\n  - A 2D array of SSE values corresponding to each combination of slopes and intercepts.\n\nInput:\n```python\nx = [-10.0, -5.0, 0.0, 5.0, 10.0]\ny = [3.0, 2.0, 1.0, 2.0, 3.0]\na = [1.0, 2.0]\nb = [0.0, 1.0]\n```\n\nOutput:\n```python\n[\n  array([[1., 2.],\n       [1., 2.]]), \n  array([[0., 0.],\n       [1., 1.]]), \n  array([[ 27.7,  26. ],\n       [102.7, 101. ]])\n]\n```", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef draw_hill(x, y, a, b):\n    def calc_loss(a, b, x, y):\n        tmp = y - (a * x + b)\n        tmp = tmp ** 2\n        SSE = sum(tmp) / (2 * len(x))\n        return SSE\n\n    x = np.array(x)\n    y = np.array(y)\n    allSSE = np.zeros(shape=(len(a), len(b)))\n    for ai in range(0, len(a)):\n        for bi in range(0, len(b)):\n            a0 = a[ai]\n            b0 = b[bi]\n            SSE = calc_loss(a=a0, b=b0, x=x, y=y)\n            allSSE[ai][bi] = SSE\n    (a, b) = np.meshgrid(a, b)\n    return [a, b, allSSE]", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(5, 20)\n        x = np.random.uniform(-100, 100, size=num_points).tolist()\n        y = np.random.uniform(-100, 100, size=num_points).tolist()\n\n        num_a = np.random.randint(2, 10)\n        num_b = np.random.randint(2, 10)\n        a = np.random.uniform(-10, 10, size=num_a).tolist()\n        b = np.random.uniform(-10, 10, size=num_b).tolist()\n\n        test_cases.append((x, y, a, b))\n\n    return test_cases"}
{"problem_id": "numpy_61", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in the reciprocal space of a crystal lattice based on given parameters. The function will take three parameters that represent physical quantities related to the crystal structure. The function signature is as follows:\n\n```python\ndef orcf1(a: float, b: float, c: float) -> dict:\n```\n\n### Constants Used:\n- The constant values used in the calculations are derived from the input parameters `a`, `b`, and `c`.\n\n### Input Format:\n- The function takes three floating-point numbers as input: `a`, `b`, and `c`.\n\n### Output Format:\n- The function returns a dictionary with two keys:\n  - `'kpoints'`: a dictionary mapping k-point names to their corresponding coordinates (as NumPy arrays).\n  - `'path'`: a list of lists, where each inner list contains the names of k-points that define a path in reciprocal space.\n\n```python\nInput: (5.3, 2.0, 3.0)\nOutput: {\n  'kpoints': {\n    '\\\\Gamma': array([0., 0., 0.]), \n    'A': array([0.5       , 1.72534722, 1.22534722]), \n    'A_1': array([ 0.5       , -0.72534722, -0.22534722]), \n    'L': array([0.5, 0.5, 0.5]), \n    'T': array([1. , 0.5, 0.5]), \n    'X': array([0.        , 2.78590278, 2.78590278]), \n    'X_1': array([ 1.        , -1.78590278, -1.78590278]), \n    'Y': array([0.5, 0. , 0.5]), 'Z': array([0.5, 0.5, 0. ])}, \n  'path': [['\\\\Gamma', 'Y', 'T', 'Z', '\\\\Gamma', 'X', 'A_1', 'Y'], ['T', 'X_1'], ['X', 'A', 'Z'], ['L', '\\\\Gamma']]\n}\n\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef orcf1(a, b, c):\n    if any(x == 0 for x in (b, c)):\n        return None\n\n    zeta = (1 + (a / b) ** 2 - (a / c) ** 2) / 4\n    eta = (1 + (a / b) ** 2 + (a / c) ** 2) / 4\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'A': np.array([0.5, 0.5 + zeta, zeta]),\n        'A_1': np.array([0.5, 0.5 - zeta, 1 - zeta]),\n        'L': np.array([0.5, 0.5, 0.5]),\n        'T': np.array([1, 0.5, 0.5]),\n        'X': np.array([0.0, eta, eta]),\n        'X_1': np.array([1, 1 - eta, 1 - eta]),\n        'Y': np.array([0.5, 0.0, 0.5]),\n        'Z': np.array([0.5, 0.5, 0.0])\n    }\n\n    path = [\n        ['\\\\Gamma', 'Y', 'T', 'Z', '\\\\Gamma', 'X', 'A_1', 'Y'],\n        ['T', 'X_1'],\n        ['X', 'A', 'Z'],\n        ['L', '\\\\Gamma']\n    ]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a = np.random.uniform(-10, 10)\n        b = np.random.uniform(0.1, 10)\n        c = np.random.uniform(0.1, 10)\n\n        test_cases.append((a, b, c))\n\n    return test_cases"}
{"problem_id": "numpy_62", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in the reciprocal space of a crystal lattice based on given lattice parameters. The function will take three parameters representing the lengths of the lattice vectors and return a dictionary containing the k-points and the paths between them.\n\nFunction signature:\n```python\ndef orcf2(a: float, b: float, c: float) -> dict:\n```\n\n### Constants Used:\n- The function uses the following constants derived from the input parameters:\n  - `phi`\n  - `eta`\n  - `delta`\n\n### Input Format:\n- The function takes three floating-point numbers as input.\n\n### Output Format:\n- The function returns a dictionary with the following structure:\n  ```python\n  {\n      'kpoints': {<k-point label>: <coordinates array>, ...},\n      'path': [[<k-point label>, <k-point label>, ...], ...]\n  }\n  ```\n\n```python\nInput: (3.5, 7.2, 2.1)\nOutput: {\n  'kpoints': {'\\\\Gamma': array([0., 0., 0.]), \n              'C': array([0.5       , 0.88536844, 1.38536844]), \n              'C_1': array([ 0.5       ,  0.11463156, -0.38536844]), \n              'D': array([2.13081633, 0.5       , 2.63081633]), \n              'D_1': array([-1.13081633,  0.5       , -1.63081633]), \n              'L': array([0.5, 0.5, 0.5]), 'H': array([0.81873264, 0.31873264, 0.5       ]), \n              'H_1': array([0.18126736, 0.68126736, 0.5       ]), \n              'X': array([0. , 0.5, 0.5]), 'Y': array([0.5, 0. , 0.5]), \n              'Z': array([0.5, 0.5, 0. ])}, \n  'path': [['\\\\Gamma', 'Y', 'C', 'D', 'X', '\\\\Gamma', 'Z', 'D_1', 'H', 'C'], ['C_1', 'Z'], ['X', 'H_1'], ['H', 'Y'], ['L', '\\\\Gamma']]\n}\n\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef orcf2(a, b, c):\n    phi = (1 + (c / b) ** 2 - (c / a) ** 2) / 4\n    eta = (1 + (a / b) ** 2 - (a / c) ** 2) / 4\n    delta = (1 + (b / a) ** 2 - (b / c) ** 2) / 4\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'C': np.array([0.5, 0.5 - eta, 1 - eta]),\n        'C_1': np.array([0.5, 0.5 + eta, eta]),\n        'D': np.array([0.5 - delta, 0.5, 1 - delta]),\n        'D_1': np.array([0.5 + delta, 0.5, delta]),\n        'L': np.array([0.5, 0.5, 0.5]),\n        'H': np.array([1 - phi, 0.5 - phi, 0.5]),\n        'H_1': np.array([phi, 0.5 + phi, 0.5]),\n        'X': np.array([0.0, 0.5, 0.5]),\n        'Y': np.array([0.5, 0.0, 0.5]),\n        'Z': np.array([0.5, 0.5, 0.0])\n    }\n\n    path = [\n        ['\\\\Gamma', 'Y', 'C', 'D', 'X', '\\\\Gamma', 'Z', 'D_1', 'H', 'C'],\n        ['C_1', 'Z'],\n        ['X', 'H_1'],\n        ['H', 'Y'],\n        ['L', '\\\\Gamma']\n    ]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a, b, c = np.random.uniform(0.1, 10.0, size=3)\n\n        test_cases.append((a, b, c))\n    return test_cases"}
{"problem_id": "numpy_63", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points in the Brillouin zone of a crystal lattice based on a given angle, alpha. The function will also define a path through these k-points for visualization purposes.\n\nFunction signature:\n```python\ndef rhl2(alpha):\n```\n\nIn this function, the following constant is used:\n- `nu` is calculated as `3.0 / 4.0 - eta / 2.0`, where `eta` is derived from the input angle `alpha`.\n\nInput format:\n- A single floating-point number representing the angle `alpha` in radians.\n\nOutput format:\n- A dictionary with two keys:\n  - `'kpoints'`: A dictionary of k-point names and their corresponding coordinates.\n  - `'path'`: A list containing the sequence of k-point names.\n\n```python\nInput: 0.7853981633974483  # This is approximately \u03c0/4\nOutput: {\n  'kpoints': {\n    '\\\\Gamma': array([0., 0., 0.]), \n    'F': array([ 0.5, -0.5,  0. ]), \n    'L': array([0.5, 0. , 0. ]), \n    'P': array([1.70710678, 0.70710678, 1.70710678]), \n    'P_1': array([-0.70710678, -1.70710678, -1.70710678]), \n    'Q': array([2.91421356, 2.91421356, 2.91421356]), \n    'Q_1': array([-1.91421356, -2.91421356, -2.91421356]), \n    'Z': array([ 0.5, -0.5,  0.5])}, \n  'path': [['\\\\Gamma', 'P', 'Z', 'Q', '\\\\Gamma', 'F', 'P_1', 'Q_1', 'L', 'Z']]\n}\n```", "ground_truth_code": "import numpy as np\nfrom math import tan\n\n# main code\ndef rhl2(alpha):\n    eta = 1 / (2 * tan(alpha / 2.0) ** 2)\n    nu = 3.0 / 4.0 - eta / 2.0\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'F': np.array([0.5, -0.5, 0.0]),\n        'L': np.array([0.5, 0.0, 0.0]),\n        'P': np.array([1 - nu, -nu, 1 - nu]),\n        'P_1': np.array([nu, nu - 1.0, nu - 1.0]),\n        'Q': np.array([eta, eta, eta]),\n        'Q_1': np.array([1.0 - eta, -eta, -eta]),\n        'Z': np.array([0.5, -0.5, 0.5])\n    }\n    path = [['\\\\Gamma', 'P', 'Z', 'Q', '\\\\Gamma', 'F', 'P_1', 'Q_1', 'L', 'Z']]\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\nfrom math import pi\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        alpha = np.random.uniform(0.1, pi - 0.1)\n\n        test_cases.append(alpha)\n    return test_cases\n"}
{"problem_id": "numpy_64", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in the Brillouin zone of a crystal lattice based on given parameters. The function will utilize trigonometric calculations to derive the necessary values.\n\nFunction signature:\n```python\ndef mclc1(a: float, b: float, c: float, alpha: float) -> dict:\n```\n\n### Constants:\n- The constant used in the main code is `0.5`, which is used in various calculations to derive the values of `eta` and `phi`.\n\n### Input Format:\n- The function accepts four floating-point numbers: `a`, `b`, `c`, and `alpha`.\n\n### Output Format:\n- The function returns a dictionary with two keys:\n  - `'kpoints'`: A dictionary mapping k-point labels to their coordinates.\n  - `'path'`: A list of lists, where each inner list contains k-point labels representing a path.\n\nInput: \n```python\n(3.5, 7.2, 5.1, 1.0471975511965976)  # a=3.5, b=7.2, c=5.1, alpha=pi/3\n```\n\nOutput:\n```python\n{\n  'kpoints': \n   {'\\\\Gamma': array([0., 0., 0.]), \n    'N': array([0.5, 0. , 0. ]), \n    'N_1': array([ 0. , -0.5,  0. ]), \n    'F': array([0.56862745, 0.56862745, 0.19444444]), \n    'F_1': array([0.43137255, 0.43137255, 0.80555556]), \n    'F_2': array([-0.43137255, -0.43137255,  0.19444444]), \n    'I': array([0.72683294, 0.27316706, 0.5       ]), \n    'I_1': array([ 0.27316706, -0.27316706,  0.5       ]), \n    'L': array([0.5, 0.5, 0.5]), \n    'M': array([0.5, 0. , 0.5]), \n    'X': array([ 0.328768, -0.328768,  0.      ]), \n    'X_1': array([0.671232, 0.328768, 0.      ]), \n    'X_2': array([-0.328768, -0.671232,  0.      ]), \n    'Y': array([0.5, 0.5, 0. ]), \n    'Y_1': array([-0.5, -0.5,  0. ]), \n    'Z': array([0. , 0. , 0.5])}, \n  'path': [['\\\\Gamma', 'Y', 'F', 'L', 'I'], ['I_1', 'Z', 'F_1'], ['Y', 'X_1'], ['X', '\\\\Gamma', 'N'], ['M', '\\\\Gamma']]\n}\n```", "ground_truth_code": "import numpy as np\nfrom math import sin, cos\n\n# main code\ndef mclc1(a, b, c, alpha):\n\n    sin_alpha_sq = sin(alpha) ** 2\n    cos_alpha = cos(alpha)\n\n    zeta = (2 - (b * cos_alpha / c)) / (4 * sin_alpha_sq)\n    eta = 0.5 + (2 * zeta * c * cos_alpha / b)\n    psi = 0.75 - (a ** 2 / (4 * b ** 2 * sin_alpha_sq))\n    phi = psi + (0.75 - psi) * (b * cos_alpha / c)\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'N': np.array([0.5, 0.0, 0.0]),\n        'N_1': np.array([0.0, -0.5, 0.0]),\n        'F': np.array([1 - zeta, 1 - zeta, 1 - eta]),\n        'F_1': np.array([zeta, zeta, eta]),\n        'F_2': np.array([-zeta, -zeta, 1 - eta]),\n        'I': np.array([phi, 1 - phi, 0.5]),\n        'I_1': np.array([1 - phi, phi - 1, 0.5]),\n        'L': np.array([0.5, 0.5, 0.5]),\n        'M': np.array([0.5, 0.0, 0.5]),\n        'X': np.array([1 - psi, psi - 1, 0.0]),\n        'X_1': np.array([psi, 1 - psi, 0.0]),\n        'X_2': np.array([psi - 1, -psi, 0.0]),\n        'Y': np.array([0.5, 0.5, 0.0]),\n        'Y_1': np.array([-0.5, -0.5, 0.0]),\n        'Z': np.array([0.0, 0.0, 0.5])\n    }\n\n    path = [\n        ['\\\\Gamma', 'Y', 'F', 'L', 'I'],\n        ['I_1', 'Z', 'F_1'],\n        ['Y', 'X_1'],\n        ['X', '\\\\Gamma', 'N'],\n        ['M', '\\\\Gamma']\n    ]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\nfrom math import pi\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a = np.random.uniform(0.1, 10.0)\n        b = np.random.uniform(0.1, 10.0)\n        c = np.random.uniform(0.1, 10.0)\n        alpha = np.random.uniform(0.1, pi - 0.1)\n\n        test_cases.append((a, b, c, alpha))\n    return test_cases"}
{"problem_id": "numpy_65", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in a crystal lattice based on given parameters. The function will utilize mathematical formulas to derive the coordinates of various k-points in a three-dimensional space, which are essential for understanding the electronic properties of materials.\n\nFunction Signature:\n```python\ndef mclc3(a: float, b: float, c: float, alpha: float) -> dict:\n```\n\nConstants Used:\n- The constant `mu` is calculated as `(1 + b ** 2 / a ** 2) / 4.0`.\n\nInput Format:\n- The function accepts four floating-point numbers as input: `a`, `b`, `c`, and `alpha`.\n\nOutput Format:\n- The function returns a dictionary with two keys:\n  - `'kpoints'`: A dictionary mapping k-point names to their corresponding 3D coordinates (as NumPy arrays).\n  - `'path'`: A list of lists, where each sublist contains the names of k-points that define a path in the Brillouin zone.\n\nInput: \n```python\n(5.2, 3.4, 7.1, 1.2)\n```\n\nOutput:\n```python\n{\n  'kpoints': {\n    '\\\\Gamma': array([0., 0., 0.]), \n    'F': array([0.36902917, 0.36902917, 0.30179182]), \n    'F_1': array([ 0.63097083, -0.36902917,  0.69820818]), \n    'F_2': array([ 0.36902917, -0.63097083,  0.30179182]), \n    'H': array([0.34472823, 0.34472823, 1.02170361]), \n    'H_1': array([ 0.65527177, -0.34472823, -0.02170361]), \n    'H_2': array([-0.34472823, -0.34472823, -0.02170361]), \n    'I': array([ 0.5, -0.5,  0.5]), \n    'M': array([0.5, 0. , 0.5]), \n    'N': array([0.5, 0. , 0. ]), \n    'N_1': array([ 0. , -0.5,  0. ]), \n    'X': array([ 0.5, -0.5,  0. ]), \n    'Y': array([0.3568787 , 0.3568787 , 0.16174771]), \n    'Y_1': array([ 0.6431213 , -0.3568787 , -0.16174771]), \n    'Y_2': array([-0.3568787 , -0.3568787 , -0.16174771]), \n    'Y_3': array([ 0.3568787 , -0.6431213 ,  0.16174771]), \n    'Z': array([0. , 0. , 0.5])\n  }, \n  'path': [['\\\\Gamma', 'Y', 'F', 'H', 'Z', 'I', 'F_1'], ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'], ['M', '\\\\Gamma']]\n}\n```", "ground_truth_code": "import numpy as np\nfrom math import cos, sin\n\n# main code\ndef mclc3(a, b, c, alpha):\n    mu = (1 + b ** 2 / a ** 2) / 4.0\n    delta = b * c * cos(alpha) / (2 * a ** 2)\n    zeta = mu - 0.25 + (1 - b * cos(alpha) / c) / (4 * sin(alpha) ** 2)\n    eta = 0.5 + 2 * zeta * c * cos(alpha) / b\n    phi = 1 + zeta - 2 * mu\n    psi = eta - 2 * delta\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'F': np.array([1 - phi, 1 - phi, 1 - psi]),\n        'F_1': np.array([phi, phi - 1, psi]),\n        'F_2': np.array([1 - phi, -phi, 1 - psi]),\n        'H': np.array([zeta, zeta, eta]),\n        'H_1': np.array([1 - zeta, -zeta, 1 - eta]),\n        'H_2': np.array([-zeta, -zeta, 1 - eta]),\n        'I': np.array([0.5, -0.5, 0.5]),\n        'M': np.array([0.5, 0.0, 0.5]),\n        'N': np.array([0.5, 0.0, 0.0]),\n        'N_1': np.array([0.0, -0.5, 0.0]),\n        'X': np.array([0.5, -0.5, 0.0]),\n        'Y': np.array([mu, mu, delta]),\n        'Y_1': np.array([1 - mu, -mu, -delta]),\n        'Y_2': np.array([-mu, -mu, -delta]),\n        'Y_3': np.array([mu, mu - 1, delta]),\n        'Z': np.array([0.0, 0.0, 0.5])\n    }\n\n    path = [\n        ['\\\\Gamma', 'Y', 'F', 'H', 'Z', 'I', 'F_1'],\n        ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'],\n        ['M', '\\\\Gamma']\n    ]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\nfrom math import pi\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a = np.random.uniform(0.1, 10.0)\n        b = np.random.uniform(0.1, 10.0)\n        c = np.random.uniform(0.1, 10.0)\n        alpha = np.random.uniform(0.1, pi - 0.1)\n\n        test_cases.append((a, b, c, alpha))\n\n    return test_cases"}
{"problem_id": "numpy_66", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in the Brillouin zone of a crystal lattice based on given parameters. The function will utilize mathematical formulas to derive the coordinates of various k-points and define paths between them.\n\nFunction Signature:\n```python\ndef mclc4(a: float, b: float, c: float, alpha: float) -> dict:\n```\n\nConstants Used:\n- The constant `mu` is calculated as `(1 + (b / a) ** 2) / 4.0`.\n\nInput Format:\n- The function accepts four floating-point numbers as input parameters.\n\nOutput Format:\n- The function returns a dictionary with two keys:\n  - `'kpoints'`: A dictionary of k-point labels and their corresponding coordinates.\n  - `'path'`: A list of lists, where each sublist contains a sequence of k-point labels representing a path.\n\n```python\n# Input\na = 5.0\nb = 3.0\nc = 2.0\nalpha = 1.0  # radians\n\n# Output\n{\n  'kpoints': {\n    '\\\\Gamma': array([0., 0., 0.]), \n    'F': array([0.52307666, 0.52307666, 0.5166245 ]), \n    'F_1': array([ 0.47692334, -0.52307666,  0.4833755 ]), \n    'F_2': array([ 0.52307666, -0.47692334,  0.5166245 ]), \n    'H': array([0.15692334, 0.15692334, 0.61304805]), \n    'H_1': array([ 0.84307666, -0.15692334,  0.38695195]), \n    'H_2': array([-0.15692334, -0.15692334,  0.38695195]), \n    'I': array([ 0.5, -0.5,  0.5]), \n    'M': array([0.5, 0. , 0.5]), \n    'N': array([0.5, 0. , 0. ]), \n    'N_1': array([ 0. , -0.5,  0. ]), \n    'X': array([ 0.5, -0.5,  0. ]), \n    'Y': array([0.34      , 0.34      , 0.06483628]), \n    'Y_1': array([ 0.66      , -0.34      , -0.06483628]), \n    'Y_2': array([-0.34      , -0.34      , -0.06483628]), \n    'Y_3': array([ 0.34      , -0.66      ,  0.06483628]), \n    'Z': array([0. , 0. , 0.5])\n  }, \n  'path': [['\\\\Gamma', 'Y', 'F', 'H', 'Z', 'I'], ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'], ['M', '\\\\Gamma']]\n}\n```", "ground_truth_code": "import numpy as np\nfrom math import cos, sin\n\n# main code\ndef mclc4(a, b, c, alpha):\n    mu = (1 + (b / a) ** 2) / 4.0\n    delta = (b * c * cos(alpha)) / (2 * a ** 2)\n    zeta = mu - 0.25 + (1 - (b * cos(alpha) / c)) / (4 * sin(alpha) ** 2)\n    eta = 0.5 + 2 * zeta * c * cos(alpha) / b\n    phi = 1 + zeta - 2 * mu\n    psi = eta - 2 * delta\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'F': np.array([1 - phi, 1 - phi, 1 - psi]),\n        'F_1': np.array([phi, phi - 1, psi]),\n        'F_2': np.array([1 - phi, -phi, 1 - psi]),\n        'H': np.array([zeta, zeta, eta]),\n        'H_1': np.array([1 - zeta, -zeta, 1 - eta]),\n        'H_2': np.array([-zeta, -zeta, 1 - eta]),\n        'I': np.array([0.5, -0.5, 0.5]),\n        'M': np.array([0.5, 0.0, 0.5]),\n        'N': np.array([0.5, 0.0, 0.0]),\n        'N_1': np.array([0.0, -0.5, 0.0]),\n        'X': np.array([0.5, -0.5, 0.0]),\n        'Y': np.array([mu, mu, delta]),\n        'Y_1': np.array([1 - mu, -mu, -delta]),\n        'Y_2': np.array([-mu, -mu, -delta]),\n        'Y_3': np.array([mu, mu - 1, delta]),\n        'Z': np.array([0.0, 0.0, 0.5])\n    }\n\n    path = [['\\\\Gamma', 'Y', 'F', 'H', 'Z', 'I'], ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'], ['M', '\\\\Gamma']]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\nfrom math import pi\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a = np.random.uniform(0.1, 10.0)\n        b = np.random.uniform(0.1, 10.0)\n        c = np.random.uniform(0.1, 10.0)\n        alpha = np.random.uniform(0.1, pi - 0.1)\n\n        test_cases.append((a, b, c, alpha))\n\n    return test_cases"}
{"problem_id": "numpy_67", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates specific k-points and paths in the Brillouin zone of a crystal lattice based on given parameters. The function will utilize mathematical formulas to derive values that represent the positions of these k-points in a three-dimensional space.\n\nFunction signature:\n```python\ndef mclc5(a: float, b: float, c: float, alpha: float) -> dict:\n```\n\n### Constants Used:\n- The constant values used in the calculations are derived from the input parameters `a`, `b`, `c`, and `alpha`. These parameters represent physical dimensions and angles relevant to the crystal structure.\n\n\n### Input Format:\n- The function accepts four floating-point numbers as input: `a`, `b`, `c`, and `alpha`.\n\n### Output Format:\n- The function returns a dictionary with two keys:\n  - `'kpoints'`: A dictionary mapping k-point labels to their corresponding 3D coordinates (as NumPy arrays).\n  - `'path'`: A list of lists, where each sublist contains k-point labels representing a path through the Brillouin zone.\n\nInput:  \n```python\n(2.5, 3.0, 1.5, 1.0471975511965976)  # a=2.5, b=3.0, c=1.5, alpha=pi/3\n```\n\nOutput:  \n```python\n{\n  'kpoints': {\n    '\\\\Gamma': array([0., 0., 0.]), \n    'F': array([0.68, 0.68, 0.32]), \n    'F_1': array([0.32, 0.32, 0.68]), \n    'F_2': array([ 0.68, -0.32,  0.32]), \n    'H': array([0.36, 0.36, 0.68]), \n    'H_1': array([ 0.64, -0.36,  0.32]), \n    'H_2': array([-0.36, -0.36,  0.32]), \n    'I': array([0.75, 0.25, 0.5 ]), \n    'I_1': array([ 0.25, -0.25,  0.5 ]), \n    'L': array([0.5, 0.5, 0.5]), \n    'M': array([0.5, 0. , 0.5]), \n    'N': array([0.5, 0. , 0. ]), \n    'N_1': array([ 0. , -0.5,  0. ]), \n    'X': array([ 0.5, -0.5,  0. ]), \n    'Y': array([ 5.20000000e-01,  5.20000000e-01, -5.55111512e-17]), \n    'Y_1': array([ 4.80000000e-01, -5.20000000e-01,  5.55111512e-17]), \n    'Y_2': array([-5.20000000e-01, -5.20000000e-01,  5.55111512e-17]), \n    'Y_3': array([ 5.20000000e-01, -4.80000000e-01, -5.55111512e-17]), \n    'Z': array([0. , 0. , 0.5])\n  }, \n  'path': [['\\\\Gamma', 'Y', 'F', 'L', 'I'], ['I_1', 'Z', 'H', 'F_1'], ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'], ['M', '\\\\Gamma']]\n}\n\n```", "ground_truth_code": "import numpy as np\nfrom math import cos, sin\n\n# main code\ndef mclc5(a, b, c, alpha):\n    zeta = (b ** 2 / a ** 2 + (1 - b * cos(alpha) / c) / sin(alpha) ** 2) / 4\n    eta = 0.5 + 2 * zeta * c * cos(alpha) / b\n    mu = eta / 2 + b ** 2 / (4 * a ** 2) - b * c * cos(alpha) / (2 * a ** 2)\n    nu = 2 * mu - zeta\n    rho = 1 - zeta * a ** 2 / b ** 2\n    omega = (4 * nu - 1 - b ** 2 * sin(alpha) ** 2 / a ** 2) * c / (2 * b * cos(alpha))\n    delta = zeta * c * cos(alpha) / b + omega / 2 - 0.25\n\n    kpoints = {\n        '\\\\Gamma': np.array([0.0, 0.0, 0.0]),\n        'F': np.array([nu, nu, omega]),\n        'F_1': np.array([1 - nu, 1 - nu, 1 - omega]),\n        'F_2': np.array([nu, nu - 1, omega]),\n        'H': np.array([zeta, zeta, eta]),\n        'H_1': np.array([1 - zeta, -zeta, 1 - eta]),\n        'H_2': np.array([-zeta, -zeta, 1 - eta]),\n        'I': np.array([rho, 1 - rho, 0.5]),\n        'I_1': np.array([1 - rho, rho - 1, 0.5]),\n        'L': np.array([0.5, 0.5, 0.5]),\n        'M': np.array([0.5, 0.0, 0.5]),\n        'N': np.array([0.5, 0.0, 0.0]),\n        'N_1': np.array([0.0, -0.5, 0.0]),\n        'X': np.array([0.5, -0.5, 0.0]),\n        'Y': np.array([mu, mu, delta]),\n        'Y_1': np.array([1 - mu, -mu, -delta]),\n        'Y_2': np.array([-mu, -mu, -delta]),\n        'Y_3': np.array([mu, mu - 1, delta]),\n        'Z': np.array([0.0, 0.0, 0.5])\n    }\n\n    path = [['\\\\Gamma', 'Y', 'F', 'L', 'I'], ['I_1', 'Z', 'H', 'F_1'], ['H_1', 'Y_1', 'X', '\\\\Gamma', 'N'],\n            ['M', '\\\\Gamma']]\n\n    return {'kpoints': kpoints, 'path': path}", "test_script": "import numpy as np\nfrom math import pi\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a = np.random.uniform(0.1, 10)\n        b = np.random.uniform(0.1, 10)\n        c = np.random.uniform(0.1, 10)\n        alpha = np.random.uniform(0.1, pi - 0.1)\n\n        test_cases.append((a, b, c, alpha))\n\n    return test_cases"}
{"problem_id": "numpy_68", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the weighted mode of an array along a specified axis. The weighted mode is the value that appears most frequently in the array, taking into account the weights assigned to each element. If there are multiple modes, the function should return the smallest mode. \n\nFunction signature:\n```python\ndef weighted_mode(a, w, axis):\n```\n\n### Constants:\n- The function uses a constant `0` to initialize the `axis` parameter when it is set to `None`.\n\n### Input Format:\n- The function takes three parameters:\n  - `a`: a NumPy array of numerical values.\n  - `w`: a NumPy array of weights corresponding to each element in `a`.\n  - `axis`: an integer or `None`, indicating the axis along which to compute the weighted mode.\n\n### Output Format:\n- The function returns a tuple:\n  - The first element is a NumPy array containing the most frequent score(s).\n  - The second element is a NumPy array containing the counts of the most frequent score(s).\n\nInput:\n```python\na = np.array([[1, 2, 2], [3, 1, 1]])\nw = np.array([[1, 2, 3], [4, 1, 1]])\naxis = 0\n```\n\nOutput:\n```python\n(mostfrequent, counts) = (array([[3., 2., 2.]]), array([[4., 2., 3.]]))\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef weighted_mode(a, w, axis):\n    if axis is None:\n        a = np.ravel(a)\n        w = np.ravel(w)\n        axis = 0\n    else:\n        a = np.asarray(a)\n        w = np.asarray(w)\n    if a.shape != w.shape:\n        w = np.full(a.shape, w, dtype=w.dtype)\n    scores = np.unique(np.ravel(a))\n    testshape = list(a.shape)\n    testshape[axis] = 1\n    oldmostfreq = np.zeros(testshape)\n    oldcounts = np.zeros(testshape)\n    for score in scores:\n        template = np.zeros(a.shape)\n        ind = a == score\n        template[ind] = w[ind]\n        counts = np.expand_dims(np.sum(template, axis), axis)\n        mostfrequent = np.where(counts > oldcounts, score, oldmostfreq)\n        oldcounts = np.maximum(counts, oldcounts)\n        oldmostfreq = mostfrequent\n    return (mostfrequent, oldcounts)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 6, size=np.random.randint(1, 4)))\n        a = np.random.randint(0, 10, size=shape)\n        w = np.random.randint(1, 5, size=shape)\n        axis = np.random.choice([None] + list(range(len(shape))))\n\n        test_cases.append((a, w, axis))\n\n    return test_cases"}
{"problem_id": "numpy_69", "library": "numpy", "code_problem": "You are tasked with implementing a function that assigns spatial coordinates (good spots) to specific cell labels based on a given label matrix. The function should identify cells that have a certain number of associated coordinates and return the assignments of good spots to these cells.\n\nFunction Signature:\n```python\ndef AssignReadsToCells(labels: np.ndarray, good_spots: np.ndarray) -> tuple[np.ndarray, np.ndarray]:\n```\n\nConstant used in the main code:\n- The constant values used to filter the number of coordinates for each cell are 1000 and 100000.\n\n\nInput Format:\n- `labels`: A 2D numpy array where each element represents a cell label.\n- `good_spots`: A 2D numpy array of coordinates (points) for which cell assignments are to be determined.\n\nOutput Format:\n- A tuple containing:\n  - A 1D numpy array of cell assignments corresponding to each point in `good_spots`.\n  - A 2D numpy array of coordinates for the valid cells that were identified.\n\n**Input:**\n```python\nlabels = np.array([[0, 0], [0, 0], [0, 0]])\n\ngood_spots = np.array([[1, 0], [0, 1]])\n```\n\n**Output:**\n```python\n(array([], dtype=float64), [])\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy.spatial import cKDTree\n\n# main code\ndef AssignReadsToCells(labels, good_spots):\n    Nlabels = labels.max()\n    coords = []\n    cell_ids = []\n    num_cells = 0\n\n    for i in range(Nlabels):\n        curr_coords = np.argwhere(labels == i)\n        if 1000 < curr_coords.shape[0] < 100000:\n            coords.append(curr_coords)\n            cell_ids.append(np.repeat(i, curr_coords.shape[0]))\n            num_cells += 1\n\n    if len(coords) == 0:\n        return np.array([]), []\n\n    coords = np.vstack(coords)\n    cell_ids = np.concatenate(cell_ids)\n\n    label_kd = cKDTree(coords)\n    cell_assignments = np.array([cell_ids[label_kd.query(p)[1]] for p in good_spots])\n\n    return (cell_assignments, coords)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        label_size = np.random.randint(50, 200, size=2)\n        labels = np.random.randint(0, np.random.randint(5, 20), size=label_size)\n\n        unique_labels = np.unique(labels)\n        for lbl in unique_labels:\n            label_mask = labels == lbl\n            num_points = np.sum(label_mask)\n            if num_points < 1000 or num_points > 100000:\n                labels[label_mask] = 0\n\n        num_good_spots = np.random.randint(50, 500)\n        good_spots = np.column_stack(\n            (np.random.randint(0, label_size[0], size=num_good_spots),\n             np.random.randint(0, label_size[1], size=num_good_spots)))\n\n        test_cases.append((labels, good_spots))\n\n    return test_cases\n"}
{"problem_id": "numpy_70", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes shape padding for a given tensor shape. The function will take in a tensor shape, padding values, and margin values, and return a dictionary containing the processed shapes and weights for padding.\n\nFunction signature:\n```python\ndef process_shape_padding(tshape, pad, margin):\n```\n\nConstants used in the main code:\n- The constant `2` is used to calculate the output dimensions for padding.\n\n\nInput format:\n- The function takes three parameters:\n  - `tshape`: A shape descriptor for the tensor (can be an integer or a tuple of integers).\n  - `pad`: Padding values for the tensor (can be an integer or a tuple of integers).\n  - `margin`: Margin values for the tensor (can be an integer or a tuple of integers).\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `\"tshape\"`: The processed tensor shape as a tuple.\n  - `\"pad\"`: The processed padding values as a tuple.\n  - `\"margin\"`: The processed margin values as a tuple.\n  - `\"wy\"`: An array of weights for the height dimension.\n  - `\"wx\"`: An array of weights for the width dimension.\n\nInput:\n```python\ntshape = 45\npad = 3\nmargin = 2\n```\n\nOutput:\n```python\n{\n  'tshape': (45, 45),\n  'pad': (3, 3),\n  'margin': (2, 2),\n  'wy': array([0.14285714, 0.28571429, 0.42857143, 0.57142857, 0.71428571, 0.85714286]),\n  'wx': array([0.14285714, 0.28571429, 0.42857143, 0.57142857, 0.71428571, 0.85714286])\n}\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef process_shape_padding(tshape, pad, margin):\n    tshape = tuple(np.broadcast_to(tshape, 2).astype(int))\n    pad = tuple(np.broadcast_to(pad, 2).astype(int))\n    margin = tuple(np.broadcast_to(margin, 2).astype(int))\n\n    (oly, olx) = 2 * np.array(pad, int)\n    wy = (np.arange(oly) + 1) / (oly + 1)\n    wx = (np.arange(olx) + 1) / (olx + 1)\n\n    return {\n        \"tshape\": tshape,\n        \"pad\": pad,\n        \"margin\": margin,\n        \"wy\": wy,\n        \"wx\": wx\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        tshape = tuple(np.random.randint(1, 100, size=np.random.choice([1, 2])))\n        pad = tuple(np.random.randint(0, 10, size=len(tshape)))\n        margin = tuple(np.random.randint(0, 10, size=len(tshape)))\n\n        test_cases.append((tshape, pad, margin))\n\n    return test_cases"}
{"problem_id": "numpy_71", "library": "numpy", "code_problem": "```python\ndef generate_equidistant_points_on_sphere(N, r):\n```\n\nIn this function, `generate_equidistant_points_on_sphere`, the goal is to generate `N` equidistant points on the surface of a sphere with radius `r`. \n\n### Constants Used:\n- The constant `a` is defined as `4 * np.pi / N`, which represents the area allocated for each point on the sphere.\n\n\n### Input and Output Format:\n- **Input**: The function takes two parameters:\n  - `N`: An integer representing the number of equidistant points to generate.\n  - `r`: A float representing the radius of the sphere.\n\n- **Output**: The function returns a NumPy array of shape `(N, 3)`, where each row contains the Cartesian coordinates `(x, y, z)` of a point on the sphere.\n\n```python\nInput: (50, 5.0)\nOutput: array([[ 1.29409523,  0.        ,  4.82962913],\n        ...\n       [-0.64704761, -1.12071934, -4.82962913]])\n``` \n\n(Note: The output is truncated for brevity and will contain 50 rows of 3D coordinates representing points on the sphere.)", "ground_truth_code": "import numpy as np\n\n# main code\ndef generate_equidistant_points_on_sphere(N, r):\n    x = []\n    y = []\n    z = []\n    a = 4 * np.pi / N\n    d = np.sqrt(a)\n    Mt = np.around(np.pi / d).astype(int)\n    dt = np.pi / Mt\n    dp = a / dt\n    for m in range(Mt):\n        theta = np.pi * (m + 0.5) / Mt\n        Mp = np.around(2 * np.pi * np.sin(theta) / dp).astype(int)\n        for n in range(Mp):\n            phi = 2 * np.pi * n / Mp\n            x.append(np.sin(theta) * np.cos(phi) * r)\n            y.append(np.sin(theta) * np.sin(phi) * r)\n            z.append(np.cos(theta) * r)\n    return np.column_stack((x, y, z))", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    test_cases.append((random.randint(1, 100), 0))\n    test_cases.append((1, random.uniform(0.1, 10.0)))\n    for _ in range(n - 2):\n        N = random.randint(2, 1000)\n        r = random.uniform(0.1, 10.0)\n        test_cases.append((N, r))\n\n    return test_cases\n"}
{"problem_id": "numpy_72", "library": "numpy", "code_problem": "You are tasked with implementing a function that converts a nested dictionary structure representing interactions between residues into a pandas DataFrame. The function should allow for customization of data types, handling of empty values, and the option to drop empty columns from the resulting DataFrame.\n\nFunction Signature:\n```python\ndef to_dataframe(ifp: dict, interactions: list, count: bool, dtype: type, drop_empty: bool, index_col: str) -> pd.DataFrame:\n```\n\nConstants:\n- `empty_value`: This constant is defined based on the `dtype` parameter or defaults to `0` if `count` is `True`, or `False` if `count` is `False`.\n\n\nInput Format:\n- `ifp`: A dictionary of dictionaries representing frames and their corresponding residue interactions.\n- `interactions`: A list of interaction identifiers.\n- `count`: A boolean indicating whether to count interactions.\n- `dtype`: A type for the DataFrame values.\n- `drop_empty`: A boolean indicating whether to drop empty columns.\n- `index_col`: A string for naming the index column.\n\nOutput Format:\n- The function returns a pandas DataFrame structured according to the specified parameters, containing the interaction data for the given residue pairs.\n\n**Input:**\n```python\nifp = {\n    0: {\n        ('lig_0', 'prot_0'): {'int_0': (1, 2), 'int_1': (3,)},\n        ('lig_1', 'prot_1'): {'int_0': (4,)}\n    },\n    1: {\n        ('lig_0', 'prot_0'): {'int_1': (5, 6)},\n        ('lig_1', 'prot_1'): {}\n    }\n}\ninteractions = ['int_0', 'int_1']\ncount = False\ndtype = bool\ndrop_empty = True\nindex_col = \"Frame_Index\"\n```\n\n**Output:**\n```python\nligand       lig_0        lig_1\nprotein     prot_0       prot_1\ninteraction  int_0 int_1  int_0\nFrame_Index                    \n0             True  True   True\n1            False  True  False\n```\n", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n\n# main code\ndef to_dataframe(ifp, interactions, count, dtype, drop_empty, index_col):\n    dtype = dtype or (np.uint8 if count else bool)\n    empty_value = dtype(0)\n\n    residue_pairs = sorted(set(residue_tuple for frame_ifp in ifp.values() for residue_tuple in frame_ifp))\n    data = {residue_tuple: [] for residue_tuple in residue_pairs}\n    index = []\n\n    for i, frame_ifp in ifp.items():\n        index.append(i)\n        for residue_tuple in residue_pairs:\n            ifp_dict = frame_ifp.get(residue_tuple, {})\n            if count:\n                bitvector = np.array([len(ifp_dict.get(i, ())) for i in interactions], dtype=dtype)\n            else:\n                bitvector = np.array([i in ifp_dict for i in interactions], dtype=bool)\n            data[residue_tuple].append(bitvector)\n\n    index = pd.Series(index, name=index_col)\n    if not data:\n        return pd.DataFrame([], index=index)\n\n    values = np.array([\n        np.hstack([bitvector_list[frame] for bitvector_list in data.values()])\n        for frame in range(len(index))\n    ])\n\n    columns = pd.MultiIndex.from_tuples(\n        [(str(lig_res), str(prot_res), i) for (lig_res, prot_res) in residue_pairs for i in interactions],\n        names=['ligand', 'protein', 'interaction']\n    )\n\n    df = pd.DataFrame(values, columns=columns, index=index).astype(dtype)\n\n    if drop_empty:\n        mask = (df != empty_value).any(axis=0)\n        df = df.loc[:, mask]\n\n    return df", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_frames = random.randint(1, 50)\n        num_residues = random.randint(1, 10)\n        num_interactions = random.randint(1, 5)\n\n        residue_pairs = [(f'lig_{i}', f'prot_{j}') for i in range(num_residues) for j in range(num_residues)]\n        interactions = [f'int_{i}' for i in range(num_interactions)]\n\n        ifp = {}\n        for frame_idx in range(num_frames):\n            frame_data = {}\n            for residue in random.sample(residue_pairs, random.randint(1, len(residue_pairs))):\n                frame_data[residue] = {\n                    interaction: tuple(np.random.randint(0, 10, random.randint(1, 3)))\n                    for interaction in random.sample(interactions, random.randint(1, len(interactions)))\n                }\n            ifp[frame_idx] = frame_data\n        dtype = random.choice([np.uint8, np.float32, np.int32, bool])\n        count = random.choice([True, False])\n        drop_empty = random.choice([True, False])\n        index_col = \"Frame_Index\"\n        test_cases.append((ifp, interactions, count, dtype, drop_empty, index_col))\n\n    return test_cases\n"}
{"problem_id": "numpy_73", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a window function used in signal processing. The window function is designed to taper the edges of a signal to reduce spectral leakage when performing a Fourier transform.\n\nFunction signature:\n```python\ndef get_window(N, alpha=0.2):\n```\n\nConstant used in the main code:\n- The constant `alpha` is set to `0.2` by default, which determines the width of the tapering region of the window.\n\nInput format:\n- The function accepts two parameters:\n  - `N`: an integer representing the size of the window.\n  - `alpha`: a float (optional) representing the width of the tapering region (default is `0.2`).\n\nOutput format:\n- The function returns a NumPy array of size `N`, representing the window function values, where the edges are smoothly tapered according to the specified `alpha`.\n\n```python\nInput: (10, 0.2)\nOutput: array([0., 1., 1., 1., 1., 1., 1., 1., 1., 0.])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_window(N, alpha=0.2):\n    window = np.ones(N)\n    x = np.linspace(-1.0, 1.0, N)\n    ind1 = (abs(x) > 1 - alpha) * (x < 0)\n    ind2 = (abs(x) > 1 - alpha) * (x > 0)\n    window[ind1] = 0.5 * (1 - np.cos(np.pi * (x[ind1] + 1) / alpha))\n    window[ind2] = 0.5 * (1 - np.cos(np.pi * (x[ind2] - 1) / alpha))\n    return window", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n\n    test_cases.append((0, random.uniform(0.0, 1.0)))\n    test_cases.append((1, random.uniform(0.0, 1.0)))\n    test_cases.append((1000, 0.0))\n    test_cases.append((1000, 1.0))\n\n    for _ in range(n - len(test_cases)):\n        N = random.randint(0, 1000)\n        alpha = random.uniform(0.0, 1.0)\n        test_cases.append((N, alpha))\n\n    return test_cases\n"}
{"problem_id": "numpy_74", "library": "numpy", "code_problem": "You are tasked with creating a function that calculates the virtual last points for junction roads based on given junction coordinates, road coordinates, and a specified radius. The function should determine the positions of these last points based on the angles of the roads relative to the junction.\n\nFunction Signature:\n```python\ndef createVirtualLastPointForJunctionRoads(jx: float, jy: float, jrxs: List[float], jrys: List[float], radius: float) -> List[List[float]]:\n```\n\nConstants Used:\n- The constant value used in the main code is `np.pi`, which represents the mathematical constant \u03c0 (pi).\n\nInput Format:\n- `jx`: A float representing the x-coordinate of the junction.\n- `jy`: A float representing the y-coordinate of the junction.\n- `jrxs`: A list of floats representing the x-coordinates of the roads.\n- `jrys`: A list of floats representing the y-coordinates of the roads.\n- `radius`: A float representing the radius used for calculations.\n\nOutput Format:\n- The function returns a list of lists, where each inner list contains two floats representing the y and x coordinates of the calculated last point for each road.\n\n```python\n# Input\njx = 10.0\njy = 15.0\njrxs = [12.0, 8.0, 14.0]\njrys = [18.0, 10.0, 20.0]\nradius = 5.0\n\n# Output\nlastPoints = [[11.8, 17.7], [8.2, 10.5], [13.123475237772121, 18.90434404721515]]\n```", "ground_truth_code": "import numpy as np\n\ndef getPositiveHeading(hdg):\n    while hdg < 0.0:\n        hdg += 2.0 * np.pi\n    return hdg % (np.pi * 2.0)\n\ndef giveHeading(x1, y1, x2, y2):\n    if x1 == x2 and y1 == y2:\n        return 0.0\n    x_arr = np.array([x1, x2]) - x1\n    y_arr = np.array([y1, y2]) - y1\n    if x_arr[1] > 0:\n        phi = np.arctan(y_arr[1] / x_arr[1])\n    elif x_arr[1] == 0:\n        phi = np.pi / 2 if y_arr[1] > 0 else -np.pi / 2\n    elif y_arr[1] >= 0:\n        phi = np.arctan(y_arr[1] / x_arr[1]) + np.pi\n    else:\n        phi = np.arctan(y_arr[1] / x_arr[1]) - np.pi\n    return getPositiveHeading(phi)\n\ndef getXYPositionFromLineLength(xstart, ystart, heading, length):\n    xend = xstart + np.cos(heading) * length\n    yend = ystart + np.sin(heading) * length\n    return (xend, yend)\n\ndef schnittpunkt(x1, y1, hdg1, x2, y2, hdg2):\n    if abs(np.sin(hdg1) * np.cos(hdg2) - np.sin(hdg2) * np.cos(hdg1)) < 0.02:\n        r2 = (y1 * np.cos(hdg1) + np.sin(hdg1) * (x2 - x1) - y2 * np.cos(hdg1)) / (np.sin(hdg2) * np.cos(hdg1) - np.sin(hdg1) * np.cos(hdg2))\n        r1 = (y2 - y1 + np.sin(hdg2) * r2) / np.sin(hdg1) if abs(abs(hdg1) - np.pi / 2.0) < 0.2 else (x2 - x1 + np.cos(hdg2) * r2) / np.cos(hdg1)\n    else:\n        r1 = (-y1 * np.cos(hdg2) + y2 * np.cos(hdg2) + np.sin(hdg2) * x1 - np.sin(hdg2) * x2) / (np.sin(hdg1) * np.cos(hdg2) - np.sin(hdg2) * np.cos(hdg1))\n        r2 = (y1 - y2 + np.sin(hdg1) * r1) / np.sin(hdg2) if abs(abs(hdg2) - np.pi / 2.0) < 0.2 else (x1 - x2 + np.cos(hdg1) * r1) / np.cos(hdg2)\n    x_s = x1 + np.cos(hdg1) * r1\n    y_s = y1 + np.sin(hdg1) * r1\n    return (x_s, y_s, r1, r2)\n\ndef distance(x1, y1, x2, y2):\n    return ((x1 - x2) ** 2 + (y1 - y2) ** 2) ** 0.5\n\n# main code\ndef createVirtualLastPointForJunctionRoads(jx, jy, jrxs, jrys, radius):\n    lastPoints = []\n    for i in range(len(jrxs)):\n        x = jrxs[i]\n        y = jrys[i]\n        hdg1 = giveHeading(jx, jy, x, y)\n        hdg1_90 = hdg1 - np.pi / 2.0\n        x1t1 = x + radius * np.cos(hdg1_90)\n        y1t1 = y + radius * np.sin(hdg1_90)\n        x1t2 = x - radius * np.cos(hdg1_90)\n        y1t2 = y - radius * np.sin(hdg1_90)\n        relevantr = [min(distance(jx, jy, x, y) * 0.9, radius)]\n        for j in range(len(jrxs)):\n            if i == j:\n                continue\n            x2 = jrxs[j]\n            y2 = jrys[j]\n            hdg2 = giveHeading(jx, jy, x2, y2)\n            hdg2_90 = hdg2 - np.pi / 2.0\n            x2t1 = x2 + radius * np.cos(hdg2_90)\n            y2t1 = y2 + radius * np.sin(hdg2_90)\n            x2t2 = x2 - radius * np.cos(hdg2_90)\n            y2t2 = y2 - radius * np.sin(hdg2_90)\n            for ix, iy in [\n                schnittpunkt(x1t1, y1t1, hdg1, x2t1, y2t1, hdg2)[:2],\n                schnittpunkt(x1t2, y1t2, hdg1, x2t1, y2t1, hdg2)[:2],\n                schnittpunkt(x1t1, y1t1, hdg1, x2t2, y2t2, hdg2)[:2],\n                schnittpunkt(x1t2, y1t2, hdg1, x2t2, y2t2, hdg2)[:2]\n            ]:\n                if min(x, jx) < ix < max(x, jx) and min(y, jy) < iy < max(y, jy):\n                    relevantr.append(distance(ix, iy, jx, jy))\n        (lasty, lastx) = getXYPositionFromLineLength(jx, jy, hdg1, max(relevantr))\n        lastPoints.append([lasty, lastx])\n    return lastPoints", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        jx, jy = np.random.uniform(-1000, 1000, size=2)\n\n        num_roads = np.random.randint(2, 6)\n        jrxs = np.random.uniform(-1000, 1000, size=num_roads).tolist()\n        jrys = np.random.uniform(-1000, 1000, size=num_roads).tolist()\n\n        radius = np.random.uniform(1, 100)\n\n        test_cases.append((jx, jy, jrxs, jrys, radius))\n    return test_cases\n"}
{"problem_id": "numpy_75", "library": "numpy", "code_problem": "You are tasked with implementing a function that subsamples a multi-dimensional NumPy array based on a specified step size. The function should also have the capability to pad the array if necessary, using a specified padding mode. The function signature is as follows:\n\n```python\ndef subsample_array(x: np.ndarray, step: tuple, pad: bool, mode: str) -> np.ndarray:\n```\n\n### Constants:\n- The constant used in the main code is `0`, which is used in the context of padding calculations.\n\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A NumPy array of any shape.\n  - `step`: A tuple of integers representing the step size for each dimension.\n  - `pad`: A boolean indicating whether to pad the array if necessary.\n  - `mode`: A string specifying the padding mode (e.g., 'constant', 'edge', etc.).\n\n- **Output**: \n  - A NumPy array that is a subsampled version of the input array `x`, potentially padded according to the specified parameters.\n\nInput:\n```python\nx = np.array([[0.1, 0.2, 0.3, 0.4],\n              [0.5, 0.6, 0.7, 0.8],\n              [0.9, 1.0, 1.1, 1.2]])\nstep = (2, 2)\npad = True\nmode = 'edge'\n```\n\nOutput:\n```python\narray([[[[0.1, 0.3],\n         [0.9, 1.1]],\n        [[0.2, 0.4],\n         [1. , 1.2]]],\n       [[[0.5, 0.7],\n         [0.9, 1.1]],\n        [[0.6, 0.8],\n         [1. , 1.2]]]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef subsample_array(x, step, pad, mode):\n    if np.any(np.greater_equal(step, x.shape)):\n        return np.empty(0)\n\n    sbsz, dvmd = np.divmod(x.shape, step)\n\n    if pad and np.any(dvmd):\n        sbsz += np.clip(dvmd, 0, 1)\n        psz = np.subtract(np.multiply(sbsz, step), x.shape)\n        pdt = [(0, p) for p in psz]\n        x = np.pad(x, pdt, mode=mode)\n\n    outsz = step + tuple(sbsz)\n    outstrd = x.strides + tuple(np.multiply(step, x.strides))\n\n    return np.lib.stride_tricks.as_strided(x, outsz, outstrd)\n", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(5, 20, size=np.random.randint(2, 5)))\n        x = np.random.rand(*shape)\n        step = tuple(np.random.randint(1, max(2, min(shape) // 2), size=len(shape)))\n        pad = random.choice([True, False])\n        mode = random.choice(['constant', 'edge', 'linear_ramp', 'maximum', 'mean', 'median',\n                              'minimum', 'reflect', 'symmetric', 'wrap'])\n\n        test_cases.append((x, step, pad, mode))\n\n    return test_cases"}
{"problem_id": "numpy_76", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the first-order score for a given set of parameters. The function will utilize properties of the gamma distribution and skewness to compute the score based on the input values.\n\nFunction signature:\n```python\ndef first_order_score(y, mean, scale, shape, skewness):\n```\n\nConstant used in the main code:\n- The constant used in the main code is derived from the gamma function, specifically:\n  ```python\n  m1 = np.sqrt(shape) * sp.gamma((shape - 1.0) / 2.0) / (np.sqrt(np.pi) * sp.gamma(shape / 2.0))\n  ```\n\n\nInput format:\n- The function takes in five parameters:\n  - `y`: A float representing the value for which the score is to be calculated.\n  - `mean`: A float representing the mean of the distribution.\n  - `scale`: A float representing the scale parameter of the distribution.\n  - `shape`: A float representing the shape parameter of the distribution.\n  - `skewness`: A float representing the skewness of the distribution.\n\nOutput format:\n- The function returns a float which is the calculated first-order score based on the input parameters.\n\n```python\nInput: (y=25.3, mean=2.5, scale=1.2, shape=3.0, skewness=0.5)\nOutput: 0.16110609551260646\n```", "ground_truth_code": "import numpy as np\nimport scipy.special as sp\n\n# main code\ndef first_order_score(y, mean, scale, shape, skewness):\n    m1 = np.sqrt(shape) * sp.gamma((shape - 1.0) / 2.0) / (np.sqrt(np.pi) * sp.gamma(shape / 2.0))\n    mean = mean + (skewness - 1.0 / skewness) * scale * m1\n    if y - mean >= 0:\n        return (shape + 1) / shape * (y - mean) / (np.power(skewness * scale, 2) + np.power(y - mean, 2) / shape)\n    else:\n        return (shape + 1) / shape * (y - mean) / (np.power(scale, 2) + np.power(skewness * (y - mean), 2) / shape)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        y = random.uniform(-100.0, 100.0)\n        mean = random.uniform(-10.0, 10.0)\n        scale = random.uniform(0.01, 10.0)\n        shape = random.uniform(1.0, 5.0)\n        skewness = random.uniform(-2.0, 2.0)\n        test_cases.append((y, mean, scale, shape, skewness))\n    \n    return test_cases\n"}
{"problem_id": "numpy_77", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the log probability density function (logpdf) of a specific distribution based on the Student's t-distribution. The function will handle two cases depending on the input values relative to a specified location parameter. \n\nThe function signature is as follows:\n```python\ndef logpdf_internal(x, df, loc, scale, gamma):\n```\n\n### Constants:\n- The constant `2.0` is used in the computation of the log probability density function.\n\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A NumPy array of float values.\n  - `df`: An integer representing the degrees of freedom.\n  - `loc`: A NumPy array of float values representing the location parameter.\n  - `scale`: A float value representing the scale parameter.\n  - `gamma`: A float value representing the scaling factor.\n\n- **Output**: \n  - A NumPy array of float values representing the log probability density function evaluated at each element of `x`.\n\n```python\n# Input\nx = np.array([-3.5, 0.0, 2.5])\ndf = 10\nloc = np.array([-2.0, 0.0, 1.0])\nscale = 2.0\ngamma = 1.5\n\n# Output\narray([-2.37252753, -1.71708724, -1.85289661])\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as ss\n\n# main code\ndef logpdf_internal(x, df, loc, scale, gamma):\n    result = np.zeros(x.shape[0])\n    result[x - loc < 0] = np.log(2.0) - np.log(gamma + 1.0 / gamma) + ss.t.logpdf(x=gamma * x[x - loc < 0], loc=loc[x - loc < 0] * gamma, df=df, scale=scale)\n    result[x - loc >= 0] = np.log(2.0) - np.log(gamma + 1.0 / gamma) + ss.t.logpdf(x=x[x - loc >= 0] / gamma, loc=loc[x - loc >= 0] / gamma, df=df, scale=scale)\n    return result", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        df = random.randint(1, 30)\n        scale = random.uniform(0.1, 10.0)\n        gamma = random.uniform(0.1, 10.0)\n        size = random.randint(1, 10)\n        x = np.random.uniform(-10.0, 10.0, size=size)\n        if random.random() > 0.5:\n            loc = np.random.uniform(-5.0, 5.0, size=size)\n        else:\n            loc = np.full(size, np.random.uniform(-5.0, 5.0))\n\n        test_cases.append((x, df, loc, scale, gamma))\n\n    return test_cases\n"}
{"problem_id": "numpy_78", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a regression score based on a given set of parameters. The function will utilize statistical concepts to adjust the mean based on skewness and then compute a score based on the difference between a target value and the adjusted mean.\n\nFunction signature:\n```python\ndef reg_score_function(X, y, mean, scale, shape, skewness):\n```\n\nConstants used in the main code:\n- `m1`: This constant is calculated using the shape parameter and the gamma function from the `scipy.special` library. It is used to adjust the mean based on the skewness.\n\n\nInput format:\n- `X`: A numerical value representing the input feature.\n- `y`: A numerical value representing the target value.\n- `mean`: A numerical value representing the initial mean.\n- `scale`: A numerical value representing the scale parameter.\n- `shape`: A numerical value representing the shape parameter.\n- `skewness`: A numerical value representing the skewness of the distribution.\n\nOutput format:\n- The function returns a numerical value representing the regression score based on the provided inputs.\n\nInput: (3.5, 2.0, 0.5, 1.0, 2.0, 0.5)\nOutput: 2.793005174738626", "ground_truth_code": "import numpy as np\nimport scipy.special as sp\n\n# main code\ndef reg_score_function(X, y, mean, scale, shape, skewness):\n    m1 = np.sqrt(shape) * sp.gamma((shape - 1.0) / 2.0) / (np.sqrt(np.pi) * sp.gamma(shape / 2.0))\n    mean = mean + (skewness - 1.0 / skewness) * scale * m1\n    if y - mean >= 0:\n        return (shape + 1) / shape * ((y - mean) * X) / (np.power(skewness * scale, 2) + np.power(y - mean, 2) / shape)\n    else:\n        return (shape + 1) / shape * ((y - mean) * X) / (np.power(scale, 2) + np.power(skewness * (y - mean), 2) / shape)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        X = random.uniform(-10.0, 10.0)\n        y = random.uniform(-10.0, 10.0)\n        mean = random.uniform(-5.0, 5.0)\n        scale = random.uniform(0.1, 5.0)\n        shape = random.uniform(1.0, 10.0)\n        skewness = random.uniform(-5.0, 5.0)\n\n        test_cases.append((X, y, mean, scale, shape, skewness))\n\n    return test_cases\n"}
{"problem_id": "numpy_79", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a second-order score based on a given set of parameters. The function will utilize statistical concepts to adjust the mean based on skewness and then compute a score based on the relationship between a given value and the adjusted mean.\n\nFunction signature:\n```python\ndef second_order_score(y, mean, scale, shape, skewness):\n```\n\nConstant used in the main code:\n- The constant used in the main code is derived from the gamma function, specifically:\n  ```python\n  m1 = np.sqrt(shape) * sp.gamma((shape - 1.0) / 2.0) / (np.sqrt(np.pi) * sp.gamma(shape / 2.0))\n  ```\n\n\nInput format:\n- The function takes the following parameters:\n  - `y`: A float representing the value for which the score is to be calculated.\n  - `mean`: A float representing the initial mean of the distribution.\n  - `scale`: A float representing the scale parameter of the distribution.\n  - `shape`: A float representing the shape parameter of the distribution.\n  - `skewness`: A float representing the skewness of the distribution.\n\nOutput format:\n- The function returns a float representing the calculated second-order score based on the input parameters.\n\n```python\nInput: (y=25.3, mean=10.5, scale=2.0, shape=3.0, skewness=1.5)\nOutput: 0.26586533422538394\n```", "ground_truth_code": "import numpy as np\nimport scipy.special as sp\n\n# main code\ndef second_order_score(y, mean, scale, shape, skewness):\n    m1 = np.sqrt(shape) * sp.gamma((shape - 1.0) / 2.0) / (np.sqrt(np.pi) * sp.gamma(shape / 2.0))\n    mean = mean + (skewness - 1.0 / skewness) * scale * m1\n    if y - mean >= 0:\n        return (shape + 1) / shape * (y - mean) / (np.power(skewness * scale, 2) + np.power(y - mean, 2) / shape)\n    else:\n        return (shape + 1) / shape * (y - mean) / (np.power(scale, 2) + np.power(skewness * (y - mean), 2) / shape)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        y = random.uniform(-100, 100)\n        mean = random.uniform(-50, 50)\n        scale = random.uniform(0.1, 10)\n        shape = random.uniform(0.1, 10)\n        skewness = random.uniform(-10, 10)\n        test_cases.append((y, mean, scale, shape, skewness))\n\n    return test_cases"}
{"problem_id": "numpy_80", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs a two-dimensional Fourier transform on a given spectrogram and computes its power and phase spectra. The function should also allow for the option to return the power spectrum in decibels (dB) if specified.\n\nFunction signature:\n```python\ndef mtfft(spectrogram: np.ndarray, df: np.ndarray, dt: np.ndarray, Log: bool) -> tuple:\n```\n\nConstants used in the main code:\n- The constant `10` is used to convert the power spectrum to decibels when the `Log` parameter is set to `True`.\n\n\nInput format:\n- `spectrogram`: A 2D numpy array of shape (N, M) where N is the number of frequency bins and M is the number of time bins.\n- `df`: A 1D numpy array of shape (N,) representing the frequency values.\n- `dt`: A 1D numpy array of shape (M,) representing the time values.\n- `Log`: A boolean value indicating whether to return the power spectrum in decibels.\n\nOutput format:\n- A tuple containing:\n  - A 1D numpy array of spectral frequencies.\n  - A 1D numpy array of temporal frequencies.\n  - A 2D numpy array of the power spectrum.\n  - A 2D numpy array of the phase spectrum.\n\nInput:\n```python\nspectrogram = np.array([[0.1, 0.2, 0.3], \n                         [0.4, 0.5, 0.6], \n                         [0.7, 0.8, 0.9]])\ndf = (0.5, 1.0, 1.5, 2.0)\ndt = (0.01, 0.02)\nLog = True\n```\n\nOutput:\n```python\n(spectral_freq, temporal_freq, mps_pow, mps_phase) = mtfft(spectrogram, df, dt, Log)\n\n# Example output values (actual values will vary based on the FFT computation):\nspectral_freq = np.array([-0.66666667,  0.        ,  0.66666667])\ntemporal_freq = np.array([-33.33333333,   0.        ,  33.33333333])\nmps_pow = np.array([[-317.91080228,    3.85606274, -317.91080228], [  -5.68636236,   13.06425028,   -5.68636236], [-317.91080228,    3.85606274, -317.91080228]])\nmps_phase = np.array([[ 0.85707195, -2.61799388,  0.85707195], [-2.61799388, -0.        ,  2.61799388], [-0.85707195,  2.61799388, -0.85707195]])\n```", "ground_truth_code": "from scipy.fftpack import fft2\nfrom numpy.fft import fftshift\nimport numpy as np\nfrom scipy.fftpack import fftfreq\n\n# main code\ndef mtfft(spectrogram, df, dt, Log):\n    smps = fft2(spectrogram)\n    smps = fftshift(smps)\n    mps_pow = np.abs(smps) ** 2\n    if Log:\n        mps_pow = 10 * np.log10(mps_pow)\n    mps_phase = np.angle(smps)\n    nf = mps_pow.shape[0]\n    nt = mps_pow.shape[1]\n    spectral_freq = fftshift(fftfreq(nf, d=df[1] - df[0]))\n    temporal_freq = fftshift(fftfreq(nt, d=dt[1] - dt[0]))\n    return (spectral_freq, temporal_freq, mps_pow, mps_phase)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for i in range(n):\n        m = np.random.randint(2, 300)\n        n = np.random.randint(2, 300)\n        spectrogram = np.random.rand(m, n)\n\n        df = (np.random.uniform(0.1, 10),\n              np.random.uniform(0.1, 10),\n              np.random.uniform(0.1, 10),\n              np.random.uniform(0.1, 10))\n\n        dt = (np.random.uniform(0.001, 0.1),\n              np.random.uniform(0.001, 0.1))\n\n        Log = np.random.choice([True, False])\n\n        test_cases.append((spectrogram, df, dt, Log))\n\n    return test_cases"}
{"problem_id": "numpy_81", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes statistical metrics from a given spectral frequency and a corresponding spectral representation. The function will normalize the spectral data, calculate the mean frequency, and determine specific quantile frequencies based on cumulative sums of the normalized data.\n\nFunction signature:\n```python\ndef spec_stats(spec_freq: np.ndarray, spec: np.ndarray) -> dict:\n```\n\nConstant used in the main code:\n- `qvals`: A list containing the quantile values `[0.25, 0.5, 0.75]`.\n\n\nInput format:\n- `spec_freq`: A 1D numpy array of shape (nfreq,) representing the frequencies.\n- `spec`: A 2D numpy array of shape (nfreq, nt) representing the spectral data.\n\nOutput format:\n- A dictionary containing:\n  - `'Q'`: A 2D numpy array of shape (len(qvals), nt) with the quantile frequencies.\n  - `'qvals'`: A list of quantile values.\n  - `'freq_mean'`: A 1D numpy array representing the mean frequency for each time point.\n\nInput:\n```python\nspec_freq = np.array([10.0, 20.0, 30.0, 40.0, 50.0])\nspec = np.array([[1.0, 2.0, 3.0],\n                 [4.0, 5.0, 6.0],\n                 [7.0, 8.0, 9.0],\n                 [10.0, 11.0, 12.0],\n                 [13.0, 14.0, 15.0]])\n```\n\nOutput:\n```python\n{\n  'Q': array([[20., 20., 20.],\n       [30., 30., 30.],\n       [40., 40., 40.]]), \n  'qvals': [0.25, 0.5, 0.75], \n  'freq_mean': array([40.        , 38.57142857, 37.5       ])\n}\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef spec_stats(spec_freq, spec):\n    nfreq, nt = spec.shape\n    spec_p = spec - spec.min()\n    spec_p_sum = spec_p.sum(axis=0)\n\n    spec_p = np.divide(spec_p, spec_p_sum, where=spec_p_sum != 0)\n\n    freq_mean = np.dot(spec_p.T, spec_freq)\n    spec_p_csum = np.cumsum(spec_p, axis=0)\n\n    qvals = [0.25, 0.5, 0.75]\n    Q = np.zeros([len(qvals), nt])\n\n    for t in range(nt):\n        for k, q in enumerate(qvals):\n            i = spec_p_csum[:, t] <= q\n            if np.any(i):\n                fi = np.max(np.where(i)[0])\n                Q[k, t] = spec_freq[fi]\n\n    stats = {\n        'Q': Q,\n        'qvals': qvals,\n        'freq_mean': freq_mean\n    }\n\n    return stats", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nfreq = np.random.randint(10, 1000)\n        nt = np.random.randint(5, 500)\n        spec_freq = np.sort(np.random.rand(nfreq)) * 100\n        spec = np.random.rand(nfreq, nt) * 100\n\n        test_cases.append((spec_freq, spec))\n\n    return test_cases"}
{"problem_id": "numpy_82", "library": "numpy", "code_problem": "You are tasked with creating a function that generates a NumPy array based on specific input parameters. The function should be able to create an array filled with zeros, an array filled with ones, or convert an existing list into a NumPy array. \n\nThe function signature is as follows:\n```python\ndef create_array(arr, dtype, zeros_shape, ones_shape):\n```\n\n### Constants:\n- The function uses the NumPy library, which must be imported as `np`.\n\n### Input Format:\n- The function accepts four parameters:\n  - `arr`: A list or `None`.\n  - `dtype`: A data type (e.g., `int`, `float`).\n  - `zeros_shape`: A tuple or `None`.\n  - `ones_shape`: A tuple or `None`.\n\n### Output Format:\n- The function returns a NumPy array based on the provided parameters. The array can be filled with zeros, filled with ones, or converted from the input list, depending on the input conditions.\n\nInput: (None, np.float32, (3, 3), None)  \nOutput: array([[0., 0., 0.],  \n               [0., 0., 0.],  \n               [0., 0., 0.]], dtype=float32)", "ground_truth_code": "import numpy as np\n\n# main code\ndef create_array(arr, dtype, zeros_shape, ones_shape):\n    if zeros_shape is not None:\n        return np.zeros(zeros_shape, dtype=dtype)\n    if ones_shape is not None:\n        return np.ones(ones_shape, dtype=dtype)\n\n    arr = arr if arr is not None else []\n    return np.array(arr, dtype=dtype)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    dtypes = [np.int32, np.float32, np.float64, np.uint8, np.int16, np.bool_]\n\n    for _ in range(n):\n        arr = random.choice([None, list(np.random.randint(0, 100, size=random.randint(1, 10))), []])\n        dtype = random.choice(dtypes)\n\n        shape_choice = random.choice(['zeros', 'ones', 'none'])\n\n        zeros_shape = (random.randint(1, 5), random.randint(1, 5)) if shape_choice == 'zeros' else None\n        ones_shape = (random.randint(1, 5), random.randint(1, 5)) if shape_choice == 'ones' else None\n        test_case = (arr, dtype, zeros_shape, ones_shape)\n        test_cases.append(test_case)\n\n    return test_cases\n"}
{"problem_id": "numpy_83", "library": "numpy", "code_problem": "```python\ndef xcorr_axis(x: np.ndarray, y: np.ndarray, axis: int) -> np.ndarray:\n```\n\nIn this code, the function `xcorr_axis` computes the cross-correlation of two multi-dimensional arrays `x` and `y` along a specified axis. The function uses the Fast Fourier Transform (FFT) to efficiently calculate the cross-correlation.\n\n\n### Input and Output Format:\n- **Input**:\n  - `x`: A multi-dimensional NumPy array.\n  - `y`: A multi-dimensional NumPy array of the same shape as `x`.\n  - `axis`: An integer specifying the axis along which to compute the cross-correlation.\n\n- **Output**:\n  - A NumPy array containing the cross-correlation of `x` and `y` along the specified axis.\n\nInput:\n```python\nx = np.array([[1, 2, 3, 4, 5],\n              [6, 7, 8, 9, 10]])\ny = np.array([[10, 9, 8, 7, 6],\n              [5, 4, 3, 2, 1]])\naxis = 0\n```\n\nOutput:\n```python\narray([[0, 0, 0, 0, 0],\n       [0, 0, 0, 0, 0]])\n```", "ground_truth_code": "import numpy as np\nfrom numpy.fft import irfft, rfft\n\n# main code\ndef xcorr_axis(x, y, axis):\n    if axis >= x.ndim or axis >= y.ndim:\n        return np.array([])\n\n    if x.shape[axis] < 4:\n        return np.zeros_like(x)\n\n    y_rev = np.flip(y, axis=axis)\n    c = irfft(rfft(x, axis=axis) * rfft(y_rev, axis=axis), axis=axis)\n    split_index = c.shape[axis] // 2 - 1\n    c_first = c.take(indices=range(0, split_index), axis=axis)\n    c_last = c.take(indices=range(split_index, c.shape[axis]), axis=axis)\n\n    return np.concatenate([c_last, c_first], axis=axis)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dims = np.random.randint(1, 6)\n        shape = tuple(np.random.randint(4, 10) for _ in range(dims))\n        axis = np.random.randint(0, dims)\n        x = np.random.randn(*shape)\n        y = np.random.randn(*shape)\n\n        test_cases.append((x, y, axis))\n\n    return test_cases"}
{"problem_id": "numpy_84", "library": "numpy", "code_problem": "You are tasked with implementing a function that aligns multiple time series data based on synchronization signals. The function should take in a list of time series and a corresponding list of synchronization signals, and it should return the aligned time series.\n\nFunction Signature:\n```python\ndef align_timeseries_interpol(timeseries, sync_signals):\n```\n\nConstant Used:\n- The function does not use any explicit constants, but it relies on the first synchronization signal as a reference for alignment.\n\nInput Format:\n- The function takes two parameters:\n  - `timeseries`: A list of numpy arrays, where each array represents a time series.\n  - `sync_signals`: A list of numpy arrays, where each array represents the synchronization signals corresponding to the time series.\n\nOutput Format:\n- The function returns a list of numpy arrays, where each array represents the aligned time series. If the input conditions are not met, it returns an empty list.\n\nInput:\n```python\ntimeseries = [\n    np.array([1, 2, 3, 4, 5], dtype=np.int32),\n    np.array([10, 20, 30, 40, 50], dtype=np.float64)\n]\nsync_signals = [\n    np.array([1, 2, 3, 4, 5], dtype=np.int32),\n    np.array([10, 20, 30, 40, 50], dtype=np.float32)\n]\n```\n\nOutput:\n```python\n[\n  array([1, 2, 3, 4, 5]), \n  array([1, 2, 3, 4, 5])\n]\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef align_timeseries_interpol(timeseries, sync_signals):\n\n    if len(timeseries) < 2 or len(sync_signals) != len(timeseries):\n        return []\n\n    for tsi, ts in enumerate(timeseries):\n        timeseries[tsi] = ts.astype(np.int64) if ts.dtype != np.int64 else ts\n\n    for tsi, ts in enumerate(sync_signals):\n        sync_signals[tsi] = ts.astype(np.int64) if ts.dtype != np.int64 else ts\n\n    ref_sync = sync_signals[0]\n\n    for i, (ts, ss) in enumerate(zip(timeseries[1:], sync_signals[1:])):\n        a, b = np.polyfit(ss, ref_sync, 1)\n        timeseries[i + 1] = np.round(a * ts + b, 0).astype(np.int64)\n\n    return timeseries", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_series = random.randint(2, 10)\n        series_length = random.randint(3, 100)\n        timeseries = [np.sort(np.random.randint(0, 1000, series_length)) for _ in range(num_series)]\n        sync_signals = [np.sort(np.random.randint(0, 1000, series_length)) for _ in range(num_series)]\n        if random.random() > 0.5:\n            random_series = random.choice(timeseries)\n            random_series[random.randint(0, series_length - 1)] = np.float64(random_series[0])\n\n        if random.random() > 0.5:\n            random_signal = random.choice(sync_signals)\n            random_signal[random.randint(0, series_length - 1)] = np.float32(random_signal[0])\n\n        test_cases.append((timeseries, sync_signals))\n\n    return test_cases"}
{"problem_id": "numpy_85", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs a local weighted partial least squares (LWPLS) regression. The function will take in a new input data point and use it, along with existing datasets, to predict an output value based on a weighted regression approach.\n\nFunction Signature:\n```python\ndef lwpls(xnew, loc_par, mvmobj, X, Y):\n```\n\n### Constants:\n- `loc_par`: A parameter that controls the locality of the weighting in the regression.\n\n\n### Input Format:\n- `xnew`: A 1D array-like structure representing the new input data point.\n- `loc_par`: A float representing the locality parameter for weighting.\n- `mvmobj`: A dictionary containing model parameters, including weights and explained variance.\n- `X`: A 2D array-like structure (or DataFrame) representing the input dataset.\n- `Y`: A 2D array-like structure (or DataFrame) representing the output dataset.\n\n### Output Format:\n- The function returns a 1D array representing the predicted output value corresponding to the input `xnew`. If no prediction can be made, it returns a zero array of the same shape as `xnew`.\n\n**Input:**\n```python\nxnew = np.array([[0.5], [0.3]])\nloc_par = 2.5\nmvmobj = {\n    'Ws': np.array([[0.1, 0.2]]),\n    'r2y': np.array([0.7]),\n    'T': np.array([[0.1, 0.2, 0.6]])\n}\nX = pd.DataFrame(np.array([[1, 0.1, 0.2], [1, 0.3, 0.4], [1, 0.5, 0.6]]))\nY = pd.DataFrame(np.array([[1, 0.2, 0.3], [1, 0.4, 0.5], [1, 0.6, 0.7]]))\n```\n\n**Output:**\n```python\narray([[0.3]])\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef lwpls(xnew, loc_par, mvmobj, X, Y):\n\n    xnew = np.reshape(xnew, (-1, 1))\n\n    X = np.array(X.values[:, 1:]).astype(float) if isinstance(X, pd.DataFrame) else np.array(X)\n    Y = np.array(Y.values[:, 1:]).astype(float) if isinstance(Y, pd.DataFrame) else np.array(Y)\n\n    vip = np.sum(np.abs(mvmobj['Ws'] * np.tile(mvmobj['r2y'], (mvmobj['Ws'].shape[0], 1))), axis=1)\n    theta = np.reshape(vip, (len(vip), -1))\n\n    D = X - np.tile(xnew.T, (X.shape[0], 1))\n    d2 = D * np.tile(theta.T, (X.shape[0], 1)) * D\n    d2 = np.sqrt(np.sum(d2, axis=1))\n\n    variance_d2 = np.var(d2, ddof=1) if np.var(d2, ddof=1) != 0 else 1.0\n    omega = np.exp(-d2 / (variance_d2 * loc_par))\n    OMEGA = np.diag(omega)\n\n    omega = np.reshape(omega, (len(omega), -1))\n\n    X_weighted_mean = np.sum(np.tile(omega, (1, X.shape[1])) * X, axis=0) / np.sum(omega)\n    Y_weighted_mean = np.sum(np.tile(omega, (1, Y.shape[1])) * Y, axis=0) / np.sum(omega)\n\n    X_weighted_mean = np.reshape(X_weighted_mean, (len(X_weighted_mean), -1))\n    Y_weighted_mean = np.reshape(Y_weighted_mean, (len(Y_weighted_mean), -1))\n\n    Xi = X - X_weighted_mean.T\n    Yi = Y - Y_weighted_mean.T\n    xnewi = xnew - X_weighted_mean\n\n    yhat = Y_weighted_mean\n\n    for a in range(mvmobj['T'].shape[1]):\n        U_, S, Wh = np.linalg.svd(Xi.T @ OMEGA @ Yi @ Yi.T @ OMEGA @ Xi)\n        w = Wh.T[:, [0]]\n        t = Xi @ w\n        p = Xi.T @ OMEGA @ t / (t.T @ OMEGA @ t)\n        q = Yi.T @ OMEGA @ t / (t.T @ OMEGA @ t)\n\n        tnew = xnewi.T @ w\n        yhat = yhat + q @ tnew\n\n        Xi = Xi - t @ p.T\n        Yi = Yi - t @ q.T\n        xnewi = xnewi - p @ tnew\n\n    return yhat[0].T if yhat.size > 0 else np.zeros_like(xnew)", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_features = np.random.randint(2, 20)\n        num_components = np.random.randint(1, num_features)\n\n        xnew = np.random.rand(num_features, 1)\n\n        loc_par = np.random.uniform(0.1, 10.0)\n\n        mvmobj = {\n            'Ws': np.random.rand(num_features, num_components),\n            'r2y': np.random.rand(num_components),\n            'T': np.random.rand(num_samples, num_components)\n        }\n\n        X = pd.DataFrame(np.random.rand(num_samples, num_features + 1))\n        Y = pd.DataFrame(np.random.rand(num_samples, num_features + 1))\n\n        test_cases.append((xnew, loc_par, mvmobj, X, Y))\n\n    return test_cases"}
{"problem_id": "numpy_86", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs interpolation based on two-dimensional and one-dimensional data tables. The function will take in two indices and three data tables, and it will return a specific interpolated value based on the conditions of the indices.\n\nFunction signature:\n```python\ndef f95(i: int, j: int, tab1: np.ndarray, tab2: np.ndarray, tab3: np.ndarray) -> float:\n```\n\nConstant used in the main code:\n- The constant value `120` is used as a threshold to determine which interpolation method to apply based on the input indices `i` and `j`.\n\n\nInput format:\n- The function takes in two integers `i` and `j`, and three numpy arrays `tab1`, `tab2`, and `tab3`.\n\nOutput format:\n- The function returns a float value which is the result of the interpolation or a default value based on the conditions described.\n\nInput:\n```python\ni = 130\nj = 75\ntab1 = np.array([[0, 10, 20, 30, 40],\n                 [0, 0.1, 0.2, 0.3, 0.4],\n                 [0, 0.5, 0.6, 0.7, 0.8],\n                 [0, 0.9, 1.0, 1.1, 1.2],\n                 [0, 1.3, 1.4, 1.5, 1.6]])\ntab2 = np.array([[0, 10],\n                 [50, 20],\n                 [100, 30]])\ntab3 = np.array([[0, 5],\n                 [50, 15],\n                 [100, 25]])\n```\n\nOutput:\n```python\nf95_ = 20.0\n```", "ground_truth_code": "import numpy as np\nfrom scipy import interpolate\n\n# main code\ndef f95(i, j, tab1, tab2, tab3):\n    if i <= 120 and j <= 120:\n        Y = tab1[1:, 0]\n        X = tab1[0, 1:]\n        Z = tab1[1:, 1:]\n        f = interpolate.RectBivariateSpline(Y, X, Z, kx=3, ky=3)\n        f95_ = f(j, i)[0]\n    elif i > 120 and j <= 120:\n        f95_ = np.interp(j, tab3[:, 0], tab3[:, 1])\n    elif i <= 120 and j > 120:\n        f95_ = np.interp(i, tab2[:, 0], tab2[:, 1])\n    else:\n        f95_ = 1\n\n    return f95_\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        i = np.random.randint(0, 200)\n        j = np.random.randint(0, 200)\n        x_len = np.random.randint(5, 20)\n        y_len = np.random.randint(5, 20)\n        X = np.linspace(0, 150, x_len)\n        Y = np.linspace(0, 150, y_len)\n        Z = np.random.random((y_len, x_len))\n        tab1 = np.vstack([np.hstack([[0], X]), np.column_stack([Y, Z])])\n        size = np.random.randint(10, 30)\n        tab2 = np.column_stack([\n            np.linspace(0, 150, size),\n            np.random.random(size) * 100\n        ])\n        size = np.random.randint(10, 30)\n        tab3 = np.column_stack([\n            np.linspace(0, 150, size),\n            np.random.random(size) * 100\n        ])\n        test_cases.append((i, j, tab1, tab2, tab3))\n\n    return test_cases"}
{"problem_id": "numpy_87", "library": "numpy", "code_problem": "You are tasked with creating a function that generates outlines for a head shape based on a spherical model. The function will compute the coordinates for the head, nose, and ears, and also provide a mask position and clipping radius for rendering purposes.\n\nFunction signature:\n```python\ndef make_head_outlines(sphere, pos, outlines, clip_origin, points, nose_angle, ear_scale, ear_x_values, ear_y_values, nose_y_scale):\n```\n\n### Constants Used:\n- The constant used in the main code is `1.0`, which is used to ensure that the mask scale is at least 1.0.\n\n\n### Input Format:\n- `sphere`: A NumPy array containing four elements: `[x, y, z, radius]`.\n- `pos`: A NumPy array of shape (n, 3) representing positions.\n- `outlines`: Either a string ('head' or None) or a dictionary to store outlines.\n- `clip_origin`: A tuple representing the origin for clipping.\n- `points`: An integer specifying the number of points to generate for the head outline.\n- `nose_angle`: A float representing the angle of the nose in degrees.\n- `ear_scale`: A float to scale the ear size.\n- `ear_x_values`: A NumPy array of x-coordinates for the ears.\n- `ear_y_values`: A NumPy array of y-coordinates for the ears.\n- `nose_y_scale`: A float to scale the y-coordinate of the nose.\n\n### Output Format:\n- The function returns a dictionary containing the outlines for the head, nose, and ears, as well as the mask position and clipping radius. If the input is invalid, it returns an empty dictionary.\n\n**Input:**\n```python\n(\n    np.array([10.0, 20.0, 0.0, 15.0]),  # sphere\n    np.array([[5.0, 5.0], [10.0, 10.0]]),  # pos\n    'head',  # outlines\n    np.array([-5.0, -5.0]),  # clip_origin\n    100,  # points\n    30.0,  # nose_angle\n    1.5,  # ear_scale\n    np.array([1.0, 2.0, 3.0]),  # ear_x_values\n    np.array([0.5, 1.0, 1.5]),  # ear_y_values\n    1.0  # nose_y_scale\n)\n```\n\n**Output:**\n```python\n{\n    'head': (array([25., 24.96980015, 24.87932219, ..., 25.0]), array([20., 20.95135879, 21.8988868, ..., 20.0])),\n    'nose': (array([ 2.14601837, 10.        , 17.85398163]), array([32.77947466, 35.        , 32.77947466])), \n    'ear_left': (array([-12.5, -35. , -57.5]), array([31.25, 42.5 , 53.75])), \n    'ear_right': (array([32.5, 55. , 77.5]), array([31.25, 42.5 , 53.75])),\n    'mask_pos': (array([...]), array([...])),  # scaled head coordinates\n    'clip_radius': (15.0, 15.0), \n    'clip_origin': array([-5., -5.])\n}\n```\n", "ground_truth_code": "import numpy as np\n\n# main code\ndef make_head_outlines(sphere, pos, outlines, clip_origin, points, nose_angle, ear_scale, ear_x_values, ear_y_values, nose_y_scale):\n    if not isinstance(sphere, np.ndarray):\n        return {}\n    (x, y, _, radius) = sphere\n    del sphere\n\n    if outlines in ('head', None):\n        ll = np.linspace(0, 2 * np.pi, points)\n        head_x = np.cos(ll) * radius + x\n        head_y = np.sin(ll) * radius + y\n\n        dx = np.exp(np.arccos(np.deg2rad(nose_angle)) * 1j)\n        (dx, dy) = (dx.real, dx.imag)\n\n        nose_x = np.array([-dx, 0, dx]) * radius + x\n        nose_y = np.array([dy, nose_y_scale, dy]) * radius + y\n\n        ear_x = ear_x_values * (radius * ear_scale)\n        ear_y = ear_y_values * (radius * ear_scale) + y\n\n        outlines_dict = {\n            'head': (head_x, head_y),\n            'nose': (nose_x, nose_y),\n            'ear_left': (-ear_x + x, ear_y),\n            'ear_right': (ear_x + x, ear_y)\n        } if outlines is not None else {}\n\n        mask_scale = max(1.0, np.linalg.norm(pos, axis=1).max() * 1.01 / radius)\n        outlines_dict['mask_pos'] = (mask_scale * head_x, mask_scale * head_y)\n        clip_radius = radius * mask_scale\n        outlines_dict['clip_radius'] = (clip_radius,) * 2\n        outlines_dict['clip_origin'] = clip_origin\n        outlines = outlines_dict\n\n    elif isinstance(outlines, dict):\n        outlines.setdefault('mask_pos', (np.array([]), np.array([])))\n\n    else:\n        return {}\n\n    return outlines", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        sphere = np.array([\n            np.random.uniform(-100, 100),\n            np.random.uniform(-100, 100),\n            np.random.uniform(-100, 100),\n            np.random.uniform(1, 50)\n        ])\n\n        pos = np.random.rand(random.randint(1, 100), 2) * 200 - 100\n        outlines = random.choice(['head', 'nose', 'ear_left', 'ear_right', None, {}])\n        clip_origin = np.random.rand(2) * 200 - 100\n        points = random.randint(3, 1000)\n        nose_angle = np.random.uniform(0, 180)\n        ear_scale = np.random.uniform(0.1, 3)\n\n        ear_x_values = np.random.rand(random.randint(3, 50))\n        ear_y_values = np.random.rand(len(ear_x_values))\n\n        nose_y_scale = np.random.uniform(0.1, 2)\n\n        test_cases.append((sphere, pos, outlines, clip_origin, points, nose_angle,\n                           ear_scale, ear_x_values, ear_y_values, nose_y_scale))\n\n    return test_cases"}
{"problem_id": "numpy_88", "library": "numpy", "code_problem": "You are tasked with implementing a function that processes feature data related to a set of residues in a molecular dataset. The function should extract and organize time series data for multiple variables based on the specified feature type. \n\nThe function signature is as follows:\n\n```python\ndef get_multivar_res_timeseries(feat, data, feature_type):\n```\n\n### Constants Used:\n- There are no specific constants defined in the main code.\n\n### Input Format:\n- The function accepts three parameters: a dictionary `feat`, a dictionary `data`, and a string `feature_type`.\n\n### Output Format:\n- The function returns a tuple containing two dictionaries: `feature_names` and `features_data`, both indexed by the `feature_type`.\n\n**Input:**\n```python\nfeat = {\n    \"type1\": [\"feature_1 residue 1\", \"feature_2 residue 1\", \"feature_3 residue 2\"],\n    \"type2\": []\n}\ndata = {\n    \"type1\": np.array([[0.1, 0.2, 0.3],\n                       [0.4, 0.5, 0.6],\n                       [0.7, 0.8, 0.9]]),\n    \"type2\": np.array([])\n}\nfeature_type = \"type1\"\n```\n\n**Output:**\n```python\nfeature_names, features_data = get_multivar_res_timeseries(feat, data, feature_type)\n\n# Expected Output\nfeature_names = {\n    \"type1\": [\"residue 1\", \"residue 2\"]\n}\nfeatures_data = {\n    \"type1\": [\n        [[0.1, 0.4, 0.7],  # feature_1 residue 1\n         [0.2, 0.5, 0.8]], # feature_2 residue 1\n        [[0.3, 0.6, 0.9]]  # feature_3 residue 2\n    ]\n}\n```\n\n### Explanation:\n- The input consists of a feature dictionary `feat` with two features associated with \"residue 1\" and one feature associated with \"residue 2\".\n- The `data` dictionary contains time series data for \"type1\".\n- The output consists of `feature_names` which lists the unique residues and `features_data` which contains the corresponding time series data for each feature grouped by residue.", "ground_truth_code": "import numpy as np\n\n\ndef get_feature_data(feat, data, feature_name):\n    index = np.where(np.array(feat) == feature_name)[0][0]\n    return data[:, index] if index is not None else np.array([])\n\ndef get_feature_timeseries(feat, data, feature_type, feature_name):\n    return get_feature_data(feat.get(feature_type, []), data.get(feature_type, np.array([])), feature_name)\n\n# main code\ndef get_multivar_res_timeseries(feat, data, feature_type):\n    feature_names = {}\n    features_data = {}\n\n    feat_name_list = feat.get(feature_type, [])\n    if not feat_name_list:\n        return feature_names, features_data\n\n    res_numbers = [int(feat_name.split()[-1]) for feat_name in feat_name_list]\n    index_same_res = [\n        list(np.where(np.array(res_numbers) == seq_num)[0])\n        for seq_num in set(res_numbers)\n    ]\n\n    multivar_res_timeseries_data = []\n    sorted_names = []\n\n    for residue_indices in index_same_res:\n        feat_timeseries = [\n            list(get_feature_timeseries(feat, data, feature_type, feat_name_list[idx]))\n            for idx in residue_indices\n        ]\n\n        multivar_res_timeseries_data.append(feat_timeseries)\n        feat_name_split = feat_name_list[residue_indices[0]].split()\n        resname = feat_name_split[-2] + ' ' + feat_name_split[-1]\n        sorted_names.append(resname)\n\n\n    feature_names[feature_type] = sorted_names\n    features_data[feature_type] = multivar_res_timeseries_data\n\n    return feature_names, features_data", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_features = random.randint(1, 10)\n        num_residues = random.randint(1, 5)\n        time_steps = random.randint(5, 20)\n        feature_names = [\n            f\"feature_{random.randint(0, 10)} residue {random.randint(1, num_residues)}\"\n            for _ in range(num_features)\n        ]\n        data = {\n            \"type1\": np.random.rand(time_steps, num_features),\n            \"type2\": np.random.rand(time_steps, num_features),\n        }\n        feature_type = random.choice([\"type1\", \"type2\"])\n        feat = {\n            \"type1\": feature_names if feature_type == \"type1\" else [],\n            \"type2\": feature_names if feature_type == \"type2\" else [],\n        }\n\n        test_cases.append((feat, data, feature_type))\n\n    return test_cases"}
{"problem_id": "numpy_89", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes a specific mathematical construct known as the \"psi\" matrix, which is derived from a given set of matrices called \"phi\". The function will utilize linear algebra operations to achieve this.\n\nFunction signature:\n```python\ndef get_psi(phi, N, tau_max):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0`, which is used to initialize the first element of the `psi` array.\n\n\nInput format:\n- The function takes three inputs:\n  1. `phi`: A list or array of matrices of shape `(tau_max + 1, N, N)`.\n  2. `N`: An integer representing the dimension of the square matrices.\n  3. `tau_max`: An integer representing the maximum time step.\n\nOutput format:\n- The function returns a numpy array `psi` of shape `(tau_max + 1, N, N)`, containing the computed psi matrices for each time step.\n\nInput:\n```python\nphi = [\n    [[0.6, 0.7], [0.5, 0.6]],  # phi[0]\n    [[0.5, 0.6], [0.4, 0.5]],  # phi[1]\n    [[0.5, 0.5], [0.4, 0.6]]   # phi[2]\n]\nN = 2\ntau_max = 2\n```\n\nOutput:\n```python\narray([[[ -2.10526316,  -3.68421053],\n        [ -2.63157895,  -2.10526316]],\n       [[ 13.49030471,  15.84487535],\n        [ 11.46814404,  13.49030471]],\n       [[-55.78655781, -65.74281965],\n        [-47.96034407, -56.3128736 ]]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_psi(phi, N, tau_max):\n    psi = np.zeros((tau_max + 1, N, N))\n    psi[0] = np.linalg.pinv(np.identity(N) - phi[0])\n    for tau in range(1, tau_max + 1):\n        for s in range(1, tau + 1):\n            psi[tau] += np.matmul(psi[0], np.matmul(phi[s], psi[tau - s]))\n    return psi", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        N = random.randint(1, 50)\n        tau_max = random.randint(0, 10)\n        phi = np.random.rand(N, N) * 0.4 + 0.5\n        for i in range(N):\n            phi[i, i] += 0.1\n        phi_lags = [phi] + [np.random.rand(N, N) * 0.4 + 0.5 for _ in range(tau_max)]\n        for i in range(1, len(phi_lags)):\n            for j in range(N):\n                phi_lags[i][j, j] += 0.1\n        test_cases.append((phi_lags, N, tau_max))\n\n    return test_cases"}
{"problem_id": "numpy_90", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes a specific mathematical transformation based on input matrices. The function signature is as follows:\n\n```python\ndef get_psi_k(phi, k, N, tau_max):\n```\n\n### Constants:\n- The constant used in the main code is `tau_max`, which determines the maximum time step for the computation.\n\n\n### Input and Output Format:\n- **Input**: The function takes four parameters:\n  - `phi`: A 3D numpy array of shape `(T, N, N)`, where `T` is the number of time steps, and `N` is the dimension of the matrices.\n  - `k`: An integer or a list of integers representing the indices of columns in `phi` to be zeroed out.\n  - `N`: An integer representing the size of the square matrices.\n  - `tau_max`: An integer representing the maximum time step for the computation.\n\n- **Output**: The function returns a 3D numpy array `psi_k` of shape `(tau_max + 1, N, N)`, containing the computed transformation results for each time step.\n\nInput:\n```python\nphi = np.array([[[ 0.5, -0.2], [ 0.1,  0.3]], \n                 [[ 0.4,  0.0], [-0.1,  0.2]], \n                 [[ 0.3,  0.1], [ 0.0, -0.4]]])\nk = 1\nN = 2\ntau_max = 2\n```\n\nOutput:\n```python\narray([[[ 2.00000000e+00, -4.00000000e-01],\n        [ 2.77555756e-17,  1.00000000e+00]],\n       [[ 1.60000000e+00, -3.20000000e-01],\n        [ 2.22044605e-17, -4.44089210e-18]],\n       [[ 2.48000000e+00, -2.96000000e-01],\n        [ 3.44169138e-17, -4.10782519e-18]]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_psi_k(phi, k, N, tau_max):\n    psi_k = np.zeros((tau_max + 1, N, N))\n    phi_k = np.copy(phi)\n    if isinstance(k, int):\n        phi_k[:, k, :] = 0.0\n    else:\n        for k_here in k:\n            phi_k[:, k_here, :] = 0.0\n    psi_k[0] = np.linalg.pinv(np.identity(N) - phi_k[0])\n    for tau in range(1, tau_max + 1):\n        for s in range(1, tau + 1):\n            psi_k[tau] += np.matmul(psi_k[0], np.matmul(phi_k[s], psi_k[tau - s]))\n    return psi_k", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        N = random.randint(2, 10)\n        tau_max = random.randint(1, 20)\n        phi = np.random.randn(tau_max + 1, N, N)\n        if random.random() < 0.5:\n            k = random.randint(0, N - 1)\n        else:\n            k = random.sample(range(N), random.randint(1, N))\n        test_cases.append((phi, k, N, tau_max))\n\n    return test_cases"}
{"problem_id": "numpy_91", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a Latin Hypercube Sampling (LHS) for a given number of variables. The function will create samples for upper and lower bounds based on specified parameters. The function signature is as follows:\n\n```python\ndef lhs(n, au, al, te, bounds):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is implicitly used in the `np.full` function to create a column vector filled with the value of `te`.\n\n### Input Format:\n- The function takes the following inputs:\n  - An integer `n` (number of samples).\n  - A list or array `au` of upper bounds.\n  - A list or array `al` of lower bounds.\n  - A float or integer `te` (constant value).\n  - A list or array `bounds` containing two float or integer values.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A 2D array of shape `(n, len(au))` representing the generated upper samples.\n  - A 2D array of shape `(n, len(al))` representing the generated lower samples.\n  - A 2D array of shape `(n, 1)` filled with the value of `te`.\n\nInput:\n```python\nn = 5\nau = np.array([2.5, 3.0, 1.2])\nal = np.array([0.1, 0.2, 0.05])\nte = 4.5\nbounds = (-0.5, 1.0)\n```\n\nOutput:\n```python\nresult_au = np.array([[1.66  , 2.02  , 0.7975],\n                      [2.38  , 2.86  , 1.1425],\n                      [3.1   , 3.7   , 1.4875],\n                      [3.82  , 4.54  , 1.8325],\n                      [4.54  , 5.38  , 2.1775]])\n\nresult_al = np.array([[-0.74  , -0.78  , -0.3525],\n                      [-0.02  ,  0.06  , -0.0075],\n                      [ 0.7   ,  0.9   ,  0.3375],\n                      [ 1.42  ,  1.74  ,  0.6825],\n                      [ 2.14  ,  2.58  ,  1.0275]])\n\nresult_te = np.array([[4.5], [4.5], [4.5], [4.5], [4.5]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef lhs(n, au, al, te, bounds):\n    nvars = len(au)\n    result_au = np.zeros((n, nvars))\n    result_al = np.zeros((n, nvars))\n    result_te = np.full((n, 1), te)\n\n    def generate_partitions(start, end, size):\n        step = (end - start) / size\n        return np.linspace(start, end, size + 1)[:-1] + step / 2\n\n    for i in range(nvars):\n        au_start = au[i] + bounds[0] * (au[i] - al[i])\n        au_end = au[i] + bounds[1] * (au[i] - al[i])\n        result_au[:, i] = generate_partitions(au_start, au_end, n)\n\n        al_start = al[i] + bounds[0] * (au[i] - al[i])\n        al_end = al[i] + bounds[1] * (au[i] - al[i])\n        result_al[:, i] = generate_partitions(al_start, al_end, n)\n\n    return result_au, result_al, result_te", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nvars = np.random.randint(1, 11)\n        au = np.random.uniform(0.5, 5.0, size=nvars)\n        al = np.random.uniform(0.0, 0.49, size=nvars)\n        te = np.random.uniform(-10, 10)\n        lower_bound = np.random.uniform(-1.0, 0.0)\n        upper_bound = np.random.uniform(0.1, 2.0)\n        bounds = (lower_bound, upper_bound)\n\n        test_cases.append((n, au, al, te, bounds))\n\n    return test_cases"}
{"problem_id": "numpy_92", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs various augmentations on a given 2D image represented as a NumPy array. The function should be able to apply different transformations based on a specified mode. The transformations include flipping the image upside down and rotating it in 90-degree increments.\n\nFunction signature:\n```python\ndef augment_img(img: np.ndarray, mode: int) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant `k` is used in the `np.rot90` function to specify the number of 90-degree rotations to apply.\n\n\nInput format:\n- The input consists of a 2D NumPy array `img` representing the image and an integer `mode` indicating the desired transformation.\n\nOutput format:\n- The output is a 2D NumPy array representing the augmented image after applying the specified transformation based on the `mode`.\n\nInput:\n```python\nimg = np.array([[1, 2, 3], \n                 [4, 5, 6], \n                 [7, 8, 9]], dtype=np.uint8)\nmode = 1\n```\n\nOutput:\n```python\narray([[1, 4, 7],\n       [2, 5, 8],\n       [3, 6, 9]], dtype=uint8)\n```", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef augment_img(img, mode):\n    if img.size == 0 or img.ndim != 2:\n        return img\n\n    if mode == 0:\n        return img\n    elif mode == 1:\n        return np.flipud(np.rot90(img))\n    elif mode == 2:\n        return np.flipud(img)\n    elif mode == 3:\n        return np.rot90(img, k=3)\n    elif mode == 4:\n        return np.flipud(np.rot90(img, k=2))\n    elif mode == 5:\n        return np.rot90(img)\n    elif mode == 6:\n        return np.rot90(img, k=2)\n    elif mode == 7:\n        return np.flipud(np.rot90(img, k=3))\n\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        mode = np.random.randint(0, 8)\n        height = np.random.randint(0, 101)\n        width = np.random.randint(0, 101)\n        if height == 0 or width == 0:\n            img = np.array([])\n        else:\n            img = np.random.randint(0, 256, (height, width), dtype=np.uint8)\n        test_cases.append((img, mode))\n    return test_cases"}
{"problem_id": "numpy_93", "library": "numpy", "code_problem": "You are tasked with implementing a function that applies a box filter to a given image. The box filter is a simple averaging filter that smooths the image by averaging the pixel values in a square neighborhood around each pixel. The function should be able to handle multi-dimensional images (e.g., grayscale and color images).\n\nFunction signature:\n```python\ndef box(img: np.ndarray, r: int) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant `r` represents the radius of the box filter, which defines the size of the neighborhood around each pixel that will be averaged.\n\n\nInput format:\n- The function takes an input image `img` as a NumPy array and an integer `r` representing the radius of the box filter.\n\nOutput format:\n- The function returns a NumPy array representing the image after applying the box filter.\n\n**Input:**\n```python\nimg = np.array([[[  0,  50, 100],\n                 [ 10,  60, 110],\n                 [ 20,  70, 120],\n                 [ 30,  80, 130],\n                 [ 40,  90, 140]],\n\n                [[  5,  55, 105],\n                 [ 15,  65, 115],\n                 [ 25,  75, 125],\n                 [ 35,  85, 135],\n                 [ 45,  95, 145]],\n\n                [[  1,  51, 101],\n                 [ 11,  61, 111],\n                 [ 21,  71, 121],\n                 [ 31,  81, 131],\n                 [ 41,  91, 141]],\n\n                [[  6,  56, 106],\n                 [ 16,  66, 116],\n                 [ 26,  76, 126],\n                 [ 36,  86, 136],\n                 [ 46,  96, 146]],\n\n                [[  2,  52, 102],\n                 [ 12,  62, 112],\n                 [ 22,  72, 122],\n                 [ 32,  82, 132],\n                 [ 42,  92, 142]]], dtype=np.uint8)\n\nr = 1\n```\n\n**Output:**\n```python\narray([[[ 30, 230, 174],\n        [ 75, 119, 163],\n        [135, 179, 223],\n        [195, 239,  27],\n        [150,  94,  38]],\n       [[ 42,  86, 130],\n        [108,  46, 240],\n        [198, 136,  74],\n        [ 32, 226, 164],\n        [222,  10,  54]],\n       [[ 54,  98, 142],\n        [126,  64,   2],\n        [216, 154,  92],\n        [ 50, 244, 182],\n        [234,  22,  66]],\n       [[ 48,  92, 136],\n        [117,  55, 249],\n        [207, 145,  83],\n        [ 41, 235, 173],\n        [228,  16,  60]],\n       [[ 36, 236, 180],\n        [ 84, 128, 172],\n        [144, 188, 232],\n        [204, 248,  36],\n        [156, 100,  44]]], dtype=uint8)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef box(img, r):\n    (rows, cols) = img.shape[:2]\n    imDst = np.zeros_like(img)\n    tile = [1] * img.ndim\n    tile[0] = r\n    imCum = np.cumsum(img, 0)\n    imDst[0:r + 1, :, ...] = imCum[r:2 * r + 1, :, ...]\n    imDst[r + 1:rows - r, :, ...] = imCum[2 * r + 1:rows, :, ...] - imCum[0:rows - 2 * r - 1, :, ...]\n    imDst[rows - r:rows, :, ...] = np.tile(imCum[rows - 1:rows, :, ...], tile) - imCum[rows - 2 * r - 1:rows - r - 1, :, ...]\n    tile = [1] * img.ndim\n    tile[1] = r\n    imCum = np.cumsum(imDst, 1)\n    imDst[:, 0:r + 1, ...] = imCum[:, r:2 * r + 1, ...]\n    imDst[:, r + 1:cols - r, ...] = imCum[:, 2 * r + 1:cols, ...] - imCum[:, 0:cols - 2 * r - 1, ...]\n    imDst[:, cols - r:cols, ...] = np.tile(imCum[:, cols - 1:cols, ...], tile) - imCum[:, cols - 2 * r - 1:cols - r - 1, ...]\n    return imDst", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(10, 500)\n        cols = random.randint(10, 500)\n        channels = random.choice([1, 3])\n        img = np.random.randint(0, 256, size=(rows, cols, channels), dtype=np.uint8)\n        r = random.randint(1, min(rows, cols) // 4)\n        test_cases.append((img, r))\n    return test_cases"}
{"problem_id": "numpy_94", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a survival table from a set of event data, specifically focusing on death times, observed events, and birth times. The function will aggregate this data to provide insights into survival analysis.\n\nFunction Signature:\n```python\ndef survival_table_from_events(death_times, event_observed, birth_times, columns, weights, collapse, intervals):\n```\n\n### Constants Used:\n- The function uses the constant `0` to determine the minimum birth time when `birth_times` is `None`.\n\n### Input Format:\n- `death_times`: A list or array of times at which events (deaths) occurred.\n- `event_observed`: A list or array indicating whether each event was observed (1) or not (0).\n- `birth_times`: A list or array of times at which subjects entered the study (births).\n- `columns`: A list of strings representing the names of the columns in the output DataFrame: `[removed, observed, censored, entrance, at_risk]`.\n- `weights`: A list or array of weights corresponding to each event.\n- `collapse`: A boolean indicating whether to collapse the event data into intervals.\n- `intervals`: A list or array of intervals for grouping the event data.\n\n### Output Format:\n- The function returns a DataFrame containing the aggregated survival data, with columns for `removed`, `observed`, `censored`, `entrance`, and `at_risk`. The data types of the columns depend on the weights provided.\n\n**Input:**\n```python\ndeath_times = np.array([10, 20, 30, 40, 50])\nevent_observed = np.array([1, 0, 1, 1, 0])\nbirth_times = np.array([0, 5, 15, 25, 35])\ncolumns = ['removed', 'observed', 'censored', 'entrance', 'at_risk']\nweights = np.array([1, 1, 1, 1, 1])\ncollapse = False\nintervals = None\n```\n\n**Output:**\n```python\n          removed  observed  censored  entrance  at_risk\nevent_at                                                \n0               0         0         0         1        1\n5               0         0         0         1        2\n10              1         1         0         0        2\n15              0         0         0         1        2\n20              1         0         1         0        2\n25              0         0         0         1        2\n30              1         1         0         0        2\n35              0         0         0         1        2\n40              1         1         0         0        2\n50              1         0         1         0        1\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n\ndef _group_event_table_by_intervals(event_table, intervals):\n    event_table = event_table.reset_index()\n    if intervals is None:\n        event_max = event_table['event_at'].max()\n        q75, q25 = np.percentile(event_table['event_at'], [75, 25])\n        event_iqr = q75 - q25\n        bin_width = 2 * event_iqr * len(event_table['event_at']) ** (-1 / 3)\n        intervals = np.arange(0, event_max + bin_width, bin_width)\n\n    event_table = event_table.groupby(\n        pd.cut(event_table['event_at'], intervals, include_lowest=True),\n        observed=False\n    ).agg({\n        'removed': 'sum',\n        'observed': 'sum',\n        'censored': 'sum',\n        'at_risk': 'max'\n    }).rename_axis(columns=None)  # Ensures no MultiIndex issues\n\n    if isinstance(event_table.columns, pd.MultiIndex):\n        event_table.columns = event_table.columns.droplevel(1)\n\n    return event_table.bfill().fillna(0)\n\n\n# main code\ndef survival_table_from_events(death_times, event_observed, birth_times, columns, weights, collapse, intervals):\n    removed, observed, censored, entrance, at_risk = columns\n    death_times = np.asarray(death_times)\n\n    if birth_times is None:\n        birth_times = np.full(death_times.shape[0], min(0, death_times.min()))\n    else:\n        birth_times = np.asarray(birth_times)\n\n    weights = weights if weights is not None else 1\n\n    df = pd.DataFrame(death_times, columns=['event_at'])\n    df[removed] = np.asarray(weights)\n    df[observed] = np.asarray(weights) * np.asarray(event_observed).astype(bool)\n\n    death_table = df.groupby('event_at').sum()\n    death_table[censored] = (death_table[removed] - death_table[observed]).astype(int)\n\n    births = pd.DataFrame(birth_times, columns=['event_at'])\n    births[entrance] = np.asarray(weights)\n    births_table = births.groupby('event_at').sum()\n\n    event_table = death_table.join(births_table, how='outer', sort=True).fillna(0)\n    event_table[at_risk] = event_table[entrance].cumsum() - event_table[removed].cumsum().shift(1).fillna(0)\n\n    if collapse or intervals is not None:\n        event_table = _group_event_table_by_intervals(event_table, intervals)\n\n    if (np.asarray(weights).astype(int) != weights).any():\n        return event_table.astype(float)\n\n    return event_table.astype(int)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_events = np.random.randint(10, 1000)\n        death_times = np.sort(np.random.uniform(0, 1000, size=num_events))\n        event_observed = np.random.choice([0, 1], size=num_events)\n        birth_times = np.sort(np.random.uniform(0, 500, size=num_events))\n        columns = ['removed', 'observed', 'censored', 'entrance', 'at_risk']\n        weights = np.random.choice([1, 2, 3], size=num_events)\n        collapse = np.random.choice([True, False])\n        if np.random.choice([True, False]):\n            intervals = np.sort(np.random.uniform(0, 1000, size=np.random.randint(5, 20)))\n        else:\n            intervals = None\n        test_cases.append((death_times, event_observed, birth_times, columns, weights, collapse, intervals))\n\n    return test_cases"}
{"problem_id": "numpy_95", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a specific mathematical value based on given parameters related to frequency, distance, and a sign indicator. The function signature is as follows:\n\n```python\ndef FMetisShad(fGHz, r, D, sign):\n```\n\n### Constants:\n- The constant used in the main code is `lamda`, which is calculated as `0.3 / fGHz`. This represents the wavelength corresponding to the frequency `fGHz`.\n\n\n### Input and Output Format:\n- **Input**: The function takes four parameters: a float `fGHz`, a float `r`, a float `D`, and an integer `sign`.\n- **Output**: The function returns a float value `F`, which is the result of the calculation described above.\n\nInput: (5.25, 10.0, 50.0, 1)\nOutput: 0.4956790462609905", "ground_truth_code": "import numpy as np\n\n# main code\ndef FMetisShad(fGHz, r, D, sign):\n    lamda = 0.3 / fGHz\n    F = np.arctan(sign * np.pi / 2.0 * np.sqrt(np.pi / lamda * (D - r))) / np.pi\n    return F", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        fGHz = round(random.uniform(0.1, 30.0), 2)\n        r = round(random.uniform(1.0, 1000.0), 2)\n        D = round(random.uniform(r + 0.01, 1000.0), 2)\n        sign = random.choice([1, -1])\n        test_cases.append((fGHz, r, D, sign))\n    \n    return test_cases\n"}
{"problem_id": "numpy_96", "library": "numpy", "code_problem": "```python\ndef LossMetisShadowing2(fGHz, tx, rx, pg, uw, uh, w, h):\n```\n\nIn this code, the function `LossMetisShadowing2` calculates the shadowing loss in a wireless communication scenario considering multiple segments and screens. The main constant used in the code is derived from the frequency `fGHz`, specifically `lamda = 0.3 / fGHz`, which represents the wavelength in meters.\n\n### Input and Output Format:\n- **Input Format**:\n  - The function takes in multiple numpy arrays as parameters, which represent the frequency, transmitter and receiver coordinates, screen positions, and dimensions.\n\n- **Output Format**:\n  - The function returns a numpy array representing the calculated shadowing loss values.\n\n**Input:**\n```python\nfGHz = np.array([6.62493324])\ntx = np.array([[-25.938922  ,  -1.64140896,  13.73923524, -38.38202638, -75.84832934],\n               [-14.33054688, -82.32904167, -72.78742217, -76.57934828, 42.41964974],\n               [-33.00867811,  63.9727125 , -55.88330251,  41.12325104, 14.82373157]])\nrx = np.array([[ 29.0362445 , -80.8941856 , -31.40655611, -10.98644635, 45.63809959],\n               [-35.17015236, -75.49364568,  82.04794501,   8.12630394, 53.24615042],\n               [ 97.41305296,  17.61300572,  51.89520291, -77.86486219, 53.85757821]])\npg = np.array([[  8.78474404, -38.60716032, -99.75584954],\n               [  0.84330985,   1.51921977, -48.72273165],\n               [-44.87305008,  89.24794565, -40.81795557]])\nuw = np.array([[-0.27907229,  0.08451224, -0.41429992],\n               [-0.41880753, -0.65809765,  0.90472896],\n               [ 0.86412899, -0.74817456,  0.0991014 ]])\nuh = np.array([[ 0.04714505,  0.09733191, -0.9052507 ],\n               [-0.35600041, -0.65749138, -0.4153686 ],\n               [-0.9332958 ,  0.74714897, -0.08938738]])\nw = np.array([8.41512126, 2.73304371, 3.60271154])\nh = np.array([8.60203244, 1.49133268, 3.10411602])\n```\n\n**Output:**\n```python\narray([[[1.59347351e-06],\n        [5.04649439e-09],\n        [3.85045759e-04]],\n       [[2.31795326e-08],\n        [2.02153028e-09],\n        [4.64996197e-09]],\n       [[1.25617415e-05],\n        [1.46742395e-08],\n        [7.37846482e-10]],\n       [[1.84495456e-06],\n        [3.55902120e-09],\n        [1.81274760e-08]],\n       [[1.38577066e-07],\n        [6.00810921e-09],\n        [3.24427436e-09]]])\n\n```", "ground_truth_code": "import numpy as np\nimport numpy.linalg as la\n\ndef FMetisShad2(fGHz, r, D, sign):\n\n    lamda = 0.3 / fGHz[None, None, :]\n    F = np.arctan(sign[:, :, None] * np.pi / 2.0 * np.sqrt(np.pi / lamda * (D[:, :, None] - r[:, None, None]))) / np.pi\n    return F\n\n# main code\ndef LossMetisShadowing2(fGHz, tx, rx, pg, uw, uh, w, h):\n    Nseg = tx.shape[1]\n    Nscreen = uw.shape[1]\n    rxtx = rx - tx\n    U = rxtx.T[:, None, :, None]\n    W = uw.T[None, :, :, None]\n    H = uh.T[None, :, :, None]\n    We = W + np.zeros(U.shape)\n    He = H + np.zeros(U.shape)\n    Ue = U + np.zeros(He.shape)\n    A = np.concatenate((Ue, -We, -He), axis=3)\n    b = pg.T[None, :, :] - tx.T[:, None, :]\n    x = la.solve(A, b)\n    condseg = (x[:, :, 0] > 1) + (x[:, :, 0] < 0)\n    condw = (x[:, :, 1] > w[None, :] / 2.0) + (x[:, :, 1] < -w[None, :] / 2.0)\n    condh = (x[:, :, 2] > h[None, :] / 2.0) + (x[:, :, 2] < -h[None, :] / 2.0)\n    visi = (condseg + condw + condh) % 2\n    r = np.sum(rxtx * rxtx, axis=0) ** 0.5\n    w1 = pg + uw * w[None, :] / 2.0\n    w2 = pg - uw * w[None, :] / 2.0\n    h1 = pg + uh * h[None, :] / 2.0\n    h2 = pg - uh * h[None, :] / 2.0\n    Dtw1 = np.sum((tx[..., None] - w1[:, None, :]) * (tx[..., None] - w1[:, None, :]), axis=0) ** 0.5\n    Drw1 = np.sum((rx[..., None] - w1[:, None, :]) * (rx[..., None] - w1[:, None, :]), axis=0) ** 0.5\n    Dtw2 = np.sum((tx[..., None] - w2[:, None, :]) * (tx[..., None] - w2[:, None, :]), axis=0) ** 0.5\n    Drw2 = np.sum((rx[..., None] - w2[:, None, :]) * (rx[..., None] - w2[:, None, :]), axis=0) ** 0.5\n    Dth1 = np.sum((tx[..., None] - h1[:, None, :]) * (tx[..., None] - h1[:, None, :]), axis=0) ** 0.5\n    Drh1 = np.sum((rx[..., None] - h1[:, None, :]) * (rx[..., None] - h1[:, None, :]), axis=0) ** 0.5\n    Dth2 = np.sum((tx[..., None] - h2[:, None, :]) * (tx[..., None] - h2[:, None, :]), axis=0) ** 0.5\n    Drh2 = np.sum((rx[..., None] - h2[:, None, :]) * (rx[..., None] - h2[:, None, :]), axis=0) ** 0.5\n    D1w = Dtw1 + Drw1\n    D1h = Dth1 + Drh1\n    D2w = Dtw2 + Drw2\n    D2h = Dth2 + Drh2\n    signw1 = np.ones((Nseg, Nscreen))\n    signw2 = np.ones((Nseg, Nscreen))\n    signh1 = np.ones((Nseg, Nscreen))\n    signh2 = np.ones((Nseg, Nscreen))\n    condw1 = (visi * condw * (D1w <= D2w)).astype(bool)\n    condw2 = (visi * condw * (D1w > D2w)).astype(bool)\n    signw1[condw1] = -1\n    signw2[condw2] = -1\n    condh1 = (visi * condh * (D1h <= D2h)).astype(bool)\n    condh2 = (visi * condh * (D1h > D2h)).astype(bool)\n    signh1[condh1] = -1\n    signh2[condh2] = -1\n    Fw1 = FMetisShad2(fGHz, r, D1w, sign=signw1)\n    Fh1 = FMetisShad2(fGHz, r, D1h, sign=signh1)\n    Fw2 = FMetisShad2(fGHz, r, D2w, sign=signw2)\n    Fh2 = FMetisShad2(fGHz, r, D2h, sign=signh2)\n    tmp = (Fh1 + Fh2) * (Fw1 + Fw2)\n    Lsh = -20 * np.log10(1 - tmp)\n    return Lsh", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    fGHz_values = np.random.uniform(low=0.1, high=10.0, size=n)\n\n    for i in range(n):\n        tx = np.random.uniform(low=-100, high=100, size=(3, 5))\n        rx = np.random.uniform(low=-100, high=100, size=(3, 5))\n        pg = np.random.uniform(low=-100, high=100, size=(3, 3))\n        uw = np.random.randn(3, 3)\n        uw /= np.linalg.norm(uw, axis=0, keepdims=True)\n        uh = np.random.randn(3, 3)\n        uh /= np.linalg.norm(uh, axis=0, keepdims=True)\n        w = np.random.uniform(low=0.1, high=10.0, size=(3,))\n        h = np.random.uniform(low=0.1, high=10.0, size=(3,))\n        test_cases.append((fGHz_values[i:i+1], tx, rx, pg, uw, uh, w, h))\n    \n    return test_cases\n"}
{"problem_id": "numpy_97", "library": "numpy", "code_problem": "```python\ndef gaspl(d, fGHz, T, PhPa, wvden, affO2, affH2O):\n```\n\nIn this function, the main goal is to calculate the gas attenuation in decibels (dB) over a specified distance based on various atmospheric and frequency parameters. The function takes the following parameters:\n\n- `d`: Distance in meters.\n- `fGHz`: Frequency in gigahertz (GHz).\n- `T`: Temperature in degrees Celsius.\n- `PhPa`: Pressure in pascals (Pa).\n- `wvden`: Water vapor density.\n- `affO2`: An array containing coefficients related to oxygen.\n- `affH2O`: An array containing coefficients related to water vapor.\n\n### Constant Used:\n- The constant `dkm` is derived from the input distance `d` by converting it from meters to kilometers (1 km = 1000 m).\n\n### Input Format:\n- The function accepts the following inputs:\n  - `d`: A float representing the distance in meters.\n  - `fGHz`: A numpy array of floats representing frequencies in gigahertz.\n  - `T`: A float representing the temperature in degrees Celsius.\n  - `PhPa`: A float representing the pressure in pascals.\n  - `wvden`: A float representing the water vapor density.\n  - `affO2`: A 2D numpy array of floats containing coefficients related to oxygen.\n  - `affH2O`: A 2D numpy array of floats containing coefficients related to water vapor.\n\n### Output Format:\n- The function returns a numpy array of floats representing the gas attenuation in decibels (dB) for the specified distance and frequency range.\n\n```python\n# Input\nd = 1500.0\nfGHz = np.array([100.0, 200.0, 300.0, 400.0, 500.0])\nT = 25.0\nPhPa = 1013.25\nwvden = 10.0\naffO2 = np.array([[0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8]] * 40)\naffH2O = np.array([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]] * 40)\n\n# Output\narray([2.5287204 , 2.53973696, 2.55736043, 2.5802065 , 2.60719621])\n```", "ground_truth_code": "import numpy as np\n\n\n# main code\ndef gaspl(d, fGHz, T, PhPa, wvden, affO2, affH2O):\n\n    dkm = d / 1000.0\n    TK = T + 273.15\n    theta = 300.0 / TK\n\n    fO2, a1, a2, a3, a4, a5, a6 = [affO2[:, i] for i in range(7)]\n    fH2O, b1, b2, b3, b4, b5, b6 = [affH2O[:, i] for i in range(7)]\n\n    e = wvden * TK / 216.7\n\n    SO2 = a1 * 1e-07 * PhPa * theta ** 3 * np.exp(a2 * (1 - theta))\n    DO2 = a3 * 0.0001 * (PhPa * theta ** (0.8 - a4) + 1.1 * e * theta)\n    SH2O = b1 * 0.1 * e * theta ** 3.5 * np.exp(b2 * (1 - theta))\n    DH2O = b3 * 0.0001 * (PhPa * theta ** b4 + b5 * e * theta ** b6)\n\n    DO2_m = np.sqrt(DO2 ** 2 + 2.25e-06)\n    DH2O_m = 0.535 * DH2O + np.sqrt(0.217 * DH2O ** 2 + 2.1316 * 1e-12 * fH2O ** 2 / theta)\n\n    deltaO2 = (a5 + a6 * theta) * 0.0001 * (PhPa + e) * theta ** 0.8\n\n    uO2, vO2 = fO2[:, None] - fGHz[None, :], fO2[:, None] + fGHz[None, :]\n    n1O2, n2O2 = DO2_m[:, None] - deltaO2[:, None] * uO2, DO2_m[:, None] - deltaO2[:, None] * vO2\n    d1O2, d2O2 = uO2 ** 2 + DO2_m[:, None] ** 2, vO2 ** 2 + DO2_m[:, None] ** 2\n\n    FO2 = fGHz[None, :] / fO2[:, None] * (n1O2 / d1O2 + n2O2 / d2O2)\n    UO2 = SO2[:, None] * FO2\n\n    uH2O, vH2O = fH2O[:, None] - fGHz[None, :], fH2O[:, None] + fGHz[None, :]\n    nH2O = DH2O_m[:, None]\n    d1H2O, d2H2O = uH2O ** 2 + DH2O_m[:, None] ** 2, vH2O ** 2 + DH2O_m[:, None] ** 2\n\n    FH2O = fGHz[None, :] / fH2O[:, None] * (nH2O / d1H2O + nH2O / d2H2O)\n    UH2O = SH2O[:, None] * FH2O\n\n    dD = 0.00056 * (PhPa + e) * theta ** 0.8\n    t1 = 6.14e-05 / (dD * (1.0 + (fGHz / dD) ** 2))\n    t2 = 1.4e-12 * PhPa * theta ** 1.5 / (1 + 1.9e-05 * fGHz ** 1.5)\n    Nsec = fGHz * PhPa * theta ** 2 * (t1 + t2)\n\n    ulow, uhigh = np.where(fGHz < 118.750343)[0], np.where(fGHz >= 118.750343)[0]\n    UO2low, UO2high = UO2[:, ulow], UO2[:, uhigh]\n\n    SO2low, SO2high = np.sum(UO2low, axis=0), np.sum(UO2high[38:, :], axis=0)\n    sSO2 = np.hstack((SO2low, SO2high))\n\n    Npp = sSO2 + np.sum(UH2O, axis=0) + Nsec\n    gamma = 0.182 * fGHz * Npp\n    LgasdB = gamma * dkm\n\n    return LgasdB", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        d = np.random.uniform(0.1, 10000)\n        fGHz = np.random.uniform(0.1, 1000, size=np.random.randint(10, 100))\n        T = np.random.uniform(-50, 50)\n        PhPa = np.random.uniform(500, 1100)\n        wvden = np.random.uniform(0, 30)\n        affO2 = np.random.uniform(0.1, 1, size=(40, 7))\n        affH2O = np.random.uniform(0.1, 1, size=(40, 7))\n\n        test_cases.append((d, fGHz, T, PhPa, wvden, affO2, affH2O))\n\n    return test_cases"}
{"problem_id": "numpy_98", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes a conditional distribution based on a given set of indices, a vector, a covariance matrix, and a mean vector. The function will return the updated mean, the dimension of the reduced space, the inverse of the covariance matrix, and the original data vector.\n\nFunction signature:\n```python\ndef condition(indices, x, A, dim, mu):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1.0`, which is used to handle the case when the dimension of the covariance matrix is one.\n\nInput format:\n- The function accepts the following inputs:\n  - `indices`: A list of integers representing the indices of the conditioned dimensions.\n  - `x`: A numpy array representing the data point.\n  - `A`: A numpy 2D array representing the covariance matrix.\n  - `dim`: An integer representing the total number of dimensions.\n  - `mu`: A numpy array representing the mean vector.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `'dim'`: An integer representing the dimension of the reduced space.\n  - `'mu'`: A numpy array representing the updated mean vector.\n  - `'sigma'`: A numpy array representing the inverse covariance matrix.\n  - `'data'`: A numpy array representing the original data vector `x`.\n\nInput:\n```python\nindices = np.array([0, 2])\nx = np.array([-0.5, 1.2])\nA = np.array([[2.0, 0.5, 0.3],\n              [0.5, 1.0, 0.2],\n              [0.3, 0.2, 1.5]])\ndim = 3\nmu = np.array([0.0, 1.0, -1.0])\n```\n\nOutput:\n```python\n{'dim': 1, 'mu': array([0.81]), 'sigma': array([[1.]]), 'data': array([-0.5,  1.2])}\n```", "ground_truth_code": "import numpy as np\nimport numpy.linalg as la\n\n# main code\ndef condition(indices, x, A, dim, mu):\n\n    idim = indices\n    odim = np.array([i for i in range(dim) if i not in indices])\n\n    Aaa = A[np.ix_(odim, odim)]\n    Aab = A[np.ix_(odim, idim)]\n\n    iAaa = 1.0 / Aaa if len(odim) == 1 else la.inv(Aaa)\n\n    premu = np.dot(iAaa, Aab)\n    mub = mu[idim]\n    mua = mu[odim]\n\n    new_mu = mua - np.dot(premu, x - mub)\n    new_E = iAaa\n\n    return {\n        'dim': len(odim),\n        'mu': new_mu,\n        'sigma': new_E,\n        'data': x\n    }\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dim = np.random.randint(2, 10)\n        B = np.random.randn(dim, dim)\n        A = np.dot(B, B.T) + np.eye(dim)\n        idim = np.sort(np.random.choice(dim, size=np.random.randint(1, dim), replace=False))\n        mu = np.random.randn(dim)\n        x = np.random.randn(len(idim))\n        test_cases.append((idim, x, A, dim, mu))\n\n    return test_cases"}
{"problem_id": "numpy_99", "library": "numpy", "code_problem": "You are tasked with creating a function that generates a grid of coordinates for a specified height and width, and allows for multiple batches of these coordinates. The function should be able to handle the creation of a coordinate grid that can be used in various applications such as image processing or spatial analysis.\n\nFunction signature:\n```python\ndef coords_grid(batch: int, ht: int, wd: int) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `np.float32`, which specifies the data type for the coordinates.\n\nInput format:\n- The function takes three integer inputs: `batch`, `ht`, and `wd`.\n\nOutput format:\n- The function returns a 3D NumPy array of shape `(batch, 2, ht, wd)`, where the first dimension is the batch size, the second dimension contains the x and y coordinates, and the last two dimensions represent the height and width of the grid.\n\nInput: (2, 3, 4)  \nOutput:  \narray([[[[0., 1., 2., 3.],\n         [0., 1., 2., 3.],\n         [0., 1., 2., 3.]],\n        [[0., 0., 0., 0.],\n         [1., 1., 1., 1.],\n         [2., 2., 2., 2.]]],\n       [[[0., 1., 2., 3.],\n         [0., 1., 2., 3.],\n         [0., 1., 2., 3.]],\n        [[0., 0., 0., 0.],\n         [1., 1., 1., 1.],\n         [2., 2., 2., 2.]]]], dtype=float32)", "ground_truth_code": "import numpy as np\n\n# main code\ndef coords_grid(batch, ht, wd):\n    coords = np.meshgrid(np.arange(wd), np.arange(ht))[::-1]\n    coords = np.stack(coords[::-1], axis=0).astype(np.float32)\n    return coords[np.newaxis, ...].repeat(batch, axis=0)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch = random.randint(1, 100)\n        ht = random.randint(1, 512)\n        wd = random.randint(1, 512)\n        test_cases.append((batch, ht, wd))\n    return test_cases"}
{"problem_id": "numpy_100", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the indices for a sliding window operation over a multi-dimensional input tensor, commonly used in convolutional neural networks. The function will take the shape of the input tensor and parameters related to the sliding window, such as filter height, filter width, stride, and padding, and return the indices for the height, width, and depth dimensions.\n\nFunction signature:\n```python\ndef get_indices(X_shape, HF, WF, stride, pad):\n```\n\nConstants used in the main code:\n- `HF`: Height of the filter.\n- `WF`: Width of the filter.\n\nInput format:\n- `X_shape`: A tuple of integers representing the shape of the input tensor (m, n_C, n_H, n_W).\n- `HF`: An integer representing the height of the filter.\n- `WF`: An integer representing the width of the filter.\n- `stride`: An integer representing the stride of the sliding window.\n- `pad`: An integer representing the amount of zero-padding added to the input tensor.\n\nOutput format:\n- A tuple of three numpy arrays: `(i, j, d)`, where:\n  - `i`: Array of height indices.\n  - `j`: Array of width indices.\n  - `d`: Array of depth indices.\n\n**Input:**\n```python\nX_shape = (1, 1, 1, 1)  # (m, n_C, n_H, n_W)\nHF = 2                     # Height of the filter\nWF = 2                     # Width of the filter\nstride = 2                 # Stride\npad = 1                    # Padding\n```\n\n**Output:**\n```python\n\ni = array([[0], [0], [1], [1]]) \nj = array([[0], [1], [0], [1]])\nd = array([[0], [0], [0], [0]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_indices(X_shape, HF, WF, stride, pad):\n    (m, n_C, n_H, n_W) = X_shape\n    out_h = int((n_H + 2 * pad - HF) / stride) + 1\n    out_w = int((n_W + 2 * pad - WF) / stride) + 1\n    level1 = np.repeat(np.arange(HF), WF)\n    level1 = np.tile(level1, n_C)\n    everyLevels = stride * np.repeat(np.arange(out_h), out_w)\n    i = level1.reshape(-1, 1) + everyLevels.reshape(1, -1)\n    slide1 = np.tile(np.arange(WF), HF)\n    slide1 = np.tile(slide1, n_C)\n    everySlides = stride * np.tile(np.arange(out_w), out_h)\n    j = slide1.reshape(-1, 1) + everySlides.reshape(1, -1)\n    d = np.repeat(np.arange(n_C), HF * WF).reshape(-1, 1)\n    return (i, j, d)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = random.randint(1, 10)\n        n_C = random.randint(1, 10)\n        n_H = random.randint(10, 100)\n        n_W = random.randint(10, 100)\n\n        HF = random.randint(1, min(n_H, n_W) // 2)\n        WF = random.randint(1, min(n_H, n_W) // 2)\n\n        stride = random.randint(1, 4)\n        pad = random.randint(0, 5)\n        out_h = (n_H + 2 * pad - HF) // stride + 1\n        out_w = (n_W + 2 * pad - WF) // stride + 1\n        if out_h > 0 and out_w > 0:\n            X_shape = (m, n_C, n_H, n_W)\n            test_cases.append((X_shape, HF, WF, stride, pad))\n\n    return test_cases"}
{"problem_id": "numpy_101", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the indices for extracting patches from a multi-dimensional input array, commonly used in convolutional neural networks. The function will help in transforming the input data into a format suitable for applying convolution operations.\n\nFunction signature:\n```python\ndef get_im2col_indices(x_shape, field_height, field_width, padding, stride):\n```\n\n### Constants:\n- The constant used in the main code is `np.int32`, which is used to ensure that the output dimensions are represented as 32-bit integers.\n\n\n### Input Format:\n- The function takes the following inputs:\n  - `x_shape`: A tuple of integers (N, C, H, W)\n  - `field_height`: An integer\n  - `field_width`: An integer\n  - `padding`: An integer\n  - `stride`: An integer\n\n### Output Format:\n- The function returns a tuple of three numpy arrays:\n  - `k`: An array of shape (number of patches,)\n  - `i`: An array of shape (number of patches,)\n  - `j`: An array of shape (number of patches,)\n\n**Input:**\n```python\n((2, 3, 5, 5), 3, 3, 1, 1)\n```\n\n**Output:**\n```python\n(k, i, j) = (\narray([[0],[0],[0],[0],[0],[0],[0],[0],[0]]),\narray([[0],[0],[0],[1],[1],[1],[2],[2],[2]]),\narray([[0],[1],[2],[0],[1],[2],[0],[1],[2]])\n)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_im2col_indices(x_shape, field_height, field_width, padding, stride):\n    (N, C, H, W) = x_shape\n    out_height = np.int32((H + 2 * padding - field_height) / stride + 1)\n    out_width = np.int32((W + 2 * padding - field_width) / stride + 1)\n    i0 = np.repeat(np.arange(field_height), field_width)\n    i0 = np.tile(i0, C)\n    i1 = stride * np.repeat(np.arange(out_height), out_width)\n    j0 = np.tile(np.arange(field_width), field_height * C)\n    j1 = stride * np.tile(np.arange(out_width), out_height)\n    i = i0.reshape(-1, 1) + i1.reshape(1, -1)\n    j = j0.reshape(-1, 1) + j1.reshape(1, -1)\n    k = np.repeat(np.arange(C), field_height * field_width).reshape(-1, 1)\n    return (k, i, j)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        N = random.randint(1, 10)\n        C = random.randint(1, 10)\n        H = random.randint(1, 12)\n        W = random.randint(1, 12)\n\n        field_height = random.randint(1, H)\n        field_width = random.randint(1, W)\n        padding = random.randint(0, 2)\n        stride = random.randint(1, 2)\n\n        test_cases.append(((N, C, H, W), field_height, field_width, padding, stride))\n\n    return test_cases"}
{"problem_id": "numpy_102", "library": "numpy", "code_problem": "```python\ndef move_analyzer(clone_x: float, clone_y: float, clone_r: float, v_x: float, v_y: float, tar_x: float, tar_y: float, tar_r: float) -> tuple:\n```\n\nIn the `move_analyzer` function, the goal is to calculate the new position and velocity of a moving object (referred to as \"clone\") as it attempts to reach a target position while considering its current velocity and radius, as well as the target's radius. The function takes the following parameters:\n\n- `clone_x`: The current x-coordinate of the clone.\n- `clone_y`: The current y-coordinate of the clone.\n- `clone_r`: The radius of the clone.\n- `v_x`: The current x-component of the clone's velocity.\n- `v_y`: The current y-component of the clone's velocity.\n- `tar_x`: The x-coordinate of the target.\n- `tar_y`: The y-coordinate of the target.\n- `tar_r`: The radius of the target.\n\n### Input and Output Format:\n\n- **Input Format**: The function takes in seven floating-point numbers representing the clone's position, radius, velocity, target's position, and target's radius.\n  \n- **Output Format**: The function returns a tuple containing six floating-point numbers: the new x-coordinate, new y-coordinate, new radius, new x-component of velocity, new y-component of velocity, and the time spent moving.\n\nInput:\n```python\n(100.0, 200.0, 10.0, 30.0, 40.0, 300.0, 400.0, 20.0)\n```\n\nOutput:\n```python\n(285.85786437626905, 385.85786437626905, 22.360679774997898, 17.67766952966369, 17.67766952966369, 10.633733752154177)\n```", "ground_truth_code": "import numpy as np\n\ndef vector2angle(x, y):\n    theta = np.arctan2(y, x)\n    angle = theta * 180 / np.pi\n    if isinstance(angle, np.float64) or isinstance(angle, float):\n        if abs(angle) < 0.0001:\n            angle = 0\n        elif angle < 0:\n            angle += 360\n        return angle\n    angle[np.abs(angle) < 0.0001] = 0\n    angle[angle < 0] = angle[angle < 0] + 360.0\n    return angle\n\ndef ang_to_rad(ang):\n    return ang / 180.0 * np.pi\n\ndef get_dis(x1, y1, x2, y2):\n    dis = np.sqrt(np.power(x1 - x2, 2) + np.power(y1 - y2, 2))\n    return dis\n\n# main code\ndef move_analyzer(clone_x, clone_y, clone_r, v_x, v_y, tar_x, tar_y, tar_r):\n    ang_v = vector2angle(v_x, v_y)\n    spd_value = np.sqrt(np.power(v_x, 2) + np.power(v_y, 2))\n    dt_x = tar_x - clone_x\n    dt_y = tar_y - clone_y\n    ang_to_tar = vector2angle(dt_x, dt_y)\n    dt_ang = float(np.abs(ang_to_tar - ang_v))\n    if dt_ang > 180.0:\n        dt_ang = 360.0 - dt_ang\n    dt_rad = ang_to_rad(dt_ang)\n    dis_center = get_dis(clone_x, clone_y, tar_x, tar_y)\n    dis_move = dis_center - max(clone_r, tar_r)\n    clone_r_last = np.sqrt(np.power(clone_r, 2) + np.power(tar_r, 2))\n    if dis_move <= 0:\n        return (float(clone_x), float(clone_y), float(clone_r_last), float(v_x), float(v_y), 0.0)\n    v_0_length = float(np.cos(dt_rad) * spd_value)\n    acc = 100\n    v_last_length = float(np.sqrt(2 * acc * dis_move + np.power(v_0_length, 2)))\n    v_max_length = 500.0 / (clone_r + 10)\n    if v_last_length > v_max_length:\n        v_last_length = v_max_length\n        acc_time = (v_last_length - v_0_length) / acc\n        has_move = (v_last_length + v_0_length) / 2 * acc_time\n        rest_move = max(0, dis_move - has_move)\n        rest_time = rest_move / v_last_length\n        spend_time = acc_time + rest_time\n    else:\n        spend_time = (v_last_length - v_0_length) / acc\n    clone_x_last = clone_x + dt_x * dis_move / dis_center\n    clone_y_last = clone_y + dt_y * dis_move / dis_center\n    v_x_last = v_last_length * dt_x / dis_center\n    v_y_last = v_last_length * dt_y / dis_center\n    return (float(clone_x_last), float(clone_y_last), float(clone_r_last), float(v_x_last), float(v_y_last), float(spend_time))", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        clone_x = random.uniform(-1000.0, 1000.0)\n        clone_y = random.uniform(-1000.0, 1000.0)\n        tar_x = random.uniform(-1000.0, 1000.0)\n        tar_y = random.uniform(-1000.0, 1000.0)\n        clone_r = random.uniform(0.0, 100.0)\n        tar_r = random.uniform(0.0, 100.0)\n        v_x = random.uniform(-50.0, 50.0)\n        v_y = random.uniform(-50.0, 50.0)\n\n        test_cases.append((clone_x, clone_y, clone_r, v_x, v_y, tar_x, tar_y, tar_r))\n\n    return test_cases"}
{"problem_id": "numpy_103", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the Average Precision (AP) score from predicted matches and their corresponding scores against ground truth matches. The function should take in two arrays: one representing the predicted matches and another representing the predicted scores. The function will return the Average Precision score based on the provided inputs.\n\nFunction Signature:\n```python\ndef compute_ap_from_matches_scores(pred_match: np.ndarray, pred_scores: np.ndarray, gt_match: np.ndarray) -> float:\n```\n\nConstants Used:\n- The function uses a constant value of `0` to initialize the precision and recall arrays.\n\nInput Format:\n- `pred_match`: A 1D numpy array of predicted matches.\n- `pred_scores`: A 1D numpy array of predicted scores corresponding to the matches.\n- `gt_match`: A 1D numpy array of ground truth matches.\n\nOutput Format:\n- The function returns a float representing the Average Precision score, or `None` if the input arrays are of unequal lengths.\n\nInput:\n```python\npred_match = np.array([0, 1, -1, 2, 1])\npred_scores = np.array([0.9, 0.8, 0.5, 0.7, 0.6])\ngt_match = np.array([0, 1, 2])\n```\n\nOutput:\n```python\n1.3333333730697632\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef compute_ap_from_matches_scores(pred_match, pred_scores, gt_match):\n    if pred_match.shape[0] != pred_scores.shape[0]:\n        return None\n\n    score_indices = np.argsort(pred_scores)[::-1]\n    pred_match = pred_match[score_indices]\n\n    total_matches = len(pred_match)\n    precisions = np.cumsum(pred_match > -1) / (np.arange(total_matches) + 1)\n    recalls = np.cumsum(pred_match > -1).astype(np.float32) / len(gt_match)\n\n    precisions = np.concatenate([[0], precisions, [0]])\n    recalls = np.concatenate([[0], recalls, [1]])\n    for i in range(len(precisions) - 2, -1, -1):\n        precisions[i] = max(precisions[i], precisions[i + 1])\n    indices = np.where(recalls[:-1] != recalls[1:])[0] + 1\n    ap = np.sum((recalls[indices] - recalls[indices - 1]) * precisions[indices])\n\n    return ap", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_preds = np.random.randint(1, 1000)\n        num_gts = np.random.randint(1, 1000)\n        pred_match = np.random.choice([-1] + list(range(num_gts)), size=num_preds)\n        pred_scores = np.random.rand(num_preds)\n        gt_match = np.random.randint(0, num_gts, size=num_gts)\n\n        test_cases.append((pred_match, pred_scores, gt_match))\n\n    return test_cases"}
{"problem_id": "numpy_104", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs inverse iteration to find an eigenvector corresponding to the eigenvalue of a tridiagonal matrix. The function signature is as follows:\n\n```python\ndef tridi_inverse_iteration(d, e, w, x0, rtol):\n```\n\n### Constants:\n- `rtol`: A relative tolerance value used to determine the convergence of the iteration process.\n\n### Input and Output Format:\n- **Input**: The function takes in five parameters: two 1D arrays (`d`, `e`), one scalar (`w`), one optional 1D array (`x0`), and one scalar (`rtol`).\n- **Output**: The function returns a 1D array representing the eigenvector corresponding to the specified eigenvalue.\n\nInput:\n```python\nd = np.array([0.4, 1.4, 1.1])\ne = np.array([1.6, -0.3])\nw = 1.0\nx0 = np.array([ 1., -0.9, 0.7])\nrtol = 1e-5\n```\n\nOutput:\n```python\narray([0.16980363, 0.07195827, 0.98284726])\n```", "ground_truth_code": "import numpy as np\n\ndef tridisolve(d, e, b):\n    N = len(b)\n    dw = d.copy()\n    ew = e.copy()\n\n    x = b\n\n    for k in range(1, N):\n        ew[k - 1] /= dw[k - 1]\n        dw[k] -= ew[k - 1] * e[k - 1]\n\n    for k in range(1, N):\n        x[k] -= ew[k - 1] * x[k - 1]\n\n    x[N - 1] /= dw[N - 1]\n    for k in range(N - 2, -1, -1):\n        x[k] = x[k] / dw[k] - ew[k] * x[k + 1]\n\n    return x\n\n# main code\ndef tridi_inverse_iteration(d, e, w, x0, rtol):\n    eig_diag = d - w\n\n    if x0 is None:\n        x0 = np.random.randn(len(d))\n\n    x_prev = np.zeros_like(x0)\n    x0 /= np.linalg.norm(x0)\n\n    while np.linalg.norm(np.abs(x0) - np.abs(x_prev)) > rtol:\n        x_prev = x0.copy()\n        tridisolve(eig_diag, e, x0)\n        x0 /= np.linalg.norm(x0)\n\n    return x0", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        N = np.random.randint(2, 100)\n        d = np.random.randn(N)\n        e = np.random.randn(N - 1)\n        w = np.random.randn()\n        x0 = np.random.randn(N)\n        rtol = np.random.uniform(1e-10, 1e-3)\n        test_cases.append((d, e, w, x0, rtol))\n\n    return test_cases"}
{"problem_id": "numpy_105", "library": "numpy", "code_problem": "You are tasked with implementing a function that converts a depth image into a 3D point cloud representation. The function should take into account the camera intrinsic parameters and an optional mask to filter the depth values. The function signature is as follows:\n\n```python\ndef depth_image_to_pointcloud3d(depth_image, camera_k, mask, subsample):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used to create a homogeneous coordinate for the pixel locations.\n\n### Input and Output Format:\n- **Input**:\n  - `depth_image`: A 3D NumPy array of shape (height, width, channels).\n  - `camera_k`: A 3x3 NumPy array representing the camera intrinsic matrix.\n  - `mask`: A 2D NumPy array of shape (height, width) or `None`.\n  - `subsample`: An integer value.\n\n- **Output**:\n  - A 2D NumPy array of shape (3, N) representing the 3D point cloud, where N is the number of valid points. If no valid points are found, an empty array of shape (3, 0) is returned.\n\n**Input:**\n```python\ndepth_image = np.array([[[5.0], [5.0]], [[10.0], [10.0]], [[15.0], [15.0]], [[0.0], [0.0]]])\ncamera_k = np.array([[1000, 0, 320],\n                     [0, 1000, 240],\n                     [0, 0, 1]])\nmask = np.array([[[1], [1]], [[1], [1]], [[1], [1]], [[0], [0]]], dtype=np.uint8)\nsubsample = 1\n```\n\n**Output:**\n```python\narray([[-1.6  , -1.595, -3.2  , -3.19 , -4.8  , -4.785],\n       [-1.2  , -1.2  , -2.39 , -2.39 , -3.57 , -3.57 ],\n       [ 5.   ,  5.   , 10.   , 10.   , 15.   , 15.   ]])\n```", "ground_truth_code": "import numpy as np\n\ndef depth_coords_to_camera_points(coords, z_vals, camera_k):\n    if coords.shape[0] != 2 or z_vals.shape[0] != 1 or coords.shape[1] != z_vals.shape[1]:\n        return np.empty((3, 0))\n\n    k_inv = np.linalg.inv(camera_k)\n    homogenous_uvs = np.concatenate((coords, np.ones((1, coords.shape[1]))))\n    unscaled_points = k_inv @ homogenous_uvs\n    scaled_points = np.multiply(unscaled_points, z_vals)\n    return scaled_points\n\n# main code\ndef depth_image_to_pointcloud3d(depth_image, camera_k, mask, subsample):\n    v_size, u_size, _ = depth_image.shape\n    u_img_range = np.arange(u_size)\n    v_img_range = np.arange(v_size)\n\n    u_grid, v_grid = np.meshgrid(u_img_range, v_img_range)\n    u_img, v_img, d = u_grid.ravel(), v_grid.ravel(), depth_image[v_grid, u_grid].ravel()\n\n    if mask is not None:\n        v_grid, u_grid = np.where(mask.squeeze())\n        u_img, v_img, d = u_grid.ravel(), v_grid.ravel(), depth_image[v_grid, u_grid].ravel()\n\n    if subsample > 1:\n        u_img, v_img, d = u_img[::subsample], v_img[::subsample], d[::subsample]\n\n    pc = depth_coords_to_camera_points(np.stack((u_img, v_img)), np.expand_dims(d, axis=0), camera_k)\n    d_zero_mask = pc[2, :] != 0\n    pc = pc[:, d_zero_mask]\n\n    return pc if pc.size > 0 else np.empty((3, 0))", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        v_size = np.random.randint(50, 1000)\n        u_size = np.random.randint(50, 1000)\n        depth_image = np.random.rand(v_size, u_size, 1) * 10\n        camera_k = np.array([[np.random.uniform(500, 2000), 0, np.random.uniform(200, 800)],\n                             [0, np.random.uniform(500, 2000), np.random.uniform(200, 800)],\n                             [0, 0, 1]])\n        if np.random.rand() > 0.5:\n            mask = (np.random.rand(v_size, u_size, 1) > 0.5).astype(np.uint8)\n        else:\n            mask = None\n        subsample = np.random.choice([1, 2, 4, 8, 16])\n\n        test_cases.append((depth_image, camera_k, mask, subsample))\n\n    return test_cases"}
{"problem_id": "numpy_106", "library": "numpy", "code_problem": "You are tasked with implementing a function that ranks data based on different ranking methods. The function should handle various input types and provide rankings according to specified methods. The function signature is as follows:\n\n```python\ndef rankdata(a, method):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used to adjust the ranking in the 'ordinal' method.\n\n### Input Format:\n- The input consists of two parameters:\n  - `a`: An array-like structure containing numerical values.\n  - `method`: A string indicating the ranking method.\n\n### Output Format:\n- The output is a numpy array of type `float64` containing the ranks of the input data based on the specified method.\n\nInput: \n```python\n([3, 1, 2, 2, 4], 'ordinal')\n```\n\nOutput: \n```python\narray([4., 1., 2., 3., 5.])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef rankdata(a, method):\n    arr = np.ravel(np.asarray(a))\n    if method == 'ordinal':\n        sorter = arr.argsort(kind='mergesort')\n    else:\n        sorter = arr.argsort(kind='quicksort')\n    inv = np.empty(sorter.size, dtype=np.intp)\n    inv[sorter] = np.arange(sorter.size)\n    if method == 'ordinal':\n        return (inv + 1).astype(np.float64)\n    arr = arr[sorter]\n    obs = np.ones(arr.size, np.bool_)\n    obs[1:] = arr[1:] != arr[:-1]\n    dense = obs.cumsum()[inv]\n    if method == 'dense':\n        return dense.astype(np.float64)\n    nonzero = np.nonzero(obs)[0]\n    count = np.concatenate((nonzero, np.array([len(obs)], nonzero.dtype)))\n    if method == 'max':\n        return count[dense].astype(np.float64)\n    if method == 'min':\n        return (count[dense - 1] + 1).astype(np.float64)\n    return 0.5 * (count[dense] + count[dense - 1] + 1)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        method = random.choice(['average', 'min', 'max', 'dense', 'ordinal'])\n\n        list_size = random.randint(0, 100)\n        if list_size == 0:\n            a = []\n        else:\n            a = []\n            for _ in range(list_size):\n                if random.choice([True, False]):\n                    a.append(random.randint(0, 100))\n                else:\n                    a.append(random.uniform(0, 100))\n\n            if random.choice([True, False]) and list_size > 1:\n                num_duplicates = random.randint(1, 5)\n                for _ in range(num_duplicates):\n                    value = random.choice(a)\n                    a.append(value)\n\n            if all(isinstance(x, float) for x in a):\n                a = [float(x) for x in a]\n            else:\n                a = [int(x) for x in a]\n        test_cases.append((a, method))\n    \n    return test_cases\n"}
{"problem_id": "numpy_107", "library": "numpy", "code_problem": "You are tasked with implementing a function that evaluates the performance of a classification model using precision, recall, and F1 score metrics. The function will take the true labels and predicted labels of a classification task, along with the list of class names, and return a structured summary of the performance metrics.\n\nFunction Signature:\n```python\ndef get_performance(y_true, y_pred, classes):\n```\n\nConstant used in the main code:\n- `zero_division=0`: This constant is used in the `precision_recall_fscore_support` function to handle cases where there is a division by zero, ensuring that the function returns 0 for precision, recall, or F1 score when there are no true positive samples.\n\nInput Format:\n- `y_true`: A list or array of true labels (ground truth).\n- `y_pred`: A list or array of predicted labels from the classification model.\n- `classes`: A list of class names corresponding to the labels.\n\nOutput Format:\n- A dictionary containing:\n  - An `'overall'` key with a dictionary of overall metrics (precision, recall, F1 score, and number of samples).\n  - A `'class'` key with a dictionary where each class name maps to its respective metrics (precision, recall, F1 score, and number of samples).\n\nInput:\n```python\ny_true = np.array(['class_0', 'class_1', 'class_0', 'class_2', 'class_1', 'class_0', 'class_2', 'class_1', 'class_0', 'class_2'])\ny_pred = np.array(['class_0', 'class_1', 'class_0', 'class_1', 'class_1', 'class_0', 'class_2', 'class_0', 'class_0', 'class_2'])\nclasses = ['class_0', 'class_1', 'class_2']\n```\n\nOutput:\n```python\n{\n    'overall': {\n        'precision': 0.8222222222222223, \n        'recall': 0.7777777777777777, \n        'f1': 0.7851851851851851, \n        'num_samples': 10.0\n    }, \n    'class': {\n        'class_0': {\n            'precision': 0.8, \n            'recall': 1.0, \n            'f1': 0.8888888888888888, \n            'num_samples': 4.0\n        }, \n        'class_1': {\n            'precision': 0.6666666666666666, \n            'recall': 0.6666666666666666, \n            'f1': 0.6666666666666666, \n            'num_samples': 3.0\n        }, \n        'class_2': {\n            'precision': 1.0, \n            'recall': 0.6666666666666666, \n            'f1': 0.8, 'num_samples': 3.0\n        }\n    }\n}\n\n```", "ground_truth_code": "from sklearn.metrics import precision_recall_fscore_support\nimport numpy as np\n\n# main code\ndef get_performance(y_true, y_pred, classes):\n    performance = {'overall': {}, 'class': {}}\n\n    metrics = precision_recall_fscore_support(y_true, y_pred, labels=classes, zero_division=0)\n\n    performance['overall']['precision'] = np.mean(metrics[0])\n    performance['overall']['recall'] = np.mean(metrics[1])\n    performance['overall']['f1'] = np.mean(metrics[2])\n    performance['overall']['num_samples'] = np.float64(np.sum(metrics[3]))\n\n    for i, class_name in enumerate(classes):\n        performance['class'][class_name] = {\n            'precision': metrics[0][i],\n            'recall': metrics[1][i],\n            'f1': metrics[2][i],\n            'num_samples': np.float64(metrics[3][i])\n        }\n\n    return performance", "test_script": "from random import randint\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = randint(10, 500)\n        num_classes = randint(2, 10)\n        classes = [f'class_{i}' for i in range(num_classes)]\n        y_true = np.random.choice(classes, size=num_samples)\n        y_pred = np.random.choice(classes, size=num_samples)\n        test_cases.append((y_true, y_pred, classes))\n\n    return test_cases\n"}
{"problem_id": "numpy_108", "library": "numpy", "code_problem": "You are tasked with creating a function that generates a synthetic dataset for a treatment-outcome analysis. The dataset will include treatment variables, outcome variables, and common causes, which can be either linear or nonlinear in their relationships. The function should also allow for the specification of the number of samples, the presence of an effect, the number of common causes, and the standard deviation of the error terms.\n\nFunction signature:\n```python\ndef xy_dataset(num_samples, effect, num_common_causes, is_linear, sd_error):\n```\n\nConstant used in the main code:\n- The constant value `6` is used as a baseline in the calculations for both the treatment and outcome variables.\n\nInput format:\n- `num_samples`: An integer representing the number of samples to generate.\n- `effect`: A boolean indicating whether to include an effect in the outcome variable.\n- `num_common_causes`: An integer representing the number of common causes to generate.\n- `is_linear`: A boolean indicating whether the relationship is linear or nonlinear.\n- `sd_error`: A float representing the standard deviation of the error terms.\n\nOutput format:\n- The function returns a dictionary containing:\n  - `'df'`: A pandas DataFrame with the generated dataset.\n  - `'treatment_name'`: A string with the name of the treatment variable.\n  - `'outcome_name'`: A string with the name of the outcome variable.\n  - `'common_causes_names'`: A list of strings with the names of the common causes.\n  - `'time_val'`: A string with the name of the time variable.\n  - Additional keys for instrument names, graph representations, and average treatment effect, which are set to `None`.\n\nInput:\n```python\n(100, True, 3, False, 5)\n```\n\nOutput:\n```python\n{\n    'df':     \n        Treatment    Outcome        w0         s        w1        w2\n        0   15.911283  27.681377 -0.732161  8.807716 -0.845115  0.497048\n        1   17.771765  23.124647 -3.262345  7.858869  0.135733  0.348621\n        2    7.288656  16.064423  1.865400  4.461027 -1.228858  0.383170\n        3   13.983270  26.037520 -3.171491  7.910225 -0.622701 -0.709873\n        4    7.163848  19.244425  2.512352  1.780308 -1.146848  1.432720\n        ..        ...        ...       ...       ...       ...       ...\n        95  20.519980  37.630564  3.972902  2.835384  1.077699  1.051470\n        96  12.905052  30.622040 -2.361960  8.279860  0.607713 -1.219993\n        97  16.336395  13.037045  0.651143  1.170012  0.160932 -0.281834\n        98   9.117931  20.653272  2.219331  1.665583  1.413883  0.428102\n        99  19.125715  29.581851 -2.146089  5.638416  0.666574  0.477330\n        [100 rows x 6 columns], \n    'treatment_name': 'Treatment', \n    'outcome_name': 'Outcome', \n    'common_causes_names': ['w0', 'w1', 'w2'], \n    'time_val': 's', \n    'instrument_names': None, \n    'dot_graph': None, \n    'gml_graph': None, \n    'ate': None\n}\n``` \n\n(Note: The actual DataFrame content will vary due to the randomness in the generation process.)", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef xy_dataset(num_samples, effect, num_common_causes, is_linear, sd_error):\n    treatment = 'Treatment'\n    outcome = 'Outcome'\n    common_causes = ['w' + str(i) for i in range(num_common_causes)]\n    time_var = 's'\n    E1 = np.random.normal(loc=0, scale=sd_error, size=num_samples)\n    E2 = np.random.normal(loc=0, scale=sd_error, size=num_samples)\n    S = np.random.uniform(0, 10, num_samples)\n    T1 = 4 - (S - 3) * (S - 3)\n    T1[S >= 5] = 0\n    T2 = (S - 7) * (S - 7) - 4\n    T2[S <= 5] = 0\n    W0 = T1 + T2\n    (tterm, yterm) = (0, 0)\n    if num_common_causes > 1:\n        means = np.random.uniform(-1, 1, num_common_causes - 1)\n        cov_mat = np.diag(np.ones(num_common_causes - 1))\n        otherW = np.random.multivariate_normal(means, cov_mat, num_samples)\n        c1 = np.random.uniform(0, 1, (otherW.shape[1], 1))\n        c2 = np.random.uniform(0, 1, (otherW.shape[1], 1))\n        tterm = (otherW @ c1)[:, 0]\n        yterm = (otherW @ c2)[:, 0]\n    if is_linear:\n        V = 6 + W0 + tterm + E1\n        Y = 6 + W0 + yterm + E2\n        if effect:\n            Y += V\n        else:\n            Y += 6 + W0\n    else:\n        V = 6 + W0 * W0 + tterm + E1\n        Y = 6 + W0 * W0 + yterm + E2\n        if effect:\n            Y += V\n        else:\n            Y += 6 + W0\n    dat = {treatment: V, outcome: Y, common_causes[0]: W0, time_var: S}\n    if num_common_causes > 1:\n        for i in range(otherW.shape[1]):\n            dat[common_causes[i + 1]] = otherW[:, i]\n    data = pd.DataFrame(data=dat)\n    ret_dict = {'df': data, 'treatment_name': treatment, 'outcome_name': outcome, 'common_causes_names': common_causes, 'time_val': time_var, 'instrument_names': None, 'dot_graph': None, 'gml_graph': None, 'ate': None}\n    return ret_dict", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(1, 1000)\n        effect = random.choice([True, False])\n        num_common_causes = random.randint(1, 10)\n        is_linear = random.choice([True, False])\n        sd_error = random.randint(0, 10)\n\n        test_cases.append((num_samples, effect, num_common_causes, is_linear, sd_error))\n\n    return test_cases\n"}
{"problem_id": "numpy_109", "library": "numpy", "code_problem": "```python\ndef get_stark(kpt, nr, rpts, ptg_nsym, ptg_symrel):\n```\n\nIn this code, the function `get_stark` computes a complex array based on the input parameters. The constant used in the main code is `two_pi`, which is defined as `2.0 * np.pi`.\n\n\n### Input and Output Format:\n- **Input**: \n  - `kpt`: A vector representing a point in reciprocal space.\n  - `nr`: An integer representing the size of the output array.\n  - `rpts`: A matrix representing real space points.\n  - `ptg_nsym`: An integer representing the number of symmetry operations.\n  - `ptg_symrel`: A list of matrices representing symmetry relations.\n\n- **Output**: \n  - A complex array of size `nr` containing the computed values based on the input parameters.\n\nInput:\n```python\nkpt = np.array([0.5, 0.2, 0.8])\nnr = 3\nrpts = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nptg_nsym = 2\nptg_symrel = [np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), \n               np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]])]\n```\n\nOutput:\n```python\narray([ 0.02703656+0.8603173j , -0.09037162-0.02625538j, -0.42162496+0.62040229j])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_stark(kpt, nr, rpts, ptg_nsym, ptg_symrel):\n    two_pi = 2.0 * np.pi\n    skr = np.zeros(nr, dtype=complex)\n    _np_exp = np.exp\n    for omat in ptg_symrel:\n        sk = two_pi * np.matmul(omat.T, kpt)\n        skr += _np_exp(1j * np.matmul(rpts, sk))\n    skr /= ptg_nsym\n    return skr", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    \n    for _ in range(n):\n        kpt = np.random.rand(3)\n        nr = random.randint(1, 10)\n        rpts = np.random.rand(nr, 3)\n        ptg_nsym = random.randint(1, nr)\n        ptg_symrel = []\n        for _ in range(ptg_nsym):\n            sym_matrix = np.random.rand(3, 3)\n            q, _ = np.linalg.qr(sym_matrix)\n            ptg_symrel.append(q)\n        test_cases.append((kpt, nr, rpts, ptg_nsym, ptg_symrel))\n    \n    return test_cases\n"}
{"problem_id": "numpy_110", "library": "numpy", "code_problem": "You are given a crystal lattice, a **k-point** in reciprocal space, and the **point-group symmetries** of the lattice.  \nFor every lattice vector **R** you want to evaluate the *first derivative* of the structure factor  \n\n\\[\nS(\\mathbf k)=\\sum_{\\mathbf R}\\;e^{\\,i\\,2\\pi\\,\\mathbf k\\!\\cdot\\!\\mathbf R},\n\\]\n\naveraged over all symmetry operations of the point group.  \nMathematically, the derivative (with respect to **k**) averaged over *N<sub>sym</sub>* symmetry operations **O** is\n\n\\[\n\\frac{1}{N_{\\text{sym}}}\\sum_{O}\n\\left[\n\\,\\mathrm i\\,2\\pi\n\\;e^{\\,i\\,2\\pi\\,(O^{\\mathsf T}\\mathbf k)\\!\\cdot\\!\\mathbf R}\\;O\\mathbf R\n\\right].\n\\]\n\nThe result is a **3 \u00d7 N<sub>R</sub>** complex array whose *j-th column* is the derivative vector for the *j-th lattice point*.\n\nYour task is to implement a function `get_stark_dk1` that computes this quantity efficiently.\n\n```python\ndef get_stark_dk1(kpt, nr, ptg_nsym, rpts, ptg_symrel):\n```\n\nInput format:\n- `kpt`: A 1D array representing the wave vector.\n- `nr`: An integer representing the number of lattice points.\n- `ptg_nsym`: An integer representing the number of symmetry operations.\n- `rpts`: A 2D array of shape (nr, 3) representing the lattice points.\n- `ptg_symrel`: A list of 2D arrays, where each array represents a symmetry operation.\n\nOutput format:\n- The function returns a 2D array of shape (3, nr) containing complex numbers, which represent the transformed values based on the input parameters.\n\nInput:\n```python\nkpt = np.array([0.5, -0.3, 0.1])\nnr = 3\nptg_nsym = 2\nrpts = np.array([[0.1, 0.2, 0.3], [1.0, 1.5, 1.2], [0.5, 0.5, 0.5]])\nptg_symrel = [np.array([[1, 0, 0], [0, 1, 0], [0, 0, 1]]), \n               np.array([[0, -1, 0], [1, 0, 0], [0, 0, 1]])]\n```\n\nOutput:\n```python\narray([[-0.06504519-3.12959644e-02j, -0.11881887-4.37743452e-01j, -0.4045085 +2.93892626e-01j],\n       [ 0.01685594+1.39662320e-01j, -0.87011966+8.13728782e-01j, 0.        +2.77555756e-17j],\n       [ 0.0693678 +2.70169754e-01j, -0.78125158+8.31948436e-01j, 0.        +2.77555756e-17j]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_stark_dk1(kpt, nr, ptg_nsym, rpts, ptg_symrel):\n    srk_dk1 = np.zeros((3, nr), dtype=complex)\n    two_pi = 2.0 * np.pi\n    for omat in ptg_symrel:\n        sk = two_pi * np.matmul(omat.T, kpt)\n        exp_skr = np.exp(1j * np.matmul(rpts, sk))\n        for (ir, rr) in enumerate(rpts):\n            srk_dk1[:, ir] += exp_skr[ir] * np.matmul(omat, rr)\n    srk_dk1 *= 1j / ptg_nsym\n    return srk_dk1", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        kpt = np.random.uniform(-1, 1, size=3)\n        nr = random.randint(1, 10)\n        ptg_nsym = random.randint(1, 5)\n        rpts = np.random.uniform(0, 2, size=(nr, 3))\n        ptg_symrel = []\n        for _ in range(ptg_nsym):\n            mat = np.random.rand(3, 3) * 2 - 1\n            ptg_symrel.append(mat)\n        test_cases.append((kpt, nr, ptg_nsym, rpts, ptg_symrel))\n\n    return test_cases\n"}
{"problem_id": "numpy_111", "library": "numpy", "code_problem": "In image and volume processing you often need an **affine matrix** that combines per-axis zoom, an optional left\u2013right flip, and a centering shift\u2014all in one shot.  \nWrite a function that returns a NumPy float matrix implementing that transform for arrays of up to three dimensions.\n\n```python\ndef shape_zoom_affine(shape: list, zooms: list, x_flip: bool) -> np.ndarray:\n```\n\nIn this function, the constant used is `3`, which is utilized to ensure that the input dimensions are padded to a minimum of three dimensions.\n\nInput format:\n- `shape`: A list of integers representing the dimensions of the shape.\n- `zooms`: A list of floats representing the zoom factors for each dimension.\n- `x_flip`: A boolean indicating whether to flip the shape along the x-axis.\n\nOutput format:\n- Returns a 4x4 numpy array representing the affine transformation matrix.\n\n```python\nInput: (shape=array([64, 32, 16]), zooms=array([1.5, 0.5, 2.0]), x_flip=True)\nOutput: array([[ -1.5 ,   0.  ,   0.  ,  47.25],\n               [  0.  ,   0.5 ,   0.  ,  -7.75],\n               [  0.  ,   0.  ,   2.  , -15.  ],\n               [  0.  ,   0.  ,   0.  ,   1.  ]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef shape_zoom_affine(shape, zooms, x_flip):\n    ndims = len(shape)\n    shape = shape[:3] if ndims >= 3 else np.pad(shape, (0, 3 - ndims), constant_values=1)\n    zooms = zooms[:3] if ndims >= 3 else np.pad(zooms, (0, 3 - ndims), constant_values=1)\n\n    if x_flip:\n        zooms[0] *= -1\n\n    origin = (shape - 1) / 2.0\n    aff = np.eye(4)\n    aff[:3, :3] = np.diag(zooms)\n    aff[:3, -1] = -origin * zooms\n\n    return aff", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(1, 100, size=random.choice([1, 2, 3, 4, 5]))\n        zooms = np.random.uniform(0.1, 3.0, size=len(shape))\n        x_flip = random.choice([True, False])\n        test_cases.append((shape, zooms, x_flip))\n\n    return test_cases"}
{"problem_id": "numpy_112", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the interpolation weights for a given set of points in a multidimensional space. The function will utilize Delaunay triangulation to determine the relationship between the input points and the specified coordinates.\n\nFunction signature:\n```python\ndef interp_weights(xyz, uvw, d):\n```\n\n### Constants:\n- The constant used in the main code is `d`, which represents the dimensionality of the input points.\n\n### Input Format:\n- `xyz`: A list or array of points in a d-dimensional space (shape: (n, d)).\n- `uvw`: A list or array of points for which interpolation weights are to be computed (shape: (m, d)).\n- `d`: An integer representing the dimensionality of the input points.\n\n### Output Format:\n- A tuple containing:\n  - `vertices`: An array of the vertices of the simplices that contain each point in `uvw`.\n  - `weights`: An array of the interpolation weights corresponding to each point in `uvw`.\n\nInput:\n```python\n([[74., 15.],[9., 89.],[7., 95.],[78., 59.]],\n [[75., 15.],[74., 15.],[9., 90.],[9., 90.]],\n 2)\n```\n\nOutput:\n```python\n(array([[1, 0, 3],[1, 0, 3],[1, 3, 2],[1, 3, 2]], dtype=int32), \n array([[-0.013942,  0.990494,  0.023447],\n       [ 0.      ,  1.      ,  0.      ],\n       [ 0.799435,  0.00565 ,  0.194915],\n       [ 0.799435,  0.00565 ,  0.194915]])\n )\n```", "ground_truth_code": "import numpy as np\nfrom scipy.spatial import qhull as qhull\n\n# main code\ndef interp_weights(xyz, uvw, d):\n    uvw = np.array(uvw)\n    if uvw.shape[-1] != d:\n        uvw = uvw.T\n    xyz = np.array(xyz)\n    if xyz.shape[-1] != d:\n        xyz = xyz.T\n\n    tri = qhull.Delaunay(xyz)\n    simplex = tri.find_simplex(uvw)\n    vertices = np.take(tri.simplices, simplex, axis=0)\n    temp = np.take(tri.transform, simplex, axis=0)\n    delta = uvw - temp[:, d]\n    bary = np.einsum('njk,nk->nj', temp[:, :d, :], delta)\n    weights = np.hstack((bary, 1 - bary.sum(axis=1, keepdims=True)))\n    weights = np.round(weights, 6)\n    return (vertices, weights)", "test_script": "import numpy as np\nfrom scipy.spatial import qhull as qhull\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        d = np.random.randint(2, 5)\n        num_points = np.random.randint(d + 1, 50)\n        xyz = np.random.rand(num_points, d) * 100\n        num_queries = np.random.randint(1, 20)\n        uvw = xyz[np.random.choice(num_points, num_queries)] + np.random.rand(num_queries, d) * 0.1\n        test_cases.append((xyz.tolist(), uvw.tolist(), d))\n\n    return test_cases"}
{"problem_id": "numpy_113", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a sequence of logarithmically spaced integers between a specified lower and upper bound. The function should allow for customization of the spacing ratio and the number of points in the sequence. Additionally, the function can optionally prepend a zero to the output sequence.\n\nFunction signature:\n```python\ndef logbins_numba(lo: float, hi: float, ratio: float, N: int, prepend_zero: bool) -> np.ndarray:\n```\n\n### Constants:\n- The constant used in the main code is `10`, which is utilized for generating logarithmic values.\n\n### Input Format:\n- `lo`: A float representing the lower bound of the range.\n- `hi`: A float representing the upper bound of the range.\n- `ratio`: A float representing the ratio for logarithmic spacing.\n- `N`: An integer representing the desired number of points in the sequence.\n- `prepend_zero`: A boolean indicating whether to prepend a zero to the output array.\n\n### Output Format:\n- The function returns a NumPy array of integers that are logarithmically spaced between `lo` and `hi`, with optional inclusion of `0` at the beginning.\n\n```python\nInput: (10, 100, 2.0, 0, True)\nOutput: array([  0,  10,  32, 100])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef logbins_numba(lo, hi, ratio, N, prepend_zero):\n    lo = int(lo)\n    hi = int(hi)\n\n    if ratio != 0 and N == 0:\n        N = np.log(hi / lo) / np.log(ratio)\n    elif N == 0:\n        N = 10\n\n    N = max(1, int(N))\n\n    data10 = 10 ** np.linspace(np.log10(lo), np.log10(hi), N)\n    data10 = np.rint(data10).astype(np.int_)\n    data10_int = np.sort(np.unique(data10))\n\n    if len(data10_int) == 0:\n        return np.array([0] if prepend_zero else [])\n\n    if data10_int[0] != lo:\n        data10_int = np.insert(data10_int, 0, lo)\n    if data10_int[-1] != hi:\n        data10_int = np.append(data10_int, hi)\n    if prepend_zero:\n        data10_int = np.concatenate(([0], data10_int))\n\n    return data10_int", "test_script": "import random\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        lo = random.randint(1, 100)\n        hi = random.randint(lo + 1, lo + 100)\n        ratio = random.uniform(1.01, 5.0) if random.choice([True, False]) else 0\n        N = random.randint(0, 50)\n        prepend_zero = random.choice([True, False])\n\n        test_cases.append((lo, hi, ratio, N, prepend_zero))\n\n    return test_cases"}
{"problem_id": "numpy_114", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a mapping and demapping table for Quadrature Amplitude Modulation (QAM) based on a given modulation order \\( M \\). The function should handle special cases for \\( M = 8 \\) and \\( M = 32 \\) and generate the appropriate Gray code and constellation points for other values of \\( M \\).\n\nFunction signature:\n```python\ndef qam_mod(M):\n```\n\nConstant used in the main code:\n- The constant values used in the special cases are \\( 8 \\) and \\( 32 \\).\n\nInput format:\n- The function takes a single integer \\( M \\) as input, which represents the modulation order for QAM.\n\nOutput format:\n- The function returns a tuple containing two dictionaries: the first dictionary is the mapping table from Gray code to constellation points, and the second dictionary is the demapping table from constellation points back to Gray code.\n\nHere is a short test case input and output pair for the provided ground truth code:\n\n**Example Input & Output:**\n\nInput: `16`\n\nOutput: \n```python\n({0: (-3-3j), 1: (-3-1j), 3: (-3+1j), 2: (-3+3j), 4: (-1-3j), 5: (-1-1j), 7: (-1+1j), 6: (-1+3j), 12: (1-3j), 13: (1-1j), 15: (1+1j), 14: (1+3j), 8: (3-3j), 9: (3-1j), 11: (3+1j), 10: (3+3j)}, \n {(-3-3j): 0, (-3-1j): 1, (-3+1j): 3, (-3+3j): 2, (-1-3j): 4, (-1-1j): 5, (-1+1j): 7, (-1+3j): 6, (1-3j): 12, (1-1j): 13, (1+1j): 15, (1+3j): 14, (3-3j): 8, (3-1j): 9, (3+1j): 11, (3+3j): 10})\n\n``` \n\nThis input corresponds to the QAM modulation for M=16, and the output includes the mapping and demapping tables.", "ground_truth_code": "import numpy as np\nimport math\n\n# main code\ndef qam_mod(M):\n    sqrtM = int(math.sqrt(M))\n    special_cases = {8: (np.array([0, 1, 3, 7, 5, 4, 6, 2]),\n                         [-2 - 2j, -2 + 0j, -2 + 2j, 0 + 2j, 2 + 2j, 2 + 0j, 2 - 2j, 0 - 2j]),\n                     32: (np.zeros(M, dtype=int),\n                          [(-7 - 3j + 2 * (x + y * 1j)) for (x, y) in np.ndindex(8, 4)])}\n\n    if M in special_cases:\n        graycode, constellation = special_cases[M]\n        if M == 32:\n            temp1 = np.bitwise_xor(np.arange(8), np.right_shift(np.arange(8), 1))\n            temp2 = np.bitwise_xor(np.arange(4), np.right_shift(np.arange(4), 1))\n            num = 0\n            for i in temp1:\n                for j in temp2:\n                    graycode[num] = 4 * i + j\n                    num += 1\n    else:\n        temp = np.bitwise_xor(np.arange(sqrtM), np.right_shift(np.arange(sqrtM), 1))\n        graycode = np.zeros(M, dtype=int)\n        constellation = [-(sqrtM - 1) * (1 + 1j) + 2 * (x + y * 1j) for (x, y) in np.ndindex(sqrtM, sqrtM)]\n        num = 0\n        for i in temp:\n            for j in temp:\n                graycode[num] = sqrtM * i + j\n                num += 1\n\n    map_table = dict(zip(graycode, constellation))\n    demap_table = {v: k for (k, v) in map_table.items()}\n    return (map_table, demap_table)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    valid_M_values = [8, 16, 32, 64, 128, 256]\n\n    for _ in range(n):\n        M = random.choice(valid_M_values)\n        test_cases.append(M)\n\n    return test_cases"}
{"problem_id": "numpy_115", "library": "numpy", "code_problem": "You are tasked with implementing a function that generates a grid of pixel coordinates for a given dimension and size. The function should normalize the pixel coordinates to a range of [-1, 1] and optionally flatten the output.\n\nFunction signature:\n```python\ndef get_mgrid(sidelen, dim, flatten):\n```\n\nConstant used in the main code:\n- The constant `2.0` is used to scale the pixel coordinates after normalization.\n\nInput format:\n- `sidelen`: An integer or a tuple of integers representing the size of each dimension.\n- `dim`: An integer (2 or 3) representing the number of dimensions for the grid.\n- `flatten`: A boolean indicating whether to flatten the output tensor.\n\nOutput format:\n- A PyTorch tensor containing the normalized pixel coordinates in the specified dimension, optionally flattened.\n\n```python\nInput: ((5, 5), 2, True)\nOutput: tensor(\n       [[-1.0000, -1.0000],\n        [-1.0000, -0.5000],\n        [-1.0000,  0.0000],\n        [-1.0000,  0.5000],\n        [-1.0000,  1.0000],\n        [-0.5000, -1.0000],\n        [-0.5000, -0.5000],\n        [-0.5000,  0.0000],\n        [-0.5000,  0.5000],\n        [-0.5000,  1.0000],\n        [ 0.0000, -1.0000],\n        [ 0.0000, -0.5000],\n        [ 0.0000,  0.0000],\n        [ 0.0000,  0.5000],\n        [ 0.0000,  1.0000],\n        [ 0.5000, -1.0000],\n        [ 0.5000, -0.5000],\n        [ 0.5000,  0.0000],\n        [ 0.5000,  0.5000],\n        [ 0.5000,  1.0000],\n        [ 1.0000, -1.0000],\n        [ 1.0000, -0.5000],\n        [ 1.0000,  0.0000],\n        [ 1.0000,  0.5000],\n        [ 1.0000,  1.0000]])\n```", "ground_truth_code": "import torch\nimport numpy as np\n\n# main code\ndef get_mgrid(sidelen, dim, flatten):\n    sidelen = (dim * (sidelen,) if isinstance(sidelen, int) else sidelen)\n\n    pixel_coords = None\n    if dim == 2:\n        pixel_coords = np.stack(np.mgrid[:sidelen[0], :sidelen[1]], axis=-1)[None, ...].astype(np.float32)\n        pixel_coords[0, :, :, 0] /= max(sidelen[0] - 1, 1)\n        pixel_coords[0, :, :, 1] /= max(sidelen[1] - 1, 1)\n    elif dim == 3:\n        pixel_coords = np.stack(np.mgrid[:sidelen[0], :sidelen[1], :sidelen[2]], axis=-1)[None, ...].astype(np.float32)\n        pixel_coords[..., 0] /= max(sidelen[0] - 1, 1)\n        pixel_coords[..., 1] /= max(sidelen[1] - 1, 1)\n        pixel_coords[..., 2] /= max(sidelen[2] - 1, 1)\n\n    if pixel_coords is None:\n        return torch.tensor([])\n\n    pixel_coords -= 0.5\n    pixel_coords *= 2.0\n    pixel_coords = torch.from_numpy(pixel_coords)\n\n    if flatten:\n        pixel_coords = pixel_coords.view(-1, dim)\n\n    return pixel_coords", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dim = random.choice([2, 3])\n        if dim == 2:\n            sidelen = (random.randint(2, 100), random.randint(2, 100))\n        else:\n            sidelen = (random.randint(2, 30), random.randint(2, 30), random.randint(2, 30))\n\n        flatten = random.choice([True, False])\n        test_cases.append((sidelen, dim, flatten))\n\n    return test_cases"}
{"problem_id": "numpy_116", "library": "numpy", "code_problem": "```python\ndef process_parameters_psd(dim, mean, cov):\n```\n\nIn this function, the goal is to process the input parameters `dim`, `mean`, and `cov` to ensure they are in the correct format for further statistical analysis, particularly for creating a positive semi-definite covariance matrix.\n\n### Constant Used:\n- The constant `1.0` is used to initialize the covariance matrix when it is not provided.\n\n### Input Format:\n- The function takes three parameters:\n  - `dim`: An integer or `None` representing the dimension.\n  - `mean`: A list, array, or `None` representing the mean values.\n  - `cov`: A list, array, or `None` representing the covariance values.\n\n### Output Format:\n- The function returns a tuple containing:\n  - An integer representing the dimension.\n  - A NumPy array representing the mean.\n  - A NumPy array representing the covariance matrix.\n\nInput:\n```python\ndim = 2\nmean = [1.5, -0.5]\ncov = [[1.0, 0.5], [0.5, 2.0]]\n```\n\nOutput:\n```python\n(2, array([ 1.5, -0.5]), array([[1. , 0.5], [0.5, 2. ]]))\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef process_parameters_psd(dim, mean, cov):\n    dim = 1 if dim is None else dim\n\n    if mean is not None:\n        mean = np.asarray(mean, dtype=float)\n        dim = mean.size\n    elif cov is not None:\n        cov = np.asarray(cov, dtype=float)\n        dim = 1 if cov.ndim < 2 else cov.shape[0]\n\n    mean = np.zeros(dim) if mean is None else np.asarray(mean, dtype=float)\n    cov = np.array(1.0) if cov is None else np.asarray(cov, dtype=float)\n\n    if dim == 1:\n        mean = mean.reshape(1)\n        if cov.ndim == 0 or cov.size == 1:\n            cov = cov.reshape(1, 1)\n        else:\n            cov = np.array([[np.mean(cov)]])\n\n    if cov.ndim == 0:\n        cov = cov * np.eye(dim)\n    elif cov.ndim == 1:\n        cov = np.diag(cov)\n    elif cov.ndim == 2 and cov.shape != (dim, dim):\n        rows, cols = cov.shape\n        cov = np.eye(dim) if rows != cols else np.zeros((dim, dim))\n    elif cov.ndim > 2:\n        cov = np.eye(dim)\n\n    return dim, mean, cov", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dim = random.choice([None, random.randint(1, 20)])\n        if random.random() < 0.5:\n            mean = None\n        else:\n            mean = np.random.randn(dim if dim is not None else random.randint(1, 20))\n\n        cov_case = random.choice([None, 0, 1, 2, 3])\n        if cov_case == 0:\n            cov = None\n        elif cov_case == 1:\n            cov = random.uniform(0.1, 10.0)\n        elif cov_case == 2:\n            size = dim if dim is not None else (mean.size if mean is not None else random.randint(1, 20))\n            cov = np.abs(np.random.randn(size))\n        elif cov_case == 3:\n            size = dim if dim is not None else (mean.size if mean is not None else random.randint(1, 20))\n            cov = np.random.randn(size, size)\n        else:\n            shape = random.choice([(random.randint(1, 10), random.randint(1, 10)), (2, 3), (3, 2)])\n            cov = np.random.randn(*shape)\n        test_cases.append((dim, mean, cov))\n    return test_cases"}
{"problem_id": "numpy_117", "library": "numpy", "code_problem": "```python\ndef process_parameters(n, p, eps):\n```\n\nIn this function, the goal is to process a set of parameters represented by an integer array `n` and a 2D array `p`, while also considering a small threshold value `eps`. The function performs the following steps:\n\nThe constant used in the main code is `eps`, which serves as a threshold for determining whether adjustments to the last column of `p` should be made.\n\nInput format:\n- `n`: An array of integers.\n- `p`: A 2D array of floats.\n- `eps`: A float representing a small threshold value.\n\nOutput format:\n- A tuple containing:\n  - The processed array `n`.\n  - The adjusted array `p`.\n  - A boolean array indicating the presence of invalid values in either `n` or `p`.\n\nInput:\n```python\nn = np.array([5, 10, -3])\np = np.array([[0.2, 0.3, 0.5], [0.1, 0.4, 0.5], [1.2, -0.1, 0.9]])\neps = 0.01\n```\n\nOutput:\n```python\n(n, p, ncond | pcond) = (array([ 5, 10, -3]), array([[ 0.2,  0.3,  0.5], [ 0.1,  0.4,  0.5], [ 1.2, -0.1, -0.1]]), array([False, False,  True]))\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef process_parameters(n, p, eps):\n    p = np.array(p, dtype=np.float64, copy=True)\n    p_adjusted = 1.0 - p[..., :-1].sum(axis=-1)\n    i_adjusted = np.abs(p_adjusted) > eps\n    p[i_adjusted, -1] = p_adjusted[i_adjusted]\n    pcond = np.any(p < 0, axis=-1)\n    pcond |= np.any(p > 1, axis=-1)\n    n = np.array(n, dtype=int, copy=True)\n    ncond = n < 0\n    return (n, p, ncond | pcond)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_values = np.random.randint(-10, 100, size=np.random.randint(1, 10))\n        p_shape = (n_values.size, np.random.randint(2, 10))\n        p_values = np.random.uniform(-0.1, 1.1, size=p_shape)\n        eps = np.random.uniform(1e-9, 1e-2)\n\n        test_cases.append((n_values, p_values, eps))\n\n    return test_cases"}
{"problem_id": "numpy_118", "library": "numpy", "code_problem": "The task is to implement a function that processes a given size and the dimensions of a shape defined by two lists. The function should ensure that the size is a valid non-negative integer or default to 1 if it is not. It will then compute the product of the size and return a tuple containing the product and the combined dimensions of the size and shape.\n\nFunction signature:\n```python\ndef process_size_shape(size, r, c):\n```\n\nConstant used in the main code:\n- The constant value used in the code is `1`, which is the default size when the input size is `None` or invalid.\n\nInput format:\n- The function takes three parameters:\n  - `size`: Can be an integer, a list of integers, or `None`.\n  - `r`: A list of integers representing one dimension of the shape.\n  - `c`: A list of integers representing another dimension of the shape.\n\nOutput format:\n- The function returns a tuple containing:\n  - An integer representing the product of the size.\n  - A tuple that combines the size and the shape dimensions.\n\nInput: `([3, 5], [0.6, 0.7], [0.8])`  \nOutput: `(15, (3, 5, 2, 1))`\n\n", "ground_truth_code": "import numpy as np\n\n# main code\ndef process_size_shape(size, r, c):\n    shape = (len(r), len(c))\n    size = np.atleast_1d(size) if size is not None else np.array([1])\n    size = np.where((np.issubdtype(size.dtype, np.integer) & (size >= 0)), size, np.array([1]))\n    return (np.prod(size), tuple(size) + shape)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_len = np.random.randint(1, 5)\n        size = np.random.randint(0, 10, size_len).astype(int)\n\n        if np.random.rand() < 0.2:\n            size = None\n\n        r_len = np.random.randint(1, 5)\n        c_len = np.random.randint(1, 5)\n\n        r = np.random.rand(r_len).tolist()\n        c = np.random.rand(c_len).tolist()\n        test_cases.append((size, r, c))\n\n    return test_cases"}
{"problem_id": "numpy_119", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the expected value of a quantum operator in a two-dimensional space. The function will utilize numerical integration techniques to evaluate the expected value based on a given wave function and operator.\n\nFunction Signature:\n```python\ndef expectedValueOperator2D(X: np.ndarray, Y: np.ndarray, psi: np.ndarray, result: np.ndarray, operator: Optional[Callable], t: float, extra_param: Any, doConjugate: bool) -> float:\n```\n\n### Constants Used:\n- The constant used in the main code is derived from the dimensions of the input arrays `X` and `Y`, specifically the differences between the last and first elements of these arrays, which are used to calculate the integration step sizes.\n\n### Input Format:\n- The function accepts the following inputs:\n  - `X`: A 1D numpy array of floats.\n  - `Y`: A 1D numpy array of floats.\n  - `psi`: A 2D numpy array of complex numbers.\n  - `result`: A 2D numpy array of complex numbers (initialized to zeros).\n  - `operator`: A callable function or a 2D numpy array representing the operator.\n  - `t`: A float value.\n  - `extra_param`: Any additional parameter required by the operator.\n  - `doConjugate`: A boolean value.\n\n### Output Format:\n- The function returns a float representing the expected value computed from the wave function and the operator.\n\nInput:\n```python\nX = np.array([0.0, 0.5, 1.0])\nY = np.array([0.0, 0.5, 1.0])\npsi = np.array([[1 + 1j, 2 + 2j, 3 + 3j],\n                 [4 + 4j, 5 + 5j, 6 + 6j],\n                 [7 + 7j, 8 + 8j, 9 + 9j]])\nresult = np.zeros((3, 3), dtype=complex)\noperator = np.array([[1.0, 0.0], [0.0, 1.0], [0.0, 0.0]])\nt = 1.0\nextra_param = None\ndoConjugate = False\n```\n\nOutput:\n```python\n(32.5+0j)\n```", "ground_truth_code": "import numpy as np\n\ndef abs2(x):\n    return x.real ** 2 + x.imag ** 2\n\n\ndef applyOperator2DOp(X, Y, psi, result, operator, doConjugate):\n    for i in range(1, len(psi) - 1):\n        for j in range(1, len(psi[0]) - 1):\n            result[i, j] = (operator[0, 0] * psi[i, j] +\n                            operator[1, 0] * psi[i - 1, j] +\n                            operator[1, 1] * psi[i + 1, j] +\n                            operator[2, 0] * psi[i, j - 1] +\n                            operator[2, 1] * psi[i, j + 1])\n            if doConjugate:\n                result[i, j] *= np.conj(psi[i, j])\n    return result\n\n\ndef applyOperator2DFunc(X, Y, psi, result, operator, t, extra_param, doConjugate):\n    dx = (X[-1] - X[0]) / (len(psi) - 1)\n    dy = (Y[-1] - Y[0]) / (len(psi[0]) - 1)\n    op = np.array([[1.0, 0.0], [0.0, 0.0], [0.0, 0.0]])\n    operator(op, (X[0], Y[0]), (dx, dy), t, extra_param=extra_param, onlyUpdate=False)\n\n    for i in range(1, len(psi) - 1):\n        for j in range(1, len(psi[0]) - 1):\n            operator(op, (X[i], Y[j]), (dx, dy), t, extra_param=extra_param)\n            result[i, j] = (op[0, 0] * psi[i, j] +\n                            op[1, 0] * psi[i - 1, j] +\n                            op[1, 1] * psi[i + 1, j] +\n                            op[2, 0] * psi[i, j - 1] +\n                            op[2, 1] * psi[i, j + 1])\n            if doConjugate:\n                result[i, j] *= np.conj(psi[i, j])\n    return result\n\n\ndef applyOperator2D(X, Y, psi, result, operator, t, extra_param, doConjugate):\n    if not callable(operator):\n        return applyOperator2DOp(X, Y, psi, result, operator, doConjugate=doConjugate)\n    return applyOperator2DFunc(X, Y, psi, result, operator, t=t, extra_param=extra_param, doConjugate=doConjugate)\n\n\n# main code\ndef expectedValueOperator2D(X, Y, psi, result, operator, t, extra_param, doConjugate):\n    if operator is None:\n        np.conjugate(psi, out=result)\n        np.multiply(psi, result, out=result)\n        return np.trapz(np.trapz(result)) * (X[-1] - X[0]) / (len(psi) - 1) * (Y[-1] - Y[0]) / (len(psi[0]) - 1)\n\n    result = applyOperator2D(X, Y, psi, result, operator, t=t, extra_param=extra_param, doConjugate=doConjugate)\n\n    if doConjugate:\n        return np.trapz(np.trapz(result)) * (X[-1] - X[0]) / (len(X) - 1) * (Y[-1] - Y[0]) / (len(Y) - 1)\n\n    return np.trapz(np.trapz(np.multiply(np.conj(psi), result))) * (X[-1] - X[0]) / (len(X) - 1) * (Y[-1] - Y[0]) / (len(Y) - 1)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        grid_size_x = np.random.randint(5, 100)\n        grid_size_y = np.random.randint(5, 100)\n        X = np.linspace(0, 1, grid_size_x)\n        Y = np.linspace(0, 1, grid_size_y)\n        psi = np.random.rand(grid_size_x, grid_size_y) + 1j * np.random.rand(grid_size_x, grid_size_y)\n        result = np.zeros((grid_size_x, grid_size_y), dtype=complex)\n        operator = np.random.rand(3, 2)\n        t = np.random.uniform(0, 10)\n        extra_param = np.random.rand() if np.random.rand() > 0.5 else np.random.rand(3, 3)\n        doConjugate = np.random.choice([True, False])\n        test_cases.append((X, Y, psi, result, operator, t, extra_param, doConjugate))\n\n    return test_cases"}
{"problem_id": "numpy_120", "library": "numpy", "code_problem": "You are tasked with implementing a function that forecasts future values based on historical data using a rolling window approach. The function will utilize linear regression to predict values based on temperature data and actual values, while also applying bounds to the predictions.\n\nFunction signature:\n```python\ndef rollingDylanForecast(rawData, upBound, lowBound, rolling_window):\n```\n\nConstants used in the main code:\n- The constant `168` represents the number of data points corresponding to one week (assuming data is collected hourly).\n\nInput format:\n- `rawData`: A 2D list or array where each row contains two values: the actual value and the temperature.\n- `upBound`: A float representing the upper bound multiplier for the forecasted values.\n- `lowBound`: A float representing the lower bound multiplier for the forecasted values.\n- `rolling_window`: An integer representing the number of weeks to consider for the rolling window.\n\nOutput format:\n- A tuple containing:\n  - A list of forecasted values (with `None` for any NaN values).\n  - A float representing the Mean Absolute Percentage Error (MAPE).\n\n**Input:**\n```python\nrawData = np.array([[10, 20], [15, 25], [20, 30], [25, 35], [30, 40], \n                    [35, 45], [40, 50], [45, 55], [50, 60], [55, 65],\n                    [60, 70], [65, 75], [70, 80], [75, 85], [80, 90],\n                    [85, 95], [90, 100], [95, 105], [100, 110], [105, 115]])\nupBound = 1.5\nlowBound = 0.8\nrolling_window = 2\n```\n\n**Output:**\n```python\n([None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None, None], nan)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef rollingDylanForecast(rawData, upBound, lowBound, rolling_window):\n    forecasted = np.full(len(rawData), np.nan)\n    rawData = np.asarray(rawData)\n    actual = rawData[:, 0]\n    temps = rawData[:, 1]\n\n    for w in range(168 * rolling_window, len(rawData)):\n        training_indices = [w - 168 * (i + 1) for i in range(rolling_window)]\n        x = temps[training_indices]\n        y = actual[training_indices]\n\n        x_mean, x_std = np.mean(x), np.std(x)\n        y_mean, y_std = np.mean(y), np.std(y)\n\n        if x_std == 0 or y_std == 0:\n            z = np.polyfit(x, y, 1)\n            p = np.poly1d(z)\n            pred = p(temps[w])\n        else:\n            x_scaled = (x - x_mean) / x_std\n            y_scaled = (y - y_mean) / y_std\n            z = np.polyfit(x_scaled, y_scaled, 1)\n            p = np.poly1d(z)\n            pred = p((temps[w] - x_mean) / x_std) * y_std + y_mean\n\n        hist_indices = [w - 168 * (i + 1) for i in range(rolling_window)]\n        hist_data = actual[hist_indices]\n        hist_min = np.min(hist_data)\n        hist_max = np.max(hist_data)\n        floor = lowBound * hist_min\n        ceiling = upBound * hist_max\n\n        pred = max(min(pred, ceiling), floor)\n        forecasted[w] = pred\n\n    MAPE = np.nanmean(np.abs(forecasted - actual) / actual)\n    forecasted = forecasted.tolist()\n    forecasted = [None if np.isnan(val) else val for val in forecasted]\n\n    return forecasted, MAPE", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rolling_window = np.random.randint(1, 10)\n        min_length = 168 * rolling_window + np.random.randint(50, 200)\n        rawData = np.random.rand(min_length, 2) * 100\n        upBound = np.random.uniform(1.0, 2.0)\n        lowBound = np.random.uniform(0.5, 1.0)\n        test_cases.append((rawData, upBound, lowBound, rolling_window))\n\n    return test_cases\n"}
{"problem_id": "numpy_121", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates a specific probability density function (PDF) based on the normal distribution. The function will take several parameters related to two random variables and compute the output using statistical formulas.\n\nFunction signature:\n```python\ndef pdf_R_both_D_and_k_normal(r, next_I, curr_I, N, mu_D, var_D, mu_k, var_k):\n```\n\n### Constants:\nIn the main code, the constant used is:\n```python\nconst = np.exp(-(alpha_0 - alpha_1 ** 2 / (4 * alpha_2))) / (2 * np.pi * np.sqrt(var_D * var_k))\n```\n\n### Input and Output Format:\n- **Input Format**: The function takes in eight parameters as described above.\n- **Output Format**: The function returns a single floating-point number representing the computed probability density value.\n\nInput:\n```python\nr = 5.23\nnext_I = 250.0\ncurr_I = 200.0\nN = 5000\nmu_D = 1.2\nvar_D = 0.5\nmu_k = -1.0\nvar_k = 0.3\n```\n\nOutput:\n```python\noutput = 2.250907094257419e-84\n```", "ground_truth_code": "import numpy as np\nfrom scipy.stats import norm\n\n# main code\ndef pdf_R_both_D_and_k_normal(r, next_I, curr_I, N, mu_D, var_D, mu_k, var_k):\n    (k1, k2) = (0.01, N / curr_I)\n    (a, b) = (curr_I / N, np.absolute((next_I - curr_I) / curr_I))\n    alpha_0 = (-(1 / b) + r / b - mu_D) ** 2 / (2 * var_D) + mu_k ** 2 / (2 * var_k)\n    alpha_1 = -((-(1 / b) + r / b - mu_D) * (r * a / b) / var_D) - mu_k / var_k\n    alpha_2 = (r * a / b) ** 2 / (2 * var_D) + 1 / (2 * var_k)\n    (beta_0, beta_1) = (1 / b, -a / b)\n    const = np.exp(-(alpha_0 - alpha_1 ** 2 / (4 * alpha_2))) / (2 * np.pi * np.sqrt(var_D * var_k))\n    (mu_c, var_c) = (-alpha_1 / (2 * alpha_2), 1 / (2 * alpha_2))\n    output_term1 = beta_1 * var_c * const * (np.exp(-(k1 - mu_c) ** 2 / (2 * var_c)) - np.exp(-(k2 - mu_c) ** 2 / (2 * var_c)))\n    output_term2 = (beta_1 * mu_c + beta_0) * const * np.sqrt(2 * np.pi * var_c) * (norm.cdf((k2 - mu_c) / np.sqrt(var_c)) - norm.cdf((k1 - mu_c) / np.sqrt(var_c)))\n    return output_term1 + output_term2", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        r = np.random.uniform(0.01, 10.0)\n        next_I = np.random.uniform(0.1, 1000.0)\n        curr_I = np.random.uniform(0.1, 1000.0)\n        N = np.random.randint(10, 10000)\n        mu_D = np.random.uniform(-5, 5)\n        var_D = np.random.uniform(0.01, 2.0)\n        mu_k = np.random.uniform(-5, 5)\n        var_k = np.random.uniform(0.01, 2.0)\n\n        test_cases.append((r, next_I, curr_I, N, mu_D, var_D, mu_k, var_k))\n\n    return test_cases\n"}
{"problem_id": "numpy_122", "library": "numpy", "code_problem": "You are tasked with implementing a function that computes the set difference between two lists of integers. The function should return a list containing the elements that are present in the first list but not in the second list. The function should also ensure that the input lists are treated as unique sets of integers, meaning that any duplicate values in the input lists should be ignored. Additionally, the function should have an option to specify whether the input lists are already unique, which can optimize the computation.\n\nFunction signature:\n```python\ndef setdiff(x, y, sort: bool) -> list:\n```\n\nConstant used in the main code:\n- The constant `assume_unique` is used in the `np.setdiff1d` function to indicate whether the input arrays are unique.\n\nInput format:\n- The function takes two lists of integers `x` and `y`, and a boolean `sort` as input.\n\nOutput format:\n- The function returns a list of integers representing the set difference between `x` and `y`.\n\nInput:\n```python\n([1, 2, 3, 4, 5, 6], [4, 5, 6, 7, 8], True)\n```\n\nOutput:\n```python\n[1, 2, 3]\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef setdiff(x, y, sort):\n    x = np.unique(np.array(x))\n    y = np.unique(np.array(y))\n    return list(np.setdiff1d(x, y, assume_unique=sort))", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_x = random.randint(1, 1000)\n        size_y = random.randint(1, 1000)\n        common_elements = np.random.choice(np.arange(0, 5000), size=random.randint(0, min(size_x, size_y) // 2), replace=False)\n        x_unique = np.random.choice(np.arange(0, 5000), size=size_x - len(common_elements), replace=False)\n        y_unique = np.random.choice(np.arange(0, 5000), size=size_y - len(common_elements), replace=False)\n        x = np.concatenate([x_unique, common_elements])\n        y = np.concatenate([y_unique, common_elements])\n        np.random.shuffle(x)\n        np.random.shuffle(y)\n        sort = random.choice([True, False])\n        test_cases.append((x.tolist(), y.tolist(), sort))\n\n    return test_cases"}
{"problem_id": "numpy_123", "library": "numpy", "code_problem": "You are tasked with implementing a function that calculates the cumulative return of a financial asset based on a given type of return calculation. The function will take in a 2D array representing financial data, a column index to specify which data to use for the calculation, and a type of return ('normal' or 'log').\n\nFunction Signature:\n```python\ndef cummulative_return(array, col, type):\n```\n\nConstant Used:\n- The constant used in the main code is the value `1`, which is added to the elements of the specified column for the 'normal' return calculation.\n\n\nInput Format:\n- The input consists of a 2D numpy array, an integer for the column index, and a string indicating the type of return ('normal' or 'log').\n\nOutput Format:\n- The output is a numpy array containing the cumulative return calculated based on the specified type.\n\nInput:\n```python\narray = np.array([[0.02, 0.03], [0.01, 0.04], [0.05, 0.02]])\ncol = 0\ntype = 'normal'\n```\n\nOutput:\n```python\narray([0.02  , 0.0506])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef cummulative_return(array, col, type):\n    if type == 'normal':\n        return np.cumprod(array[col] + 1) - 1\n    if type == 'log':\n        return np.cumprod(np.exp(array[col])) - 1\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(5, 1000)\n        cols = np.random.randint(1, 10)\n\n        array = np.random.rand(rows, cols) * 0.1\n        col = np.random.randint(0, cols)\n        type_choice = np.random.choice(['normal', 'log'])\n\n        test_cases.append((array, col, type_choice))\n\n    return test_cases"}
{"problem_id": "numpy_124", "library": "numpy", "code_problem": "You are tasked with implementing a mutation operation for a genetic algorithm. The mutation operation is designed to create a new individual (chromosome) based on the characteristics of other individuals in the population. The function signature for the main code is as follows:\n\n```python\ndef mutationOperation(i, params, population, sizepop):\n```\n\n### Constants:\n- The constant used in the main code is `params[1]`, which is a mutation factor that influences how much the new chromosome deviates from the selected parents.\n\n\n### Input and Output Format:\n- **Input**: The function takes four parameters: an integer `i`, a list of parameters `params`, a list of individuals `population`, and an integer `sizepop`.\n- **Output**: The function returns a new chromosome, which is a numerical representation of the mutated individual.\n\n**Input:**\n```python\ni = 2\nparams = [0.5, 0.8]\npopulation = [\n    type('Individual', (object,), {'chrom': np.array([0.1, 0.2, 0.3])})(),\n    type('Individual', (object,), {'chrom': np.array([0.4, 0.5, 0.6])})(),\n    type('Individual', (object,), {'chrom': np.array([0.7, 0.8, 0.9])})(),\n    type('Individual', (object,), {'chrom': np.array([0.2, 0.3, 0.4])})(),\n    type('Individual', (object,), {'chrom': np.array([0.5, 0.6, 0.7])})()\n]\nsizepop = 5\n```\n\n**Output:**\n```python\narray([0.32, 0.42, 0.52])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef mutationOperation(i, params, population, sizepop):\n    a = np.random.randint(0, sizepop - 1)\n    while a == i:\n        a = np.random.randint(0, sizepop - 1)\n    b = np.random.randint(0, sizepop - 1)\n    while b == i or b == a:\n        b = np.random.randint(0, sizepop - 1)\n    c = np.random.randint(0, sizepop - 1)\n    while c == i or c == b or c == a:\n        c = np.random.randint(0, sizepop - 1)\n    vi = population[c].chrom + params[1] * (population[a].chrom - population[b].chrom)\n    return vi", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    sizepop = 5\n    num_chromosomes = 3\n\n    for _ in range(n):\n        i = random.randint(0, sizepop - 1)\n        params = [random.uniform(0, 1), random.uniform(0, 1)]\n        population = [\n            type('Individual', (object,), {'chrom': np.random.rand(num_chromosomes)}) for _ in range(sizepop)\n        ]\n        \n        test_cases.append([i, params, population, sizepop])\n\n    return test_cases"}
{"problem_id": "numpy_125", "library": "numpy", "code_problem": "```python\ndef pose_spherical_dtu(radii: float, focus_depth: float, n_poses: int, world_center: np.ndarray) -> np.ndarray:\n```\n\nIn this code, the function `pose_spherical_dtu` generates a set of camera poses arranged in a spherical spiral pattern around a specified point in 3D space. The function takes four parameters: `radii`, which determines the radius of the spiral; `focus_depth`, which specifies the depth at which the camera should focus; `n_poses`, which indicates the number of poses to generate; and `world_center`, which is a 3D point that represents the center of the world coordinates.\n\n\n### Input and Output Format:\n- **Input**: \n  - `radii`: A float representing the radius of the spiral.\n  - `focus_depth`: A float representing the depth at which the camera should focus.\n  - `n_poses`: An integer representing the number of poses to generate.\n  - `world_center`: A NumPy array of shape (3,) representing the center of the world coordinates.\n\n- **Output**: \n  - A NumPy array of shape (n_poses, 4, 4) containing the generated camera poses in a 4x4 matrix format.\n\nInput:\n```python\n(5.2, 12.3, 10, np.array([-3.5, 2.1, 0.0]))\n```\n\nOutput:\n```python\narray([[[ 9.21070571e-01,  0.00000000e+00, -3.89395689e-01, 1.70000000e+00],\n        [ 0.00000000e+00, -1.00000000e+00,  0.00000000e+00, 2.10000000e+00],\n        [-3.89395689e-01,  0.00000000e+00, -9.21070571e-01, 0.00000000e+00]],\n        ...\n        [[ 9.94569883e-01,  3.17450015e-02, -9.91110668e-02, -1.89311163e+00],\n        [ 0.00000000e+00, -9.52341942e-01, -3.05032499e-01, 7.04549388e+00],\n        [-1.04070883e-01,  3.03376136e-01, -9.47170614e-01, 3.05648331e+00]]])\n```\n\n(Note: the output is a 10*3*4 array)", "ground_truth_code": "import numpy as np\n\n\ndef normalize(v):\n    return v / np.linalg.norm(v)\n\n# main code\ndef pose_spherical_dtu(radii, focus_depth, n_poses, world_center):\n    poses_spiral = []\n    for t in np.linspace(0, 4 * np.pi, n_poses + 1)[:-1]:\n        center = np.array([np.cos(t), -np.sin(t), -np.sin(0.5 * t)]) * radii\n        z = normalize(center - np.array([0, 0, -focus_depth]))\n        y_ = np.array([0, 1, 0])\n        x = normalize(np.cross(y_, z))\n        y = np.cross(z, x)\n        poses_spiral += [np.stack([x, y, z, center + world_center], 1)]\n    return np.stack(poses_spiral, 0) @ np.array([[1, 0, 0, 0], [0, -1, 0, 0], [0, 0, -1, 0], [0, 0, 0, 1]])\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        radii = np.random.uniform(0.1, 10.0)\n        focus_depth = np.random.uniform(0.5, 20.0)\n        n_poses = np.random.randint(5, 100)\n        world_center = np.random.uniform(-10, 10, size=(3,))\n\n        test_cases.append((radii, focus_depth, n_poses, world_center))\n\n    return test_cases"}
{"problem_id": "numpy_126", "library": "numpy", "code_problem": "You are tasked with implementing a function that manipulates the diagonal dimensions of a multi-dimensional array (tensor) using Einstein summation convention. The function should be able to adjust the number of diagonal dimensions of the input tensor based on specified parameters.\n\nFunction Signature:\n```python\ndef get_diag(X: np.ndarray, ndim: int, ndim_to: int) -> np.ndarray:\n```\n\n### Constants:\n- The constant used in the main code is `0`, which is used to ensure that the dimensions are non-negative.\n\n\n### Input Format:\n- The function takes three parameters:\n  - `X`: A NumPy array of arbitrary dimensions.\n  - `ndim`: An integer indicating the number of diagonal dimensions in `X`.\n  - `ndim_to`: An integer indicating the desired number of diagonal dimensions in the output.\n\n### Output Format:\n- The function returns a NumPy array that has been manipulated according to the specified diagonal dimensions. The output will have the same data type as the input tensor `X`.\n\n```python\n# Input\nX = np.array([[[[ 0.1,  0.2],\n                [ 0.3,  0.4]],\n\n               [[ 0.5,  0.6],\n                [ 0.7,  0.8]]]])\n\nndim = 1\nndim_to = 0\n\n# Output\nresult = array([[[0.1, 0.4], [0.5, 0.8]]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_diag(X, ndim, ndim_to):\n    ndim = max(0, ndim)\n    ndim_to = max(0, min(ndim, ndim_to))\n\n    if ndim == 0 or np.ndim(X) < 2 * ndim:\n        return X\n\n    if np.shape(X)[-ndim:] != np.shape(X)[-2 * ndim:-ndim]:\n        return X\n\n    if ndim == ndim_to:\n        return X\n\n    n_plate_axes = np.ndim(X) - 2 * ndim\n    n_diag_axes = ndim - ndim_to\n    axes = tuple(range(0, np.ndim(X) - ndim + ndim_to))\n    lengths = [0, n_plate_axes, n_diag_axes, ndim_to, ndim_to]\n    cutpoints = list(np.cumsum(lengths))\n\n    axes_plates = axes[cutpoints[0]:cutpoints[1]]\n    axes_diag = axes[cutpoints[1]:cutpoints[2]]\n    axes_dims1 = axes[cutpoints[2]:cutpoints[3]]\n    axes_dims2 = axes[cutpoints[3]:cutpoints[4]]\n\n    axes_input = axes_plates + axes_diag + axes_dims1 + axes_diag + axes_dims2\n    axes_output = axes_plates + axes_diag + axes_dims1 + axes_dims2\n\n    return np.einsum(X, axes_input, axes_output)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        ndim = np.random.randint(0, 5)\n        ndim_to = np.random.randint(0, ndim + 1)\n\n        if ndim == 0:\n            shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 5)))\n        else:\n            plate_shape = tuple(np.random.randint(1, 5, size=np.random.randint(1, 3)))\n            diag_shape = tuple(np.random.randint(1, 5, size=ndim))\n            shape = plate_shape + diag_shape + diag_shape\n        X = np.random.randn(*shape)\n        test_cases.append((X, ndim, ndim_to))\n\n    return test_cases"}
{"problem_id": "numpy_127", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs blockwise coordinate descent mapping for a given set of input matrices. The function will update a matrix based on the provided parameters and return the modified matrix.\n\nFunction signature:\n```python\ndef blockwise_coord_descent_mapping(X_T, S_T, B_T, lam):\n```\n\nConstant used in the main code:\n- `alpha` is defined as `lam / 10.0`.\n\n\nInput format:\n- `X_T`: A 2D numpy array (matrix).\n- `S_T`: A 2D numpy array (matrix).\n- `B_T`: A 2D numpy array (matrix).\n- `lam`: A float representing the regularization parameter.\n\nOutput format:\n- Returns a 2D numpy array (matrix) which is the updated version of `S_T`.\n\nInput:\n```python\nX_T = np.array([[0.1, 0.2, 0.3],\n                 [0.4, 0.5, 0.6],\n                 [0.7, 0.8, 0.9]])\nS_T = np.array([[0.1, 0.2],\n                 [0.3, 0.4],\n                 [0.5, 0.6]])\nB_T = np.array([[0.1, 0.2, 0.3],\n                 [0.4, 0.5, 0.6]])\nlam = 1.0\n```\n\nOutput:\n```python\nS = np.array([[0.     , 0.092  , 0.208  ], [0.22   , 0.64056, 1.05344]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef blockwise_coord_descent_mapping(X_T, S_T, B_T, lam):\n    alpha = lam / 10.0\n    K = B_T.shape[0]\n    A = B_T.dot(B_T.T)\n    np.fill_diagonal(A, 0)\n    E = B_T.dot(X_T.T)\n    S = np.copy(S_T.T)\n\n    for k in range(K):\n        row = E[k] - A[k].dot(S)\n        S[k] = np.sign(row) * np.maximum(np.abs(row) - alpha, 0)\n\n    return S", "test_script": "import numpy as np\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(1, 100)\n        n_features = np.random.randint(1, 10)\n        p = np.random.randint(1, 10)\n\n        X_T = np.random.rand(m, n_features)\n        S_T = np.random.rand(m, p)\n        B_T = np.random.rand(p, n_features)\n        lam = np.random.uniform(0.1, 10.0)\n        test_cases.append((X_T, S_T, B_T, lam))\n\n    return test_cases"}
{"problem_id": "numpy_128", "library": "numpy", "code_problem": "You are tasked with implementing a function that constructs a matrix and a list of descriptions based on input data and its derivatives. The function will generate polynomial features from the input data and combine them with the provided derivatives to create a comprehensive feature set.\n\nFunction signature:\n```python\ndef build_Theta(data: np.ndarray, derivatives: np.ndarray, derivatives_description: list, P: int, data_description: list) -> tuple:\n```\n\n### Constants:\n- The constant `P` represents the maximum degree of polynomial terms to be generated from the input data.\n\n\n### Input Format:\n- `data`: A 2D numpy array of shape (n, d) where `n` is the number of samples and `d` is the number of features.\n- `derivatives`: A 2D numpy array of shape (m, d2) where `m` is the number of samples (should match `n`) and `d2` is the number of derivatives.\n- `derivatives_description`: A list of strings describing each derivative.\n- `P`: An integer representing the maximum degree of polynomial terms to generate.\n- `data_description`: A list of strings describing each feature in `data`.\n\n### Output Format:\n- Returns a tuple containing:\n  - A 2D numpy array `Theta` of shape (n, 1 + d2 + len(powers) * d2).\n  - A list of strings `descr` containing descriptions of the features and their combinations.\n\n**Input:**\n```python\ndata = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]])\nderivatives = np.array([[1.0], [2.0], [3.0]])\nderivatives_description = ['d0']\nP = 2\ndata_description = ['x0', 'x1']\n```\n\n**Output:**\n```python\nTheta = np.array([[1.  +0.j, 1.  +0.j, 0.1 +0.j, 0.2 +0.j, 0.01+0.j, 0.02+0.j,\n        0.04+0.j],\n       [1.  +0.j, 2.  +0.j, 0.6 +0.j, 0.8 +0.j, 0.18+0.j, 0.24+0.j,\n        0.32+0.j],\n       [1.  +0.j, 3.  +0.j, 1.5 +0.j, 1.8 +0.j, 0.75+0.j, 0.9 +0.j,\n        1.08+0.j]], dtype=complex64) \ndescr = ['', 'd0', 'x0d0', 'x1d0', 'x0^2d0', 'x0x1d0', 'x1^2d0']\n```", "ground_truth_code": "import numpy as np\nfrom itertools import combinations_with_replacement\n\n\ndef fast_power(x, y):\n    return np.prod(x**y, axis=1)\n\n# main code\ndef build_Theta(data, derivatives, derivatives_description, P, data_description):\n    n, d = data.shape\n    m, d2 = derivatives.shape\n\n    if n != m or (data_description is not None and len(data_description) != d):\n        return np.empty((0, 0)), []\n\n    rhs_functions = {}\n    powers = []\n    for p in range(1, P + 1):\n        for comb in combinations_with_replacement(range(d), p):\n            power = np.bincount(comb, minlength=d)\n            powers.append(tuple(power))\n\n    for power in powers:\n        rhs_functions[power] = [power]\n\n    Theta = np.ones((n, 1 + d2 + len(powers) * d2), dtype=np.complex64)\n    descr = ['']\n\n    Theta[:, 1:1 + d2] = derivatives\n    descr.extend(derivatives_description)\n\n    idx = 1 + d2\n    data_powers = np.array([fast_power(data, np.array(power)) for power in rhs_functions])\n    for D in range(d2):\n        Theta[:, idx:idx + len(powers)] = data_powers.T * derivatives[:, D][:, None]\n        if data_description is None:\n            descr.extend([str(power) + derivatives_description[D] for power in rhs_functions])\n        else:\n            for power in rhs_functions:\n                function_description = ''.join(\n                    f\"{data_description[j]}^{power[j]}\" if power[j] > 1 else data_description[j]\n                    for j in range(d) if power[j] != 0\n                )\n                descr.append(function_description + derivatives_description[D])\n        idx += len(powers)\n\n    return Theta, descr", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_val = np.random.randint(5, 50)\n        d = np.random.randint(2, 10)\n        d2 = np.random.randint(1, 10)\n        P = np.random.randint(1, 5)\n\n        data = np.random.rand(n_val, d).astype(np.float64)\n        derivatives = np.random.rand(n_val, d2).astype(np.float64)\n\n        data_description = [f'x{j}' for j in range(d)] if np.random.rand() > 0.5 else None\n        derivatives_description = [f'd{j}' for j in range(d2)]\n        test_cases.append((data, derivatives, derivatives_description, P, data_description))\n\n    return test_cases\n\n\n"}
{"problem_id": "numpy_129", "library": "numpy", "code_problem": "You are tasked with implementing a function that performs iterative correction on a symmetric matrix. The function should adjust the values of the matrix based on a specified number of iterations, while also allowing for the option to ignore certain diagonal elements during the correction process. The function will return the corrected matrix, a bias array, and a report indicating whether the process converged and the number of iterations performed.\n\nFunction signature:\n```python\ndef iterative_correction_symmetric(x: np.ndarray, max_iter: int, ignore_diags: int, tol: float) -> tuple:\n```\n\nConstants used in the main code:\n- The constant `0.8` is used in the calculation of the scaling factor for the sum of the matrix rows.\n\n\nInput format:\n- `x`: A 2D numpy array representing the symmetric matrix to be corrected.\n- `max_iter`: An integer specifying the maximum number of iterations to perform.\n- `ignore_diags`: An integer indicating how many diagonals to ignore during the correction.\n- `tol`: A float representing the tolerance level for convergence.\n\nOutput format:\n- A tuple containing:\n  - A 2D numpy array representing the corrected matrix.\n  - A 1D numpy array representing the bias adjustments.\n  - A tuple with a boolean indicating convergence and an integer for the number of iterations performed.\n\nInput:\n```python\n(\n    np.array([[1.0, 0.5], [0.5, 1.0]]),  # Symmetric matrix\n    10,                               # max_iter\n    0,                                # ignore_diags\n    1e-5                              # tol\n)\n```\n\nOutput:\n```python\n(array([[1. , 0.5],  [0.5, 1. ]]), array([1., 1.]), (True, 0))\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef iterative_correction_symmetric(x, max_iter, ignore_diags, tol):\n    N = len(x)\n    _x = x.copy()\n    if ignore_diags > 0:\n        idx = np.arange(N)\n        for d in range(ignore_diags):\n            mask = np.abs(idx[:, None] - idx[None, :]) == d\n            _x[mask] = 0\n\n    totalBias = np.ones(N, dtype=np.double)\n    converged = False\n\n    for iternum in range(max_iter):\n        s = np.sum(_x, axis=1)\n        mask = s == 0\n        non_zero_mask = ~mask\n\n        if np.any(non_zero_mask):\n            s[non_zero_mask] /= np.mean(s[non_zero_mask])\n\n        s[mask] = 1\n        s = 0.8 * (s - 1) + 1\n\n        totalBias *= s\n        scaling = np.outer(s, s)\n        _x /= scaling\n\n        crit = np.var(s)\n        if tol > 0 and crit < tol:\n            converged = True\n            break\n\n    corr = totalBias[non_zero_mask].mean()\n    _x *= corr ** 2\n    totalBias /= corr\n    report = (converged, iternum)\n    return _x, totalBias, report\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    Ns = np.random.randint(2, 500, size=n)\n    test_cases = [\n        (\n            np.random.rand(N, N) + np.random.rand(N, N).T,\n            np.random.randint(1, 100),\n            np.random.randint(0, N - 1),\n            np.random.uniform(1e-6, 1e-2)\n        )\n        for N in Ns\n    ]\n    return test_cases\n"}
{"problem_id": "numpy_130", "library": "numpy", "code_problem": "You are tasked with creating a function that generates a frequency table from a given dataset. The function will analyze the data to determine the appropriate binning method based on a normality test and then calculate the absolute and relative frequencies for each bin. The output should be structured in a DataFrame format that includes various statistics related to the frequency distribution.\n\nFunction signature:\n```python\ndef tabela_frequencias(dados):\n```\n\nConstant used in the main code:\n- `alpha = 0.05`: This constant is used as the significance level for the normality test.\n\n\nInput format:\n- The input to the function `tabela_frequencias` is a dataset `dados`, which can be a list or array of numerical values.\n\nOutput format:\n- The output of the function is a DataFrame containing the frequency table with the specified columns and their corresponding values.\n\nInput:\n```python\ndados = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\n```\n\nOutput:\n```\n   Lower limit  Upper limit  ...  Count  Direct Cumulative Frequency (%)\n0         0.10         0.18  ...      2                             20.0\n1         0.28         0.36  ...      4                             40.0\n2         0.46         0.54  ...      6                             60.0\n3         0.64         0.72  ...      8                             80.0\n4         0.82         1.00  ...     10                            100.0\n[5 rows x 7 columns]\n```", "ground_truth_code": "from scipy.stats import normaltest\nimport pandas as pd\nimport numpy as np\n\ndef testar_norm(data):\n    (k, p) = normaltest(data)\n    alpha = 0.05\n    if p < alpha:\n        return 'doane'\n    else:\n        return 'sturges'\n\ndef classes_frequencias(dados):\n    dist_type = testar_norm(dados)\n    classes = np.histogram_bin_edges(dados, bins=dist_type)\n    n_classes = len(classes) - 1\n    lista_classes = []\n    for i in range(0, n_classes):\n        lista_classes.append([])\n    classe = 0\n    for sample in sorted(dados):\n        if sample >= classes[classe] and sample < classes[classe + 1]:\n            lista_classes[classe].append(sample)\n        else:\n            for intervalo in range(0, n_classes):\n                if sample >= classes[intervalo] and sample <= classes[intervalo + 1]:\n                    classe = intervalo\n                    lista_classes[classe].append(sample)\n    counts = []\n    for classe in range(0, len(lista_classes)):\n        counts.append(len(lista_classes[classe]))\n    relative_freq = []\n    for i in counts:\n        freq = i / len(dados) * 100\n        relative_freq.append(freq)\n    intervals_min = []\n    intervals_max = []\n    minimum = min(dados)\n    maximum = max(dados)\n    Ai = (max(dados) - min(dados)) / n_classes\n    for i in range(0, n_classes):\n        intervals_min.append(minimum + i * Ai)\n    for i in range(1, n_classes):\n        intervals_max.append(i * Ai)\n    intervals_max.append(maximum)\n    return (counts, relative_freq, intervals_min, intervals_max)\n\n# main code\ndef tabela_frequencias(dados):\n    freq = pd.DataFrame()\n    (contagem, freq_relativa, intervalos_min, intervalos_max) = classes_frequencias(dados)\n    contagem = np.asarray(contagem)\n    freq_relativa = np.asarray(freq_relativa)\n    freq_acumulada = contagem.cumsum()\n    freq_acum_dir = []\n    for i in freq_acumulada:\n        freq_acum_dir.append(i / len(dados) * 100)\n    freq_acum_dir = np.asarray(freq_acum_dir)\n    intervalos_min = np.asarray(intervalos_min)\n    intervalos_max = np.asarray(intervalos_max)\n    inverse_freq = []\n    for i in freq_relativa[::-1]:\n        inverse_freq.append(i)\n    freq.insert(loc=0, column='Lower limit', value=intervalos_min)\n    freq.insert(loc=1, column='Upper limit', value=intervalos_max)\n    freq.insert(loc=2, column='Lower limit (log)', value=np.log10(intervalos_min))\n    freq.insert(loc=3, column='Absolut Frequency', value=contagem)\n    freq.insert(loc=4, column='Relative Frequency (%)', value=freq_relativa)\n    freq.insert(loc=5, column='Count', value=freq_acumulada)\n    freq.insert(loc=6, column='Direct Cumulative Frequency (%)', value=freq_acum_dir)\n    return freq", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for i in range(n):\n        if i % 2 == 0:\n            size = np.random.randint(30, 1000)\n            data = np.random.normal(0, 1, size)\n        else:\n            size = np.random.randint(30, 1000)\n            data = np.random.exponential(scale=1.0, size=size)\n        data += np.random.normal(0, 0.01, size)\n        test_cases.append(data)\n    return test_cases\n"}
{"problem_id": "pandas_0", "library": "pandas", "code_problem": "You are tasked with implementing a function that transforms a given DataFrame by subtracting a sinusoidal wave from its values. The sinusoidal wave is defined by parameters such as amplitude, angular frequency, and phase shift, which are provided in a separate DataFrame. \n\nFunction signature:\n```python\ndef transform(df: pd.DataFrame, sin_params: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `np.newaxis`, which is utilized to add a new axis to the NumPy array for broadcasting purposes.\n\n\nInput format:\n- The function takes two inputs:\n  1. `df`: A pandas DataFrame containing numerical data.\n  2. `sin_params`: A pandas DataFrame containing three columns: 'amp', 'omega', and 'phase', each representing the amplitude, angular frequency, and phase shift of the sinusoidal wave.\n\nOutput format:\n- The function returns a pandas DataFrame that contains the transformed values after subtracting the sinusoidal wave from the original DataFrame.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test DataFrame\ndf = pd.DataFrame({\n    'Col0': [1.0, 2.0, 3.0, 4.0, 5.0],\n    'Col1': [5.0, 4.0, 3.0, 2.0, 1.0]\n}, index=[0, 1, 2, 3, 4])\n\n# Sinusoidal parameters\nsin_params = {\n    'amp': pd.Series({'Col0': 2.0, 'Col1': 1.5}),\n    'omega': pd.Series({'Col0': 0.5, 'Col1': 1.0}),\n    'phase': pd.Series({'Col0': 0.0, 'Col1': 0.5})\n}\n```\n\n**Output:**\n```python\n       Col0      Col1\n0  1.000000  4.280862\n1  1.041149  2.503758\n2  1.317058  2.102292\n3  2.005010  2.526175\n4  3.181405  2.466295\n```\n\n### Explanation:\n- The input consists of a DataFrame `df` with 5 rows and 2 columns, and a dictionary `sin_params` containing sinusoidal parameters for each column.\n- The output is the transformed DataFrame after applying the sinusoidal transformation as defined in the `transform` function. The values in the output DataFrame are calculated based on the sine function using the provided parameters.", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef transform(df, sin_params):\n    X = pd.to_numeric(df.index, errors='coerce', downcast='integer').to_numpy()\n    X = np.repeat(X[..., np.newaxis], df.shape[1], axis=1)\n    sin_df = pd.DataFrame(sin_params['amp'].to_frame().to_numpy().T * np.sin(sin_params['omega'].to_frame().to_numpy().T * X + sin_params['phase'].to_frame().to_numpy().T), columns=df.columns)\n    df_index = df.index\n    df = df.astype(float).reset_index(drop=True) - sin_df.reset_index(drop=True)\n    df.index = df_index\n    return df", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly select the number of rows and columns\n        num_rows = random.randint(5, 20)\n        num_cols = random.randint(2, 5)\n\n        # Generate a random index (integer time steps)\n        index = np.arange(num_rows)\n\n        # Generate a random DataFrame with float values\n        df = pd.DataFrame(\n            np.random.uniform(-10, 10, size=(num_rows, num_cols)),\n            index=index,\n            columns=[f'Col{i}' for i in range(num_cols)]\n        )\n\n        # Generate random sinusoidal parameters\n        sin_params = {\n            'amp': pd.Series({col: random.uniform(0.5, 5) for col in df.columns}),\n            'omega': pd.Series({col: random.uniform(0.1, np.pi) for col in df.columns}),\n            'phase': pd.Series({col: random.uniform(0, np.pi) for col in df.columns})\n        }\n        test_cases.append((df, sin_params))\n\n    return test_cases"}
{"problem_id": "pandas_1", "library": "pandas", "code_problem": "You are tasked with implementing a function that transforms a given pandas DataFrame from a \"melted\" format back to a \"unmelted\" format. The function should handle both single and multi-index DataFrames and should return the appropriate structure based on the input.\n\nFunction signature:\n```python\ndef unmelt(df: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the string `'Value'`, which is used to check if the DataFrame has a single column named 'Value'.\n\n\nInput format:\n- The input to the function is a pandas DataFrame that may have either a single index or a MultiIndex, and it may contain one or more columns.\n\nOutput format:\n- The output of the function is a pandas DataFrame that represents the unmelted version of the input DataFrame, structured according to the logic described above.\n\n**Input:**\n```python\n# Single Column Named 'Value'\ndf_input = pd.DataFrame(\n    {'Value': [10, 20, 30]},\n    index=pd.Index(['Metric1', 'Metric2', 'Metric3'], name='Metric')\n)\n```\n\n**Output:**\n```python\n# Expected Output after unmelt function\ndf_output = pd.DataFrame(\n    {\n        'Metric1': [10],\n        'Metric2': [20],\n        'Metric3': [30]\n    }\n)\n```\n\n### Explanation:\n- The input is a DataFrame with a single column named 'Value' and a single-level index named 'Metric'.\n- The expected output is a DataFrame where the original values are spread across columns, with each metric as a separate column.", "ground_truth_code": "import pandas as pd\n\n# main code\ndef unmelt(df):\n    if not isinstance(df, pd.DataFrame):\n        return df\n    if isinstance(df.index, pd.MultiIndex):\n        names = df.index.get_level_values(0).unique()\n    else:\n        names = df.index\n    single_value_col = len(df.columns) == 1 and df.columns[0] == 'Value'\n    if len(df.index.names) == 1:\n        df = pd.DataFrame(df.stack(0, dropna=False)).T\n    else:\n        df = pd.concat([df.loc[n] for n in names], axis=1, keys=names, names=['Metric'])\n    if single_value_col:\n        return df.droplevel(1, axis=1)\n    return df", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for i in range(n):\n        case_type = i % 4  # Cycle through different types of test cases\n\n        if i == 0:  # Non-DataFrame Input\n            test_cases.append((\"Non-DataFrame\", f\"test_string_{i}\"))\n\n        elif case_type == 0:  # Single-Level Index DataFrame\n            data = np.random.randint(0, 100, size=(3, 3))\n            df = pd.DataFrame(data, columns=[f\"Col{j}\" for j in range(3)], index=[f\"Row{j}\" for j in range(3)])\n            test_cases.append((\"Single-Level Index DataFrame\", df))\n\n        elif case_type == 1:  # MultiIndex DataFrame\n            index = pd.MultiIndex.from_tuples(\n                [(f\"Metric{i%5}\", j) for j in range(3)],\n                names=['Metric', 'Index']\n            )\n            df = pd.DataFrame(\n                np.random.randint(0, 100, size=(3, 5)),\n                index=index,\n                columns=[f\"Feature{k}\" for k in range(5)]\n            )\n            test_cases.append((\"MultiIndex DataFrame\", df))\n\n        elif case_type == 2:  # MultiIndex DataFrame\n            col = np.random.randint(0, 10)\n            row = np.random.randint(0, 10)\n            index = pd.MultiIndex.from_tuples(\n                [(f\"Metric{i%5}\", j) for j in range(col)],\n                names=['Metric', 'Index']\n            )\n            df = pd.DataFrame(\n                np.random.randint(0, 100, size=(col, row)),\n                index=index,\n                columns=[f\"Feature{k}\" for k in range(row)]\n            )\n            test_cases.append((\"MultiIndex DataFrame\", df))\n\n        else:  # Single Column Named 'Value'\n            df = pd.DataFrame(\n                {'Value': np.random.randint(0, 100, size=(3,))},\n                index=pd.Index([f\"Metric{j}\" for j in range(3)], name='Metric')\n            )\n            test_cases.append((\"Single Column Named 'Value'\", df))\n\n    return test_cases"}
{"problem_id": "pandas_2", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the historical positions of stocks based on trades, stock splits, and dividends. The function will process trade data to adjust quantities and prices according to stock splits, compute cash flows, and calculate cumulative quantities and average costs. The function will also account for dividends and their impact on the overall returns.\n\nFunction Signature:\n```python\ndef hist_positions(as_at_date: str, split_df: pd.DataFrame, div_df: pd.DataFrame, trades_df: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstants Used:\n- A small constant `1e-9` is used to prevent division by zero when calculating average costs.\n\nInput Format:\n- `as_at_date`: A string representing the date up to which trades are considered.\n- `split_df`: A DataFrame containing stock split information with columns 'Ticker', 'Date', and 'Stock Splits'.\n- `div_df`: A DataFrame containing dividend information with columns 'Ticker', 'Date', and 'Dividends'.\n- `trades_df`: A DataFrame containing trade information with columns 'Date', 'Ticker', 'Quantity', 'Price', 'Fees', and 'Direction'.\n\nOutput Format:\n- The function returns a DataFrame containing the historical positions with columns including 'Date', 'Ticker', 'Quantity', 'Price', 'Fees', 'Direction', 'CF', 'AdjQuan', 'CumQuan', 'CFBuy', 'CumCost', 'QBuy', 'CumBuyQuan', 'AvgCostRaw', 'AvgCostAdj', 'AvgCost', 'RlGain', 'Dividends', 'CumDiv', and 'TotalRlGain'.\n\n**Input:**\n```python\nas_at_date = pd.Timestamp('2023-06-15')\nsplit_df = pd.DataFrame({\n    'Date': [pd.Timestamp('2023-05-01'), pd.Timestamp('2023-06-01')],\n    'Ticker': ['AAPL', 'AAPL'],\n    'Stock Splits': [2, 1.5]\n})\ndiv_df = pd.DataFrame({\n    'Date': [pd.Timestamp('2023-04-01'), pd.Timestamp('2023-06-01')],\n    'Ticker': ['AAPL', 'AAPL'],\n    'Dividends': [0.5, 1.0]\n})\ntrades_df = pd.DataFrame({\n    'Date': [pd.Timestamp('2023-01-10'), pd.Timestamp('2023-03-15'), pd.Timestamp('2023-06-10')],\n    'Ticker': ['AAPL', 'AAPL', 'AAPL'],\n    'Quantity': [100, 50, 30],\n    'Price': [150, 160, 155],\n    'Fees': [1, 2, 1],\n    'Direction': ['Buy', 'Sell', 'Buy']\n})\n```\n\n**Output:**\n```python\nresult = hist_positions(as_at_date, split_df, div_df, trades_df)\nprint(result)\n```\n\n**Expected Output:**\n```plaintext\n         Date Ticker  Quantity  ...  Dividends  CumDiv TotalRlGain\n0 2023-01-10   AAPL     300.0  ...        0.0     0.0         0.0\n1 2023-03-15   AAPL     150.0  ...        0.0     0.0       497.5\n2 2023-04-01   AAPL     150.0  ...       25.0    25.0       497.5\n3 2023-06-01   AAPL     150.0  ...      100.0   125.0       497.5\n4 2023-06-10   AAPL      30.0  ...        0.0   125.0       497.5\n[5 rows x 21 columns]\n```\n\n### Explanation:\n- The input consists of a specific date (`as_at_date`), stock splits, dividends, and trades for a single ticker (`AAPL`).\n- The output shows the historical positions after processing the trades, splits, and dividends, including calculated fields like cash flow (`CF`), adjusted quantity (`AdjQuan`), cumulative quantity (`CumQuan`), and realized gains (`RlGain`).", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n\ndef calc_avg_price(group):\n    group['AvgCostAdj'] = group['CumCost'] / (group['CumBuyQuan'] + 1e-9)\n    group['grouping'] = 0\n    return group\n\n\n# main code\ndef hist_positions(as_at_date, split_df, div_df, trades_df):\n    hist_pos = trades_df[trades_df.Date <= as_at_date].copy()\n    hist_pos.sort_values(['Date', 'Ticker'], inplace=True)\n    hist_pos.Quantity = pd.to_numeric(hist_pos.Quantity)\n    hist_pos.Price = pd.to_numeric(hist_pos.Price)\n    hist_pos.Fees = pd.to_numeric(hist_pos.Fees)\n\n    for ticker in hist_pos['Ticker'].unique():\n        splits = split_df[split_df['Ticker'] == ticker].copy()\n        if not splits.empty:\n            splits.sort_values('Date', ascending=False, inplace=True)\n            for (_, row) in splits.iterrows():\n                hist_pos['Quantity'] = np.where((hist_pos['Date'] <= row['Date']) & (hist_pos['Ticker'] == ticker),\n                                                round(hist_pos['Quantity'] * row['Stock Splits'], 0),\n                                                hist_pos['Quantity'])\n                hist_pos['Price'] = np.where((hist_pos['Date'] <= row['Date']) & (hist_pos['Ticker'] == ticker),\n                                             hist_pos['Price'] / row['Stock Splits'],\n                                             hist_pos['Price'])\n                div_df['Dividends'] = np.where((div_df['Date'] <= row['Date']) & (div_df['Ticker'] == ticker),\n                                               div_df['Dividends'] / row['Stock Splits'],\n                                               div_df['Dividends'])\n\n    hist_pos['CF'] = np.where(hist_pos.Direction == 'Buy', -1, 1) * (hist_pos.Quantity * hist_pos.Price) - hist_pos.Fees\n    hist_pos['AdjQuan'] = np.where(hist_pos.Direction == 'Sell', -1,\n                                   np.where(hist_pos.Direction == 'Div', 0, 1)) * hist_pos.Quantity\n    hist_pos['CumQuan'] = hist_pos.groupby('Ticker')['AdjQuan'].cumsum()\n\n    for ticker in hist_pos['Ticker'].unique():\n        dividends = div_df[div_df['Ticker'] == ticker].copy()\n        if not dividends.empty:\n            for (_, row) in dividends.iterrows():\n                dt_div = hist_pos[(hist_pos['Date'] <= row['Date']) & (hist_pos['Ticker'] == ticker)][\n                    'Date'].idxmax()\n                div_qty = hist_pos.loc[dt_div]['CumQuan']\n                if div_qty != 0:\n                    hist_pos = hist_pos._append(pd.DataFrame(\n                        [[row['Date'], ticker, div_qty, row['Dividends'], 0, 'Div', div_qty * row['Dividends'], 0,\n                          div_qty]],\n                        columns=hist_pos.columns), ignore_index=True)\n\n    hist_pos.sort_values(['Ticker', 'Date'], inplace=True)\n    hist_pos['CFBuy'] = np.where(hist_pos.Direction == 'Buy', hist_pos.CF, 0)\n    hist_pos['CumCost'] = hist_pos.groupby('Ticker')['CFBuy'].cumsum()\n    hist_pos['QBuy'] = np.where(hist_pos.Direction == 'Buy', hist_pos.Quantity, 0)\n    hist_pos['CumBuyQuan'] = hist_pos.groupby('Ticker')['QBuy'].cumsum()\n    hist_pos['AvgCostRaw'] = hist_pos['CumCost'] / hist_pos['CumBuyQuan']\n\n\n    if not hist_pos.empty:\n        hist_pos = hist_pos.groupby('Ticker').apply(calc_avg_price).reset_index(drop=True)\n    else:\n        hist_pos['grouping'] = 0\n        hist_pos['AvgCostAdj'] = 0\n\n    hist_pos['AvgCost'] = np.where(hist_pos['grouping'] == 0, hist_pos['AvgCostRaw'], hist_pos['AvgCostAdj'])\n    hist_pos['RlGain'] = np.where(hist_pos.Direction == 'Sell',\n                                  hist_pos.CF + hist_pos.AvgCost * hist_pos.Quantity, 0)\n    hist_pos['Dividends'] = np.where(hist_pos.Direction == 'Div', hist_pos.CF, 0)\n    hist_pos['CumDiv'] = hist_pos.groupby('Ticker')['Dividends'].cumsum()\n    hist_pos['TotalRlGain'] = hist_pos.groupby('Ticker')['RlGain'].cumsum()\n\n    return hist_pos", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    def generate_random_date(start_date='2023-01-01', end_date='2024-02-01'):\n        start = pd.Timestamp(start_date)\n        end = pd.Timestamp(end_date)\n        return start + pd.to_timedelta(np.random.randint(0, (end - start).days), unit='D')\n\n    test_cases = []\n    for _ in range(n):\n        as_at_date = generate_random_date()\n        split_data = []\n        div_data = []\n        trades_data = []\n        tickers = ['AAPL', 'TSLA', 'GOOGL', 'MSFT', 'AMZN']\n        n_row = np.random.randint(5, 100)\n        for _ in range(n_row):\n            ticker = np.random.choice(tickers)\n            date = pd.Timestamp('2023-01-01') + pd.to_timedelta(np.random.randint(0, 365), unit='D')\n            split_data.append([date, ticker, np.random.choice([2, 3, 1.5])])\n            div_data.append([date, ticker, np.random.uniform(0.1, 2)])\n            trades_data.append(\n                [date, ticker, np.random.randint(1, 100), np.random.uniform(50, 500), np.random.uniform(1, 10),\n                 np.random.choice(['Buy', 'Sell'])])\n\n        split_df = pd.DataFrame(split_data, columns=['Date', 'Ticker', 'Stock Splits'])\n        div_df = pd.DataFrame(div_data, columns=['Date', 'Ticker', 'Dividends'])\n        trades_df = pd.DataFrame(trades_data, columns=['Date', 'Ticker', 'Quantity', 'Price', 'Fees', 'Direction'])\n\n        test_cases.append((as_at_date, split_df, div_df, trades_df))\n    return test_cases"}
{"problem_id": "pandas_3", "library": "pandas", "code_problem": "You are tasked with creating a function that processes historical cryptocurrency data. The function will take a dictionary containing price, market cap, and total volume data, and return a formatted DataFrame that organizes this information in a more accessible way.\n\nFunction signature:\n```python\ndef geckoHistorical(r):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `unit='ms'`, which indicates that the timestamps in the input data are in milliseconds.\n\n\nInput format:\n- The input to the function is a dictionary `r` with the following structure:\n  ```python\n  {\n      'prices': [[timestamp1, price1], [timestamp2, price2], ...],\n      'market_caps': [[timestamp1, market_cap1], [timestamp2, market_cap2], ...],\n      'total_volumes': [[timestamp1, total_volume1], [timestamp2, total_volume2], ...]\n  }\n  ```\n\nOutput format:\n- The output of the function is a pandas DataFrame with the following structure:\n  ```\n  date                price   market_caps   total_volumes\n  2021-01-01 00:00:00  price1  market_cap1   total_volume1\n  2021-01-02 00:00:00  price2  market_cap2   total_volume2\n  ...\n  ```\n\n**Input:**\n```python\n{\n    'prices': [\n        [1577836800000, 45000.00],\n        [1577923200000, 46000.50],\n        [1578009600000, 45500.75]\n    ],\n    'market_caps': [\n        [1577836800000, 800000000],\n        [1577923200000, 810000000],\n        [1578009600000, 805000000]\n    ],\n    'total_volumes': [\n        [1577836800000, 200000000],\n        [1577923200000, 210000000],\n        [1578009600000, 205000000]\n    ]\n}\n```\n\n**Output:**\n```python\n               price  market_caps  total_volumes\ndate                                            \n2020-01-01  45000.00    800000000      200000000\n2020-01-02  46000.50    810000000      210000000\n2020-01-03  45500.75    805000000      205000000\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef geckoHistorical(r):\n    prices = pd.DataFrame(r['prices'])\n    market_caps = pd.DataFrame(r['market_caps'])\n    total_volumes = pd.DataFrame(r['total_volumes'])\n    df = pd.concat([prices, market_caps[1], total_volumes[1]], axis=1)\n    df[0] = pd.to_datetime(df[0], unit='ms')\n    df.columns = ['date', 'price', 'market_caps', 'total_volumes']\n    df.set_index('date', inplace=True)\n    return df\n", "test_script": "import numpy as np\nfrom datetime import datetime\n\ndef test_case_input_generator(n=200):\n    test_case = []\n    for _ in range(n):\n        num_entries = np.random.randint(5, 100)  # Randomly choose number of data points per test case\n        start_time = int(datetime(2020, 1, 1).timestamp() * 1000)  # Start timestamp in milliseconds\n        interval = 24 * 60 * 60 * 1000  # One-day intervals in milliseconds\n\n        r = {\n            'prices': [],\n            'market_caps': [],\n            'total_volumes': []\n        }\n\n        for i in range(num_entries):\n            timestamp = start_time + i * interval\n            price = round(np.random.uniform(10000, 60000), 2)  # Random price between 10k and 60k\n            market_cap = np.random.randint(500000000, 1000000000)  # Random market cap\n            total_volume = np.random.randint(100000000, 500000000)  # Random volume\n\n            r['prices'].append([timestamp, price])\n            r['market_caps'].append([timestamp, market_cap])\n            r['total_volumes'].append([timestamp, total_volume])\n\n        test_case.append(r)\n\n    return test_case\n"}
{"problem_id": "pandas_4", "library": "pandas", "code_problem": "You are tasked with processing a dictionary of measurements for different models in a machine learning context. The goal is to extract and organize specific metrics related to few-shot learning into a structured format using a pandas DataFrame. \n\nThe function signature of the main code is:\n```python\ndef process_fewshot_for_moe_comparison(measurements_dict):\n```\n\nIn the main code, a constant is used in the form of a tuple that defines the model names to be processed:\n```python\nmodel_name in ('MoE', '[Det]_4', '[MoE]_4')\n```\n\nInput format:\n- The input to the function is a dictionary `measurements_dict` where keys are model names and values are pandas DataFrames or Series containing numerical measurements.\n\nOutput format:\n- The output of the function is a pandas DataFrame with a MultiIndex for columns, where the first level represents the metric type and the second level represents the dataset. The index of the DataFrame corresponds to the model names.\n\n**Input:**\n```python\n{\n    'MoE': pd.DataFrame({\n        'z/cifar10_10shot_accuracy': [0.8, 0.85, 0.82],\n        'z/imagenet_20shot_best_l2': [0.1, 0.1, 0.1],\n    }),\n    '[Det]_4': pd.DataFrame({\n        'z/imagenet_5shot_recall': [0.75, 0.78, 0.76],\n        'z/mnist_1shot_accuracy': [0.85, 0.87, 0.86],\n    }),\n    '[MoE]_4': pd.DataFrame({\n        'z/mnist_20shot_best_l2': [0.15, 0.15, 0.15],\n        'z/imagenet_10shot_accuracy': [0.95, 0.96, 0.94],\n    })\n\n```\n\n**Output:**\n```python\nmetric      10shot_accuracy      5shot_recall 1shot_accuracy   10shot_accuracy\ndataset    few-shot cifar10 few-shot imagenet few-shot mnist few-shot imagenet\nmodel_name                                                                    \nMoE                0.823333               NaN            NaN               NaN\n[Det]_4                 NaN          0.763333           0.86               NaN\n[MoE]_4                 NaN               NaN            NaN              0.95\n```", "ground_truth_code": "import re\nimport pandas as pd\n\ndef _parse_column(c):\n    match = re.fullmatch('z/(.*)_(\\\\d*)shot_(.*)$', c)\n    is_valid = match is not None and 'best_l2' not in c\n    if not is_valid:\n        return None\n    else:\n        (dataset, shot, metric_type) = match.groups()\n        column_name = (f'{shot}shot_{metric_type}', f'few-shot {dataset}')\n        return column_name\n\n# main code\ndef process_fewshot_for_moe_comparison(measurements_dict):\n    def _parse_column(c):\n        match = re.fullmatch('z/(.*)_(\\\\d*)shot_(.*)$', c)\n        is_valid = match is not None and 'best_l2' not in c\n        if not is_valid:\n            return None\n        else:\n            (dataset, shot, metric_type) = match.groups()\n            column_name = (f'{shot}shot_{metric_type}', f'few-shot {dataset}')\n            return column_name\n    rows = []\n    for model_name in ('MoE', '[Det]_4', '[MoE]_4'):\n        series = measurements_dict[model_name].mean(axis=0)\n        assert isinstance(series, pd.Series)\n        fewshot_dict = series.to_dict()\n        column_names = {c: _parse_column(c) for c in fewshot_dict}\n        fewshot_dict = {column_name: fewshot_dict[key] for (key, column_name) in column_names.items() if column_name is not None}\n        fewshot_dict['model_name'] = model_name\n        rows.append(fewshot_dict)\n    df = pd.DataFrame(rows).set_index('model_name')\n    df.columns = pd.MultiIndex.from_tuples(df.columns, names=['metric', 'dataset'])\n    return df", "test_script": "import pandas as pd\nimport random\nimport numpy as np\n\n\n# Function to generate synthetic test cases\ndef test_case_input_generator(n=200):\n    test_cases = []\n    datasets = ['cifar10', 'imagenet', 'mnist']\n    metric_types = ['accuracy', 'loss', 'precision', 'recall']\n    shots = [1, 5, 10, 20]\n    models = ('MoE', '[Det]_4', '[MoE]_4')\n    row_n = np.random.randint(1, 100)\n    for _ in range(n):\n        # Create a dictionary to hold data for each model\n        measurements_dict = {}\n\n        for model in models:\n            columns = {}\n            for _ in range(row_n):\n                dataset = random.choice(datasets)\n                shot = random.choice(shots)\n                metric = random.choice(metric_types)\n\n                # 90% of the time, generate valid columns, 10% with 'best_l2' to test filtering\n                if random.random() < 0.9:\n                    col_name = f\"z/{dataset}_{shot}shot_{metric}\"\n                else:\n                    col_name = f\"z/{dataset}_{shot}shot_best_l2\"\n\n                # Generate random values (simulating measurement results)\n                columns[col_name] = np.random.uniform(0, 1, size=3)  # 3 sample measurements\n\n            # Convert to DataFrame\n            measurements_dict[model] = pd.DataFrame(columns)\n        test_cases.append(measurements_dict)\n    return test_cases\n"}
{"problem_id": "pandas_5", "library": "pandas", "code_problem": "You are tasked with creating a function that merges two dataframes based on their common columns. The function should take two pandas dataframes as input and return a new dataframe that contains the merged data. If there are no common columns between the two dataframes, the function should return None.\n\nFunction signature:\n```python\ndef merge_indicator_for_same_stock(df1, df2):\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\n\nInput format:\n- The function takes two inputs: `df1` and `df2`, which are both pandas dataframes.\n\nOutput format:\n- The function returns a pandas dataframe that is the result of merging `df1` and `df2` on their common columns, or None if there are no common columns.\n\n**Input:**\n```python\ndf1 = pd.DataFrame({\n    'Stock': ['AAPL', 'GOOG', 'AAPL'],\n    'Date': ['2020-01-01', '2020-01-02', '2020-01-03'],\n    'Feature1': [100, 200, 150]\n})\n\ndf2 = pd.DataFrame({\n    'Stock': ['AAPL', 'GOOG', 'MSFT'],\n    'Date': ['2020-01-01', '2020-01-02', '2020-01-04'],\n    'Indicator1': [10, 20, 30]\n})\n```\n\n**Output:**\n```python\n  Stock        Date  Feature1  Indicator1\n0  AAPL  2020-01-01       100          10\n1  GOOG  2020-01-02       200          20\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef merge_indicator_for_same_stock(df1, df2):\n\n    if len(set(df1.columns).intersection(set(df2.columns))) > 0:\n        common_cols = list(set(df1.columns).intersection(set(df2.columns)))\n        df = pd.merge(df1, df2, on=common_cols)\n        return df\n    else:\n        return None", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(columns, rows, common_cols=None):\n        \"\"\"Generate a random DataFrame with given columns and rows.\"\"\"\n        data = {}\n        for col in columns:\n            if \"Stock\" in col:\n                data[col] = np.random.choice([\"AAPL\", \"GOOG\", \"MSFT\", \"AMZN\", \"TSLA\"], size=rows, replace=True)\n            elif \"Date\" in col:\n                data[col] = pd.date_range(\"2020-01-01\", periods=rows).strftime('%Y-%m-%d').tolist()\n            else:\n                data[col] = np.random.randint(10, 500, size=rows)\n        return pd.DataFrame(data)\n\n    test_cases = []\n\n    for i in range(n):\n        num_cols1 = np.random.randint(1, 5)\n        num_cols2 = np.random.randint(1, 5)\n        num_rows1 = np.random.randint(0, 10)\n        num_rows2 = np.random.randint(0, 10)\n\n        common_cols = list(np.random.choice([\"Stock\", \"Date\", \"Symbol\"], np.random.randint(0, min(num_cols1, num_cols2)), replace=False))\n        df1_cols = common_cols + [f\"Feature{j}\" for j in range(num_cols1 - len(common_cols))]\n        df2_cols = common_cols + [f\"Indicator{j}\" for j in range(num_cols2 - len(common_cols))]\n\n        df1 = generate_random_dataframe(df1_cols, num_rows1)\n        df2 = generate_random_dataframe(df2_cols, num_rows2)\n\n        test_cases.append((df1, df2))\n\n    return test_cases"}
{"problem_id": "pandas_6", "library": "pandas", "code_problem": "You are tasked with implementing a function that transforms a given pandas DataFrame by melting it into a long format. The function should handle both flat and multi-level column indices and remove any empty levels from the resulting DataFrame. The function signature for the main code is as follows:\n\n```python\ndef melt(df):\n```\n\nIn the main code, the constant used is `['Metric']`, which is the name assigned to the new index level when concatenating the DataFrame.\n\n\nInput format:\n- The input to the `melt` function is a pandas DataFrame, which may have either flat or multi-level column indices.\n\nOutput format:\n- The output of the `melt` function is a transformed pandas DataFrame in long format, with any empty levels removed from the index.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a DataFrame with a MultiIndex that has an empty level\nindex = pd.MultiIndex.from_arrays(\n    [[None, None, None], ['A', 'B', 'C']],\n    names=['Level1', 'Level2']\n)\ndata = {\n    'Metric1': [1, 2, 3],\n    'Metric2': [4, 5, 6]\n}\ndf = pd.DataFrame(data, index=index)\n```\n\n**Output:**\n```\n                       Value\nMetric  Level1 Level2       \nMetric1 NaN    A           1\n               B           2\n               C           3\nMetric2 NaN    A           4\n               B           5\n               C           6\n```", "ground_truth_code": "import pandas as pd\n\ndef remove_empty_level(df):\n\n    if not isinstance(df, pd.DataFrame) or not isinstance(df.index, pd.MultiIndex):\n        return df\n    drop = []\n    for (i, level) in enumerate(df.index.levels):\n        if not level.name and len(level.values) == 1 and (not level.values[0]):\n            drop.append(i)\n    return df.droplevel(drop)\n\n# main code\ndef melt(df):\n    if df.empty:\n        return df\n    if not isinstance(df, pd.DataFrame):\n        return df\n    if isinstance(df.columns, pd.MultiIndex):\n        flat_idx = False\n        names = df.columns.get_level_values(0).unique()\n    else:\n        flat_idx = True\n        names = df.columns\n    if len(names) == 0:\n        return df\n    try:\n        df = pd.concat([df[n] for n in names if n in df], keys=names, names=['Metric'])\n    except ValueError:\n        return df\n\n    df = pd.DataFrame(df)\n    if flat_idx:\n        df.columns = ['Value']\n\n    return remove_empty_level(df)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly decide the type of DataFrame\n        case_type = random.choice([\n            \"single_index\", \"multi_index\", \"multi_index_with_empty\",\n            \"multi_col_index\", \"empty\", \"with_nan\"\n        ])\n\n        num_rows = random.randint(1, 10)  # Limit rows to avoid huge outputs\n        num_cols = random.randint(1, 5)\n\n        if case_type == \"single_index\":\n            df = pd.DataFrame(\n                np.random.randint(0, 100, size=(num_rows, num_cols)),\n                columns=[f\"Col_{i}\" for i in range(num_cols)]\n            )\n\n        elif case_type == \"multi_index\":\n            levels = [\n                np.random.choice(['A', 'B', 'C'], size=num_rows),\n                np.random.randint(0, 10, size=num_rows)\n            ]\n            index = pd.MultiIndex.from_arrays(levels, names=['Level1', 'Level2'])\n            df = pd.DataFrame(np.random.rand(num_rows, num_cols), index=index,\n                              columns=[f\"Col_{i}\" for i in range(num_cols)])\n\n        elif case_type == \"multi_index_with_empty\":\n            levels = [\n                [None] * num_rows,  # Empty level\n                np.random.choice(['X', 'Y', 'Z'], size=num_rows)\n            ]\n            index = pd.MultiIndex.from_arrays(levels)\n            df = pd.DataFrame(np.random.rand(num_rows, num_cols), index=index,\n                              columns=[f\"Col_{i}\" for i in range(num_cols)])\n\n        elif case_type == \"multi_col_index\":\n            col_levels = [\n                np.random.choice(['Metric1', 'Metric2'], size=num_cols),\n                [f\"Sub_{i}\" for i in range(num_cols)]\n            ]\n            columns = pd.MultiIndex.from_arrays(col_levels, names=['Metric', 'Submetric'])\n            df = pd.DataFrame(np.random.rand(num_rows, num_cols), columns=columns)\n\n        elif case_type == \"empty\":\n            df = pd.DataFrame()\n\n        elif case_type == \"with_nan\":\n            df = pd.DataFrame(\n                np.random.choice([1, 2, 3, np.nan], size=(num_rows, num_cols)),\n                columns=[f\"Col_{i}\" for i in range(num_cols)]\n            )\n\n        test_cases.append(df)\n\n    return test_cases"}
{"problem_id": "pandas_7", "library": "pandas", "code_problem": "You are tasked with writing a function that fills in missing technology descriptions for power plants based on their operational data. The function should take a DataFrame containing information about various power plants and their generators, and it should fill in any missing technology descriptions by backfilling from subsequent entries in the DataFrame.\n\nFunction signature:\n```python\ndef fill_missing_tech_descriptions(df, date_col):\n```\n\nConstant used in the main code:\n- There are no constants explicitly defined in the main code.\n\n\nInput format:\n- The input to the function is a pandas DataFrame `df` with at least the following columns: `plant_id_eia`, `generator_id`, and `technology_description`, along with a date column specified by `date_col`.\n\nOutput format:\n- The output of the function is a pandas DataFrame that includes all original rows from `df`, with missing `technology_description` values filled in where possible.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'plant_id_eia': [1, 1, 1, 2, 2, 3],\n    'generator_id': ['A', 'A', 'A', 'B', 'B', 'C'],\n    'technology_description': ['Solar', None, None, 'Wind', None, 'Gas'],\n    'report_date': pd.to_datetime(['2023-01-01', '2023-01-02', '2023-01-03', \n                                    '2023-01-01', '2023-01-02', '2023-01-01'])\n}\n\ndf = pd.DataFrame(data)\ndate_col = 'report_date'\n```\n\n**Output:**\n```python\n   plant_id_eia generator_id technology_description report_date\n0             1            A                  Solar  2023-01-01\n3             2            B                   Wind  2023-01-01\n5             3            C                    Gas  2023-01-01\n0             1            A                   None  2023-01-02\n1             1            A                   None  2023-01-03\n2             2            B                   None  2023-01-02\n```", "ground_truth_code": "import pandas as pd\n\n\n# main code\ndef fill_missing_tech_descriptions(df, date_col):\n    df = df.sort_values(by=date_col)\n    df_list = []\n    missing_tech_plants = df.loc[df['technology_description'].isna(), :]\n    if missing_tech_plants.empty:\n        return df\n    df = df.drop(index=missing_tech_plants.index)\n    for (_, _df) in missing_tech_plants.groupby(['plant_id_eia', 'generator_id'], as_index=False):\n        _df['technology_description'].fillna(method='bfill', inplace=True)\n        df_list.append(_df)\n    results = pd.concat([df, pd.concat(df_list, ignore_index=True, sort=False)])\n\n    return results", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_rows = np.random.randint(1, 100)\n        plant_ids = np.random.randint(1, 10, size=n_rows)\n        generator_ids = np.random.choice(['A', 'B', 'C', 'D'], size=n_rows)\n        dates = pd.date_range(start='2023-01-01', periods=n_rows, freq='D')\n\n        tech_options = ['Solar', 'Wind', 'Hydro', 'Gas', None]\n        tech_descriptions = [random.choice(tech_options) for _ in range(n_rows)]\n\n        df = pd.DataFrame({\n            'plant_id_eia': plant_ids,\n            'generator_id': generator_ids,\n            'technology_description': tech_descriptions,\n            'report_date': np.random.choice(dates, size=n_rows, replace=False)\n        })\n        date_col = 'report_date'\n        test_cases.append((df, date_col))\n    return test_cases"}
{"problem_id": "pandas_8", "library": "pandas", "code_problem": "The task is to implement a function that compares two pandas DataFrames, `df_original` and `df_generated`, to evaluate their similarity based on uniqueness, data quality, and distribution similarity. The function should return a similarity score between 0 and 1, where 0 indicates no similarity and 1 indicates perfect similarity.\n\nFunction Signature:\n```python\ndef compare_dataframes(df_original: pd.DataFrame, df_generated: pd.DataFrame) -> float:\n```\n\nConstant Used:\n- A small constant value of `1e-06` is used to prevent division by zero in calculations.\n\n\nInput Format:\n- The function takes two parameters:\n  - `df_original`: A pandas DataFrame representing the original dataset.\n  - `df_generated`: A pandas DataFrame representing the generated dataset.\n\nOutput Format:\n- The function returns a float value representing the similarity score between the two DataFrames, which ranges from 0 to 1.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Original DataFrame\ndf_original = pd.DataFrame({\n    'Col_0': [1, 2, 3, 4, 5],\n    'Col_1': [10, 20, 30, 40, 50],\n    'Col_2': [100, 200, 300, 400, 500]\n})\n\n# Generated DataFrame\ndf_generated = pd.DataFrame({\n    'Col_0': [1, 2, 3, 4, 6],\n    'Col_1': [10, 20, 30, 40, 60],\n    'Col_2': [100, 200, 300, 400, 600]\n})\n\n# Call the function\nsimilarity_score = compare_dataframes(df_original, df_generated)\n```\n\n**Output:**\n```python\n0.7000002999999999\n```", "ground_truth_code": "from scipy.stats import entropy\nimport pandas as pd\n\n# main code\ndef compare_dataframes(df_original, df_generated):\n\n    n_original = len(df_original)\n    n_generated = len(df_generated)\n    min_rows = min(n_original, n_generated)\n    uniq_original = df_original.nunique().sum() / (len(df_original.columns) + 1e-06)\n    uniq_generated = df_generated.nunique().sum() / (len(df_generated.columns) + 1e-06)\n    uniqueness_score = uniq_generated / uniq_original * (min_rows / n_generated)\n    data_quality_scores = []\n    for col in df_original.columns:\n        if col in df_generated.columns:\n            if pd.api.types.is_numeric_dtype(df_original[col]) and pd.api.types.is_numeric_dtype(df_generated[col]):\n                (_, p_value) = (df_original[col].value_counts().sort_index(ascending=False).diff().dropna().abs().sum() / (n_original + 1e-06), df_generated[col].value_counts().sort_index(ascending=False).diff().dropna().abs().sum() / (n_generated + 1e-06))\n                p_value = max(p_value, 1e-06)\n                data_quality_scores.append(p_value)\n    data_quality_score = sum(data_quality_scores) / len(data_quality_scores) if data_quality_scores else 1\n    psi_scores = []\n    for col_orig in df_original.columns:\n        if col_orig in df_generated.columns:\n            p_orig = df_original[col_orig].value_counts(normalize=True)\n            p_gen = df_generated[col_orig].value_counts(normalize=True)\n            h_orig = entropy(p_orig, base=2)\n            h_gen = entropy(p_gen, base=2)\n            h_joint = entropy(pd.concat([p_orig, p_gen], ignore_index=True), base=2)\n            psi = max(0, min(h_orig + h_gen - h_joint, 1))\n            psi_scores.append(psi)\n    psi_similarity = sum(psi_scores) / len(psi_scores) if psi_scores else 1\n    similarity_score = 0.5 * uniqueness_score + 0.3 * data_quality_score + 0.2 * psi_similarity\n    similarity_score = min(max(similarity_score, 0), 1)\n    return similarity_score", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(n_rows, n_cols, categorical=False, nan_prob=0.0):\n        \"\"\"Generate a random DataFrame with numerical or categorical data.\"\"\"\n        columns = [f'Col_{i}' for i in range(n_cols)]\n        data = []\n        for _ in range(n_rows):\n            if categorical:\n                row = [random.choice(['A', 'B', 'C', 'D', 'E']) if random.random() > nan_prob else np.nan for _ in\n                       range(n_cols)]\n            else:\n                row = [random.uniform(0, 100) if random.random() > nan_prob else np.nan for _ in range(n_cols)]\n            data.append(row)\n        return pd.DataFrame(data, columns=columns)\n\n    \"\"\"Generate and execute test cases for compare_dataframes.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        test_type = random.choice([\"identical\", \"random\", \"missing_columns\", \"extra_rows\", \"nan_values\", \"categorical\"])\n        n_rows, n_cols = random.randint(10, 100), random.randint(5, 20)\n        if test_type == \"identical\":\n            df1 = generate_random_dataframe(n_rows, n_cols)\n            df2 = df1.copy()\n        elif test_type == \"random\":\n            df1 = generate_random_dataframe(random.randint(5, 50), random.randint(3, 10))\n            df2 = generate_random_dataframe(random.randint(5, 50), random.randint(3, 10))\n        elif test_type == \"missing_columns\":\n            df1 = generate_random_dataframe(n_rows, n_cols)\n            df2 = df1.drop(columns=random.sample(list(df1.columns), random.randint(1, 3)))\n        elif test_type == \"extra_rows\":\n            df1 = generate_random_dataframe(n_rows, n_cols)\n            df2 = generate_random_dataframe(n_rows, n_cols)\n        elif test_type == \"nan_values\":\n            df1 = generate_random_dataframe(n_rows, n_cols, nan_prob=0.2)\n            df2 = generate_random_dataframe(n_rows, n_cols, nan_prob=0.4)\n        elif test_type == \"categorical\":\n            df1 = generate_random_dataframe(n_rows, n_cols, categorical=True)\n            df2 = generate_random_dataframe(n_rows, n_cols, categorical=True)\n\n        test_cases.append((df1, df2))\n    return test_cases"}
{"problem_id": "pandas_9", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates a cumulative integral based on the difference between two time series. The function will take two pandas Series as input, representing the difference (`dif`) and the desired effect (`dea`). The goal is to compute a new Series that accumulates values based on the signs of the differences between `dif` and `dea`.\n\nFunction signature:\n```python\ndef get_integral(dif: pd.Series, dea: pd.Series) -> pd.Series:\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\n\nInput format:\n- The function takes two parameters:\n  - `dif`: A pandas Series representing the difference values.\n  - `dea`: A pandas Series representing the desired effect values.\n\nOutput format:\n- The function returns a pandas Series containing the cumulative integral values based on the logic described.\n\nInput:\n```python\ndif = pd.Series([-3, 5, -2, 4, -1], index=pd.date_range(start=\"2020-01-01\", periods=5, freq=\"D\"))\ndea = pd.Series([1, -1, 2, -2, 0], index=pd.date_range(start=\"2020-01-01\", periods=5, freq=\"D\"))\n```\n\nOutput:\n```python\n2020-01-01    0.0\n2020-01-02    0.0\n2020-01-03    0.0\n2020-01-04    0.0\n2020-01-05    0.0\nFreq: D, dtype: float64\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef get_integral(dif, dea):\n    ser = pd.Series(index=dif.index)\n    for (i, v) in enumerate(dif - dea):\n        if i:\n            curret_sign = np.sign(v)\n            if curret_sign == previous_sign:\n                ser.iloc[i] = v + previous_v\n            else:\n                ser.iloc[i] = 0\n            previous_sign = curret_sign\n            previous_v = v\n        else:\n            ser.iloc[i] = 0\n            previous_sign = np.sign(v)\n            previous_v = v\n            continue\n    return ser", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        length = np.random.randint(1, 100)\n        index = pd.date_range(start=\"2020-01-01\", periods=length, freq=\"D\")  # Generate index\n        dif = pd.Series(np.random.randint(-10, 10, size=length), index=index)\n        dea = pd.Series(np.random.randint(-10, 10, size=length), index=index)\n\n        test_cases.append((dif, dea))\n\n    return test_cases"}
{"problem_id": "pandas_10", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs a series of mathematical operations on specified features of a given DataFrame. The function will create new columns based on these operations and return a modified DataFrame that includes both the original and the newly created columns.\n\nFunction signature:\n```python\ndef operations(df: pd.DataFrame, features: list) -> pd.DataFrame:\n```\n\nIn the main code, the following constant is used:\n- The constant value `1` is added to the DataFrame values during logarithmic, reciprocal, and square root calculations to avoid mathematical errors such as taking the log of zero or finding the reciprocal of zero.\n\nInput format:\n- The input consists of a pandas DataFrame `df` and a list of strings `features` representing the column names to be processed.\n\nOutput format:\n- The output is a pandas DataFrame that includes the original columns specified in `features` along with the newly created columns for each of the mathematical operations performed.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test DataFrame\ndata = {\n    'Col_0': [10, 20, 30],\n    'Col_1': [5, 15, 25],\n    'Col_2': [0, 10, 20]\n}\ndf = pd.DataFrame(data)\n\n# Features to be used\nfeatures = ['Col_0', 'Col_1', 'Col_2']\n```\n\n**Output:**\n```python\n   Col_0  Col_1  Col_2  ...  Col_0_SQRT_p_one  Col_1_SQRT_p_one  Col_2_SQRT_p_one\n0     10      5      0  ...          1.000000          1.000000          1.000000\n1     20     15     10  ...          3.316625          3.316625          3.316625\n2     30     25     20  ...          4.582576          4.582576          4.582576\n[3 rows x 15 columns]\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef operations(df, features):\n    df_new = df[features]\n    df_new = df_new - df_new.min()\n    sqr_name = [str(fa) + '_POWER_2' for fa in df_new.columns]\n    log_p_name = [str(fa) + '_LOG_p_one_abs' for fa in df_new.columns]\n    rec_p_name = [str(fa) + '_RECIP_p_one' for fa in df_new.columns]\n    sqrt_name = [str(fa) + '_SQRT_p_one' for fa in df_new.columns]\n    df_sqr = pd.DataFrame(np.power(df_new.values, 2), columns=sqr_name, index=df.index)\n    df_log = pd.DataFrame(np.log(df_new.add(1).abs().values), columns=log_p_name, index=df.index)\n    df_rec = pd.DataFrame(np.reciprocal(df_new.add(1).values), columns=rec_p_name, index=df.index)\n    df_sqrt = pd.DataFrame(np.sqrt(df_new.abs().add(1).values), columns=sqrt_name, index=df.index)\n    dfs = [df, df_sqr, df_log, df_rec, df_sqrt]\n    df = pd.concat(dfs, axis=1)\n    return df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(5, 100)\n        num_cols = np.random.randint(5, 20)\n        col_names = [f\"Col_{j}\" for j in range(num_cols)]\n\n        # Generate random data with values between -100 and 100\n        data = np.random.uniform(-100, 100, size=(num_rows, num_cols))\n        df_test = pd.DataFrame(data, columns=col_names)\n\n        # Randomly select feature columns to be used\n        num_features = np.random.randint(1, num_cols)  # Select at least 1 feature\n        features_test = np.random.choice(col_names, num_features, replace=False).tolist()\n\n        test_cases.append((df_test, features_test))\n\n    return test_cases"}
{"problem_id": "pandas_11", "library": "pandas", "code_problem": "You are tasked with updating the planned retirement dates of power generation units based on new data provided in a DataFrame. The function `update_planned_retirement_date_860m` takes two DataFrames as input: one containing the current planned retirement dates and another containing updated retirement years. The goal is to replace the planned retirement dates in the first DataFrame with the new dates from the second DataFrame where applicable.\n\nFunction signature:\n```python\ndef update_planned_retirement_date_860m(df: pd.DataFrame, operating_860m: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `9999`, which serves as a placeholder for missing years when comparing dates.\n\n\nInput format:\n- The function takes two parameters:\n  - `df`: A pandas DataFrame containing at least the columns `'plant_id_eia'`, `'generator_id'`, and `'planned_retirement_date'`.\n  - `operating_860m`: A pandas DataFrame containing at least the columns `'plant_id_eia'`, `'generator_id'`, and `'planned_retirement_year'`.\n\nOutput format:\n- The function returns a pandas DataFrame that has the same structure as the input DataFrame `df`, with updated values in the `'planned_retirement_date'` column where applicable.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ndf = pd.DataFrame({\n    'plant_id_eia': [1, 2, 3],\n    'generator_id': ['A', 'B', 'C'],\n    'planned_retirement_date': pd.to_datetime(['2025-12-31', '2023-06-30', None])\n})\n\noperating_860m = pd.DataFrame({\n    'plant_id_eia': [1, 2, 3],\n    'generator_id': ['A', 'B', 'C'],\n    'planned_retirement_year': [2024, 2023, 2025]\n})\n```\n\n**Output:**\n```python\n   plant_id_eia generator_id planned_retirement_date\n0             1            A              2024-01-01\n1             2            B              2023-06-30\n2             3            C              2025-01-01\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef update_planned_retirement_date_860m(df, operating_860m):\n    if 'planned_retirement_date' not in df.columns:\n        return df\n    if 'planned_retirement_year' not in operating_860m.columns:\n        return df\n    if df.empty or operating_860m.empty:\n        return df\n    _df = df.set_index(['plant_id_eia', 'generator_id'])\n    _operating_860m = operating_860m.set_index(['plant_id_eia', 'generator_id'])\n    _operating_860m['planned_retirement_date_860m'] = pd.to_datetime(_operating_860m['planned_retirement_year'], format='%Y')\n    update_df = pd.merge(_df, _operating_860m[['planned_retirement_date_860m']], how='inner', left_index=True, right_index=True)\n    mask = update_df.loc[update_df['planned_retirement_date'].dt.year.fillna(9999) != update_df['planned_retirement_date_860m'].dt.year.fillna(9999), :].index\n    _df.loc[mask, 'planned_retirement_date'] = update_df.loc[mask, 'planned_retirement_date_860m']\n    return _df.reset_index()", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        row_n = np.random.randint(1, 100)\n        plant_ids = np.random.randint(1, 1000, size=row_n)\n        generator_ids = np.random.choice([chr(i) for i in range(65, 91)], size=row_n)  # A-Z\n\n        # Generate planned retirement dates with some None values\n        planned_retirement_dates = pd.Series(\n            pd.to_datetime(\n                np.random.choice(pd.date_range(\"2020-01-01\", \"2050-12-31\", freq='Y'), size=row_n),\n                errors='coerce'\n            )\n        )\n        planned_retirement_dates.iloc[np.random.rand(row_n) < 0.1] = pd.NaT  # Introduce some NaT values\n\n        df = pd.DataFrame({\n            'plant_id_eia': plant_ids,\n            'generator_id': generator_ids,\n            'planned_retirement_date': planned_retirement_dates\n        })\n\n        # Ensure unique index for merging\n        df = df.drop_duplicates(subset=['plant_id_eia', 'generator_id'])\n\n        # Generate operating_860m data, allowing for some overlap\n        operating_plant_ids = np.random.choice(plant_ids, size=row_n, replace=True)\n        operating_generator_ids = np.random.choice(generator_ids, size=row_n, replace=True)\n        planned_retirement_years = np.random.randint(2020, 2055, size=row_n)\n\n        operating_860m = pd.DataFrame({\n            'plant_id_eia': operating_plant_ids,\n            'generator_id': operating_generator_ids,\n            'planned_retirement_year': planned_retirement_years\n        })\n\n        # Ensure unique index for merging\n        operating_860m = operating_860m.drop_duplicates(subset=['plant_id_eia', 'generator_id'])\n\n        test_cases.append((df, operating_860m))\n\n    return test_cases"}
{"problem_id": "pandas_12", "library": "pandas", "code_problem": "You are tasked with implementing a function that creates a time delay embedding from a given time series. This function will allow you to generate a dataset that includes past values (lags) of the series as well as future values (horizon) for predictive modeling.\n\nFunction Signature:\n```python\ndef time_delay_embedding(series: pd.Series, n_lags: int, horizon: int, return_Xy: bool) -> Union[pd.DataFrame, Tuple[pd.DataFrame, pd.Series]]:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0`, which is used to identify the current time step in the lagged series.\n\nInput Format:\n- A pandas Series `series` containing the time series data.\n- An integer `n_lags` representing the number of lagged observations.\n- An integer `horizon` representing the number of future observations.\n- A boolean `return_Xy` indicating the desired return format.\n\nOutput Format:\n- If `return_Xy` is `False`, the output is a pandas DataFrame containing the lagged values.\n- If `return_Xy` is `True`, the output is a tuple containing:\n  - A pandas DataFrame `X` with the lagged features.\n  - A pandas Series or DataFrame `Y` with the target values.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a test series\ntest_series = pd.Series([1, 2, 3, 4, 5], name='TestSeries')\n\n# Parameters\nn_lags = 2\nhorizon = 1\nreturn_Xy = True\n\n# Calling the function\nX, Y = time_delay_embedding(test_series, n_lags, horizon, return_Xy)\n```\n\n**Output:**\n```python\n# X\n   TestSeries(t-1)  TestSeries(t)\n2              1.0            2.0\n3              2.0            3.0\n4              3.0            4.0\n\n# Y\n2    3\n3    4\n4    5\nName: TestSeries(t+1), dtype: int64\n```", "ground_truth_code": "import re\nimport pandas as pd\nimport numpy as np\n\n# main code\ndef time_delay_embedding(series, n_lags, horizon, return_Xy):\n    if series.name is None:\n        name = 'Series'\n    else:\n        name = series.name\n    n_lags_iter = list(range(n_lags, -horizon, -1))\n    df_list = [series.shift(i) for i in n_lags_iter]\n    df = pd.concat(df_list, axis=1).dropna()\n    df.columns = [f'{name}(t-{j - 1})' if j > 0 else f'{name}(t+{np.abs(j) + 1})' for j in n_lags_iter]\n    df.columns = [re.sub('t-0', 't', x) for x in df.columns]\n    if not return_Xy:\n        return df\n    is_future = df.columns.str.contains('\\\\+')\n    X = df.iloc[:, ~is_future]\n    Y = df.iloc[:, is_future]\n    if Y.shape[1] == 1:\n        Y = Y.iloc[:, 0]\n    return (X, Y)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n\n    def generate_random_series(length, name=None):\n        data = np.random.randn(length)  # Random normal distribution\n        return pd.Series(data, name=name)\n\n    # Generate test cases\n    test_cases = []\n\n    for i in range(n):\n        series_length = random.randint(1, 100)  # Random series length\n        n_lags = random.randint(0, max(0, series_length - 1))  # Random lags within length\n        horizon = random.randint(1, 10)  # Random horizon between 1 and 10\n        return_Xy = random.choice([True, False])  # Random boolean\n\n        series_name = f\"TestSeries_{i}\"\n        series = generate_random_series(series_length, name=series_name)\n\n        test_cases.append((series, n_lags, horizon, return_Xy))\n    return test_cases"}
{"problem_id": "pandas_13", "library": "pandas", "code_problem": "You are tasked with implementing a function that splits a dataset into training and testing sets based on a specified split ratio. The dataset contains records of various categories, each associated with a date. The function should ensure that the training and testing sets maintain a balanced representation of categories while also considering the chronological order of the dates.\n\nFunction Signature:\n```python\ndef split_train_test_vec(data: pd.DataFrame, split: float) -> Tuple[pd.DataFrame, pd.DataFrame]:\n```\n\nConstant Used:\n- The constant used in the main code is `1`, which is used to indicate the cutoff for splitting the data into training and testing sets.\n\nInput Format:\n- The input to the function is a pandas DataFrame `data` containing at least the columns 'Category_id' and 'Date', and a float `split` representing the proportion of data to be used for training.\n\nOutput Format:\n- The function returns a tuple containing two pandas DataFrames: the first is the training set and the second is the testing set.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'Category_id': [1, 1, 1, 2, 2, 3, 3, 3, 3],\n    'Date': ['2023-01-01', '2023-01-02', '2023-01-03', \n             '2023-01-01', '2023-01-02', \n             '2023-01-01', '2023-01-02', '2023-01-03', '2023-01-04'],\n    'Inflation t': [2.5, 3.0, 2.8, \n                    1.5, 1.7, \n                    4.0, 4.2, 4.1, 4.3]\n})\n\nsplit = 0.5\n```\n\n**Output:**\n```python\ntrain_fixed = \nCategory_id        Date  Inflation t  cutoff\n0           1  2023-01-01          2.5     0.0\n1           1  2023-01-02          3.0     0.0\n2           2  2023-01-01          1.5     0.0\n3           2  2023-01-02          1.7     0.0\n4           3  2023-01-02          4.2     0.0\n5           3  2023-01-03          4.1     0.0,\n\ntest_fixed = \nCategory_id        Date  Inflation t  cutoff\n0           1  2023-01-03          2.8     1.0\n1           3  2023-01-04          4.3     1.0\n```", "ground_truth_code": "import pandas as pd\nimport datetime\n\n# main code\ndef split_train_test_vec(data, split):\n    train = pd.DataFrame(columns=data.columns)\n    test = pd.DataFrame(columns=data.columns)\n    all_categories = data['Category_id'].unique().tolist()\n\n    for category in all_categories:\n        df = data[data['Category_id'] == category].copy()\n        max_date = datetime.datetime.strptime(df.Date.max(), '%Y-%m-%d')\n        min_date = datetime.datetime.strptime(df.Date.min(), '%Y-%m-%d')\n        days_diff = (max_date - min_date).days\n        cutoff_date = max_date - datetime.timedelta(days=int(days_diff * (1 - split)))\n\n        df.loc[:, 'cutoff'] = df['Date'].apply(\n            lambda x: 1 if datetime.datetime.strptime(x, '%Y-%m-%d') > cutoff_date else 0\n        )\n\n        if not df[df['cutoff'] == 0].empty:\n            train = pd.concat([train, df[df['cutoff'] == 0].dropna(axis=1, how='all')], ignore_index=True)\n\n        if not df[df['cutoff'] == 1].empty:\n            test = pd.concat([test, df[df['cutoff'] == 1].dropna(axis=1, how='all')], ignore_index=True)\n\n    train_fixed = pd.DataFrame(columns=train.columns)\n    test_fixed = pd.DataFrame(columns=test.columns)\n    mode_train = int(train['Category_id'].value_counts().mode().min())\n    mode_test = int(test['Category_id'].value_counts().mode().min())\n\n    for (i, data_set) in enumerate([train, test]):\n        data_set_categories = data_set['Category_id'].unique().tolist()\n        for category in data_set_categories:\n            df = data_set[data_set['Category_id'] == category].copy()\n            df.sort_values(by=['Date'], axis=0, ascending=[True], inplace=True)\n\n            if i == 0:\n                if df.shape[0] == mode_train:\n                    train_fixed = pd.concat([train_fixed, df.dropna(axis=1, how='all')], ignore_index=True)\n                elif df.shape[0] > mode_train:\n                    train_fixed = pd.concat([train_fixed, df.tail(mode_train).dropna(axis=1, how='all')],\n                                            ignore_index=True)\n            elif i == 1:\n                if df.shape[0] == mode_test:\n                    test_fixed = pd.concat([test_fixed, df.dropna(axis=1, how='all')], ignore_index=True)\n                elif df.shape[0] > mode_test:\n                    if not df.head(mode_test).empty:\n                        test_fixed = pd.concat([test_fixed, df.head(mode_test).dropna(axis=1, how='all')],\n                                               ignore_index=True)\n\n    return train_fixed, test_fixed", "test_script": "import pandas as pd\nimport numpy as np\nimport datetime\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_categories = random.randint(3, 10)\n        categories = np.arange(1, num_categories + 1)\n        num_rows = random.randint(50, 300)\n        start_date = datetime.date(2020, 1, 1)\n        end_date = datetime.date(2023, 12, 31)\n        date_range = pd.date_range(start=start_date, end=end_date, freq='D')\n        dates = np.random.choice(date_range, size=num_rows)\n        data = pd.DataFrame({\n            'Category_id': np.random.choice(categories, num_rows),\n            'Date': pd.to_datetime(dates).strftime('%Y-%m-%d'),\n            'Inflation t': np.random.rand(num_rows) * 10\n        })\n        for i in range(1, random.randint(3, 7)):\n            data[f'Inflation t-{i}'] = np.random.rand(num_rows) * 10\n        data.sort_values(by=['Category_id', 'Date'], inplace=True)\n        split_ratio = round(random.uniform(0.5, 0.9), 2)\n\n        test_cases.append((data, split_ratio))\n\n    return test_cases"}
{"problem_id": "pandas_14", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the Inverse Distance Weighted (IDW) scores for a set of predictions based on their distances and classes. The function will take in the distances of the k-nearest neighbors, their predicted classes, the number of neighbors (k), and the unique classes present in the dataset. The goal is to compute a weighted score for each class based on the distances of the neighbors, normalizing the scores so that they sum to 1 for each instance.\n\nFunction signature:\n```python\ndef _calc_idw_weighted_score(knn_pred_dist, knn_pred_class, k, classes):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is added to the `knn_pred_dist` to avoid division by zero when calculating the inverse distance.\n\n\nInput format:\n- `knn_pred_dist`: A DataFrame containing the distances of the k-nearest neighbors.\n- `knn_pred_class`: A DataFrame containing the predicted classes of the k-nearest neighbors.\n- `k`: An integer representing the number of nearest neighbors to consider.\n- `classes`: A list of unique class labels.\n\nOutput format:\n- A DataFrame containing the normalized Inverse Distance Weighted scores for each class, with rows corresponding to instances and columns corresponding to class labels.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\nknn_pred_dist = pd.DataFrame([[0.5, 1.0, 1.5],\n                               [0.2, 0.3, 0.4],\n                               [0.6, 0.7, 0.8]])\n\nknn_pred_class = pd.DataFrame([[0, 1, 0],\n                                [1, 1, 0],\n                                [0, 0, 1]])\n\nk = 3\nclasses = [0, 1]\n```\n\n**Output:**\n```python\n          0         1\n0  0.680851  0.319149\n1  0.308300  0.691700\n2  0.685912  0.314088\n```", "ground_truth_code": "import pandas as pd\n\ndef _calc_inverse_distance(df, k, power=-1.0):\n    df = df.iloc[:, 0:k].copy()\n    df = df.pow(power)\n    idw = df.div(df.sum(axis=1), axis=0)\n    return idw\n\ndef _normalize_rows(df):\n    df_row_norm = df.div(df.sum(axis=1), axis=0)\n    return df_row_norm\n\n# main code\ndef _calc_idw_weighted_score(knn_pred_dist, knn_pred_class, k, classes):\n    l = []\n    idw = _calc_inverse_distance(knn_pred_dist + 1, k=k)\n    for e in classes:\n        weighted_score = idw * (knn_pred_class.iloc[:, 0:k] == e).astype(int)\n        l.append(weighted_score.sum(axis=1))\n    ws = pd.concat(l, axis=1)\n    ws.columns = classes\n    wsn = _normalize_rows(ws)\n    return wsn", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for i in range(n):\n        k = np.random.randint(1, 100)\n        row_n = np.random.randint(5, 50)\n        classes = [x for x in range(k)]\n\n        knn_pred_dist = pd.DataFrame(np.random.rand(row_n, k) * 10 + 0.1)\n\n        # Generate random class labels\n        knn_pred_class = pd.DataFrame(np.random.choice(classes, size=(row_n, k)))\n\n        test_cases.append((knn_pred_dist, knn_pred_class, k, classes))\n\n    return test_cases"}
{"problem_id": "pandas_15", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a DataFrame containing scores for different classes and their associated confidence levels. The function will generate a new DataFrame that summarizes the most likely class types and their corresponding scores based on the input data.\n\nFunction Signature:\n```python\ndef post_process(df: pd.DataFrame, config: Any) -> pd.DataFrame:\n```\n\n### Constants Used:\n- A constant threshold value of `0.0005` is used to filter the output scores.\n\n### Input Format:\n- `df`: A pandas DataFrame containing the following columns:\n  - `score_0`, `score_1`, ..., `score_n`: Scores for each class.\n  - `conf`: Confidence values for each row.\n  - `xmin`: Start values.\n  - `xmax`: End values.\n  - `video_name`: Name of the video.\n\n- `config`: An object that contains a list `class_real`, which maps the indices of the scores to their corresponding class types.\n\n### Output Format:\n- The function returns a pandas DataFrame with the following columns:\n  - `out_type`: The predicted class type.\n  - `out_score`: The corresponding score for the predicted class type.\n  - `start`: The start values from the original DataFrame.\n  - `end`: The end values from the original DataFrame.\n  - `video_name`: The name of the video associated with the predictions.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test DataFrame\ndf_test = pd.DataFrame({\n    'conf': [0.9, 0.8, 0.7],\n    'xmin': [0, 10, 20],\n    'xmax': [5, 15, 25],\n    'video_name': ['test_video_0', 'test_video_1', 'test_video_2'],\n    'score_0': [0.1, 0.2, 0.3],\n    'score_1': [0.4, 0.5, 0.1],\n    'score_2': [0.5, 0.3, 0.6]\n})\n\nclass MockConfig:\n    class_real = [1, 2, 3]  # Assuming 3 classes\n\nconfig = MockConfig()\n```\n\n**Output:**\n```python\n   out_type  out_score  start  end    video_name\n0         2       0.45      0    5  test_video_0\n1         1       0.40     10   15  test_video_0\n2         2       0.42     20   25  test_video_0\n0         1       0.36      0    5  test_video_0\n1         2       0.24     10   15  test_video_0\n2         1       0.07     20   25  test_video_0\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef post_process(df, config):\n    num_classes = sum(col.startswith('score_') for col in df.columns)\n    class_scores_class = [df[f'score_{i}'].values[:].tolist() for i in range(num_classes)]\n    class_scores_seg = [[class_scores_class[j][i] for j in range(num_classes)] for i in range(len(df))]\n    class_real = [0] + config.class_real\n    class_type_list = []\n    class_score_list = []\n    for i in range(len(df)):\n        class_score = np.array(class_scores_seg[i][1:]) * df.conf.values[i]\n        class_score = class_score.tolist()\n        class_type = class_real[class_score.index(max(class_score)) + 1]\n        class_type_list.append(class_type)\n        class_score_list.append(max(class_score))\n    resultDf1 = pd.DataFrame()\n    resultDf1['out_type'] = class_type_list\n    resultDf1['out_score'] = class_score_list\n    resultDf1['start'] = df.xmin.values[:]\n    resultDf1['end'] = df.xmax.values[:]\n    class_type_list = []\n    class_score_list = []\n    for i in range(len(df)):\n        class_score = np.array(class_scores_seg[i][1:]) * df.conf.values[i]\n        class_score = class_score.tolist()\n        class_score[class_score.index(max(class_score))] = 0\n        class_type = class_real[class_score.index(max(class_score)) + 1]\n        class_type_list.append(class_type)\n        class_score_list.append(max(class_score))\n    resultDf2 = pd.DataFrame()\n    resultDf2['out_type'] = class_type_list\n    resultDf2['out_score'] = class_score_list\n    resultDf2['start'] = df.xmin.values[:]\n    resultDf2['end'] = df.xmax.values[:]\n    resultDf1 = pd.concat([resultDf1, resultDf2])\n    class_type_list = []\n    class_score_list = []\n    for i in range(len(df)):\n        class_score = np.array(class_scores_seg[i][1:]) * df.conf.values[i]\n        class_score = class_score.tolist()\n        class_score[class_score.index(max(class_score))] = 0\n        class_score[class_score.index(max(class_score))] = 0\n        class_type = class_real[class_score.index(max(class_score)) + 1]\n        class_type_list.append(class_type)\n        class_score_list.append(max(class_score))\n    resultDf2 = pd.DataFrame()\n    resultDf2['out_type'] = class_type_list\n    resultDf2['out_score'] = class_score_list\n    resultDf2['start'] = df.xmin.values[:]\n    resultDf2['end'] = df.xmax.values[:]\n    resultDf1 = pd.concat([resultDf1, resultDf2])\n    resultDf1 = resultDf1[resultDf1.out_score > 0.0005]\n    resultDf1['video_name'] = [df['video_name'].values[0] for _ in range(len(resultDf1))]\n    return resultDf1", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    # Function to generate random config object\n    def generate_random_config(num_classes):\n        class MockConfig:\n            class_real = np.random.choice(range(1, num_classes + 1), size=num_classes - 1, replace=False).tolist()\n\n        return MockConfig()\n    test_cases = []\n    for _ in range(n):\n        # Create random confidence scores\n        row_n = np.random.randint(10, 100)\n        conf_values = np.random.rand(row_n)\n        num_classes = np.random.randint(5, 20)\n\n        # Create random bounding box coordinates\n        xmin_values = np.random.randint(0, 100, size=row_n)\n        xmax_values = xmin_values + np.random.randint(10, 50, size=row_n)\n\n        # Create random class scores\n        score_columns = {f'score_{i}': np.random.rand(row_n) for i in range(num_classes)}\n\n        # Create test DataFrame\n        df_test = pd.DataFrame({\n            'conf': conf_values,\n            'xmin': xmin_values,\n            'xmax': xmax_values,\n            'video_name': [f'test_video_{i}' for i in range(row_n)],  # Unique video names\n            **score_columns\n        })\n        config = generate_random_config(num_classes)\n        test_cases.append((df_test, config))\n    return test_cases"}
{"problem_id": "pandas_16", "library": "pandas", "code_problem": "You are tasked with implementing a function that prepares a dataset for time series analysis by creating lagged features and a target variable from a given time series. The function should take a pandas Series and a specified number of lags, compute the differences of the series, and return a DataFrame of lagged features along with the corresponding target variable.\n\nFunction signature:\n```python\ndef _get_X_y_standard_specification(series: pd.Series, lags: int) -> tuple:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to create a lagged version of the series for the target variable.\n\nInput format:\n- The input consists of a pandas Series `series` and an integer `lags`.\n\nOutput format:\n- The output is a tuple containing:\n  - A pandas DataFrame `X` with lagged features.\n  - A pandas Series `y` representing the target variable.\n\n**Input:**\n```python\nseries = pd.Series([1, 2, 3, 4, 5])\nlags = [1, 2]\n```\n\n**Output:**\n```python\nX = \n   0_diff_lag_1  0_diff_lag_2  y_lagged\n3           1.0           1.0       3.0\n4           1.0           1.0       4.0\n\nY=\n3    1.0\n4    1.0\ndtype: float64\n\n```\n\n### Explanation:\n- The input series is a simple increasing sequence from 1 to 5.\n- The lags specified are 1 and 2.\n- The output `X` contains the lagged differences of the series, and `y` contains the differences of the series aligned with the lagged values.", "ground_truth_code": "import pandas as pd\n\ndef _lag_df(df, lags):\n    df_lagged = pd.DataFrame()\n    if isinstance(lags, int):\n        lags = range(1, lags + 1)\n    else:\n        lags = [int(lag) for lag in lags]\n    for lag in lags:\n        temp_df = df.shift(lag).copy(deep=True)\n        temp_df.columns = [str(i) + '_diff_lag_' + str(lag) for i in temp_df.columns]\n        df_lagged = df_lagged.join(temp_df, how='outer')\n    return df_lagged\n\n# main code\ndef _get_X_y_standard_specification(series, lags):\n    series_diff = series.diff().dropna()\n    X = _lag_df(series_diff.to_frame(), lags).dropna()\n    X['y_lagged'] = series.shift(1).loc[X.index]\n    y = series_diff.loc[X.index]\n    return (X, y)", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        series_length = np.random.randint(1, 1000)\n        series = pd.Series(np.random.randn(series_length))\n        if np.random.rand() > 0.5:\n            lags = np.random.randint(1, min(10, series_length))\n        else:\n            valid_lag_range = range(1, min(10, series_length))\n            num_lags = np.random.randint(1, len(valid_lag_range) + 1)\n            lags = np.random.choice(valid_lag_range, num_lags, replace=False).tolist()\n\n        test_cases.append((series, lags))\n\n    return test_cases"}
{"problem_id": "pandas_17", "library": "pandas", "code_problem": "You are tasked with implementing a function that summarizes statistical information about a numeric dataset. The function will take in a tuple of statistics and return a Pandas Series containing descriptive statistics, which may include count, mean, standard deviation, minimum, quantiles, and maximum values. The function should also handle special cases for time-related data types, specifically for timedelta and datetime columns.\n\nFunction Signature:\n```python\ndef describe_numeric_aggregate(stats, name=None, is_timedelta_col=False, is_datetime_col=False, unit='ns'):\n```\n\nConstants Used:\n- `unit`: A string that specifies the time unit to be used for converting timedelta and datetime values. The default value is 'ns' (nanoseconds).\n\nInput Format:\n- A tuple of statistics (count, mean, std, min, quantiles, max).\n- An optional string for the name of the Series.\n- Two boolean flags indicating if the data is timedelta or datetime.\n- A string for the time unit.\n\nOutput Format:\n- A Pandas Series containing the descriptive statistics, indexed appropriately, and named if a name is provided.\n\n**Input:**\n```python\nstats = (100, 50.25, 10.5, 30.0, pd.Series([40.0, 50.0, 60.0], index=[0.25, 0.5, 0.75]), 80.0)\nname = \"Test Series\"\nis_timedelta_col = False\nis_datetime_col = False\nunit = 'ns'\n```\n\n**Output:**\n```python\ncount    100.00\nmean      50.25\nstd       10.50\nmin       30.00\n25%       40.00\n50%       50.00\n75%       60.00\nmax       80.00\nName: Test Series, dtype: float64\n``` \n\nThis output represents the aggregated statistics for a numeric series, formatted as a Pandas Series with the appropriate index labels.", "ground_truth_code": "import pandas as pd\n\ndef is_series_like(obj):\n    return isinstance(obj, (pd.Series, pd.DataFrame))\n\n# main code\ndef describe_numeric_aggregate(stats, name=None, is_timedelta_col=False, is_datetime_col=False, unit='ns'):\n    (count, mean, std, min, q, max) = stats\n\n    if is_timedelta_col:\n        mean = pd.to_timedelta(mean, unit=unit)\n        std = pd.to_timedelta(std, unit=unit)\n        min = pd.to_timedelta(min, unit=unit)\n        max = pd.to_timedelta(max, unit=unit)\n        q = q.apply(lambda x: pd.to_timedelta(x, unit=unit))\n\n    if is_datetime_col:\n        min = pd.to_datetime(min, unit=unit)\n        max = pd.to_datetime(max, unit=unit)\n        q = q.apply(lambda x: pd.to_datetime(x, unit=unit))\n\n    if is_datetime_col:\n        part1 = pd.Series([count, min], index=['count', 'min'])\n    else:\n        part1 = pd.Series([count, mean, std, min], index=['count', 'mean', 'std', 'min'])\n\n    q.index = [f'{l * 100:g}%' for l in q.index.to_list()]\n\n    if is_series_like(q) and not isinstance(q, pd.Series):\n        q = q.to_frame()\n\n    part3 = pd.Series([max], index=['max'])\n\n    result = pd.concat([part1, q, part3], sort=False)\n\n    if is_series_like(result):\n        result.name = name\n    return result\n", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    def generate_random_statistics():\n        count = random.randint(1, 1000)\n        mean = round(random.uniform(1, 1000), 2)\n        std = round(random.uniform(0, 100), 2)\n        min_val = round(random.uniform(0, mean), 2)\n        max_val = round(random.uniform(mean, mean + 1000), 2)\n\n        q_index = [0.25, 0.5, 0.75]\n        q_values = [round(random.uniform(min_val, max_val), 2) for _ in q_index]\n        q_series = pd.Series(q_values, index=q_index)\n\n        return count, mean, std, min_val, q_series, max_val\n\n    def generate_timedelta_statistics():\n        count = random.randint(1, 1000)\n        mean = random.randint(int(1e9), int(1e12))\n        std = random.randint(int(1e6), int(1e9))\n        min_val = random.randint(int(1e6), mean)\n        max_val = random.randint(mean, mean + int(1e12))\n\n        q_index = [0.25, 0.5, 0.75]\n        q_values = [random.randint(min_val, max_val) for _ in q_index]\n        q_series = pd.Series(q_values, index=q_index)\n\n        return count, mean, std, min_val, q_series, max_val\n\n\n    def generate_datetime_statistics():\n        count = random.randint(1, 1000)\n        min_val = random.randint(1609459200, 1893456000)\n        max_val = min_val + random.randint(int(1e3), int(1e6))\n\n        q_index = [0.25, 0.5, 0.75]\n        q_values = [random.randint(min_val, max_val) for _ in q_index]\n        q_series = pd.Series(q_values, index=q_index)\n\n        return count, None, None, min_val, q_series, max_val\n\n\n    def generate_empty_statistics():\n        return 0, None, None, None, pd.Series([], dtype=float, index=[]), None\n\n\n    def generate_single_value_statistics():\n        val = round(random.uniform(1, 1000), 2)\n        return 1, val, 0.0, val, pd.Series([val], index=[0.5]), val\n\n    test_cases = []\n    for _ in range(n):\n        test_type = random.choice([\"numeric\", \"timedelta\", \"datetime\", \"empty\", \"single\"])\n\n        if test_type == \"numeric\":\n            stats = generate_random_statistics()\n            name = None\n            is_timedelta_col = False\n            is_datetime_col = False\n            unit = 'ns'\n        elif test_type == \"timedelta\":\n            stats = generate_timedelta_statistics()\n            name = None\n            is_timedelta_col = True\n            is_datetime_col = False\n            unit = 'ns'\n        elif test_type == \"datetime\":\n            stats = generate_datetime_statistics()\n            name = None\n            is_timedelta_col = False\n            is_datetime_col = True\n            unit = 'ns'\n        elif test_type == \"empty\":\n            stats = generate_empty_statistics()\n            name = None\n            is_timedelta_col = False\n            is_datetime_col = False\n            unit = 'ns'\n        else:\n            stats = generate_single_value_statistics()\n            name = None\n            is_timedelta_col = False\n            is_datetime_col = False\n            unit = 'ns'\n\n        test_cases.append((stats, name, is_timedelta_col, is_datetime_col, unit))\n\n    return test_cases"}
{"problem_id": "pandas_18", "library": "pandas", "code_problem": "You are tasked with implementing a function that computes a weighted histogram based on input data representing free energy estimates and their corresponding weights. The function will utilize the principles of the Weighted Histogram Analysis Method (WHAM) to normalize the contributions of different histograms.\n\nFunction signature:\n```python\ndef output_histogram(lnZ, sum_k_Hk_Q, weighted_counts):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `np.errstate`, which is utilized to handle potential numerical issues during division operations.\n\nInput format:\n- `lnZ`: A pandas Series of float values representing the natural logarithm of partition functions.\n- `sum_k_Hk_Q`: A pandas Series of float values representing the sum of weighted counts for each state.\n- `weighted_counts`: A pandas DataFrame where each row corresponds to a state and each column corresponds to a histogram, containing float values of weighted counts.\n\nOutput format:\n- The function returns a pandas Series named 'WHAM' containing float values, which represent the normalized histogram for each state based on the input data.\n\n**Input:**\n```python\nlnZ = pd.Series([-0.5, -1.0, -1.5], index=['hist0', 'hist1', 'hist2'], name=\"lnZ\")\nsum_k_Hk_Q = pd.Series([2.0, 3.0], index=[1, 2], name=\"sum_k_Hk_Q\")\nweighted_counts = pd.DataFrame({\n    'hist0': [1.0, 0.5],\n    'hist1': [0.0, 1.5],\n    'hist2': [2.0, 0.0]\n}, index=[1, 2])\n```\n\n**Output:**\n```python\n1    0.310725\n2    1.009054\nName: WHAM, dtype: float64\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef output_histogram(lnZ, sum_k_Hk_Q, weighted_counts):\n    Z = np.exp(lnZ)\n    Z0_over_Zi = Z.iloc[0] / Z\n    output = pd.Series(index=sum_k_Hk_Q.index, name='WHAM', dtype='float64')\n    for val in sum_k_Hk_Q.index:\n        sum_w_over_Z = sum([weighted_counts.loc[val, hist_i] * Z0_over_Zi[hist_i] for hist_i in Z.index])\n        with np.errstate(divide='ignore', invalid='ignore'):\n            output[val] = sum_k_Hk_Q[val] / sum_w_over_Z\n    return output", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        histogram_indices = [f'hist{i}' for i in range(np.random.randint(5, 100))]\n        value_indices = np.arange(1, np.random.randint(5, 20))\n\n        # lnZ: Random log-values for normalization factors\n        lnZ = pd.Series(np.random.randn(len(histogram_indices)), index=histogram_indices, name=\"lnZ\")\n\n        # sum_k_Hk_Q: Random non-negative values indexed by the histogram values\n        sum_k_Hk_Q = pd.Series(np.abs(np.random.randn(len(value_indices))), index=value_indices, name=\"sum_k_Hk_Q\")\n\n        # weighted_counts: A matrix of weights indexed by values and histograms\n        weighted_counts = pd.DataFrame(np.abs(np.random.randn(len(value_indices), len(histogram_indices))),\n                                       index=value_indices, columns=histogram_indices)\n\n        test_cases.append((lnZ, sum_k_Hk_Q, weighted_counts))\n\n    return test_cases"}
{"problem_id": "pandas_19", "library": "pandas", "code_problem": "You are tasked with developing a climate prediction model that estimates the average temperature for a specific city over a given date range. The model will utilize historical temperature data to make predictions based on linear regression.\n\nFunction Signature:\n```python\ndef predict_climate(df, city, date_training_left, date_training_right, date_prediction_left, date_prediction_right):\n```\n\n### Constants Used:\n- The constant used in the main code is the number of months in a year, which is 12.\n\n### Input Format:\n- `df`: A pandas DataFrame containing historical climate data with columns including 'City', 'Date', and 'AverageTemperature'.\n- `city`: A string representing the name of the city for which predictions are to be made.\n- `date_training_left`: A string representing the start date of the training period (inclusive).\n- `date_training_right`: A string representing the end date of the training period (exclusive).\n- `date_prediction_left`: A string representing the start date of the prediction period (inclusive).\n- `date_prediction_right`: A string representing the end date of the prediction period (exclusive).\n\n### Output Format:\n- The function returns a pandas DataFrame with two columns: 'Date' and 'AverageTemperature', where 'Date' contains the first day of each month in the prediction range and 'AverageTemperature' contains the predicted average temperatures for those dates.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'dt': pd.date_range(start='1970-01-01', periods=120, freq='MS'),\n    'City': ['City_0'] * 120,\n    'AverageTemperature': np.random.uniform(-10, 35, 120)\n}\n\ndata['AverageTemperature'][::5] = np.nan  # Introduce NaN values\ndf = pd.DataFrame(data)\ndf['Year'] = df['dt'].dt.year\n\ncity = 'City_0'\ndate_training_left = '1970-01-01'\ndate_training_right = '1975-01-01'\ndate_prediction_left = '1975-02-01'\ndate_prediction_right = '1975-12-01'\n```\n\n**Output:**\n```python\n         Date  AverageTemperature\n0  1975-02-01           -1.923866\n1  1975-03-01           -1.923866\n2  1975-04-01           -1.923866\n3  1975-05-01           -1.923866\n4  1975-06-01           -1.923866\n5  1975-07-01           -1.923866\n6  1975-08-01           -1.923866\n7  1975-09-01           -1.923866\n8  1975-10-01           -1.923866\n9  1975-11-01           -1.923866\n10 1975-12-01           -1.923866\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\nfrom sklearn.linear_model import LinearRegression\n\ndef clean_data(df, first_date, last_date):\n    dfs = df.query('dt >= @first_date & dt < @last_date').query('AverageTemperature.notna()', engine='python')\n    if dfs.shape[0] == 0:\n        raise AttributeError('We have no data for this date range.')\n    return dfs\n\ndef add_dummy_months(df):\n    if 'Date' in df.columns:\n        df['Date'] = pd.to_datetime(df['Date'])  # Ensure Date is in datetime format\n        for i in range(12):\n            df[f'm{i + 1:02d}'] = (df['Date'].dt.month == i + 1).astype(int)\n    return df\n\n\n# main code\ndef predict_climate(df, city, date_training_left, date_training_right, date_prediction_left, date_prediction_right):\n\n    dfc = df.query('City==@city')\n    dfc = clean_data(dfc, date_training_left, date_training_right)\n    prediction_first_day = pd.to_datetime(date_prediction_left)\n    prediction_last_day = pd.to_datetime(date_prediction_right)\n    target_days = pd.DataFrame({'Date': pd.date_range(prediction_first_day, prediction_last_day, freq=pd.offsets.MonthBegin(1))})\n    target_days['Year'] = target_days.Date.dt.year\n    target_days = add_dummy_months(target_days)\n    target_days['Y2'] = np.square(target_days.Year)\n    view = dfc.query('City == @city').copy()\n    view = add_dummy_months(view)\n    view['Y2'] = np.square(view.Year)\n    X = view.loc[:, view.columns.intersection(target_days.columns)]\n    if 'Date' in X.columns:\n        X = X.drop(columns=['Date'])\n    X = X.values\n    y = view.AverageTemperature.values\n\n    reg = LinearRegression().fit(X, y)\n    X_pred = target_days.loc[:, target_days.columns.intersection(view.columns)]\n    if 'Date' in X_pred.columns:\n        X_pred = X_pred.drop(columns=['Date'])\n    X_pred = X_pred.values\n    out = reg.predict(X_pred)\n    return pd.DataFrame({'Date': target_days.Date, 'AverageTemperature': out})", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        city_n = np.random.randint(1, 5)\n        dates = []\n        temperatures = []\n        cities = []\n        start_year = np.random.randint(1960, 1980)\n        end_year = np.random.randint(2000, 2010)\n        row_n = (end_year - start_year) * 12 + 1\n        for city_id in range(city_n):\n\n            tmp_dates = pd.date_range(start=f'{start_year}-01-01', periods=row_n, freq='MS')\n\n            tmp_temperatures = np.random.uniform(-10, 35, row_n)\n            nan_indices = np.random.choice(row_n, size=int(row_n * 0.05), replace=False)\n            tmp_temperatures[nan_indices] = np.nan\n\n\n            tmp_cities = [f'City_{city_id}' for _ in range(row_n)]\n            dates += list(tmp_dates)\n            temperatures += list(tmp_temperatures)\n            cities += tmp_cities\n        df = pd.DataFrame({\n            'dt': dates,\n            'City': cities,\n            'AverageTemperature': temperatures\n        })\n\n        date_training_left = f'{np.random.randint(start_year, end_year - 5)}-01-01'\n        date_training_right = f'{np.random.randint(int(date_training_left[:4]) + 2, end_year - 2)}-01-01'\n        date_prediction_left = f'{np.random.randint(int(date_training_right[:4]) + 1, end_year)}-01-01'\n        date_prediction_right = f'{np.random.randint(int(date_prediction_left[:4]) + 1, end_year + 1)}-01-01'\n\n        df['Year'] = df['dt'].dt.year\n        city = 'City_%s' % (str(np.random.randint(0, city_n)))\n        test_cases.append(\n            (df, city, date_training_left, date_training_right, date_prediction_left, date_prediction_right))\n\n    return test_cases"}
{"problem_id": "pandas_20", "library": "pandas", "code_problem": "You are tasked with implementing a function that analyzes the relationship between genes and a specific trait based on boolean data. The function will compute various statistics related to the presence or absence of genes in individuals with and without the trait, and return a DataFrame summarizing these statistics.\n\nFunction signature:\n```python\ndef init_result_df(genes_bool_df: pd.DataFrame, trait_series: pd.Series) -> pd.DataFrame:\n```\n\n### Constants:\n- The constant used in the main code is `100`, which is used to convert proportions into percentages.\n\n### Input and Output Format:\n- **Input**:\n  - `genes_bool_df`: A pandas DataFrame with boolean values.\n  - `trait_series`: A pandas Series with boolean values.\n\n- **Output**:\n  - A pandas DataFrame containing the computed statistics, including gene counts, pattern IDs, sensitivity, and specificity.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ngenes_bool_df = pd.DataFrame({\n    'S1': [1, 0, 1, 0],\n    'S2': [0, 1, 1, 0],\n    'S3': [1, 1, 0, 0],\n    'S4': [0, 0, 1, 1]\n}, index=['gene_1', 'gene_2', 'gene_3', 'gene_4'])\n\ntrait_series = pd.Series({\n    'S1': True,\n    'S2': False,\n    'S3': True,\n    'S4': False\n})\n```\n\n**Output:**\n```python\n    index  g+t+  g+t-  ...  __contingency_table__  sensitivity  specificity\n0  gene_1     2     0  ...           (2, 0, 0, 2)        100.0        100.0\n1  gene_2     1     1  ...           (1, 1, 1, 1)         50.0         50.0\n2  gene_3     1     2  ...           (1, 2, 1, 0)         50.0        100.0\n3  gene_4     0     1  ...           (0, 1, 2, 1)        100.0         50.0\n[4 rows x 9 columns]\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef init_result_df(genes_bool_df, trait_series):\n\n    trait_pos = trait_series.index[trait_series]\n    trait_neg = trait_series.index[~trait_series]\n    n_pos = len(trait_pos)\n    n_neg = len(trait_neg)\n    n_tot = n_pos + n_neg\n\n    result_df = pd.DataFrame(index=genes_bool_df.index)\n    result_df['g+t+'] = genes_bool_df[trait_pos].sum(axis=1)\n    result_df['g+t-'] = genes_bool_df[trait_neg].sum(axis=1)\n    result_df['g-t+'] = n_pos - result_df['g+t+']\n    result_df['g-t-'] = n_neg - result_df['g+t-']\n    gene_sum = result_df['g+t+'] + result_df['g+t-']\n    to_keep = (gene_sum != 0) & (gene_sum != n_tot)\n    result_df = result_df[to_keep]\n    genes_bool_df_reduced = genes_bool_df.loc[to_keep, trait_pos.to_list() + trait_neg.to_list()]\n    pattern_id = genes_bool_df_reduced.groupby(by=genes_bool_df_reduced.columns.to_list()).ngroup()\n    result_df['__pattern_id__'] = pattern_id\n    result_df['__contingency_table__'] = [tuple(x) for x in result_df[['g+t+', 'g+t-', 'g-t+', 'g-t-']].to_numpy()]\n    if n_pos:\n        pos_sensitivity = result_df['g+t+'] / n_pos * 100\n        neg_sensitivity = result_df['g-t+'] / n_pos * 100\n    else:\n        pos_sensitivity = neg_sensitivity = pd.Series(0, index=result_df.index)\n    if n_neg:\n        pos_specificity = result_df['g-t-'] / n_neg * 100\n        neg_specificity = result_df['g+t-'] / n_neg * 100\n    else:\n        pos_specificity = neg_specificity = pd.Series(0, index=result_df.index)\n    keep_pos = pos_sensitivity + pos_specificity > neg_sensitivity + neg_specificity\n    result_df['sensitivity'] = pos_sensitivity.where(keep_pos, neg_sensitivity)\n    result_df['specificity'] = pos_specificity.where(keep_pos, neg_specificity)\n    result_df.reset_index(inplace=True)\n    return result_df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_genes = np.random.randint(5, 20)\n        num_samples = np.random.randint(10, 100)\n\n        genes_bool_df = pd.DataFrame(\n            np.random.choice([0, 1], size=(num_genes, num_samples)),\n            index=[f\"gene_{i + 1}\" for i in range(num_genes)],\n            columns=[f\"S{i + 1}\" for i in range(num_samples)]\n        )\n\n        # Randomly generate a trait_series\n        trait_series = pd.Series(\n            np.random.choice([True, False], size=num_samples),\n            index=genes_bool_df.columns\n        )\n        test_cases.append((genes_bool_df, trait_series))\n\n    return test_cases"}
{"problem_id": "pandas_21", "library": "pandas", "code_problem": "You are tasked with creating a function that compares two pandas DataFrames, `old` and `new`, to identify and display the differences between them. The function should handle cases where the DataFrames have different lengths by padding the shorter DataFrame with placeholder rows. The differences should be reported for each column that exists in both DataFrames, along with the number of differing rows and a percentage of the total rows.\n\nFunction Signature:\n```python\ndef assert_dfs_equal(old: pd.DataFrame, new: pd.DataFrame) -> str:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `20`, which specifies the maximum number of differing rows to display in the output.\n\nInput format:\n- The function accepts two pandas DataFrames, `old` and `new`.\n\nOutput format:\n- The function returns a string summarizing the differences between the two DataFrames, including the number of differing rows and a preview of the differences for each column.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Old DataFrame\nold_data = {\n    'col0': [10, 20, 30, 40, 50],\n    'col1': [1, 2, 3, 4, 5],\n    'mc': [1, 2, 3, 4, 5]\n}\nold_df = pd.DataFrame(old_data)\n\n# New DataFrame with modifications\nnew_data = {\n    'col0': [10, 21, 30, 41, 50],  # Modified value in second row\n    'col1': [1, 2, 3, 4, 6],       # Modified value in last row\n    'mc': [1, 2, 3, 4, 5]\n}\nnew_df = pd.DataFrame(new_data)\n\n# Call the function\noutput = assert_dfs_equal(old_df, new_df)\nprint(output)\n```\n\n**Output:**\n```\n1/5 (20.00 %) rows are different for col1:\n  old      new     \n   mc col1  mc col1\n0   5    5   5    6\n2/5 (40.00 %) rows are different for col0:\n  old      new     \n   mc col0  mc col0\n0   2   20   2   21\n1   4   40   4   41\n\n```\n\nIn this example, the old DataFrame has two columns with some values, and the new DataFrame has two modified values. The output indicates that there are differences in both columns, showing the first few rows of the differences.", "ground_truth_code": "import pandas as pd\n\ndef show_diff(old, new, diffs_per_col, old_bool, greater_length, new_bool):\n    comp_str = []\n    if 'mc' in old.columns:\n        position_col = 'mc'\n    elif 'last_mc' in old.columns:\n        position_col = 'last_mc'\n    else:\n        position_col = None\n    for (col, n_diffs) in diffs_per_col.items():\n        if n_diffs > 0:\n            if position_col is None:\n                columns = col\n            else:\n                columns = [position_col, col]\n            comparison = pd.concat([old.loc[old_bool[col], columns].reset_index(drop=True).iloc[:20], new.loc[new_bool[col], columns].iloc[:20].reset_index(drop=True)], axis=1, keys=['old', 'new'])\n            comp_str.append(f\"{n_diffs}/{greater_length} ({n_diffs / greater_length * 100:.2f} %) rows are different for {col}{(' (showing first 20)' if n_diffs > 20 else '')}:\\n{comparison}\\n\")\n    return '\\n'.join(comp_str)\n\ndef nan_eq(a, b):\n    return (a == b).fillna(False) | pd.isnull(a) & pd.isnull(b)\n\n# main code\ndef assert_dfs_equal(old, new):\n    (old_l, new_l) = (len(old), len(new))\n    greater_length = max(old_l, new_l)\n    if old_l != new_l:\n        print(f'Old length: {old_l}, new length: {new_l}')\n        old_is_shorter = new_l == greater_length\n        shorter = old if old_is_shorter else new\n        missing_rows = abs(old_l - new_l)\n        shorter_cols = shorter.columns\n        patch = pd.DataFrame([['missing row'] * len(shorter_cols)] * missing_rows, columns=shorter_cols)\n        shorter = pd.concat([shorter, patch], ignore_index=True)\n        if old_is_shorter:\n            old = shorter\n        else:\n            new = shorter\n    cols = [col for col in set(old.columns).intersection(set(new.columns))]\n    diff = [(i, j, ~nan_eq(o, n)) for ((i, o), (j, n)) in zip(old[cols].iterrows(), new[cols].iterrows())]\n    old_bool = pd.DataFrame.from_dict({ix: bool_series for (ix, _, bool_series) in diff}, orient='index')\n    new_bool = pd.DataFrame.from_dict({ix: bool_series for (_, ix, bool_series) in diff}, orient='index')\n    diffs_per_col = old_bool.sum(axis=0)\n\n    return show_diff(old, new, diffs_per_col, old_bool, greater_length, new_bool)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows_old = random.randint(5, 100)  # Old dataframe size\n        num_rows_new = num_rows_old  # Slightly varied new dataframe size\n        num_cols = random.randint(5, 10)  # Number of columns\n\n        column_names = [f'col{i}' for i in range(num_cols)]\n\n        # Old DataFrame\n        old_data = {\n            col: [random.choice([random.randint(0, 100), np.nan]) for _ in range(num_rows_old)]\n            for col in column_names\n        }\n        old_data['mc'] = list(range(1, num_rows_old + 1))\n        old_df = pd.DataFrame(old_data)\n\n        # New DataFrame with modifications\n        new_data = old_data.copy()\n        for col in column_names:\n            for i in range(num_rows_new):\n                if random.random() < 0.3:  # 30% chance of modifying a value\n                    new_data[col][i % num_rows_old] = random.choice([random.randint(0, 100), np.nan])\n\n        new_data['mc'] = list(range(1, num_rows_new + 1))  # Adjust row count if needed\n        new_df = pd.DataFrame(new_data)\n        test_cases.append((old_df, new_df))\n    return test_cases\n"}
{"problem_id": "pandas_22", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the Population Stability Index (PSI) between two datasets based on a specified column. The PSI is a measure used to determine how much a population has shifted over time, which is particularly useful in fields like credit scoring and risk management.\n\nFunction Signature:\n```python\ndef cal_psi(df1: pd.DataFrame, df2: pd.DataFrame, col: str, bin_num: int) -> tuple:\n```\n\nConstants:\n- The constant used in the main code is `float('-inf')` and `float('inf')`, which are used to define the lower and upper bounds of the bins when the data is being binned.\n\nInput Format:\n- `df1`: A pandas DataFrame containing the first dataset.\n- `df2`: A pandas DataFrame containing the second dataset.\n- `col`: A string representing the name of the column to analyze.\n- `bin_num`: An integer representing the number of bins to create.\n\nOutput Format:\n- The function returns a tuple where the first element is a float representing the calculated PSI and the second element is a pandas DataFrame containing the binned data with total counts and rates for both datasets.\n\n**Input:**\n```python\nimport pandas as pd\n\n# DataFrame 1\ndata1 = {\n    'feature': [1, 2, 2, 3, 4, 5, 5, 5, 6, 7]\n}\ndf1 = pd.DataFrame(data1)\n\n# DataFrame 2\ndata2 = {\n    'feature': [1, 1, 2, 3, 4, 4, 5, 6, 6, 7]\n}\ndf2 = pd.DataFrame(data2)\n\n# Column name and number of bins\ncol = 'feature'\nbin_num = 4\n\n# Call the function\npsi, bin_df = cal_psi(df1, df2, col, bin_num)\n```\n\n**Output:**\n```python\npsi = 0.3008154793552547, \nbin_df = \n        feature  total_A  totalrate_A  total_B  totalrate_B     Index       PSI\n0  (-inf, 2.25]        3          0.3        3          0.3  0.000000  0.300815\n1   (2.25, 4.5]        2          0.2        3          0.3  0.040547  0.300815\n2    (4.5, 5.0]        3          0.3        1          0.1  0.219722  0.300815\n3    (5.0, inf]        2          0.2        3          0.3  0.040547  0.300815\n\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef cal_psi(df1, df2, col, bin_num):\n    print(df1[col].dtype)\n    if df1[col].nunique() <= bin_num:\n        bin_df1 = df1[col].value_counts().to_frame().reset_index().rename(columns={'index': col, col: 'total_A'})\n        bin_df1['totalrate_A'] = bin_df1['total_A'] / df1.shape[0]\n        bin_df2 = df2[col].value_counts().to_frame().reset_index().rename(columns={'index': col, col: 'total_B'})\n        bin_df2['totalrate_B'] = bin_df2['total_B'] / df2.shape[0]\n    else:\n        (bin_series, bin_cut) = pd.qcut(df1[col], q=bin_num, duplicates='drop', retbins=True)\n        bin_cut[0] = float('-inf')\n        bin_cut[-1] = float('inf')\n        bucket1 = pd.cut(df1[col], bins=bin_cut)\n        group1 = df1.groupby(bucket1)\n        bin_df1 = pd.DataFrame()\n        bin_df1['total_A'] = group1[col].count()\n        bin_df1['totalrate_A'] = bin_df1['total_A'] / df1.shape[0]\n        bin_df1 = bin_df1.reset_index()\n        bucket2 = pd.cut(df2[col], bins=bin_cut)\n        group2 = df2.groupby(bucket2)\n        bin_df2 = pd.DataFrame()\n        bin_df2['total_B'] = group2[col].count()\n        bin_df2['totalrate_B'] = bin_df2['total_B'] / df2.shape[0]\n        bin_df2 = bin_df2.reset_index()\n    bin_df = pd.merge(bin_df1, bin_df2, on=col)\n    bin_df['a'] = bin_df['totalrate_B'] - bin_df['totalrate_A']\n    bin_df['b'] = np.log(bin_df['totalrate_B'] / bin_df['totalrate_A'])\n    bin_df['Index'] = bin_df['a'] * bin_df['b']\n    bin_df['PSI'] = bin_df['Index'].sum()\n    bin_df = bin_df.drop(['a', 'b'], axis=1)\n    psi = bin_df.PSI.iloc[0]\n    return (psi, bin_df)", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_cols = np.random.randint(1, 5)\n        num_rows = np.random.randint(50, 500)  # Random number of rows\n        bin_num = np.random.randint(2, 20)  # Random bin count\n\n        df1_tmp = {}\n        df2_tmp = {}\n        for i in range(num_cols):\n            df1_tmp['col_%s' % (i)] = np.random.randn(num_rows) * 10\n            df2_tmp['col_%s' % (i)] = np.random.randn(num_rows) * 10\n        df1 = pd.DataFrame(df1_tmp)\n        df2 = pd.DataFrame(df2_tmp)\n        col_name = 'col_%s' % (np.random.randint(0, num_cols))\n        test_cases.append((df1, df2, col_name, bin_num))\n    return test_cases\n"}
{"problem_id": "pandas_23", "library": "pandas", "code_problem": "You are tasked with creating a function that processes a pandas DataFrame to reduce its duration information to the first row. The function should handle both standard index types and interval indices. The function signature is as follows:\n\n```python\ndef reduce_dataframe_duration_to_first_row(df):\n```\n\nInput format:\n- The input to the function is a pandas DataFrame `df` that may contain multiple rows and a column named `duration_qb`.\n\nOutput format:\n- The output of the function is a pandas DataFrame containing a single row with the updated duration information based on the logic described.\n\nInput:\n```python\nimport pandas as pd\n\n# Test case DataFrame\ndata = {\n    \"duration_qb\": [10, 20, 30]\n}\nindex = pd.RangeIndex(start=0, stop=3, step=1)\ndf = pd.DataFrame(data, index=index)\n```\n\nOutput:\n```python\n   duration_qb\n0           60\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef reduce_dataframe_duration_to_first_row(df):\n    if len(df) == 1:\n        return df\n    idx = df.index\n    first_loc = idx[0]\n    row = df.iloc[[0]]\n    if isinstance(idx, pd.IntervalIndex):\n        start = min(idx.left)\n        end = max(idx.right)\n        iv = pd.Interval(start, end, closed=idx.closed)\n        row.index = pd.IntervalIndex([iv])\n        row.loc[iv, 'duration_qb'] = iv.length\n    else:\n        new_duration = df.duration_qb.sum()\n        row.loc[first_loc, 'duration_qb'] = new_duration\n    return row", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    # Generate 200 test cases\n    for _ in range(n):\n        num_rows = random.randint(1, 20)\n\n        # Randomly decide whether to use IntervalIndex or regular index\n        use_interval_index = random.choice([True, False])\n\n        # Generate duration values\n        duration_values = np.random.randint(1, 100, size=num_rows)\n\n        if use_interval_index:\n            # Generate non-overlapping intervals\n            starts = sorted(np.random.randint(0, 100, size=num_rows))\n            ends = [s + random.randint(1, 10) for s in starts]\n            index = pd.IntervalIndex.from_arrays(starts, ends, closed=\"right\")\n        else:\n            index = pd.RangeIndex(start=0, stop=num_rows, step=1)\n\n        # Create DataFrame\n        df = pd.DataFrame({\"duration_qb\": duration_values}, index=index)\n        test_cases.append(df)\n    return test_cases\n"}
{"problem_id": "pandas_24", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs t-distributed Stochastic Neighbor Embedding (t-SNE) on a given dataset. The function should preprocess the data, apply the t-SNE algorithm, and return the transformed data along with some metadata.\n\nFunction Signature:\n```python\ndef run_tsne(data, group, drop_cols, annotation_cols, components, perplexity, max_iter, init, dropna):\n```\n\n### Constants Used:\n- The constant `TSNE` from the `sklearn.manifold` module is used to perform the t-SNE transformation.\n\n### Input Format:\n- The function accepts a pandas DataFrame and various parameters as described above.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A dictionary with the key `'tsne'` mapping to a DataFrame of the t-SNE results.\n  - A dictionary with additional arguments related to the output.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Creating a sample DataFrame\ndata = pd.DataFrame({\n    'feature_0': np.random.randn(10),\n    'feature_1': np.random.randn(10),\n    'feature_2': np.random.randn(10),\n    'sample': [f'sample_{i % 3}' for i in range(10)],\n    'subject': [f'subject_{i % 2}' for i in range(10)],\n    'group': [f'group_{i % 2}' for i in range(10)]\n})\n\ngroup = 'group'\ndrop_cols = ['sample']\nannotation_cols = ['subject']\ncomponents = 2\nperplexity = 5.0\nmax_iter = 300\ninit = 'random'\ndropna = False\n\n# Running the function\nresult, args = run_tsne(data, group, drop_cols, annotation_cols, components, perplexity, max_iter, init, dropna)\n```\n\n**Output:**\n```python\nresult = {'tsne':      group          x          y    subject\n0  group_0  12.710702  24.141924  subject_0\n1  group_1 -61.469513  75.968834  subject_1\n2  group_0  76.064659  27.940054  subject_0\n3  group_1 -37.092129  99.464722  subject_1\n4  group_0  -1.939682 -87.781509  subject_0\n5  group_1  24.357456 -24.271444  subject_1\n6  group_0 -17.476854  32.033684  subject_0\n7  group_1 -42.369541 -12.990212  subject_1\n8  group_0  -9.409127 -35.166744  subject_0\n9  group_1  24.172403  72.182022  subject_1}\n\nargs = {'x_title': 'C1', 'y_title': 'C2'}\n```\n\n### Note:\n- The actual values in the output DataFrame will vary due to the randomness in the input data generation and the TSNE algorithm's stochastic nature.\n- The output structure is based on the expected format of the result from the `run_tsne` function.", "ground_truth_code": "import pandas as pd\nfrom sklearn.manifold import TSNE\n\n# main code\ndef run_tsne(data, group, drop_cols, annotation_cols, components, perplexity, max_iter, init, dropna):\n    result = {}\n    args = {}\n    df = data.copy()\n\n    if df.shape[0] < 2 or df.select_dtypes(['number']).shape[1] < 2:\n        return (result, args)\n\n    if len(set(drop_cols).intersection(df.columns)) == len(drop_cols):\n        df = df.drop(drop_cols, axis=1)\n    df = df.set_index(group)\n    if dropna:\n        df = df.dropna(axis=1)\n    df = df.select_dtypes(['number'])\n\n\n    if df.shape[0] < 2 or df.shape[1] < 2:\n        return (result, args)\n\n    X = df.values\n    y = df.index\n    annotations = pd.DataFrame()\n\n    if annotation_cols is not None:\n        if len(list(set(annotation_cols).intersection(data.columns))) > 0:\n            annotations = data[annotation_cols]\n\n    if X.size > 0:\n        tsne = TSNE(n_components=components, verbose=0, perplexity=perplexity, max_iter=max_iter, init=init)\n        X = tsne.fit_transform(X)\n        args = {'x_title': 'C1', 'y_title': 'C2'}\n\n        if components == 2:\n            resultDf = pd.DataFrame(X, index=y, columns=['x', 'y'])\n            resultDf = resultDf.reset_index()\n            resultDf.columns = ['group', 'x', 'y']\n\n        if components > 2:\n            args.update({'z_title': 'C3'})\n            resultDf = pd.DataFrame(X, index=y)\n            resultDf = resultDf.reset_index()\n            cols = []\n            if len(components) > 4:\n                cols = resultDf.columns[4:]\n            resultDf.columns = ['group', 'x', 'y', 'z'] + cols\n\n        resultDf = resultDf.join(annotations)\n        result['tsne'] = resultDf\n\n    return (result, args)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef generate_random_dataframe(n_rows, n_cols, include_categorical=True):\n    n_rows = max(n_rows, 2)\n    n_cols = max(n_cols, 2)\n    data = np.random.randn(n_rows, n_cols)\n    df = pd.DataFrame(data, columns=[f'feature_{i}' for i in range(n_cols)])\n\n    if include_categorical:\n        df['sample'] = [f'sample_{i % 10}' for i in range(n_rows)]\n        df['subject'] = [f'subject_{i % 5}' for i in range(n_rows)]\n        df['group'] = [f'group_{i % 3}' for i in range(n_rows)]\n    return df\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_rows = np.random.randint(10, 500)\n        n_cols = np.random.randint(2, 50)\n        include_categorical = True\n        components = random.choice([2])\n        perplexity = random.uniform(5, min(n_cols + 1, n_rows - 1))\n        max_iter = random.randint(250, 500)\n        init = random.choice(['random', 'pca'])\n        dropna = random.choice([True, False])\n        group = random.choice(['group'])\n        drop_cols = random.sample(['sample', 'subject', 'feature_0'], k=random.randint(0, 3))\n        annotation_cols = random.sample(['sample', 'subject', 'feature_1'], k=random.randint(0, 2))\n\n        df = generate_random_dataframe(n_rows, n_cols, include_categorical)\n        test_cases.append((df, group, drop_cols, annotation_cols, components, perplexity, max_iter, init, dropna))\n    return test_cases"}
{"problem_id": "pandas_25", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs Principal Component Analysis (PCA) on a given dataset. The function should handle various preprocessing steps, including dropping specified columns, managing annotations, and ensuring that the data is in the correct format for PCA. The function will return the transformed data, loadings, and explained variance ratios.\n\nFunction Signature:\n```python\ndef run_pca(data, drop_cols, group, annotation_cols, components, dropna):\n```\n\n### Constants Used:\n- The constant used in the main code is `components`, which specifies the number of principal components to compute.\n\n### Input Format:\n- `data`: A Pandas DataFrame or a NumPy ndarray containing the dataset.\n- `drop_cols`: A list of column names to be dropped from the DataFrame.\n- `group`: A string representing the name of the group column.\n- `annotation_cols`: A list of column names to be used for annotations.\n- `components`: An integer specifying the number of principal components to compute.\n- `dropna`: A boolean indicating whether to drop columns with missing values.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A DataFrame with the PCA-transformed data and annotations.\n  - A DataFrame with the loadings of the PCA components.\n  - A list of explained variance ratios for the principal components.\n  - A dictionary with additional arguments for labeling.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Creating a sample DataFrame\ndata = pd.DataFrame({\n    'feature_0': [1.0, 2.0, 3.0, 4.0],\n    'feature_1': [4.0, 3.0, 2.0, 1.0],\n    'feature_2': [1.0, 3.0, 5.0, 7.0],\n    'group': ['A', 'A', 'B', 'B'],\n    'sample': ['sample_1', 'sample_2', 'sample_3', 'sample_4']\n})\n\ndrop_cols = ['sample']\ngroup = 'group'\nannotation_cols = ['sample']\ncomponents = 2\ndropna = False\n```\n\n**Output:**\n```python\n(\n    (\n        pd.DataFrame({\n            'group': ['A', 'A', 'B', 'B'],\n            'PC1': [-3.674235, -1.224745, 1.224745, 3.674235],\n            'PC2': [0.0, 0.0, 0.0, 0.0],\n            'sample': ['sample_1', 'sample_2', 'sample_3', 'sample_4']\n        }),\n        pd.DataFrame({\n            'PC1': [-0.408248,  0.816497, 0.408248],\n            'PC2': [0.894427, 0.447214, 0.0],\n            'value': [0.983192, 0.930949, 0.408248]\n        }),\n        [1.0, 0.0]\n    ),\n    {'x_title': 'PC1 (1.00)', \n     'y_title': 'PC2 (0.00)', \n     'group': 'group'}\n)\n```", "ground_truth_code": "import pandas as pd\nfrom sklearn.decomposition import PCA\nimport numpy as np\n\n# main code\ndef run_pca(data, drop_cols, group, annotation_cols, components, dropna):\n    if isinstance(data, np.ndarray):\n        raise TypeError(\"Expected 'data' to be a Pandas DataFrame, but got a NumPy ndarray.\")\n\n    if not isinstance(data, pd.DataFrame):\n        data = pd.DataFrame(data)\n\n    if data.empty:\n        return ((pd.DataFrame(), pd.DataFrame(), []), {})\n\n    resultDf = pd.DataFrame()\n    loadings = pd.DataFrame()\n    var_exp = []\n    args = {}\n\n    df = data.copy()\n    annotations = pd.DataFrame()\n\n    if group not in df.columns:\n        raise KeyError(f\"Group column '{group}' not found in the data. Available columns: {list(df.columns)}\")\n\n    # Initialize valid_annotations\n    valid_annotations = []\n    if annotation_cols:\n        valid_annotations = list(set(annotation_cols).intersection(df.columns))\n        if valid_annotations:\n            annotations = df.set_index(group)[valid_annotations]\n\n    # Drop specified columns if they exist (but NOT the group column)\n    drop_cols_int = list(set(drop_cols).intersection(df.columns))\n    if group in drop_cols_int:\n        drop_cols_int.remove(group)\n    if drop_cols_int:\n        df = df.drop(columns=drop_cols_int)\n\n    if group not in df.columns:\n        raise KeyError(f\"Group column '{group}' was dropped or is missing after preprocessing.\")\n\n    y = df[group].tolist()\n    df = df.set_index(group)\n\n    # Select only numeric columns\n    df = df.select_dtypes(include=['number'])\n\n    if dropna:\n        df = df.dropna(axis=1)\n\n    X = df.values\n\n    # Check if PCA is applicable\n    if X.size == 0 or X.shape[1] < 1:\n        return ((pd.DataFrame(), pd.DataFrame(), []), {})\n\n    # Adjust components to ensure it's <= number of available features\n    components = min(components, X.shape[1])\n\n    # Perform PCA\n    pca = PCA(n_components=components)\n    X_transformed = pca.fit_transform(X)\n    var_exp = pca.explained_variance_ratio_\n\n    # Compute loadings\n    loadings = pd.DataFrame(pca.components_.T, index=df.columns)\n    values = {index: np.sqrt(np.sum(row ** 2)) for index, row in loadings.iterrows()}\n    loadings['value'] = loadings.index.map(values.get)\n    loadings = loadings.sort_values(by='value', ascending=False)\n\n    # Ensure there are enough variance components before formatting labels\n    args['x_title'] = f'PC1 ({var_exp[0]:.2f})' if len(var_exp) > 0 else 'PC1'\n    args['y_title'] = f'PC2 ({var_exp[1]:.2f})' if len(var_exp) > 1 else 'PC2'\n    args['group'] = 'group'\n\n    # Determine correct column names dynamically\n    pca_cols = [f'PC{i + 1}' for i in range(components)]\n\n    resultDf = pd.DataFrame(X_transformed, index=y, columns=pca_cols)\n    resultDf = resultDf.assign(**annotations)\n    resultDf = resultDf.reset_index()\n\n    # Ensure the number of column names matches the actual number of columns\n    expected_col_count = resultDf.shape[1]\n    column_names = ['group'] + pca_cols[:expected_col_count - 1 - len(valid_annotations)] + valid_annotations\n    resultDf.columns = column_names\n\n    # Ensure the same fix for loadings\n    loadings_col_count = loadings.shape[1]\n    loadings.columns = pca_cols[:loadings_col_count - 1] + ['value']\n\n    return ((resultDf, loadings, var_exp), args)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(5, 100)  # Number of rows\n        num_features = random.randint(5, 20)  # Number of feature columns\n\n        # Generate random feature data\n        data = np.random.randn(num_samples, num_features)\n        df = pd.DataFrame(data, columns=[f'feature_{i}' for i in range(num_features)])\n\n        # Add a 'group' column with random categorical values\n        df['group'] = [random.choice(['A', 'B', 'C']) for _ in range(num_samples)]\n\n        # Add optional annotation columns\n        df['sample'] = [f'sample_{i}' for i in range(num_samples)]\n        df['subject'] = [f'subject_{i}' for i in range(num_samples)]\n\n        # Random parameters\n        group = 'group'\n        drop_cols = random.choice([['sample'], ['subject'], ['sample', 'subject'], []])\n        annotation_cols = random.choice([['sample'], ['subject'], ['sample', 'subject'], []])\n        components = random.randint(1, min(num_features, 5))  # Ensure valid PCA component count\n        dropna = random.choice([True, False])\n        test_cases.append((df, drop_cols, group, annotation_cols, components, dropna))\n    return test_cases"}
{"problem_id": "pandas_26", "library": "pandas", "code_problem": "You are tasked with creating a function that fills in missing years of data for different countries in a dataset. The dataset is structured as a pandas DataFrame with a multi-level index, where the first level is 'country' and the second level is 'year'. The function should forward-fill and backward-fill the missing values for each country, ensuring that all years have corresponding data.\n\nFunction signature:\n```python\ndef fill_missing_years(fill_values: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- There are no constants explicitly defined in the main code.\n\nInput format:\n- The input to the function is a pandas DataFrame with a multi-level index, where the first level is 'country' and the second level is 'year'. The DataFrame may contain missing values.\n\nOutput format:\n- The output of the function is a pandas DataFrame with the same structure as the input, but with all missing values filled in for each country across all years.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Creating a test case DataFrame\ndata = {\n    'value': [np.nan, 10, np.nan, 20, np.nan, 30, np.nan, np.nan, 40, 50, np.nan, 60]\n}\nindex = pd.MultiIndex.from_tuples([\n    ('Country_A', 2000),\n    ('Country_A', 2001),\n    ('Country_A', 2002),\n    ('Country_A', 2003),\n    ('Country_A', 2004),\n    ('Country_B', 2000),\n    ('Country_B', 2001),\n    ('Country_B', 2002),\n    ('Country_B', 2003),\n    ('Country_B', 2004),\n    ('Country_C', 2000),\n    ('Country_C', 2001)\n], names=['country', 'year'])\n\ntest_df = pd.DataFrame(data, index=index)\n\n# Call the function\nfilled_df = fill_missing_years(test_df['value'])\nprint(filled_df)\n```\n\n**Output:**\n```\ncountry    year\nCountry_A  2000    10.0\n           2001    10.0\n           2002    10.0\n           2003    20.0\n           2004    20.0\nCountry_B  2000    30.0\n           2001    30.0\n           2002    30.0\n           2003    40.0\n           2004    50.0\nCountry_C  2000    60.0\n           2001    60.0\nName: value, dtype: float64\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef fill_missing_years(fill_values):\n    fill_values = fill_values.groupby(level='country').ffill().bfill()\n    return fill_values", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for i in range(n):\n        # Generate a random number of countries (2 to 10)\n        num_countries = np.random.randint(2, 11)\n        countries = [f'Country_{j}' for j in range(num_countries)]\n\n        # Generate a random number of years (5 to 20)\n        num_years = np.random.randint(5, 21)\n        years = np.arange(2000, 2000 + num_years)\n\n        # Create multi-index with (country, year)\n        index = pd.MultiIndex.from_product([countries, years], names=['country', 'year'])\n\n        # Generate random values with NaNs\n        values = np.random.rand(len(index)) * 100  # Random values between 0 and 100\n        mask = np.random.choice([True, False], size=len(index), p=[0.2, 0.8])  # 20% missing values\n        values[mask] = np.nan\n\n        df = pd.DataFrame({'value': values}, index=index)\n        test_cases.append(df)\n\n    return test_cases"}
{"problem_id": "pandas_27", "library": "pandas", "code_problem": "You are tasked with creating a function that concatenates three pandas DataFrames into a single DataFrame. The function should ensure that all unique columns from the three input DataFrames are included in the final DataFrame, filling any missing values with NaN.\n\nFunction signature:\n```python\ndef concatenate_dataframes(df1, df2, df3):\n```\n\nConstant used in the main code:\n- `np.nan`: This constant is used to fill in missing values for columns that are not present in some of the input DataFrames.\n\nInput format:\n- The function accepts three pandas DataFrames as input.\n\nOutput format:\n- The function returns a single pandas DataFrame that contains all unique columns from the input DataFrames, with NaN values for any missing data.\n\n**Input:**\n```python\nimport pandas as pd\n\n# DataFrame 1\ndf1 = pd.DataFrame({\n    'col_1': [1, 2],\n    'col_2': [3, 4]\n})\n\n# DataFrame 2\ndf2 = pd.DataFrame({\n    'col_2': [5, 6],\n    'col_3': ['a', 'b']\n})\n\n# DataFrame 3\ndf3 = pd.DataFrame({\n    'col_4': [7, 8],\n    'col_1': [9, 10]\n})\n\n# Call the function\nresult = concatenate_dataframes(df1, df2, df3)\nprint(result)\n```\n\n**Output:**\n```\n  col_3 col_1 col_4 col_2\n0   NaN     1   NaN     3\n1   NaN     2   NaN     4\n2     a   NaN   NaN     5\n3     b   NaN   NaN     6\n4   NaN     9     7   NaN\n5   NaN    10     8   NaN\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef concatenate_dataframes(df1, df2, df3):\n    column_names = set.union(set(df1.columns), set(df2.columns), set(df3.columns))\n    df = pd.DataFrame(columns=list(column_names))\n    df = pd.concat([df, df1], ignore_index=True)\n    df = pd.concat([df, df2], ignore_index=True)\n    df = pd.concat([df, df3], ignore_index=True)\n    for column in column_names:\n        if column not in df.columns:\n            df[column] = np.nan\n    return df", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    # Function to generate a random dataframe\n    def generate_random_dataframe():\n        num_rows = random.randint(1, 100)  # Number of rows\n        num_cols = random.randint(5, 20)  # Number of columns\n        column_names = [f\"col_{random.randint(1, 10)}\" for _ in range(num_cols)]\n\n        data = {}\n        for col in column_names:\n            dtype = random.choice([int, float, str])\n            if dtype == int:\n                data[col] = np.random.randint(0, 100, size=num_rows).tolist()\n            elif dtype == float:\n                data[col] = np.round(np.random.rand(num_rows) * 100, 2).tolist()\n            else:\n                data[col] = [f\"val_{random.randint(1, 50)}\" for _ in range(num_rows)]\n\n        return pd.DataFrame(data)\n\n    # Generate test cases\n    test_cases = []\n\n    for _ in range(n):\n        df1 = generate_random_dataframe()\n        df2 = generate_random_dataframe()\n        df3 = generate_random_dataframe()\n\n\n        test_cases.append((df1, df2, df3))\n    return test_cases"}
{"problem_id": "pandas_28", "library": "pandas", "code_problem": "You are tasked with creating a function that calculates the total carbon dioxide (CO2) emissions for different countries based on their energy consumption data. The function will utilize a dataset from Eurostat, which contains energy consumption figures categorized by fuel type for various years.\n\nFunction signature:\n```python\ndef build_eurostat_co2(eurostat: pd.DataFrame, year: int) -> pd.Series:\n```\n\nIn this function, you will use a constant set of specific emissions factors for different fuel types, which represent the amount of CO2 emitted per unit of energy consumed. The specific emissions factors are as follows:\n- Solid fossil fuels: 0.36 kg CO2 per unit\n- Oil and petroleum products: 0.285 kg CO2 per unit\n- Natural gas: 0.2 kg CO2 per unit\n\nInput format:\n- `eurostat`: A Pandas DataFrame with a multi-index where one level is 'year' and the other level represents different countries or regions. The columns represent different fuel types.\n- `year`: An integer representing the year for which the CO2 emissions are to be calculated.\n\nOutput format:\n- A Pandas Series where the index represents the countries or regions and the values represent the total CO2 emissions for the specified year.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ndata = {\n    ('Region_0', 2020): [50, 30, 20],\n    ('Region_1', 2020): [10, 40, 50],\n    ('Region_2', 2020): [20, 10, 70]\n}\neurostat = pd.DataFrame.from_dict(data, orient='index', columns=['Solid fossil fuels', 'Oil and petroleum products', 'Natural gas'])\nyear = 2020\n```\n\n**Output:**\n```python\noutput = pd.Series({\n    'Region_0': 30.55,\n    'Region_1': 25.00,\n    'Region_2': 24.05\n})\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef build_eurostat_co2(eurostat, year):\n    eurostat_year = eurostat.xs(year, level='year')\n    specific_emissions = pd.Series(index=eurostat.columns, dtype=float)\n    specific_emissions['Solid fossil fuels'] = 0.36\n    specific_emissions['Oil and petroleum products'] = 0.285\n    specific_emissions['Natural gas'] = 0.2\n    return eurostat_year.multiply(specific_emissions).sum(axis=1)", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    fuel_types = ['Solid fossil fuels', 'Oil and petroleum products', 'Natural gas']\n    years = np.arange(2000, 2026)\n    test_cases = []\n\n    for _ in range(n):\n        num_entries = np.random.randint(5, 100)\n\n        # Generate random country/region labels\n        regions = [f'Region_{i}' for i in range(num_entries)]\n\n        # Generate random year for filtering\n        selected_year = np.random.choice(years)\n\n        # Create a multi-index DataFrame with 'year' as one of the levels\n        index = pd.MultiIndex.from_product(\n            [regions, [selected_year]], names=['region', 'year']\n        )\n\n        # Generate random CO2 emission data for each fuel type\n        data = np.random.rand(num_entries, len(fuel_types)) * 100\n        df = pd.DataFrame(data, index=index, columns=fuel_types)\n\n        test_cases.append((df, selected_year))\n\n    return test_cases"}
{"problem_id": "pandas_29", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a DataFrame containing shift information and generates new rows based on specified shift timings. The function will take in a DataFrame and several parameters related to shifts, and it will return a modified DataFrame with additional shift details.\n\nFunction Signature:\n```python\ndef execute(df, shift_end, shift_start, end_timestamp, shift_day, start_timestamp, shifts, shift_id):\n```\n\nConstants Used:\n- The constant used in the main code is `None`, which is checked to determine if `shift_start` and `shift_end` are provided.\n\nInput Format:\n- The function takes the following parameters:\n  - `df`: A pandas DataFrame containing shift data.\n  - `shift_end`: A string representing the column name for shift end times.\n  - `shift_start`: A string representing the column name for shift start times.\n  - `end_timestamp`: A string representing the column name for the end timestamp.\n  - `shift_day`: A string representing the column name for the shift day.\n  - `start_timestamp`: A string representing the column name for the start timestamp.\n  - `shifts`: An object that provides methods to handle shift data.\n  - `shift_id`: A string representing the column name for the shift ID.\n\nOutput Format:\n- The function returns a pandas DataFrame that includes the original data along with additional rows and columns for the generated shift details.\n\n**Input:**\n```python\nimport pandas as pd\nfrom datetime import datetime, timedelta, time\n\n# Create a sample DataFrame\ndf = pd.DataFrame({\n    \"col1\": [1, 2, 3],\n    \"col2\": [None, 0.5, 0.8],\n})\n\n# Define parameters\nshift_end = \"shift_end\"\nshift_start = \"shift_start\"\nend_timestamp = \"end_timestamp\"\nshift_day = \"shift_day\"\nstart_timestamp = \"start_timestamp\"\n\n# Mock shifts\nclass MockShift:\n    def __init__(self, name, start_seconds, end_seconds):\n        self.name = name\n        self._start_time = time(start_seconds // 3600, (start_seconds % 3600) // 60)\n        self._end_time = time((end_seconds // 3600) % 24, (end_seconds % 3600) // 60)\n\n    def start_time(self, shift_day):\n        return datetime.combine(shift_day, self._start_time)\n\n    def end_time(self, shift_day):\n        return datetime.combine(shift_day, self._end_time)\n\nclass MockShifts:\n    def __init__(self):\n        self.shifts = [\n            MockShift(\"Morning\", 8 * 3600, 16 * 3600),\n            MockShift(\"Evening\", 16 * 3600, 23 * 3600),\n            MockShift(\"Night\", 0 * 3600, 8 * 3600)\n        ]\n\n    def split(self, start_timestamp, end_timestamp):\n        shift_day = start_timestamp.date()\n        applicable_shifts = []\n        for shift in self.shifts:\n            if shift.start_time(shift_day) <= start_timestamp < shift.end_time(shift_day):\n                applicable_shifts.append((shift_day, shift, start_timestamp, end_timestamp))\n        if applicable_shifts:\n            return applicable_shifts\n        else:\n            shift = random.choice(self.shifts)\n            return [(shift_day, shift, start_timestamp, end_timestamp)]\n\n    def get_shift(self, start_timestamp):\n        shift_day = start_timestamp.date()\n        return shift_day, random.choice(self.shifts)\n\nshifts = MockShifts()\n\n# Define start and end timestamps\nstart_times = [datetime(2025, 1, 1, 9, 0), datetime(2025, 1, 1, 17, 0), datetime(2025, 1, 1, 22, 0)]\nend_times = [start + timedelta(hours=2) for start in start_times]\ndf[start_timestamp] = start_times\ndf[end_timestamp] = end_times\n\n# Execute the function\nresult_df = execute(df, shift_end, shift_start, end_timestamp, shift_day, start_timestamp, shifts, \"shift_id\")\n```\n\n**Output:**\n```python\n   index  col1  col2  ... shift_id         shift_start           shift_end\n0      0     1   NaN  ...  Morning 2025-01-01 08:00:00 2025-01-01 16:00:00\n1      1     2   0.5  ...  Evening 2025-01-01 16:00:00 2025-01-01 23:00:00\n2      2     3   0.8  ...  Evening 2025-01-01 16:00:00 2025-01-01 23:00:00\n[3 rows x 9 columns]\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef execute(df, shift_end, shift_start, end_timestamp, shift_day, start_timestamp, shifts, shift_id):\n    generated_rows = []\n    generated_values = {shift_day: [], shift_id: [], 'shift_start': [], 'shift_end': []}\n    append_values = {shift_day: [], shift_id: [], 'shift_start': [], 'shift_end': []}\n\n    df[shift_day] = shift_day\n    df[shift_id] = shift_id\n    if shift_start is not None:\n        df[shift_start] = shift_start\n    if shift_end is not None:\n        df[shift_end] = shift_end\n\n    original_index_names = df.index.names\n    df = df.reset_index()\n\n    column_positions = {col: pos for pos, col in enumerate(df.columns, 1)}\n\n    for row in df.itertuples(index=True, name=None):\n        idx = row[0]\n        row_start = row[column_positions[start_timestamp]]\n        row_end = row[column_positions[end_timestamp]]\n\n        if pd.notna(row_start) and pd.notna(row_end):\n            result_rows = shifts.split(pd.to_datetime(row_start), pd.to_datetime(row_end))\n        elif pd.notna(row_start):\n            shift_day_val, shift = shifts.get_shift(pd.to_datetime(row_start))\n            generated_values[shift_day].append(shift_day_val.strftime('%Y-%m-%d'))\n            generated_values[shift_id].append(shift.name)\n            generated_values['shift_start'].append(shift.start_time(shift_day_val))\n            generated_values['shift_end'].append(shift.end_time(shift_day_val))\n            continue\n        else:\n            generated_values[shift_day].append(None)\n            generated_values[shift_id].append(None)\n            generated_values['shift_start'].append(None)\n            generated_values['shift_end'].append(None)\n            continue\n\n        for i, (shift_day_val, shift, start_ts, end_ts) in enumerate(result_rows):\n            if i == 0:\n                df.loc[idx, start_timestamp] = start_ts\n                df.loc[idx, end_timestamp] = end_ts\n                generated_values[shift_day].append(shift_day_val.strftime('%Y-%m-%d'))\n                generated_values[shift_id].append(shift.name)\n                generated_values['shift_start'].append(shift.start_time(shift_day_val))\n                generated_values['shift_end'].append(shift.end_time(shift_day_val))\n            else:\n                new_row = pd.Series(row[1:], index=df.columns)\n                new_row[start_timestamp] = start_ts\n                new_row[end_timestamp] = end_ts\n                generated_rows.append(new_row)\n                append_values[shift_day].append(shift_day_val.strftime('%Y-%m-%d'))\n                append_values[shift_id].append(shift.name)\n                append_values['shift_start'].append(shift.start_time(shift_day_val))\n                append_values['shift_end'].append(shift.end_time(shift_day_val))\n\n    if generated_rows:\n        df = pd.concat([df, pd.DataFrame(generated_rows)], ignore_index=True)\n        for key in generated_values:\n            generated_values[key].extend(append_values[key])\n\n    df[shift_day] = generated_values[shift_day]\n    df[shift_id] = generated_values[shift_id]\n    if shift_start is not None:\n        df[shift_start] = generated_values['shift_start']\n    if shift_end is not None:\n        df[shift_end] = generated_values['shift_end']\n    return df", "test_script": "import pandas as pd\nimport random\nfrom datetime import datetime, timedelta, time\n\n\ndef generate_random_datetime(start, end):\n    return start + timedelta(seconds=random.randint(0, int((end - start).total_seconds())))\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    # Define possible shift structures\n    class MockShift:\n        def __init__(self, name, start_seconds, end_seconds):\n            self.name = name\n            self._start_time = time(start_seconds // 3600, (start_seconds % 3600) // 60)\n            self._end_time = time((end_seconds // 3600) % 24, (end_seconds % 3600) // 60)\n\n        def start_time(self, shift_day):\n            return datetime.combine(shift_day, self._start_time)\n\n        def end_time(self, shift_day):\n            return datetime.combine(shift_day, self._end_time)\n\n    class MockShifts:\n        def __init__(self):\n            self.shifts = [\n                MockShift(\"Morning\", 8 * 3600, 16 * 3600),\n                MockShift(\"Evening\", 16 * 3600, 23 * 3600),\n                MockShift(\"Night\", 0 * 3600, 8 * 3600)\n            ]\n\n        def split(self, start_timestamp, end_timestamp):\n            shift_day = start_timestamp.date()\n            applicable_shifts = []\n            for shift in self.shifts:\n                if shift.start_time(shift_day) <= start_timestamp < shift.end_time(shift_day):\n                    applicable_shifts.append((shift_day, shift, start_timestamp, end_timestamp))\n\n            # Ensure that we always return a list of tuples in the expected format\n            if applicable_shifts:\n                return applicable_shifts\n            else:\n                shift = random.choice(self.shifts)\n                return [(shift_day, shift, start_timestamp, end_timestamp)]  # Always a list of tuples\n\n        def get_shift(self, start_timestamp):\n            shift_day = start_timestamp.date()\n            return shift_day, random.choice(self.shifts)\n\n    shifts = MockShifts()\n\n    for _ in range(n):\n        df = pd.DataFrame({\n            \"col1\": [random.randint(1, 100) for _ in range(5)],\n            \"col2\": [random.choice([None, random.random()]) for _ in range(5)],\n        })\n        shift_start = \"shift_start\"\n        shift_end = \"shift_end\"\n        start_timestamp = \"start_timestamp\"\n        end_timestamp = \"end_timestamp\"\n        shift_day = \"shift_day\"\n        shift_id = \"shift_id\"\n\n        start_times = [generate_random_datetime(datetime(2025, 1, 1), datetime(2025, 12, 31)) for _ in range(5)]\n        end_times = [s + timedelta(hours=random.randint(1, 8)) for s in start_times]\n        df[start_timestamp] = start_times\n        df[end_timestamp] = end_times\n\n        test_case = (df, shift_end, shift_start, end_timestamp, shift_day, start_timestamp, shifts, shift_id)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "pandas_30", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a given DataFrame to handle categorical variables. The function should convert non-numeric columns into categorical types and map their values to integers. Additionally, it should provide a mapping of the original categorical values to their corresponding integer representations.\n\nFunction Signature:\n```python\ndef cat_var(data, col_excl=None, return_cat=True):\n```\n\n### Constants:\n- The function uses the constant `0` to fill in missing values when mapping categorical variables to integers.\n\n### Input Format:\n- The function takes a single argument `data`, which is a pandas DataFrame. It also accepts two optional parameters: `col_excl`, which is a list of column names to exclude from processing, and `return_cat`, a boolean indicating whether to return the non-numeric columns as categorical types.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A pandas DataFrame with categorical variables mapped to integers,\n  - A DataFrame with indices and names of the categorical variables,\n  - A dictionary representing the inverse mapping of categorical values,\n  - A dictionary representing the mapping of categorical values to integers.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'col_0': [1, 2, 3, 4, 5],\n    'col_1': ['A', 'B', 'A', 'C', 'B'],\n    'col_2': ['2020-01-01', '2020-01-02', '2020-01-03', '2020-01-04', '2020-01-05']\n})\ncol_excl = ['col_0']\n```\n\n**Output:**\n```python\n(df, cat_var_df, inv_mapper, mapper) = cat_var(data, col_excl)\n\n# df:\n   col_0 col_1 col_2\n0      1     0     0\n1      2     1     1\n2      3     0     2\n3      4     2     3\n4      5     1     4\n\n# cat_var_df:\n   cat_ind cat_name\n0        2    col_2\n1        1    col_1\n\n# inv_mapper:\n{\n    'col_2': {0: '2020-01-01', 1: '2020-01-02', 2: '2020-01-03', 3: '2020-01-04', 4: '2020-01-05'}, \n    'col_1': {0: 'A', 1: 'B', 2: 'C'}\n}\n\n# mapper:\n{\n    'col_2': {'2020-01-01': 0, '2020-01-02': 1, '2020-01-03': 2, '2020-01-04': 3, '2020-01-05': 4},\n    'col_1': {'A': 0, 'B': 1, 'C': 2}\n}\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef cat_var(data, col_excl=None, return_cat=True):\n    df = data.copy()\n    if col_excl is None:\n        non_num_cols = list(set(list(df.columns)) - set(list(df.select_dtypes(include=[np.number]))))\n    else:\n        non_num_cols = list(set(list(df.columns)) - set(list(df.select_dtypes(include=[np.number]))) - set(col_excl))\n    cat_var_index = [df.columns.get_loc(c) for c in non_num_cols if c in df]\n    cat_var_df = pd.DataFrame({'cat_ind': cat_var_index, 'cat_name': non_num_cols})\n    date_cols = [s for s in list(df) if 'date' in s]\n    df.loc[:, date_cols] = df.loc[:, date_cols].astype(str)\n    cols_need_mapped = cat_var_df.cat_name.to_list()\n    inv_mapper = {col: dict(enumerate(df[col].astype('category').cat.categories)) for col in df[cols_need_mapped]}\n    mapper = {col: {v: k for (k, v) in inv_mapper[col].items()} for col in df[cols_need_mapped]}\n    for c in cols_need_mapped:\n        df.loc[:, c] = df.loc[:, c].map(mapper[c]).fillna(0).astype(int)\n    if return_cat:\n        df.loc[:, non_num_cols] = df.loc[:, non_num_cols].astype('category')\n    return (df, cat_var_df, inv_mapper, mapper)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(5, 50)  # Random number of rows\n        num_cols = random.randint(3, 10)  # Random number of columns\n\n        # Generate column names\n        col_names = [f\"col_{i}\" for i in range(num_cols)]\n\n        # Decide column types\n        col_types = random.choices([\"num\", \"cat\", \"date\"], k=num_cols)\n\n        data = {}\n        for col, col_type in zip(col_names, col_types):\n            if col_type == \"num\":\n                data[col] = np.random.randint(0, 100, size=num_rows)\n            elif col_type == \"cat\":\n                data[col] = np.random.choice([\"A\", \"B\", \"C\", \"D\"], size=num_rows)\n            elif col_type == \"date\":\n                start_date = pd.to_datetime(\"2020-01-01\")\n                data[col] = [start_date + pd.DateOffset(days=random.randint(0, 365)) for _ in range(num_rows)]\n\n        df = pd.DataFrame(data)\n\n        # Randomly choose columns to exclude (sometimes None, sometimes a subset)\n        col_excl = None if random.random() < 0.5 else random.sample(col_names, random.randint(0, len(col_names)))\n        test_cases.append((df, col_excl))\n\n    return test_cases"}
{"problem_id": "pandas_31", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs a k-nearest neighbors (KNN) classification on T-cell receptor (TCR) data while accounting for various parameters such as inverse distance weighting and prior probabilities. The function will utilize cross-validation to ensure that the model is robust and generalizes well to unseen data.\n\nFunction Signature:\n```python\ndef hold_one_subject_knn(tcrrep, max_k, inverse_distance_weight, account_for_prior, power):\n```\n\n### Constants Used:\n- `n_groups`: This constant is set to `1` in the `LeavePGroupsOut` function to specify that one group (subject) should be held out during each iteration of cross-validation.\n\n### Input Format:\n- `tcrrep`: An object containing TCR data with attributes `clone_df` (DataFrame with columns `epitope` and `subject`) and `paired_tcrdist` (distance matrix).\n- `max_k`: An integer representing the maximum number of neighbors.\n- `inverse_distance_weight`: A boolean indicating whether to apply inverse distance weighting.\n- `account_for_prior`: A boolean indicating whether to account for prior probabilities.\n- `power`: A float representing the power for inverse distance weighting.\n\n### Output Format:\n- A dictionary where each key is a unique epitope and each value is a DataFrame containing the ROC curve data, including false positive rates, true positive rates, thresholds, and the area under the curve (AUC).\n\n```python\n# Input\ntcrrep = type('TCRrep', (object,), {\n    'clone_df': pd.DataFrame({\n        'epitope': ['epitope_0', 'epitope_1', 'epitope_0', 'epitope_1'],\n        'subject': ['subject_0', 'subject_0', 'subject_1', 'subject_1']\n    }),\n    'paired_tcrdist': np.array([[0.0, 0.1, 0.2, 0.3],\n                                 [0.1, 0.0, 0.4, 0.5],\n                                 [0.2, 0.4, 0.0, 0.6],\n                                 [0.3, 0.5, 0.6, 0.0]])\n})\n\nmax_k = 2\ninverse_distance_weight = True\naccount_for_prior = False\npower = -1.0\n\n# Output\n{\n    'epitope_0': pd.DataFrame({'fpr': [0.0, 1.0], 'tpr': [0.0, 1.0], 'thr': [inf, 0.0], 'roc_auc': 0.5}),\n    'epitope_1': pd.DataFrame({'fpr': [0.0, 1.0], 'tpr': [0.0, 1.0], 'thr': [inf, 1.0], 'roc_auc': 0.5})\n}\n``` \n", "ground_truth_code": "from sklearn import preprocessing\nfrom sklearn.model_selection import LeavePGroupsOut\nfrom sklearn.metrics import roc_curve\nfrom sklearn.metrics import auc\nimport numpy as np\nimport pandas as pd\n\ndef _normalize_rows(df):\n    df_row_norm = df.div(df.sum(axis=1), axis=0)\n    return df_row_norm\n\ndef _cv_split_hold_out_by_subject_using_sklearn(tcrrep=None):\n    if tcrrep is None:\n        tcrrep = tcrrep\n    encoder_epitope = preprocessing.LabelEncoder()\n    encoder_epitope.fit(list(tcrrep.clone_df.epitope.unique()))\n    y = encoder_epitope.transform(tcrrep.clone_df.epitope)\n    X = tcrrep.paired_tcrdist\n    encoder_subjects = preprocessing.LabelEncoder()\n    encoder_subjects = encoder_subjects.fit(list(tcrrep.clone_df.subject.unique()))\n    groups = list(encoder_subjects.transform(tcrrep.clone_df.subject))\n    lpgo = LeavePGroupsOut(n_groups=1)\n    lpgo.get_n_splits(X, y, groups)\n    partitions = lpgo.split(X, y, groups)\n    return partitions\n\ndef _calc_inverse_distance(df, k, power=-1.0):\n    df = df.iloc[:, 0:k].copy()\n    df = df.pow(power)\n    idw = df.div(df.sum(axis=1), axis=0)\n    return idw\n\ndef knn(class_labels, d, cv, k):\n    (train_index, test_index) = cv\n    d_cv = d[test_index, :][:, train_index]\n    class_labels_train = class_labels[train_index]\n    class_labels_test = class_labels[test_index]\n    knn_ind = np.argsort(d_cv, axis=1)[:, 1:k + 1]\n    knn_dist = np.sort(d_cv, axis=1)[:, 1:k + 1]\n    knn_class = class_labels_train[knn_ind]\n    r = {'knn_class': pd.DataFrame(knn_class, index=test_index), 'knn_dist': pd.DataFrame(knn_dist, index=test_index), 'knn_label': pd.DataFrame(class_labels_test, index=test_index)}\n    return r\n\ndef _calc_idw_weighted_score(knn_pred_dist, knn_pred_class, k, power, classes):\n    l = []\n    idw = _calc_inverse_distance(knn_pred_dist + 1, k=k, power=power)\n    for e in classes:\n        weighted_score = idw * (knn_pred_class.iloc[:, 0:k] == e).astype(int)\n        l.append(weighted_score.sum(axis=1))\n    ws = pd.concat(l, axis=1)\n    ws.columns = classes\n    wsn = _normalize_rows(ws)\n    return wsn\n\ndef _calc_frequency(df, k):\n    dfk = df.iloc[:, 0:k].copy()\n    r = dfk.apply(pd.Series.value_counts, axis=1, normalize=True).fillna(0)\n    return r\n\ndef _calc_prior_probabilities(series):\n    r = series.value_counts(normalize=True).to_dict()\n    return r\n\ndef roc_pddf(epi, obs, pr):\n    (fpr, tpr, threshold) = roc_curve(obs[epi], pr[epi])\n    roc_auc = auc(fpr, tpr)\n    roc_df = pd.DataFrame({'fpr': fpr, 'tpr': tpr, 'thr': threshold, 'roc_auc': roc_auc})\n    return roc_df\n\n# main code\ndef hold_one_subject_knn(tcrrep, max_k, inverse_distance_weight, account_for_prior, power):\n    tr = tcrrep\n    my_cl = np.array(tr.clone_df.epitope)\n    unique_epitopes = pd.Series(my_cl).unique().tolist()\n    my_d = tr.paired_tcrdist\n    cv_partions = _cv_split_hold_out_by_subject_using_sklearn(tr)\n    knn_pred = [knn(class_labels=my_cl, d=my_d, cv=x, k=max_k) for x in cv_partions]\n    knn_pred_class = pd.concat([x['knn_class'] for x in knn_pred])\n    knn_pred_dist = pd.concat([x['knn_dist'] for x in knn_pred])\n    knn_obsv_class = pd.concat([x['knn_label'] for x in knn_pred])\n    knn_pred_class_truth = pd.get_dummies(knn_obsv_class, prefix='', prefix_sep='')\n    if inverse_distance_weight:\n        knn_pred_class_prob = _calc_idw_weighted_score(knn_pred_dist, knn_pred_class, k=max_k, power=power, classes=unique_epitopes)\n    else:\n        knn_pred_class_prob = _calc_frequency(knn_pred_class, k=max_k)\n    if account_for_prior:\n        priors = _calc_prior_probabilities(knn_obsv_class[0])\n        priors = pd.DataFrame(priors, index=knn_pred_class_prob.index.copy())\n        knn_pred_class_prob2 = knn_pred_class_prob / priors\n        knn_pred_class_posterier = knn_pred_class_prob2.div(knn_pred_class_prob2.sum(axis=1), axis=0)\n    else:\n        knn_pred_class_posterier = knn_pred_class_prob\n    roc_dict = {k: {} for k in unique_epitopes}\n    for epitope in unique_epitopes:\n        roc_dict[epitope] = roc_pddf(epitope, obs=knn_pred_class_truth, pr=knn_pred_class_posterier)\n    return roc_dict", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    def generate_synthetic_tcrrep(num_samples, num_features, num_epitopes, num_subjects):\n        \"\"\"Generates a synthetic tcrrep dataset with randomized values.\"\"\"\n        clone_df = pd.DataFrame({\n            'epitope': np.random.choice([f'epitope_{i}' for i in range(num_epitopes)], num_samples),\n            'subject': np.random.choice([f'subject_{i}' for i in range(num_subjects)], num_samples),\n            'feature': np.random.choice([f'feature_{i}' for i in range(num_features)], num_samples)\n        })\n        paired_tcrdist = np.random.rand(num_samples, num_samples)\n        return type('TCRrep', (object,), {'clone_df': clone_df, 'paired_tcrdist': paired_tcrdist})()\n\n    \"\"\"Generates n test cases with randomized parameters.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        tcrrep = generate_synthetic_tcrrep(\n            num_samples=random.randint(50, 200),\n            num_features=random.randint(5, 50),\n            num_epitopes=random.randint(2, 10),\n            num_subjects=random.randint(5, 20)\n        )\n        max_k = random.randint(1, min(10, len(tcrrep.clone_df)))\n        inverse_distance_weight = random.choice([True, False])\n        account_for_prior = random.choice([True, False])\n        power = random.uniform(-2.0, 0.0)\n        test_cases.append((tcrrep, max_k, inverse_distance_weight, account_for_prior, power))\n    return test_cases"}
{"problem_id": "pandas_32", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs a series of mathematical transformations on specified features of a given DataFrame. The function will take a DataFrame and a list of feature names as input, apply transformations to these features, and return a new DataFrame that includes the original features along with the transformed features.\n\nFunction signature:\n```python\ndef transformations(df: pd.DataFrame, features: list) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant value `1` is used in the transformations to adjust the data before applying logarithmic and reciprocal transformations.\n\nInput format:\n- The input to the function is a pandas DataFrame `df` and a list of strings `features` representing the column names to be transformed.\n\nOutput format:\n- The output of the function is a pandas DataFrame that includes the original features along with the transformed features (squared, logarithmic, reciprocal, and square root).\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test DataFrame\ndata = {\n    'feature_0': [1, 2, 3],\n    'feature_1': [4, 5, 6]\n}\ndf = pd.DataFrame(data)\n\n# Features to transform\nfeatures = ['feature_0', 'feature_1']\n```\n\n**Output:**\n```python\n   feature_0  feature_1  ...  feature_0_SQRT_p_one  feature_1_SQRT_p_one\n0          1          4  ...              1.000000              1.000000\n1          2          5  ...              1.414214              1.414214\n2          3          6  ...              1.732051              1.732051\n[3 rows x 10 columns]\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef transformations(df, features):\n    df_new = df[features]\n    df_new = df_new - df_new.min()\n    sqr_name = [str(fa) + '_POWER_2' for fa in df_new.columns]\n    log_p_name = [str(fa) + '_LOG_p_one_abs' for fa in df_new.columns]\n    rec_p_name = [str(fa) + '_RECIP_p_one' for fa in df_new.columns]\n    sqrt_name = [str(fa) + '_SQRT_p_one' for fa in df_new.columns]\n    df_sqr = pd.DataFrame(np.power(df_new.values, 2), columns=sqr_name, index=df.index)\n    df_log = pd.DataFrame(np.log(df_new.add(1).abs().values), columns=log_p_name, index=df.index)\n    df_rec = pd.DataFrame(np.reciprocal(df_new.add(1).values), columns=rec_p_name, index=df.index)\n    df_sqrt = pd.DataFrame(np.sqrt(df_new.abs().add(1).values), columns=sqrt_name, index=df.index)\n    dfs = [df, df_sqr, df_log, df_rec, df_sqrt]\n    df = pd.concat(dfs, axis=1)\n    return df", "test_script": "import pandas as pd\nimport numpy as np\n\n# Generate 200 test cases\ndef test_case_input_generator(n=200):\n    # Function to generate random test DataFrames\n    def generate_test_dataframe(num_rows, num_features):\n        data = np.random.uniform(-100, 100, size=(num_rows, num_features))  # Random values in range [-100, 100]\n        feature_names = [f'feature_{i}' for i in range(num_features)]\n        df = pd.DataFrame(data, columns=feature_names)\n        return df, feature_names\n\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(1, 500)  # Random number of rows (1 to 500)\n        num_features = np.random.randint(1, 20)  # Random number of features (1 to 20)\n\n        df, features = generate_test_dataframe(num_rows, num_features)\n        test_cases.append((df, features))\n    return test_cases"}
{"problem_id": "pandas_33", "library": "pandas", "code_problem": "You are tasked with creating a function that generates a binned representation of genomic regions based on chromosome sizes and a specified bin size. The function will take in a dictionary of chromosome sizes and a bin size, and it will return a DataFrame containing the chromosome name, start position, and end position for each bin.\n\nFunction signature:\n```python\ndef binnify(chromsizes: dict, binsize: int) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `binsize`, which determines the size of each bin in the output DataFrame.\n\nInput format:\n- The input consists of a dictionary `chromsizes` where keys are strings representing chromosome names and values are integers representing the sizes of the chromosomes. The second input is an integer `binsize` representing the size of each bin.\n\nOutput format:\n- The output is a pandas DataFrame with three columns: 'chrom' (string), 'start' (integer), and 'end' (integer), representing the chromosome name, the start position of each bin, and the end position of each bin, respectively.\n\n**Input:**\n```python\nchromsizes = pd.Series({\n    'chr1': 15,\n    'chr2': 25,\n    'chr3': 10\n})\nbinsize = 5\n```\n\n**Output:**\n```python\n  chrom  start  end\n0  chr1      0    5\n1  chr1      5   10\n2  chr1     10   15\n3  chr2      0    5\n4  chr2      5   10\n5  chr2     10   15\n6  chr2     15   20\n7  chr2     20   25\n8  chr3      0    5\n9  chr3      5   10\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef binnify(chromsizes, binsize):\n    def _each(chrom):\n        clen = chromsizes[chrom]\n        n_bins = int(np.ceil(clen / binsize))\n        binedges = np.arange(0, n_bins + 1) * binsize\n        binedges[-1] = clen\n        return pd.DataFrame({'chrom': [chrom] * n_bins, 'start': binedges[:-1], 'end': binedges[1:]}, columns=['chrom', 'start', 'end'])\n    bintable = pd.concat(map(_each, chromsizes.keys()), axis=0, ignore_index=True)\n    bintable['chrom'] = pd.Categorical(bintable['chrom'], categories=list(chromsizes.index), ordered=True)\n    return bintable", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a random number of chromosomes\n        num_chroms = random.randint(5, 100)\n\n        # Create a dictionary of chromosome sizes\n        chromsizes = pd.Series({\n            f'chr{chr_id}': random.randint(5, 100)\n            for chr_id in range(1, num_chroms + 1)\n        })\n        # Generate a random bin size\n        binsize = random.randint(1, 10)\n        # Store the test case\n        test_cases.append((chromsizes, binsize))\n\n    return test_cases"}
{"problem_id": "pandas_34", "library": "pandas", "code_problem": "You are tasked with developing a function that identifies anomalies in a set of scores using a decision tree classifier. The function will take in two data frames: one containing scores and another containing known anomalies. The goal is to train a classifier on the provided data and then use it to predict anomalies in the scores.\n\nFunction signature:\n```python\ndef score_to_anomaly(scores: pd.DataFrame, anomalies: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `max_depth=None`, which is a parameter for the `DecisionTreeClassifier` indicating that the tree can grow without a maximum depth limit.\n\nInput format:\n- `scores`: A pandas DataFrame where columns represent different series of scores and rows represent different dates.\n- `anomalies`: A pandas DataFrame with the same structure as `scores`, where the values indicate whether a score is an anomaly (typically binary values).\n\nOutput format:\n- The function returns a pandas DataFrame with the same columns as `scores`, where each entry indicates the predicted anomaly status for the corresponding score, indexed by date.\n\n**Input:**\n```python\nscores = pd.DataFrame({\n    'series_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'series_1': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'series_2': [0.2, 0.3, 0.4, 0.5, 0.6]\n}, index=pd.date_range(start=\"2020-01-01\", periods=5, freq=\"D\"))\n\nanomalies = pd.DataFrame({\n    'series_0': [0, 1, 0, 0, 1],\n    'series_1': [1, 0, 1, 0, 0],\n    'series_2': [0, 0, 1, 1, 0]\n}, index=pd.date_range(start=\"2020-01-01\", periods=5, freq=\"D\"))\n```\n\n**Output:**\n```python\nseries      series_0  series_1  series_2\ndate                                    \n2020-01-01         0         1         0\n2020-01-02         1         0         0\n2020-01-03         0         1         1\n2020-01-04         0         0         1\n2020-01-05         1         0         0\n```", "ground_truth_code": "import pandas as pd\nfrom sklearn.tree import DecisionTreeClassifier\n\n\ndef fit_anomaly_classifier(scores, anomalies):\n    scores_flat = scores.melt(var_name='series', value_name='value')\n    scores_flat['series'] = pd.Categorical(scores_flat['series'])\n    score_categories = scores_flat['series'].cat.categories.tolist()\n\n    # One-hot encode categorical series with a fixed order\n    scores_encoded = pd.get_dummies(scores_flat['series'], dtype=float)\n    scores_encoded = scores_encoded.reindex(columns=score_categories, fill_value=0)\n    scores_encoded = pd.concat([scores_encoded, scores_flat['value']], axis=1)\n\n    anomalies_flat = anomalies.melt(var_name='series', value_name='value')\n\n    # Fit decision tree classifier\n    classifier = DecisionTreeClassifier(max_depth=None)\n    classifier.fit(scores_encoded, anomalies_flat['value'])\n\n    return classifier, score_categories  # Return the classifier and category order\n\n\n# main code\ndef score_to_anomaly(scores, anomalies):\n    anomaly_classifier, score_categories = fit_anomaly_classifier(scores, anomalies)\n    scores.index.name = 'date'\n    scores_flat = scores.reset_index().melt(id_vars='date', var_name='series', value_name='value')\n\n    scores_flat['series'] = pd.Categorical(scores_flat['series'], categories=score_categories)\n\n    # Ensure encoding uses the same category order\n    scores_encoded = pd.get_dummies(scores_flat['series'], dtype=float)\n    scores_encoded = scores_encoded.reindex(columns=score_categories, fill_value=0)\n    scores_encoded = pd.concat([scores_encoded, scores_flat['value']], axis=1)\n\n    predictions = anomaly_classifier.predict(scores_encoded)\n\n    res = pd.concat([scores_flat[['date', 'series']], pd.Series(predictions, name='value')], axis=1)\n    res = res.pivot(index='date', columns='series', values='value')\n\n    return res[scores.columns]", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_series = np.random.randint(5, 20)\n        num_dates = np.random.randint(5, 100)\n        dates = pd.date_range(start=\"2020-01-01\", periods=num_dates, freq=\"D\")\n        series_names = [f\"series_{i}\" for i in range(num_series)]\n\n        scores = pd.DataFrame(np.random.rand(num_dates, num_series), index=dates, columns=series_names)\n        anomalies = pd.DataFrame(np.random.randint(0, 2, size=(num_dates, num_series)), index=dates,\n                                 columns=series_names)\n\n        test_cases.append((scores, anomalies))\n\n    return test_cases"}
{"problem_id": "pandas_35", "library": "pandas", "code_problem": "You are tasked with implementing a function that analyzes financial data to determine the direction of a trading signal based on the difference between two indicators and a volatility measure. The function will utilize a method that incorporates a rate to adjust the volatility measure, allowing for a more dynamic assessment of the trading signal.\n\nFunction signature:\n```python\ndef create_method_b(dif: pd.Series, dea: pd.Series, atr: pd.Series, rate: float) -> pd.Series:\n```\n\nIn this function, the following constant is used:\n- `delta`: This is calculated as the product of the Average True Range (ATR) and a specified rate.\n\nInput format:\n- The function takes four parameters:\n  - `dif`: A pandas Series representing the difference indicator.\n  - `dea`: A pandas Series representing the signal line.\n  - `atr`: A pandas Series representing the Average True Range.\n  - `rate`: A float representing the rate to adjust the volatility measure.\n\nOutput format:\n- The function returns a pandas Series containing the trading signal direction for each index, where the values can be 1, -1, or 0.\n\nInput:\n```python\ndif = pd.Series([0.5, 1.0, 1.5, 2.0, 2.5])\ndea = pd.Series([0.0, 0.5, 1.0, 1.5, 2.0])\natr = pd.Series([0.1, 0.2, 0.3, 0.4, 0.5])\nrate = 1.0\n```\n\nOutput:\n```python\npd.Series([0., 1., 1., 1., 1.])\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef create_method_b(dif, dea, atr, rate):\n    delta: pd.Series = atr * rate\n    diff = dif - dea\n    dir_ser = pd.Series(index=dif.index)\n    for (num, (diff_v, delta_v)) in enumerate(zip(diff, delta)):\n        if num == 0:\n            previous_dir = 0\n            dir_ser.iloc[num] = 0\n            continue\n        else:\n            if diff_v - delta_v >= 0:\n                dir_ser.iloc[num] = 1\n            elif diff_v + delta_v <= 0:\n                dir_ser.iloc[num] = -1\n            else:\n                dir_ser.iloc[num] = previous_dir\n            previous_dir = dir_ser.iloc[num]\n    return dir_ser", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_tests = np.random.randint(10, 100)\n        num_samples = np.random.randint(10, 100)\n\n        # Generate random input Series\n        dif = pd.Series(np.random.randn(num_samples))\n        dea = pd.Series(np.random.randn(num_samples))\n        atr = pd.Series(np.abs(np.random.randn(num_samples)))  # ATR should be non-negative\n        rate = np.random.uniform(0.1, 2.0)  # Random rate within a reasonable range\n\n        test_cases.append((dif, dea, atr, rate))\n    return test_cases"}
{"problem_id": "pandas_36", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs an inverse transformation on a given DataFrame based on predictions made by a trained model. The function will adjust the predictions according to specific conditions and return the modified DataFrame.\n\nFunction signature:\n```python\ndef inverse_transform(df: pd.DataFrame, model: str, need_positive: list, trained_model, phi: float, trnd_trans) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant `1` is used to check if the value of `phi` is equal to one.\n\nInput format:\n- `df`: A pandas DataFrame with a datetime index.\n- `model`: A string representing the model type.\n- `need_positive`: A list of model types that require positive values.\n- `trained_model`: A trained model object capable of making predictions.\n- `phi`: A float value used for scaling.\n- `trnd_trans`: An object that provides an inverse transformation method.\n\nOutput format:\n- Returns a pandas DataFrame that is the result of adding the original DataFrame `df` to the adjusted predictions.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\nfrom datetime import datetime\n\n# Test case input\nnum_rows = 10\nstart_date = datetime(2020, 1, 1)\ndate_index = pd.date_range(start=start_date, periods=num_rows, freq='D')\ndf = pd.DataFrame(np.random.randn(num_rows, 3), index=date_index, columns=[\"A\", \"B\", \"C\"])\n\nmodel = 'OLS'\nneed_positive = {'OLS'}\nX = np.arange(num_rows).reshape(-1, 1)  # Numeric index representation\ny = np.random.randn(num_rows, 3)\ntrained_model = LinearRegression()\ntrained_model.fit(X, y)\n\nphi = 1.5\ntrnd_trans = MinMaxScaler()\ntrnd_trans.fit(df)\n\n# Call the function\noutput = inverse_transform(df, model, need_positive, trained_model, phi, trnd_trans)\n```\n\n**Output:**\n```python\n                       A             B             C\n2020-01-01  5.637316e+17  4.696359e+17 -1.485190e+17\n2020-01-02  8.456436e+17  7.044925e+17 -2.227907e+17\n2020-01-03  1.268535e+18  1.056797e+18 -3.342044e+17\n2020-01-04  1.902907e+18  1.585282e+18 -5.013340e+17\n2020-01-05  2.854516e+18  2.378053e+18 -7.520422e+17\n2020-01-06  4.282009e+18  3.567274e+18 -1.128125e+18\n2020-01-07  6.423364e+18  5.351204e+18 -1.692280e+18\n2020-01-08  9.635574e+18  8.027246e+18 -2.538559e+18\n2020-01-09  1.445415e+19  1.204153e+19 -3.808047e+18\n2020-01-10  2.168242e+19  1.806328e+19 -5.712384e+18\n```", "ground_truth_code": "import pandas as pd\n\ndef inverse_transform(df, model, need_positive, trained_model, phi, trnd_trans):\n    x_in = pd.DatetimeIndex(df.index) if not isinstance(df.index, pd.DatetimeIndex) else df.index\n    X = pd.to_numeric(x_in, errors='coerce', downcast='integer').values\n    X = X.reshape((-1, 1))  # Ensure 2D shape\n\n    pred = trained_model.predict(X)\n\n    pred_df = pd.DataFrame(pred, index=df.index, columns=df.columns) if not isinstance(pred, pd.DataFrame) else pred\n\n    if model in need_positive:\n        pred_df = pd.DataFrame(trnd_trans.inverse_transform(pred_df), index=df.index, columns=df.columns)\n\n    if phi != 1:\n        scaling_factors = pd.Series([phi] * df.shape[0], index=df.index).pow(range(df.shape[0]))\n        pred_df = pred_df.mul(scaling_factors, axis=0)  # Ensure this works\n\n    return df + pred_df", "test_script": "import pandas as pd\nimport numpy as np\nimport random\nfrom sklearn.preprocessing import MinMaxScaler\nfrom sklearn.linear_model import LinearRegression\nfrom datetime import datetime, timedelta\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate a random DataFrame with datetime index\n        num_rows = random.randint(5, 100)  # Random number of rows\n        start_date = datetime(2020, 1, 1)\n        date_index = pd.date_range(start=start_date, periods=num_rows, freq='D')\n        df = pd.DataFrame(np.random.randn(num_rows, 3), index=date_index, columns=[\"A\", \"B\", \"C\"])\n\n        # Select a random model type\n        model_types = ['GLS', 'ARIMA', 'OLS', 'RNN', 'Transformer']\n        model = random.choice(model_types)\n\n        # Define need_positive set randomly\n        need_positive = set(random.sample(model_types, k=random.randint(1, len(model_types))))\n\n        # Create a simple trained model\n        X = np.arange(num_rows).reshape(-1, 1)  # Numeric index representation\n        y = np.random.randn(num_rows, 3)\n        trained_model = LinearRegression()\n        trained_model.fit(X, y)\n\n        # Random phi (scaling factor)\n        phi = random.choice([1, 0.5, 1.5, 2, 0.1])\n\n        # Create a transformation object\n        trnd_trans = MinMaxScaler()\n        trnd_trans.fit(df)\n\n        # Append the test case\n        test_cases.append((df, model, need_positive, trained_model, phi, trnd_trans))\n\n    return test_cases"}
{"problem_id": "pandas_37", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes financial data related to trading positions, margins, and prices. The function will perform various calculations to prepare the data for further analysis. The function signature is as follows:\n\n```python\ndef preprocessing(\n        tick_size_prices, margins, df_durations, point_prices,\n        percentage_invested, max_positions, roll_date, df_prices,\n        time_delta_365, df, df_opt_weights, AUM\n):\n```\n\n### Constants Used:\n- `time_delta_365`: This constant represents the number of days in a year, used for time-related calculations.\n\n\n### Input Format:\n- `tick_size_prices`: A numeric array representing tick size prices.\n- `margins`: A numeric array representing margin values.\n- `df_durations`: A DataFrame containing duration values.\n- `point_prices`: A numeric array representing point prices.\n- `percentage_invested`: A float representing the percentage of AUM to be invested.\n- `max_positions`: An integer representing the maximum number of positions.\n- `roll_date`: A datetime object representing the roll date.\n- `df_prices`: A DataFrame containing price values.\n- `time_delta_365`: A constant representing the number of days in a year.\n- `df`: A DataFrame containing the main data with a datetime index.\n- `df_opt_weights`: A DataFrame containing optimal weights for positions.\n- `AUM`: A float representing the total assets under management.\n\n### Output Format:\n- The function returns a DataFrame that includes the original data along with additional computed columns such as `TimeToMaturity`, future durations, margin unit, portfolio notional, positions, portfolio tick size, portfolio price, portfolio tick size price, Z-score, and T-score.\n\n**Input:**\n```python\n{\n    \"tick_size_prices\": [0.05, 0.07, 0.03],\n    \"margins\": [200, 300, 150],\n    \"df_durations\": pd.DataFrame({\n        \"Duration_0\": [100, 90, 80],\n        \"Duration_1\": [120, 110, 100],\n        \"Duration_2\": [130, 140, 150]\n    }, index=pd.date_range(start=\"2020-01-01\", periods=3)),\n    \"point_prices\": [50, 75, 100],\n    \"percentage_invested\": 0.8,\n    \"max_positions\": 5,\n    \"roll_date\": datetime(2021, 1, 1),\n    \"df_prices\": pd.DataFrame({\n        \"Asset_0\": [60, 65, 70],\n        \"Asset_1\": [80, 85, 90],\n        \"Asset_2\": [100, 110, 120]\n    }, index=pd.date_range(start=\"2020-01-01\", periods=3)),\n    \"time_delta_365\": lambda x: x.days / 365,\n    \"df\": pd.DataFrame({\n        \"RollingAvg\": [65, 70, 75],\n        \"RollingStd\": [5, 5, 5]\n    }, index=pd.date_range(start=\"2020-01-01\", periods=3)),\n    \"df_opt_weights\": pd.DataFrame({\n        \"Weight_0\": [0.1, 0.2, 0.3],\n        \"Weight_1\": [0.4, 0.5, 0.6],\n        \"Weight_2\": [0.7, 0.8, 0.9]\n    }, index=pd.date_range(start=\"2020-01-01\", periods=3)),\n    \"AUM\": 5000000\n}\n```\n\n**Output:**\n```python\n            RollingAvg  RollingStd  ...  ZScore       TScore\n2020-01-01          65           5  ...   -13.0 -1203.703704\n2020-01-02          70           5  ...   -14.0 -1014.492754\n2020-01-03          75           5  ...   -15.0  -892.857143\n[3 rows x 16 columns]\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\nfrom datetime import datetime, timedelta\n\n# main code\ndef preprocessing(\n        tick_size_prices, margins, df_durations, point_prices,\n        percentage_invested, max_positions, roll_date, df_prices,\n        time_delta_365, df, df_opt_weights, AUM\n):\n    # Ensure df_durations, df_prices, and df_opt_weights have the same index as df\n    df_durations = df_durations.set_index(df.index)\n    df_prices = df_prices.set_index(df.index)\n    df_opt_weights = df_opt_weights.set_index(df.index)\n\n    # Prevent division by zero by replacing zeros in denominators with a small value\n    margin_prices = np.where(point_prices == 0, np.nan, margins / point_prices)\n    tick_sizes = np.where(point_prices == 0, np.nan, point_prices * tick_size_prices)\n\n    max_init_margin = AUM * percentage_invested\n    position_init_margin = max_init_margin / max_positions\n\n    # Calculate time to maturity\n    df['TimeToMaturity'] = (roll_date - df.index).days / 365\n\n    # Compute future durations\n    future_durations_cols = [f'dfFutureDuration{col[8:]}' for col in df_durations.columns]\n    df_future_durations = df_durations.sub(df['TimeToMaturity'], axis=0)\n    df_future_durations.columns = future_durations_cols\n\n    # Compute margin unit safely\n    margin_unit = df_opt_weights.apply(lambda x: np.inner(np.abs(x), margin_prices), axis=1)\n    margin_unit.replace(0, np.nan, inplace=True)  # Avoid division by zero\n    margin_unit.fillna(method='ffill', inplace=True)  # Fill NaNs forward\n\n    margin_unit.name = 'MarginUnit'\n\n    # Compute portfolio notional value safely\n    port_notional = position_init_margin / margin_unit\n    port_notional.replace([np.inf, -np.inf], np.nan, inplace=True)\n    port_notional.fillna(method='bfill', inplace=True)  # Fill NaNs backward if needed\n    port_notional.name = 'PortNotional'\n\n    # Compute positions safely\n    df_positions = df_opt_weights.multiply(port_notional, axis=0).div(point_prices, axis=1)\n    df_positions.replace([np.inf, -np.inf], np.nan, inplace=True)\n    df_positions.fillna(0, inplace=True)  # Assume zero positions if NaN\n    df_positions.columns = [f'dfPosition{col[8:]}' for col in df_durations.columns]\n\n    # Compute portfolio tick size safely\n    port_tick_size = df_positions.apply(lambda x: np.inner(np.abs(x), tick_sizes), axis=1)\n    port_tick_size.name = 'PortTickSize'\n\n    # Compute portfolio price safely\n    port_price = (df_prices * df_opt_weights).sum(axis=1)\n    port_price.name = 'PortPrice'\n\n    # Compute portfolio tick size price safely\n    port_tick_size_price = port_tick_size / port_notional\n    port_tick_size_price.replace([np.inf, -np.inf], np.nan, inplace=True)\n    port_tick_size_price.fillna(method='ffill', inplace=True)\n    port_tick_size_price.name = 'PortTickSizePrice'\n\n    # Compute Z-score and T-score safely\n    z_score = (port_price - df['RollingAvg']) / df['RollingStd']\n    z_score.replace([np.inf, -np.inf], np.nan, inplace=True)\n    z_score.fillna(0, inplace=True)  # Assume no deviation if NaN\n    z_score.name = 'ZScore'\n\n    t_score = (port_price - df['RollingAvg']) / port_tick_size_price\n    t_score.replace([np.inf, -np.inf], np.nan, inplace=True)\n    t_score.fillna(0, inplace=True)  # Assume no deviation if NaN\n    t_score.name = 'TScore'\n\n    # Concatenate all computed values\n    df = pd.concat(\n        [df, df_future_durations, margin_unit, port_notional, df_positions,\n         port_tick_size, port_price, port_tick_size_price, z_score, t_score], axis=1)\n\n    return df\n\n", "test_script": "import numpy as np\nimport pandas as pd\nfrom datetime import datetime, timedelta\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        N_ASSETS = np.random.randint(5, 20)\n        N_DAYS = 365  # Number of days\n\n        # Generate random parameters\n        tick_size_prices = np.random.uniform(0.01, 0.1, N_ASSETS)\n        margins = np.random.uniform(100, 500, N_ASSETS)\n        point_prices = np.random.uniform(10, 100, N_ASSETS)\n        percentage_invested = np.random.uniform(0.5, 1.0)\n        max_positions = np.random.randint(1, 10)\n        roll_date = datetime.today() + timedelta(days=365)\n        AUM = np.random.uniform(1e6, 1e8)  # Assets Under Management\n\n        # Generate DataFrames with correct index\n        index_dates = pd.date_range(start=\"2020-01-01\", periods=N_DAYS)\n\n        df_durations = pd.DataFrame(\n            np.random.uniform(30, 365, (N_DAYS, N_ASSETS)),\n            columns=[f'Duration_{j}' for j in range(N_ASSETS)], index=index_dates\n        )\n\n        df_prices = pd.DataFrame(\n            np.random.uniform(50, 200, (N_DAYS, N_ASSETS)),\n            columns=[f'Asset_{j}' for j in range(N_ASSETS)], index=index_dates\n        )\n\n        df_opt_weights = pd.DataFrame(\n            np.random.uniform(-1, 1, (N_DAYS, N_ASSETS)),\n            columns=[f'Weight_{j}' for j in range(N_ASSETS)], index=index_dates\n        )\n\n        # DataFrame df\n        df = pd.DataFrame(index=index_dates)\n        df['RollingAvg'] = np.random.uniform(50, 150, N_DAYS)\n        df['RollingStd'] = np.random.uniform(5, 20, N_DAYS)\n\n        test_cases.append((\n            tick_size_prices, margins, df_durations, point_prices,\n            percentage_invested, max_positions, roll_date, df_prices,\n            lambda x: x.days / 365, df, df_opt_weights, AUM\n        ))\n\n    return test_cases"}
{"problem_id": "pandas_38", "library": "pandas", "code_problem": "You are tasked with writing a function that preprocesses a DataFrame containing air quality data for Beijing. The function will convert date and time information into a single datetime column, set the station name, drop unnecessary columns, and compute daily averages of the remaining data.\n\nFunction signature:\n```python\ndef preprocess_data_beijing(df: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant string `'Beijing'` is used to set the station name in the DataFrame.\n\nInput format:\n- The input to the function is a pandas DataFrame `df` that contains the following columns: `'year'`, `'month'`, `'day'`, `'hour'`, and other columns related to air quality measurements.\n\nOutput format:\n- The output of the function is a pandas DataFrame that has a MultiIndex with levels for `'station'` and `'datetime'`, containing the daily average values of the air quality measurements.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'year': [2020, 2020, 2020, 2020],\n    'month': [1, 1, 1, 1],\n    'day': [1, 1, 1, 1],\n    'hour': [0, 1, 2, 3],\n    'No': [1, 2, 3, 4],\n    'cbwd': ['NW', 'NW', 'NW', 'NW'],\n    'Iws': [1.0, 2.0, 3.0, 4.0],\n    'Is': [0.1, 0.2, 0.3, 0.4],\n    'Ir': [0.1, 0.2, 0.3, 0.4],\n    'PM2.5': [10, 20, 30, 40],\n    'PM10': [50, 60, 70, 80],\n    'SO2': [5, 10, 15, 20],\n    'NO2': [25, 30, 35, 40],\n    'CO': [0.5, 0.6, 0.7, 0.8],\n    'O3': [15, 20, 25, 30]\n}\n\ndf = pd.DataFrame(data)\n```\n\n**Output:**\n```python\n                    PM2.5  PM10   SO2   NO2    CO    O3\nstation datetime                                       \nBeijing 2020-01-01   25.0  65.0  12.5  32.5  0.65  22.5\n``` \n", "ground_truth_code": "import pandas as pd\n\n# main code\ndef preprocess_data_beijing(df):\n    df['datetime'] = pd.to_datetime(df[['year', 'month', 'day', 'hour']])\n    df['station'] = 'Beijing'\n    df.set_index(['station', 'datetime'], inplace=True)\n    df.drop(columns=['year', 'month', 'day', 'hour', 'No', 'cbwd', 'Iws', 'Is', 'Ir'], inplace=True)\n    df.sort_index(inplace=True)\n    df = df.groupby(['station', df.index.get_level_values('datetime').floor('d')], group_keys=False).mean()\n    return df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(10, 100)  # Random number of rows per test case\n        data = {\n            'year': np.random.choice([2010, 2015, 2020, 2023], num_rows),\n            'month': np.random.randint(1, 13, num_rows),\n            'day': np.random.randint(1, 29, num_rows),  # Avoids month-end issues\n            'hour': np.random.randint(0, 24, num_rows),\n            'No': np.random.randint(1, 1000, num_rows),\n            'cbwd': np.random.choice(['NW', 'NE', 'SW', 'SE'], num_rows),\n            'Iws': np.random.uniform(0, 10, num_rows),\n            'Is': np.random.uniform(0, 1, num_rows),\n            'Ir': np.random.uniform(0, 1, num_rows),\n            'PM2.5': np.random.uniform(0, 500, num_rows),\n            'PM10': np.random.uniform(0, 500, num_rows),\n            'SO2': np.random.uniform(0, 100, num_rows),\n            'NO2': np.random.uniform(0, 100, num_rows),\n            'CO': np.random.uniform(0, 10, num_rows),\n            'O3': np.random.uniform(0, 100, num_rows)\n        }\n        test_cases.append(pd.DataFrame(data))\n    return test_cases"}
{"problem_id": "pandas_39", "library": "pandas", "code_problem": "You are tasked with analyzing energy consumption data across various sectors in a country. The goal is to compute total energy consumption metrics for residential, services, agriculture, transport, rail, aviation, and navigation sectors based on a given DataFrame containing energy data.\n\nThe main function to implement is:\n\n```python\ndef idees_per_country(df):\n```\n\n### Constants Used:\n- The function uses specific row indices and labels from the DataFrame `df` to extract relevant data for calculations. These indices and labels are hardcoded within the function.\n\n### Input Format:\n- The function takes a single argument `df`, which is a pandas DataFrame containing energy consumption data with specific row labels and indices.\n\n### Output Format:\n- The function returns a pandas DataFrame containing the computed totals for various energy consumption metrics across different sectors. Each row corresponds to a specific metric, and the columns contain the respective values.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Fill the first 86 rows with zeros\nmock_values = np.zeros(86)\n\n# Update values at specific labels needed by the function\nlabel_values = {\n    'Advanced electric heating': 150,\n    'Conventional electric heating': 200,\n    'Space heating': 500,\n    'Water heating': 300,\n    'Cooking': 100,\n    'Energy consumption by fuel - Eurostat structure (ktoe)': 1200,\n    'Hot water': 250,\n    'Catering': 80,\n    'Lighting': 90,\n    'Ventilation': 70,\n    'Specific electricity uses': 60,\n    'Pumping devices (electricity)': 40,\n    'Specific heat uses': 30,\n    'Low enthalpy heat': 20,\n    'Motor drives': 100,\n    'Farming machine drives (diesel oil and liquid biofuels)': 150,\n    'Pumping devices (diesel oil and liquid biofuels)': 80,\n    'Agriculture, forestry and fishing': 400,\n    'by fuel (EUROSTAT DATA)': 600,\n    'Electricity': 300,\n    'Powered two-wheelers (Gasoline)': 200,\n    'Heavy goods vehicles (Diesel oil incl. biofuels)': 500,\n    'by fuel': 700,\n    'Energy consumption (ktoe)': 800,\n}\n\n# Start with a base list of 86 dummy row labels\nrow_labels = [f'Dummy {i}' for i in range(86)]\n\n# Replace specific indices with known labels used in the function\nknown_labels = list(label_values.keys())\nfor i, label in enumerate(known_labels):\n    row_labels[i] = label\n    mock_values[i] = label_values[label]\n\n# Create the DataFrame\ndf = pd.DataFrame(mock_values, index=row_labels, columns=['Value'])\n\n# Run the function\nresult = idees_per_country(df)\nprint(result)\n```\n\n**Output:**\n```\n                                    0\nelectricity residential space     350.0\ntotal residential space          500.0\ntotal residential water          300.0\nelectricity residential water     0.0\ntotal residential cooking         100.0\nelectricity residential cooking    0.0\ntotal residential                1200.0\nelectricity residential           0.0\ndistributed heat residential      0.0\nthermal uses residential          0.0\ntotal services space             500.0\nelectricity services space        350.0\ntotal services water              250.0\nelectricity services water         0.0\ntotal services cooking             80.0\nelectricity services cooking       0.0\ntotal services                   1200.0\nelectricity services              0.0\ndistributed heat services         0.0\nthermal uses services             0.0\ntotal agriculture electricity     250.0\ntotal agriculture heat            50.0\ntotal agriculture machinery       330.0\ntotal agriculture                400.0\ntotal road                       600.0\nelectricity road                 300.0\ntotal two-wheel                  200.0\ntotal passenger cars              0.0\nelectricity passenger cars        0.0\ntotal other road passenger        0.0\nelectricity other road passenger  0.0\ntotal light duty road freight     0.0\nelectricity light duty road freight 0.0\ntotal heavy duty road freight     500.0\npassenger car efficiency          0.0\ntotal rail                        0.0\nelectricity rail                  0.0\ntotal rail passenger              0.0\nelectricity rail passenger        0.0\ntotal rail freight                0.0\nelectricity rail freight          0.0\ntotal aviation passenger          0.0\ntotal aviation freight            0.0\ntotal domestic aviation passenger 0.0\ntotal international aviation passenger 0.0\ntotal domestic aviation freight   0.0\ntotal international aviation freight 0.0\ntotal domestic aviation           0.0\ntotal international aviation      0.0\ntotal domestic navigation         800.0\npassenger cars                   0.0\n```", "ground_truth_code": "import pandas as pd\n\ndef idees_per_country(df):\n    ct_totals = {}\n\n    # Residential sector\n    ct_totals['electricity residential space'] = df.loc[\n        ['Advanced electric heating', 'Conventional electric heating']].sum()\n    ct_totals['total residential space'] = df.loc['Space heating']\n    ct_totals['total residential water'] = df.loc['Water heating']\n    ct_totals['electricity residential water'] = df.iloc[23]\n    ct_totals['total residential cooking'] = df.loc['Cooking']\n    ct_totals['electricity residential cooking'] = df.iloc[30]\n    ct_totals['total residential'] = df.loc['Energy consumption by fuel - Eurostat structure (ktoe)']\n    ct_totals['electricity residential'] = df.iloc[40]\n    ct_totals['distributed heat residential'] = df.iloc[39]\n    ct_totals['thermal uses residential'] = df.iloc[43]\n\n    # Services sector\n    ct_totals['total services space'] = df.loc['Space heating']\n    ct_totals['electricity services space'] = df.loc[\n        ['Advanced electric heating', 'Conventional electric heating']].sum()\n    ct_totals['total services water'] = df.loc['Hot water']\n    ct_totals['electricity services water'] = df.iloc[24]\n    ct_totals['total services cooking'] = df.loc['Catering']\n    ct_totals['electricity services cooking'] = df.iloc[31]\n    ct_totals['total services'] = df.loc['Energy consumption by fuel - Eurostat structure (ktoe)']\n    ct_totals['electricity services'] = df.iloc[43]\n    ct_totals['distributed heat services'] = df.iloc[42]\n    ct_totals['thermal uses services'] = df.iloc[46]\n\n    # Agriculture sector\n    rows_agri_elec = ['Lighting', 'Ventilation', 'Specific electricity uses', 'Pumping devices (electricity)']\n    ct_totals['total agriculture electricity'] = df.loc[rows_agri_elec].sum()\n    rows_agri_heat = ['Specific heat uses', 'Low enthalpy heat']\n    ct_totals['total agriculture heat'] = df.loc[rows_agri_heat].sum()\n    rows_agri_mach = ['Motor drives', 'Farming machine drives (diesel oil and liquid biofuels)',\n                      'Pumping devices (diesel oil and liquid biofuels)']\n    ct_totals['total agriculture machinery'] = df.loc[rows_agri_mach].sum()\n    ct_totals['total agriculture'] = df.loc['Agriculture, forestry and fishing']\n\n    # Transport sector\n    ct_totals['total road'] = df.loc['by fuel (EUROSTAT DATA)']\n    ct_totals['electricity road'] = df.loc['Electricity']\n    ct_totals['total two-wheel'] = df.loc['Powered two-wheelers (Gasoline)']\n    ct_totals['total passenger cars'] = df.iloc[19]\n    ct_totals['electricity passenger cars'] = df.iloc[30]\n    ct_totals['total other road passenger'] = df.iloc[31]\n    ct_totals['electricity other road passenger'] = df.iloc[39]\n    ct_totals['total light duty road freight'] = df.iloc[41]\n    ct_totals['electricity light duty road freight'] = df.iloc[49]\n    ct_totals['total heavy duty road freight'] = df.loc['Heavy goods vehicles (Diesel oil incl. biofuels)']\n    ct_totals['passenger car efficiency'] = df.iloc[61]\n\n    # Rail sector\n    ct_totals['total rail'] = df.loc['by fuel']\n    ct_totals['electricity rail'] = df.loc['Electricity']\n    ct_totals['total rail passenger'] = df.iloc[9]\n    ct_totals['electricity rail passenger'] = df.iloc[[10, 13, 14]].sum()\n    ct_totals['total rail freight'] = df.iloc[15]\n    ct_totals['electricity rail freight'] = df.iloc[17]\n\n    # Aviation sector\n    ct_totals['total aviation passenger'] = df.iloc[4]\n    ct_totals['total aviation freight'] = df.iloc[8]\n    ct_totals['total domestic aviation passenger'] = df.iloc[2]\n    ct_totals['total international aviation passenger'] = df.iloc[[6, 7]].sum()\n    ct_totals['total domestic aviation freight'] = df.iloc[[9, 10]].sum()\n    ct_totals['total international aviation freight'] = df.iloc[11]\n    ct_totals['total domestic aviation'] = ct_totals['total domestic aviation freight'] + ct_totals[\n        'total domestic aviation passenger']\n    ct_totals['total international aviation'] = ct_totals['total international aviation freight'] + ct_totals[\n        'total international aviation passenger']\n\n    # Navigation sector\n    ct_totals['total domestic navigation'] = df.loc['Energy consumption (ktoe)']\n\n    # Road activity\n    ct_totals['passenger cars'] = df.iloc[85]\n\n    return pd.DataFrame(ct_totals)", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    index_labels = [\n        'Advanced electric heating', 'Conventional electric heating', 'Space heating', 'Water heating', 'Cooking',\n        'Energy consumption by fuel - Eurostat structure (ktoe)', 'Hot water', 'Catering',\n        'Lighting', 'Ventilation', 'Specific electricity uses', 'Pumping devices (electricity)',\n        'Specific heat uses', 'Low enthalpy heat', 'Motor drives',\n        'Farming machine drives (diesel oil and liquid biofuels)',\n        'Pumping devices (diesel oil and liquid biofuels)', 'Agriculture, forestry and fishing',\n        'by fuel (EUROSTAT DATA)', 'Electricity', 'Powered two-wheelers (Gasoline)',\n        'Heavy goods vehicles (Diesel oil incl. biofuels)',\n        'by fuel', 'Energy consumption (ktoe)'\n    ]\n    for _ in range(n):\n        # Generate random numerical values with some realistic variations\n        data = np.random.uniform(10, 1000, size=(len(index_labels) + 100))\n        df = pd.DataFrame(data, index=range(len(data)))\n\n        # Assign meaningful index names where needed\n        for i, label in enumerate(index_labels):\n            df.rename(index={i: label}, inplace=True)\n        test_cases.append(df)\n    return test_cases"}
{"problem_id": "pandas_40", "library": "pandas", "code_problem": "You are tasked with implementing a function that iteratively computes the log partition function values based on initial estimates and a set of weighted counts. The function should adjust the log partition function values until they converge within a specified tolerance or until a maximum number of iterations is reached.\n\nFunction Signature:\n```python\ndef generate_lnZ(lnZ_initial, unweighting, weighted_counts, sum_k_Hk_Q, tolerance, max_iterations):\n```\n\nConstants Used:\n- `tolerance`: A threshold value that determines when the iterative process should stop if the changes in log partition function values are sufficiently small.\n- `max_iterations`: The maximum number of iterations allowed for the convergence process.\n\n\nInput Format:\n- `lnZ_initial`: A list or array of initial log partition function values.\n- `unweighting`: A DataFrame containing unweighting values.\n- `weighted_counts`: A DataFrame containing weighted counts.\n- `sum_k_Hk_Q`: A DataFrame containing the sum of weighted counts.\n- `tolerance`: A float representing the convergence threshold.\n- `max_iterations`: An integer representing the maximum number of iterations.\n\nOutput Format:\n- Returns a Pandas Series containing the final log partition function values, indexed by the histograms.\n\n**Input:**\n```python\nlnZ_initial = [0.5, -0.2, 0.1]\nunweighting = pd.DataFrame({\n    0: [0.1, 0.2, 0.3],\n    1: [0.4, 0.5, 0.6],\n    2: [0.7, 0.8, 0.9]\n})\nweighted_counts = pd.DataFrame({\n    0: [10, 20, 30],\n    1: [15, 25, 35],\n    2: [5, 10, 15]\n})\nsum_k_Hk_Q = pd.Series([1.0, 2.0, 3.0])\ntolerance = 1e-5\nmax_iterations = 100\n```\n\n**Output:**\n```python\n0    0.000000\n1    0.908338\n2    1.376344\ndtype: float64\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef compute_difference(lnZ_old, lnZ_new):\n    \"\"\"Compute the sum of absolute differences between old and new log partition functions.\"\"\"\n    return np.sum(np.abs(lnZ_old - lnZ_new))\n\n# main code\ndef generate_lnZ(lnZ_initial, unweighting, weighted_counts, sum_k_Hk_Q, tolerance, max_iterations):\n\n    # Initialize values\n    diff = tolerance + 1  # Ensure loop runs at least once\n    iteration = 0\n    histograms = weighted_counts.columns\n    wc_values = weighted_counts.values\n    unweighting_values = unweighting.values\n    lnZ_old = pd.Series(data=lnZ_initial, index=histograms)\n    Z_new = pd.Series(index=histograms, dtype='float64')\n    sum_k_Hk_byQ = sum_k_Hk_Q.values\n\n    while diff > tolerance and iteration < max_iterations:\n        # Compute old partition function values and their reciprocals\n        Z_old = np.exp(lnZ_old)\n        reciprocal_Z_old = 1.0 / Z_old.values\n\n        # Compute new partition function values\n        for i, hist in enumerate(histograms):\n            w_i = unweighting_values[:, i]\n            numerator_byQ = np.multiply(w_i, sum_k_Hk_byQ)\n            sum_over_Z_byQ = wc_values.dot(reciprocal_Z_old)\n\n            with np.errstate(divide='ignore', invalid='ignore'):\n                addends_k = np.divide(numerator_byQ, sum_over_Z_byQ)\n\n            Z_new[hist] = np.nansum(addends_k)\n\n        # Update log partition function\n        lnZ_new = np.log(Z_new)\n\n        # Compute difference for convergence check\n        diff = compute_difference(lnZ_old, lnZ_new)\n\n        # Normalize and update\n        lnZ_old = lnZ_new - lnZ_new.iloc[0]\n        iteration += 1\n\n    return lnZ_old", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_histograms = np.random.randint(5, 20) # Number of histograms (adjustable)\n        n_data_points = np.random.randint(10, 100)  # Number of data points per histogram (adjustable)\n\n        lnZ_initial = np.random.randn(n_histograms).tolist()\n        unweighting = pd.DataFrame(np.random.rand(n_data_points, n_histograms))\n        weighted_counts = pd.DataFrame(np.random.randint(1, 100, size=(n_data_points, n_histograms)))\n        sum_k_Hk_Q = pd.Series(np.random.rand(n_data_points))\n        tolerance = np.random.uniform(1e-5, 1e-3)\n        max_iterations = np.random.randint(50, 500)\n        test_cases.append((lnZ_initial, unweighting, weighted_counts, sum_k_Hk_Q, tolerance, max_iterations))\n    return test_cases"}
{"problem_id": "pandas_41", "library": "pandas", "code_problem": "You are tasked with creating a function that modifies the layout of a given pandas DataFrame by applying a multi-level index to both its rows and columns based on specified parameters. The function signature is as follows:\n\n```python\ndef apply_viewdf_layout(df, x, y):\n```\n\n### Constants:\n- The constant used in the main code is `axis_labels`, which is defined as `['Question', 'Values']`.\n\n\n### Input and Output Format:\n- **Input**: The function takes in a pandas DataFrame `df`, a string `x`, and a string `y`.\n- **Output**: The function returns a pandas DataFrame with a modified MultiIndex for both rows and columns based on the provided parameters.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    'C0': [10, 20, 30],\n    'C1': [40, 50, 60]\n}\ndf = pd.DataFrame(data, index=['R0', 'R1', 'R2'])\n\n# Parameters\nx = 'X1'\ny = 'Y1'\n\n# Function call\nresult_df = apply_viewdf_layout(df, x, y)\n```\n\n**Output:**\n```python\nQuestion         Y1    \nValues           C0  C1\nQuestion Values        \nX1       R0      10  40\n         R1      20  50\n         R2      30  60\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef apply_viewdf_layout(df, x, y):\n    axis_labels = ['Question', 'Values']\n    df.index = pd.MultiIndex.from_product([[x], df.index], names=axis_labels)\n\n    if y is None:\n        df.columns = pd.MultiIndex.from_product([[x], df.columns], names=axis_labels)\n    elif y == '@':\n        df.columns = pd.MultiIndex.from_product([[x], ['@'] * len(df.columns)], names=axis_labels)  # FIXED\n    else:\n        df.columns = pd.MultiIndex.from_product([[y], df.columns], names=axis_labels)\n\n    return df\n", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe():\n        rows = np.random.randint(5, 100)  # Random number of rows (1 to 10)\n        cols = np.random.randint(5, 20)  # Random number of columns (1 to 10)\n\n        index = [f'R{i}' for i in range(rows)]\n        columns = [f'C{i}' for i in range(cols)]\n\n        data = np.random.randint(0, 100, size=(rows, cols))  # Random integer data\n        df = pd.DataFrame(data, index=index, columns=columns)\n        return df\n\n    test_cases = []\n\n    for _ in range(n):\n        df = generate_random_dataframe()\n        x = np.random.choice(['X1', 'X2', 'X3', 'X4', None])  # Random choice for x\n        y = np.random.choice(['Y1', 'Y2', 'Y3', '@', None])  # Random choice for y\n        test_cases.append((df, x, y))\n\n    return test_cases"}
{"problem_id": "pandas_42", "library": "pandas", "code_problem": "You are tasked with optimizing the memory usage of a pandas DataFrame by converting its columns to more efficient data types. The goal is to reduce the memory footprint of the DataFrame while preserving the integrity of the data. \n\nThe main function to implement is as follows:\n\n```python\ndef reduce_mem_usage(df):\n```\n\n### Constants Used:\n- The function uses constants related to the maximum values of different integer types (e.g., 255 for `uint8`, 65535 for `uint16`, etc.) and the minimum and maximum values for signed integer types (e.g., `np.iinfo(np.int8).min` and `np.iinfo(np.int8).max`).\n\n\n### Input and Output Format:\n- **Input**: A pandas DataFrame `df` containing various columns of numeric data.\n- **Output**: A tuple containing:\n  - The optimized pandas DataFrame.\n  - A list of column names that contained NaN values.\n  - A float representing the percentage reduction in memory usage.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\ndata = {\n    'col_0': [1, 2, 3, 4, 5],\n    'col_1': [1.1, 2.2, 3.3, np.nan, 5.5],\n    'col_2': [np.nan, np.inf, -np.inf, 4, 5],\n    'col_3': [100000, 200000, 300000, 400000, 500000]\n}\n\ndf = pd.DataFrame(data)\n```\n\n**Output:**\n```python\n# After running the reduce_mem_usage function\ndf_reduced, na_list, mem_usg_percentage = reduce_mem_usage(df)\n\ndf_reduced =\n   col_0  col_1  col_2   col_3\n0      1    1.1      0  100000\n1      2    2.2      0  200000\n2      3    3.3      0  300000\n3      4    1.1      4  400000\n4      5    5.5      5  500000\n\nna_list = ['col_1', 'col_2']\n\nmem_usg_percentage = 73.95833333333333\n\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef reduce_mem_usage(df):\n    start_mem_usg = df.memory_usage().sum() / 1024 ** 2\n    NAlist = []\n\n    for col in df.columns:\n        if df[col].dtype != object:  # Ignore object (string) columns\n            IsInt = False\n            mx = df[col].max()\n            mn = df[col].min()\n\n            # Handle NaNs and infinities\n            if not np.isfinite(df[col]).all():  # Check for NaN, inf, -inf\n                NAlist.append(col)\n                df[col] = df[col].replace([np.inf, -np.inf], np.nan)  # Replace infinities with NaN\n                df[col].fillna(mn if np.isfinite(mn) else 0, inplace=True)  # Replace NaNs with the min or 0\n\n            # Check integer type safely\n            if pd.api.types.is_integer_dtype(df[col]):\n                IsInt = True\n            else:\n                asint = df[col].round().astype(np.int64, errors='ignore')  # Ensure rounding before casting\n                result = (df[col] - asint).sum()\n                if abs(result) < 0.01:  # Allow a small floating-point error margin\n                    IsInt = True\n\n            # Convert to optimal type\n            if IsInt:\n                if mn >= 0:\n                    if mx < 255:\n                        df[col] = df[col].astype(np.uint8)\n                    elif mx < 65535:\n                        df[col] = df[col].astype(np.uint16)\n                    elif mx < 4294967295:\n                        df[col] = df[col].astype(np.uint32)\n                    else:\n                        df[col] = df[col].astype(np.uint64)\n                elif mn >= np.iinfo(np.int8).min and mx <= np.iinfo(np.int8).max:\n                    df[col] = df[col].astype(np.int8)\n                elif mn >= np.iinfo(np.int16).min and mx <= np.iinfo(np.int16).max:\n                    df[col] = df[col].astype(np.int16)\n                elif mn >= np.iinfo(np.int32).min and mx <= np.iinfo(np.int32).max:\n                    df[col] = df[col].astype(np.int32)\n                else:\n                    df[col] = df[col].astype(np.int64)\n            else:\n                df[col] = df[col].astype(np.float32)  # Safely cast to float32 instead of float64\n\n    mem_usg = df.memory_usage().sum() / 1024 ** 2\n    mem_usg_percentage = 100 * mem_usg / start_mem_usg\n\n    return df, NAlist, mem_usg_percentage", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(10, 1000)  # Random number of rows\n        num_cols = np.random.randint(1, 10)  # Random number of columns\n\n        data = {}\n        for j in range(num_cols):\n            col_type = np.random.choice([\"int\", \"float\", \"mixed\", \"nan\", \"large\", \"small\"])\n\n            if col_type == \"int\":\n                data[f\"col_{j}\"] = np.random.randint(-100000, 100000, num_rows)\n            elif col_type == \"float\":\n                data[f\"col_{j}\"] = np.random.uniform(-100000, 100000, num_rows)\n            elif col_type == \"mixed\":\n                mixed_data = np.random.choice([np.nan, np.random.randint(-100, 100)], num_rows)\n                data[f\"col_{j}\"] = mixed_data\n            elif col_type == \"nan\":\n                data[f\"col_{j}\"] = [np.nan] * num_rows  # All NaNs\n            elif col_type == \"large\":\n                data[f\"col_{j}\"] = np.random.randint(0, 2 ** 60, num_rows, dtype=np.int64)  # Large integers\n            elif col_type == \"small\":\n                data[f\"col_{j}\"] = np.random.randint(0, 10, num_rows, dtype=np.int8)  # Small integers\n\n        df = pd.DataFrame(data)\n        test_cases.append(df)\n    return test_cases"}
{"problem_id": "pandas_43", "library": "pandas", "code_problem": "You are tasked with creating a function that analyzes the feature importances of a trained XGBoost classifier. The function will take in a classifier object and a list of feature names, and it will return a DataFrame containing the features along with their normalized importance scores.\n\nFunction signature:\n```python\ndef importance_XGB(clf, features):\n```\n\nIn this function, the following constant is used:\n- `None`: This constant is used in the `pd.set_option` calls to configure the display options for pandas DataFrames.\n\nInput format:\n- `clf`: A trained XGBoost classifier object that has a `feature_importances_` attribute.\n- `features`: A list of strings representing the names of the features used in the classifier.\n\nOutput format:\n- A pandas DataFrame with two columns: 'feature' (the name of the feature) and 'importance' (the normalized importance score of the feature). The DataFrame is sorted by the 'importance' column in descending order.\n\nInput:\n```python\n# Mock XGB model with 5 features\nimport numpy as np\nimport xgboost as xgb\n\n# Creating a mock XGB model\nnum_features = 5\nfeature_importances = np.array([0.1, 0.3, 0.2, 0.4, 0.0])  # Example importances\nfeature_importances /= feature_importances.sum()  # Normalize to sum to 1\nfeature_names = [f'feature_{i}' for i in range(num_features)]\n\nclf = xgb.Booster()\nclf.feature_importances_ = feature_importances  # Mocking the attribute\n\n# Calling the function\nimportance_df = importance_XGB(clf, feature_names)\nprint(importance_df)\n```\n\nOutput:\n```\n     feature  importance\n0  feature_3         0.4\n1  feature_1         0.3\n2  feature_2         0.2\n3  feature_0         0.1\n4  feature_4         0.0\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef importance_XGB(clf, features):\n    impdf = []\n    for i in range(len(clf.feature_importances_)):\n        score = clf.feature_importances_[i]\n        ft = features[i]\n        impdf.append({'feature': ft, 'importance': score})\n    impdf = pd.DataFrame(impdf)\n    impdf = impdf.sort_values(by='importance', ascending=False).reset_index(drop=True)\n    impdf['importance'] /= impdf['importance'].sum()\n    pd.set_option('display.max_rows', None)\n    pd.set_option('display.max_columns', None)\n    pd.set_option('display.width', None)\n    pd.set_option('display.max_colwidth', None)\n    return impdf", "test_script": "import numpy as np\nimport xgboost as xgb\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(1, 50)  # Random number of features between 1 and 50\n        feature_importances = np.random.rand(num_features)\n        feature_importances /= feature_importances.sum()  # Normalize to sum to 1\n        feature_names = [f'feature_{i}' for i in range(num_features)]\n\n        # Creating a mock XGB model\n        clf = xgb.Booster()\n        clf.feature_importances_ = feature_importances  # Mocking the attribute\n\n        test_cases.append((clf, feature_names))\n    return test_cases\n"}
{"problem_id": "pandas_44", "library": "pandas", "code_problem": "You are tasked with creating a function that processes a DataFrame to handle missing values in a specified column. The function should check if the column is numeric and whether it contains any missing values. If it does, the function will create a new column indicating the presence of missing values and fill the missing values in the original column with a specified value from a dictionary or the median of the column. The function should also update the dictionary with the value used for filling.\n\nFunction signature:\n```python\ndef fix_missing(df: pd.DataFrame, col: pd.Series, name: str, na_dict: dict) -> dict:\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- A pandas DataFrame `df` containing the data.\n- A pandas Series `col` representing the column to be processed.\n- A string `name` representing the name of the column.\n- A dictionary `na_dict` that may contain previous fill values for columns.\n\nOutput format:\n- The function returns an updated dictionary `na_dict` containing the fill values used for the specified column.\n\n**Input:**\n```python\ndf = pd.DataFrame({\n    'col_0': [10, 20, np.nan, 40, 50],\n    'col_1': [np.nan, 15.5, 25.0, np.nan, 35.0]\n})\ncol = df['col_1'].tolist()\nname = 'col_1'\nna_dict = {'col_1': 20.0}  # Assume we have a predefined filler\n\n# Call the function\nna_dict_output = fix_missing(df, df['col_1'], name, na_dict)\n```\n\n**Output:**\n```python\n{'col_1': 20.0}\n```", "ground_truth_code": "from pandas.api.types import is_numeric_dtype\nimport pandas as pd\n\n# main code\ndef fix_missing(df, col, name, na_dict):\n    if is_numeric_dtype(col):\n        if pd.isnull(col).sum() or name in na_dict:\n            df[name + '_na'] = pd.isnull(col)\n            filler = na_dict[name] if name in na_dict else col.median()\n            df[name] = col.fillna(filler)\n            na_dict[name] = filler\n    return na_dict", "test_script": "import pandas as pd\nimport numpy as np\nfrom pandas.api.types import is_numeric_dtype\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_rows = np.random.randint(5, 100)  # Random number of rows\n        num_cols = np.random.randint(1, 5)  # Random number of columns\n\n        data = {}\n        for i in range(num_cols):\n            col_name = f'col_{i}'\n            col_type = np.random.choice(['int', 'float', 'str'])\n\n            if col_type == 'int':\n                col_data = np.random.randint(0, 100, size=num_rows).astype(float)\n            elif col_type == 'float':\n                col_data = np.random.rand(num_rows) * 100\n            else:\n                col_data = np.random.choice(['A', 'B', 'C', None], size=num_rows)\n\n            # Introduce NaNs randomly\n            mask = np.random.rand(num_rows) < 0.2\n            col_data[mask] = np.nan if col_type != 'str' else None\n            data[col_name] = col_data\n\n        df = pd.DataFrame(data)\n        target_col = np.random.choice(df.columns)\n        na_dict = {target_col: np.random.choice([None, df[target_col].dropna().median()])} if is_numeric_dtype(\n            df[target_col]) else {}\n        col = df[target_col].tolist()\n        name = target_col\n        test_cases.append((df, col, name, na_dict))\n    return test_cases"}
{"problem_id": "pandas_45", "library": "pandas", "code_problem": "You are tasked with merging multiple DataFrames that share common columns, excluding a specific column named 'panel'. The goal is to create a single DataFrame that combines the data from all provided DataFrames based on their common keys.\n\nThe function signature for the main code is:\n```python\ndef _merge_panels(*dfs):\n```\n\nIn this function, the following constant is used:\n- The string `'panel'`, which is excluded from the keys used for merging the DataFrames.\n\nThe input format for the code is:\n- A variable number of DataFrames (pandas DataFrame objects) passed as arguments to the function.\n\nThe output format for the code is:\n- A single pandas DataFrame that contains the merged data from all input DataFrames, excluding the 'panel' column from the keys used for merging.\n\n**Input:**\n```python\n# DataFrame 1\ndf1 = pd.DataFrame({\n    'key0': [1, 2, 3],\n    'val0': [0.1, 0.2, 0.3],\n    'panel': [0, 0, 0]\n})\n\n# DataFrame 2\ndf2 = pd.DataFrame({\n    'key0': [7, 8, 9],\n    'val0': [0.4, 0.5, 0.6],\n    'panel': [1, 1, 1]\n})\n\n# DataFrame 3\ndf3 = pd.DataFrame({\n    'key0': [10, 11, 12],\n    'val1': [0.7, 0.8, 0.9],\n    'panel': [2, 2, 2]\n})\n```\n\n**Output:**\n```python\n   level_0  key0  panel  panel  panel\n0      0.1     1    0.0    NaN    NaN\n1      0.2     2    0.0    NaN    NaN\n2      0.3     3    0.0    NaN    NaN\n3      0.4     7    NaN    1.0    NaN\n4      0.5     8    NaN    1.0    NaN\n5      0.6     9    NaN    1.0    NaN\n6      0.7    10    NaN    NaN    2.0\n7      0.8    11    NaN    NaN    2.0\n8      0.9    12    NaN    NaN    2.0\n```\n\n### Explanation:\n- The input consists of three DataFrames with different keys and values, each associated with a unique panel identifier.\n- The output is the result of merging these DataFrames, where the keys are aligned, and NaN values are filled in where data is missing.", "ground_truth_code": "import pandas as pd\n\n# main code\ndef _merge_panels(*dfs):\n    def get_keys(df):\n        return list(set(df.columns) - {'panel'})\n    dfs = (df.set_index(get_keys(df)) for df in dfs)\n    return pd.concat(dfs, axis=1).reset_index()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(panel_id, num_rows, num_columns):\n        \"\"\"Generates a random DataFrame with a given panel identifier.\"\"\"\n        keys = [f'key{i}' for i in range(random.randint(1, num_columns))]\n        values = [f'val{i}' for i in range(num_columns - len(keys))]\n        columns = keys + values + ['panel']\n\n        data = {\n            col: np.random.randint(0, 100, size=num_rows) if 'key' in col else np.random.rand(num_rows)\n            for col in columns[:-1]\n        }\n        data['panel'] = panel_id  # Ensure panel column exists\n        return pd.DataFrame(data)\n    \"\"\"Generates n test cases with random DataFrames.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        num_dfs = random.randint(2, 10)  # Random number of DataFrames to merge\n        num_rows = random.randint(5, 20)\n        num_columns = random.randint(2, 10)\n        dfs = [generate_random_dataframe(j, num_rows, num_columns) for j in range(num_dfs)]\n        test_cases.append(dfs)\n    return test_cases"}
{"problem_id": "pandas_46", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a DataFrame containing cytoband information and extracts specific details about acentric chromosome regions. The function should filter the DataFrame for rows that represent acentric regions, group the data by chromosome, and then extract the start and end positions of these regions. The function should return a new DataFrame containing the chromosome, start, end, and mid positions of the acentric regions.\n\nFunction signature:\n```python\ndef _origins_from_cytoband(cyb: pd.DataFrame, band_col: str) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The string `'acen'` is used to filter the DataFrame for acentric regions.\n\nInput format:\n- The input to the function is a pandas DataFrame `cyb` with at least two columns: one for chromosome identifiers and one for band types, specified by the `band_col` parameter.\n\nOutput format:\n- The output of the function is a pandas DataFrame containing columns: `chrom`, `start`, `end`, and `mid`, representing the chromosome, start position, end position, and mid position of the acentric regions, respectively.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = [\n    {'chrom': 'chr1', 'start': 1000, 'end': 2000, 'band': 'acen'},\n    {'chrom': 'chr1', 'start': 3000, 'end': 4000, 'band': 'acen'},\n    {'chrom': 'chr1', 'start': 5000, 'end': 6000, 'band': 'other'},\n    {'chrom': 'chr2', 'start': 1500, 'end': 2500, 'band': 'acen'},\n    {'chrom': 'chr2', 'start': 3500, 'end': 4500, 'band': 'acen'},\n    {'chrom': 'chr2', 'start': 5500, 'end': 6500, 'band': 'other'},\n]\n\ncyb = pd.DataFrame(data)\nband_col = 'band'\n```\n\n**Output:**\n```python\noutput = pd.DataFrame({\n    'chrom': ['chr1', 'chr2'],\n    'start': [1000, 1500],\n    'end': [4000, 4500],\n    'mid': [2000, 2500]\n})\n```\n\n### Explanation:\n- For `chr1`, there are two 'acen' regions: (1000, 2000) and (3000, 4000). The output captures the start of the first region, the end of the second region, and the mid-point of the first region.\n- For `chr2`, the same logic applies with its 'acen' regions.", "ground_truth_code": "import pandas as pd\n\n# main code\ndef _origins_from_cytoband(cyb, band_col):\n    cyb = cyb[cyb[band_col] == 'acen']\n    grouped = cyb.groupby('chrom', sort=False)\n    cens = []\n    for chrom, group in grouped:\n        if not len(group) == 2:\n            return pd.DataFrame(cens)\n        acens = group.sort_values('start')\n        cens.append({'chrom': chrom, 'start': acens.iloc[0]['start'], 'end': acens.iloc[1]['end'], 'mid': acens.iloc[0]['end']})\n    return pd.DataFrame.from_records(cens)", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = []\n        num_chromosomes = random.randint(5, 20)  # Number of unique chromosomes\n        for chrom in range(1, num_chromosomes + 1):\n            if random.random() < 0.8:  # 80% chance to have an acen region\n                start1 = random.randint(1000, 50000)\n                end1 = start1 + random.randint(100, 5000)\n                start2 = end1 + random.randint(500, 10000)\n                end2 = start2 + random.randint(100, 5000)\n\n                data.append({'chrom': f'chr{chrom}', 'start': start1, 'end': end1, 'band': 'acen'})\n                data.append({'chrom': f'chr{chrom}', 'start': start2, 'end': end2, 'band': 'acen'})\n\n            # Add some noise (non-acen bands)\n            for _ in range(random.randint(0, 3)):\n                start = random.randint(1000, 60000)\n                end = start + random.randint(100, 5000)\n                data.append({'chrom': f'chr{chrom}', 'start': start, 'end': end, 'band': 'other'})\n\n        test_cases.append((pd.DataFrame(data), 'band'))\n    return test_cases"}
{"problem_id": "pandas_47", "library": "pandas", "code_problem": "You are tasked with implementing a statistical analysis function that computes z-scores and p-values based on Mahalanobis distances for different groups of observations. The function will take a simulation environment object as input, which contains observation data and groups of observations. The goal is to identify how each group deviates from the mean of the observations using Mahalanobis distance, and to calculate the corresponding z-scores and p-values.\n\nFunction signature:\n```python\ndef maha_based_pdc(sim_en):\n```\n\nInput format:\n- The input to the function is an object `sim_en` that contains:\n  - `pst.nnz_obs_groups`: A list of groups of observations.\n  - `pst.observation_data`: A DataFrame containing observation data with columns for observation names, values, and weights.\n\nOutput format:\n- The function returns a tuple containing:\n  - A DataFrame with columns 'z_scores' and 'p_vals', indexed by observation group names.\n  - A DataFrame of Mahalanobis distances for each group.\n\n**Input:**\n```python\n{\n    \"sim_en\": {\n        \"pst\": {\n            \"nnz_obs_groups\": [\"group_0\", \"group_1\"],\n            \"observation_data\": {\n                \"obsnme\": [\"obs_0\", \"obs_1\", \"obs_2\", \"obs_3\", \"obs_4\", \"obs_5\", \"obs_6\", \"obs_7\", \"obs_8\", \"obs_9\", \n                           \"obs_10\", \"obs_11\", \"obs_12\", \"obs_13\", \"obs_14\"],\n                \"obgnme\": [\"group_0\"] * 10 + [\"group_1\"] * 5,\n                \"weight\": [0.5, 0.8, 0.6, 0.9, 0.7, 0.4, 0.3, 0.2, 0.1, 0.6, 0.5, 0.7, 0.8, 0.9, 0.4],\n                \"obsval\": [0.1, 0.2, 0.3, 0.4, 0.5, -0.1, -0.2, -0.3, -0.4, -0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n            }\n        },\n        \"_df\": {\n            \"obs_0\": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4, 0.5],\n            \"obs_1\": [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 1.0, 0.9, 0.8, 0.7, 0.6],\n            \"obs_2\": [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],\n            \"obs_3\": [0.0, -0.1, -0.2, -0.3, -0.4, -0.5, -0.6, -0.7, -0.8, -0.9, 0.0, -0.1, -0.2, -0.3, -0.4],\n            \"obs_4\": [0.2, 0.1, 0.0, -0.1, -0.2, -0.3, -0.4, -0.5, -0.6, -0.7, 0.2, 0.1, 0.0, -0.1, -0.2],\n            \"obs_5\": [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],\n            \"obs_6\": [0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.4, 0.5, 0.6, 0.4, 0.5, 0.6, 0.7, 0.8],\n            \"obs_7\": [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.5, 0.6, 0.7, 0.8, 0.5, 0.6, 0.7, 0.8, 0.9],\n            \"obs_8\": [0.6, 0.7, 0.8, 0.9, 1.0, 0.6, 0.7, 0.8, 0.9, 1.0, 0.6, 0.7, 0.8, 0.9, 1.0],\n            \"obs_9\": [0.7, 0.8, 0.9, 1.0, 0.7, 0.8, 0.9, 1.0, 0.7, 0.8, 0.9, 1.0, 0.7, 0.8, 0.9],\n            \"obs_10\": [0.8, 0.9, 1.0, 0.8, 0.9, 1.0, 0.8, 0.9, 1.0, 0.8, 0.9, 1.0, 0.8, 0.9, 1.0],\n            \"obs_11\": [0.9, 1.0, 0.9, 1.0, 0.9, 1.0, 0.9, 1.0, 0.9, 1.0, 0.9, 1.0, 0.9, 1.0, 0.9],\n            \"obs_12\": [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 1.0, 0.9, 0.8, 0.7, 0.6],\n            \"obs_13\": [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4, 0.5],\n            \"obs_14\": [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7]\n        }\n    }\n}\n```\n\n**Output:**\n```python\n(\n          z_scores    p_vals\nobgnme                      \ngroup_0  17.334107  0.066667\ngroup_1  33.814288  0.066667\n,\n      group_0    group_1\n0    1.265494   0.249163\n1    1.967107   0.619698\n2    2.100125   0.948541\n3    2.926260   1.354530\n4    2.975212   1.525263\n5    3.141617   1.665763\n6    3.924789   1.817638\n7    4.331879   1.948161\n8    5.203368   2.278264\n9    5.713755   2.546444\n10  10.510137   2.943079\n11  11.606688   3.457596\n12  32.440260   3.647630\n13  32.986325   7.351971\n14  59.025319  70.415631\n)\n```\n\n", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef _maha(delta, v, x, z, lower_inv):\n    d_m = np.dot(z.transpose(), z)\n    first = np.dot(np.dot(lower_inv, x), z)\n    first = np.dot(first.transpose(), first)\n    d_m = 1.0 / (delta * v) * (d_m - first)\n    return d_m\n\n# main code\ndef maha_based_pdc(sim_en):\n    groups = sim_en.pst.nnz_obs_groups\n    obs = sim_en.pst.observation_data\n    z_scores = {}\n    dm_xs = {}\n    p_vals = {}\n    for group in groups:\n        nzobs = obs.loc[obs.obgnme == group, :]\n        nzobs = nzobs.loc[nzobs.weight > 0, :].copy()\n        nzsim_en = sim_en._df.loc[:, nzobs.obsnme].copy()\n        ne, nx = nzsim_en.shape\n        ns = ne - 1\n        delta = 2.0 / (float(ns) + 2.0)\n        v = nzsim_en.var(axis=0).mean()\n        x = nzsim_en.values.copy()\n        z = nzobs.obsval.values.copy()\n        dm_x, dm_z = ([], [])\n        for ireal in range(ne):\n            x_s = x.copy()\n            x_s = np.delete(x_s, ireal, axis=0)\n            first = delta * v * ((ns - 1) / (1 - delta) * np.eye(ns))\n            a_s = first + np.dot(x_s, x_s.T)\n            lower = np.linalg.cholesky(a_s)\n            lower = np.linalg.inv(lower)\n            mu_hat = x_s.mean(axis=0)\n            dm_x.append(_maha(delta, v, x_s, x[ireal, :] - mu_hat, lower))\n            dm_z.append(_maha(delta, v, x_s, z - mu_hat, lower))\n        dm_x = np.array(dm_x)\n        dm_z = np.array(dm_z)\n        mu_x = np.median(dm_x)\n        mu_z = np.median(dm_z)\n        mad = np.median(np.abs(dm_x - mu_x))\n        sigma_x = 1.4826 * mad\n        z_score = (mu_z - mu_x) / sigma_x\n        z_scores[group] = z_score\n        dm_xs[group] = dm_x\n        dm_x.sort()\n        p = np.argmin(np.abs(dm_x - mu_z)) / dm_x.shape[0]\n        p_vals[group] = 1 - p\n    z_scores, p_vals, dm_xs = (pd.Series(z_scores), pd.Series(p_vals), pd.DataFrame(dm_xs))\n    df = pd.DataFrame({'z_scores': z_scores, 'p_vals': p_vals})\n    df.index.name = 'obgnme'\n    return (df, pd.DataFrame(dm_xs))", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    class SimEn:\n        def __init__(self, num_groups=5, num_obs_per_group=10, num_simulations=20):\n            self.pst = self._generate_pst(num_groups, num_obs_per_group)\n            self._df = self._generate_simulation_data(num_obs_per_group, num_simulations)\n\n        def _generate_pst(self, num_groups, num_obs_per_group):\n            groups = [f'group_{i}' for i in range(num_groups)]\n            nnz_obs_groups = groups\n            obs_names = [f'obs_{i}' for i in range(num_obs_per_group * num_groups)]\n            obgnme = np.repeat(groups, num_obs_per_group)\n            weight = np.random.uniform(0.1, 1.0, size=len(obs_names))\n            obsval = np.random.normal(0, 1, size=len(obs_names))\n            observation_data = pd.DataFrame({'obsnme': obs_names, 'obgnme': obgnme, 'weight': weight, 'obsval': obsval})\n\n            class PST:\n                def __init__(self, nnz_obs_groups, observation_data):\n                    self.nnz_obs_groups = nnz_obs_groups\n                    self.observation_data = observation_data\n\n            return PST(nnz_obs_groups, observation_data)\n\n        def _generate_simulation_data(self, num_obs, num_simulations):\n            return pd.DataFrame(\n                np.random.normal(0, 1, size=(num_simulations, num_obs * len(self.pst.nnz_obs_groups))),\n                columns=[f'obs_{i}' for i in range(num_obs * len(self.pst.nnz_obs_groups))]\n            )\n\n    test_cases = []\n    for _ in range(n):\n        sim_en = SimEn(num_groups=np.random.randint(2, 10), num_obs_per_group=np.random.randint(5, 15),\n                       num_simulations=np.random.randint(15, 25))\n        test_cases.append(sim_en)\n\n    return test_cases\n"}
{"problem_id": "pandas_48", "library": "pandas", "code_problem": "You are tasked with creating a function that identifies and fixes missing hourly data for a specific month in a given DataFrame. The DataFrame contains a time column with hourly timestamps and potentially other data columns. The function should ensure that each month has the correct number of hours recorded, and if any month is found to be missing hours, it should fill in the missing hours with NaN values.\n\nFunction Signature:\n```python\ndef _missing_hour_fix(df: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- `hrs_per_month`: A dictionary that maps each month (1 to 12) to the expected number of hours in that month.\n\nInput format:\n- A pandas DataFrame `df` with at least one column named 'time' containing hourly timestamps.\n\nOutput format:\n- A pandas DataFrame with the same structure as the input, but with missing hourly data for the identified month filled with NaN values.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'time': [\n        '2023-01-01 00:00:00', '2023-01-01 01:00:00', '2023-01-01 02:00:00',\n        '2023-01-01 03:00:00', '2023-01-01 04:00:00', '2023-01-01 05:00:00',\n        '2023-01-01 06:00:00', '2023-01-01 07:00:00', '2023-01-01 08:00:00',\n        '2023-01-01 09:00:00', '2023-01-01 10:00:00', '2023-01-01 11:00:00',\n        '2023-01-01 12:00:00', '2023-01-01 13:00:00',\n        '2023-01-01 15:00:00', '2023-01-01 16:00:00', '2023-01-01 17:00:00',\n        '2023-01-01 18:00:00', '2023-01-01 19:00:00', '2023-01-01 20:00:00',\n        '2023-01-01 21:00:00', '2023-01-01 22:00:00', '2023-01-01 23:00:00'\n    ],\n    'temperature': [20.5, 21.0, 19.5, 20.0, 22.0, 21.5, 20.5, 19.0, 18.5, 20.0,\n                   21.0, 22.5, 23.0, 21.5, 20.0, 19.5,  17.5, 16.0, 15.5,\n                   14.0, 13.5, 12.0, 11.5],\n    'humidity': [30, 32, 31, 29, 28, 27, 26, 25, 24,  22, 21, 20, 19, 18,\n                 17, 16, 15, 14, 13, 12, 11, 10, 9]\n}\n\ndf_input = pd.DataFrame(data)\n```\n\n**Output:**\n                  time  temperature  humidity\n0  2023-01-01 00:00:00         20.5      30.0\n1  2023-01-01 01:00:00         21.0      32.0\n2  2023-01-01 02:00:00         19.5      31.0\n3  2023-01-01 03:00:00         20.0      29.0\n4  2023-01-01 04:00:00         22.0      28.0\n5  2023-01-01 05:00:00         21.5      27.0\n6  2023-01-01 06:00:00         20.5      26.0\n7  2023-01-01 07:00:00         19.0      25.0\n8  2023-01-01 08:00:00         18.5      24.0\n9  2023-01-01 09:00:00         20.0      22.0\n10 2023-01-01 10:00:00         21.0      21.0\n11 2023-01-01 11:00:00         22.5      20.0\n12 2023-01-01 12:00:00         23.0      19.0\n13 2023-01-01 13:00:00         21.5      18.0\n14 2023-01-01 14:00:00         21.5      18.0\n15 2023-01-01 15:00:00         20.0      17.0\n16 2023-01-01 16:00:00         19.5      16.0\n17 2023-01-01 17:00:00         17.5      15.0\n18 2023-01-01 18:00:00         16.0      14.0\n19 2023-01-01 19:00:00         15.5      13.0\n20 2023-01-01 20:00:00         14.0      12.0\n21 2023-01-01 21:00:00         13.5      11.0\n22 2023-01-01 22:00:00         12.0      10.0\n23 2023-01-01 23:00:00         11.5       9.0\n```\n\nIn this test case, the input DataFrame `df_input` has one hour missing from January 1, 2023 ('2023-01-01 14:00:00'), and the output DataFrame `df_output` is expected to fill in that missing hour with its temperatrue and humidity.", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef _find_missing_val_month(df):\n    hrs_per_month = {1: 744, 2: 672, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720, 12: 744}\n    for m in range(1, 13, 1):\n        df_month = df.loc[df.time.dt.month == m]\n        if len(df_month) != hrs_per_month[m]:\n            return m\n\n# main code\ndef _missing_hour_fix(df):\n    df_missing = df.copy(deep=True)\n    df_missing['time'] = pd.to_datetime(df['time'])\n    miss_month = _find_missing_val_month(df_missing)\n\n    if miss_month is None:  # No missing hour found, return the original DataFrame\n        return df_missing\n\n    df_prior = df_missing.loc[df_missing.time.dt.month < miss_month]\n    df_post = df_missing.loc[df_missing.time.dt.month > miss_month]\n    df_bad = df_missing.loc[df_missing.time.dt.month == miss_month]\n\n    if df_bad.empty:\n        return df_missing  # No data for the missing month, return original df\n\n    df_bad.index = pd.to_datetime(df_bad.time)\n    df_full = pd.DataFrame(pd.date_range(start=df_bad.index.min(), end=df_bad.index.max(), freq='H'))\n\n    missing_cols = [col for col in df_bad.columns]\n    df_full[missing_cols] = np.nan\n    df_full['time'] = df_full[0]\n    df_full.index = pd.to_datetime(df_full.time)\n\n    df_month_fixed = pd.concat([df_bad, df_full])\n    df_month_fixed = df_month_fixed.drop_duplicates(subset=['time'], keep='first')\n    df_month_fixed = df_month_fixed.drop(columns=['time', 0])\n    df_month_fixed = df_month_fixed.sort_values(by='time', ascending=True)\n    df_month_fixed = df_month_fixed.reset_index()\n    df_month_fixed = df_month_fixed.fillna(method='ffill')\n\n    df_fixed = pd.concat([df_prior, df_month_fixed, df_post])\n    return df_fixed", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    hrs_per_month = {1: 744, 2: 672, 3: 744, 4: 720, 5: 744, 6: 720, 7: 744, 8: 744, 9: 720, 10: 744, 11: 720,\n                     12: 744}\n    for _ in range(n):\n        # Choose a random year and month\n        year = random.choice([2020, 2021, 2022, 2023])\n        month = random.randint(1, 12)\n        total_hours = hrs_per_month[month]\n\n        # Generate a complete range of timestamps for the month\n        start_time = pd.Timestamp(f\"{year}-{month:02d}-01 00:00:00\")\n        end_time = start_time + pd.DateOffset(hours=total_hours - 1)\n        time_series = pd.date_range(start=start_time, end=end_time, freq='H')\n\n        # Remove a random hour from the month\n        missing_idx = random.randint(0, total_hours - 1)\n        time_series = time_series.delete(missing_idx)\n\n        # Create a DataFrame with additional random data columns\n        data = {\n            'time': time_series,\n            'temperature': np.random.uniform(-10, 35, len(time_series)),  # Random temperature data\n            'humidity': np.random.uniform(20, 90, len(time_series)),  # Random humidity data\n        }\n        df = pd.DataFrame(data)\n        test_cases.append(df)\n    return test_cases\n"}
{"problem_id": "pandas_49", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a dataset to analyze the relationship between a specified column and a target variable. The function will categorize the data based on predefined groups and calculate various statistics, including Weight of Evidence (WoE) and Information Value (IV). The function will also handle missing values and special codes in the dataset.\n\nFunction Signature:\n```python\ndef charvarexist(inputdata: pd.DataFrame, col: str, target: str, group_info_old: pd.DataFrame, data_only: bool) -> tuple:\n```\n\nConstants Used:\n- The constant used in the main code is `1`, which is used in the calculation of WoE to ensure that the denominator does not become zero.\n\n\nInput Format:\n- `inputdata`: A pandas DataFrame containing the dataset to be analyzed.\n- `col`: A string representing the name of the column to analyze.\n- `target`: A string representing the name of the target variable.\n- `group_info_old`: A pandas DataFrame containing group information, including 'f_group', 'value', 'woe', and 'miss_s'.\n- `data_only`: A boolean indicating whether to return only the data with WoE and group information.\n\nOutput Format:\n- The function returns a tuple containing:\n  - A DataFrame with group statistics and descriptive statistics.\n  - A DataFrame with the specified column, WoE, and group information, excluding the original WoE and group columns.\n\n**Input:**\n```python\ninputdata = pd.DataFrame({\n    'feature_1': ['A', 'B', 'C', 'A', np.nan, 'D', 'E', 'B', 'C', np.nan],\n    'target_1': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0]\n})\ncol = 'feature_1'\ntarget = 'target_1'\ngroup_info_old = pd.DataFrame({\n    'f_group': ['G1', 'G2', 'G3', 'G4', 'G5'],\n    'woe': [0.5, -0.2, 0.3, 0.1, -0.4],\n    'value': ['A', 'B', 'C', 'D', 'E'],\n    'miss_s': [False, False, False, False, False]\n})\ndata_only = True\n```\n\n**Output:**\n```python\n  feature_1  woe_feature_1 f_group_feature_1\n0         A            0.5                G1\n1         B           -0.2                G2\n2         C            0.3                G3\n3         A            0.5                G1\n4         D            0.1                G4\n5         E           -0.4                G5\n6         B           -0.2                G2\n7         C            0.3                G3\n8       NaN            0.5                G1\n9       NaN            0.5                G1\n```", "ground_truth_code": "import pandas as pd\nimport math\n\n# main code\ndef charvarexist(inputdata, col, target, group_info_old, data_only):\n    woe_data = group_info_old[['f_group', 'woe']]\n    specialcode_list = list(group_info_old[group_info_old['miss_s'] == True]['value'])\n    inputdata_nomiss = inputdata[inputdata[col].isnull() == False]\n    group_info_num = group_info_old[group_info_old['miss_s'] == False]\n    f_group_map = group_info_num[['f_group', 'value']].drop_duplicates()\n    f_group_map = f_group_map.rename({'value': col}, axis=1)\n    f_group_data = pd.merge(inputdata_nomiss, f_group_map, how='left', on=col)\n    f_group_data['value'] = f_group_data[col]\n    f_group_data['miss'] = False\n    if specialcode_list != []:\n        for values in specialcode_list:\n            if values == 'miss':\n                temp = inputdata[inputdata[col].isnull()].copy()\n            else:\n                temp = inputdata[inputdata[col] == values].copy()\n            temp['f_group'] = group_info_old[group_info_old['value'] == values]['f_group'].unique()[0]\n            temp['miss'] = True\n            temp['value'] = values\n            f_group_data = f_group_data._append(temp)\n    if (len(group_info_old[group_info_old['value'] == 'miss']) == 0) & (len(inputdata[inputdata[col].isnull()]) > 0):\n        temp = inputdata[inputdata[col].isnull()].copy()\n        temp['f_group'] = group_info_old[group_info_old['woe'] == group_info_old['woe'].max()]['f_group'].values[0]\n        temp['miss'] = True\n        temp['value'] = 'miss'\n        f_group_data = f_group_data._append(temp)\n    if len(f_group_data[f_group_data['f_group'].isnull()]) > 0:\n        temp = f_group_data[f_group_data['f_group'].isnull()].copy()\n        temp['f_group'] = group_info_old[group_info_old['woe'] == group_info_old['woe'].max()]['f_group'].values[0]\n        temp['miss'] = False\n        temp['value'] = temp[col]\n        f_group_data = f_group_data[f_group_data['f_group'].isnull() == False].copy()\n        f_group_data = f_group_data._append(temp)\n    if data_only == True:\n        outputdata = pd.merge(f_group_data, woe_data, how='left', on='f_group')\n        outputdata['woe_%s' % col] = outputdata['woe']\n        outputdata['f_group_%s' % col] = outputdata['f_group']\n        outputdata = outputdata[[col, 'woe_%s' % col, 'f_group_%s' % col]]\n        return outputdata\n    tt1 = f_group_data.groupby(['f_group']).agg({target: ['mean', 'count', 'sum'], 'miss': 'max'}).reset_index()\n    tt = f_group_data.groupby(['f_group', 'value']).agg({target: ['mean', 'count', 'sum'], 'miss': 'max'}).reset_index()\n    s_data = pd.DataFrame()\n    s_data['s_Bad_rate'] = tt[target]['mean']\n    s_data['s_N_obs'] = tt[target]['count']\n    s_data['s_N_bad'] = tt[target]['sum']\n    s_data['miss_s'] = tt['miss']['max']\n    s_data['f_group'] = tt['f_group']\n    s_data['value'] = tt['value']\n    s_data['variable_name'] = '%s' % col\n    f_data = pd.DataFrame()\n    f_data['f_group'] = tt1['f_group']\n    f_data['f_Bad_rate'] = tt1[target]['mean']\n    f_data['f_N_obs'] = tt1[target]['count']\n    f_data['f_N_bad'] = tt1[target]['sum']\n    f_data['miss_f'] = tt1['miss']['max']\n    f_data['variable_name'] = '%s' % col\n    total_bad = f_data['f_N_bad'].sum()\n    total_good = f_data['f_N_obs'].sum() - f_data['f_N_bad'].sum()\n    f_data['woe'] = f_data.apply(lambda x: math.log(max(1, x['f_N_bad']) / total_bad / (max(1, x['f_N_obs'] - x['f_N_bad']) / total_good)), axis=1)\n    f_data['iv_g'] = (f_data['f_N_bad'] / total_bad - (f_data['f_N_obs'] - f_data['f_N_bad']) / total_good) * f_data['woe']\n    iv = f_data['iv_g'].sum()\n    f_data['iv'] = iv\n    dd = inputdata[col].describe()\n    ds = pd.DataFrame(dd).T.reset_index().rename({'index': 'variable_name'}, axis=1)\n    ds['miss_count'] = inputdata[col].isnull().sum()\n    group_info = pd.merge(s_data, f_data, how='left', on=['variable_name', 'f_group'])\n    group_info = pd.merge(group_info, ds, how='left', on=['variable_name'])\n    outputdata = pd.merge(f_group_data[[col, 'f_group']], f_data[['f_group', 'woe']], how='left', on=['f_group'])\n    outputdata['woe_%s' % col] = outputdata['woe']\n    outputdata['f_group_%s' % col] = outputdata['f_group']\n    return (group_info, outputdata.drop(columns=['woe', 'f_group']))", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(5, 100)  # Varying row count\n        # Generate random column name\n        col_name = \"feature_\" + str(random.randint(1, 100))\n        # Generate random target name\n        target_name = \"target_\" + str(random.randint(1, 10))\n        col_values = np.random.choice(['A', 'B', 'C', 'D', 'E', np.nan], num_rows, p=[0.2, 0.2, 0.2, 0.15, 0.15, 0.1])\n        target_values = np.random.randint(0, 2, num_rows)  # Binary target\n\n        inputdata = pd.DataFrame({\n            col_name: col_values,\n            target_name: target_values\n        })\n        group_info_old = pd.DataFrame({\n            'f_group': ['G1', 'G2', 'G3', 'G4', 'G5'],\n            'woe': np.random.randn(5),\n            'value': ['A', 'B', 'C', 'D', 'E'],\n            'miss_s': [False, False, False, False, False]\n        })\n        data_only = random.choice([True, False])\n\n        test_cases.append((inputdata, col_name, target_name, group_info_old, data_only))\n    return test_cases"}
{"problem_id": "pandas_50", "library": "pandas", "code_problem": "You are tasked with creating a function that performs subsampling on a given DataFrame. The function should allow for both random sampling based on a specified fraction of the DataFrame or a specified number of samples. Additionally, the function should have the capability to rename columns in the resulting DataFrame based on a provided mapping.\n\nFunction Signature:\n```python\ndef subsample_profiles(df: pd.DataFrame, rename_col: bool, subsampling_random_state: Optional[int], subsample_n: int, subsample_frac: float, linking_col_rename: Optional[dict]) -> pd.DataFrame:\n```\n\nConstants used in the main code:\n- A random integer between 0 and 10000 is generated if `subsampling_random_state` is `None`.\n\n\nInput Format:\n- `df`: A pandas DataFrame.\n- `rename_col`: A boolean value.\n- `subsampling_random_state`: An optional integer.\n- `subsample_n`: An integer.\n- `subsample_frac`: A float.\n- `linking_col_rename`: An optional dictionary.\n\nOutput Format:\n- Returns a pandas DataFrame that contains the sampled data, potentially with renamed columns.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a sample DataFrame\ndata = {\n    'col_0': [1, 2, 3, 4, 5],\n    'col_1': [10, 20, 30, 40, 50],\n    'col_2': [100, 200, 300, 400, 500]\n}\ndf = pd.DataFrame(data)\n\nrename_col = True\nsubsampling_random_state = 42\nsubsample_n = None\nsubsample_frac = 0.4\nlinking_col_rename = {'col_0': 'new_col_0', 'col_1': 'new_col_1'}\n\n# Calling the function\noutput_df = subsample_profiles(df, rename_col, subsampling_random_state, subsample_n, subsample_frac, linking_col_rename)\n```\n\n**Output:**\n```python\n   new_col_0  new_col_1  col_2\n1          2         20    200\n4          5         50    500\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n\ndef subsample_profiles(df, rename_col, subsampling_random_state, subsample_n, subsample_frac, linking_col_rename):\n\n    if subsampling_random_state is None:\n        random_state = np.random.randint(0, 10000)\n        subsampling_random_state = random_state\n\n    # Perform sampling based on the given fraction or count\n    if subsample_frac == 1:\n        output_df = df.sample(n=subsample_n, replace=True, random_state=subsampling_random_state)\n    else:\n        output_df = df.sample(frac=subsample_frac, random_state=subsampling_random_state)\n\n    # Rename columns if required\n    if rename_col and isinstance(linking_col_rename, dict):\n        output_df = output_df.rename(columns=linking_col_rename)\n\n    return output_df", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe():\n        num_rows = np.random.randint(10, 100)  # Random number of rows between 10 and 100\n        num_cols = np.random.randint(3, 10)  # Random number of columns between 3 and 10\n\n        columns = [f'col_{i}' for i in range(num_cols)]\n        data = {col: np.random.randint(0, 100, size=num_rows) for col in columns}\n\n        return pd.DataFrame(data)\n\n    test_cases = []\n\n    for _ in range(n):\n        df = generate_random_dataframe()\n        rename_col = np.random.choice([True, False])\n        subsampling_random_state = np.random.choice([None, np.random.randint(0, 10000)])\n        subsample_n = np.random.randint(1, len(df)) if np.random.rand() > 0.5 else None\n        subsample_frac = np.random.uniform(0.1, 1.0) if subsample_n is None else 1\n        linking_col_rename = {col: f'new_{col}' for col in\n                              df.columns[:np.random.randint(1, len(df.columns))]} if rename_col else None\n        test_cases.append((df, rename_col, subsampling_random_state, subsample_n, subsample_frac, linking_col_rename))\n\n    return test_cases"}
{"problem_id": "pandas_51", "library": "pandas", "code_problem": "You are tasked with creating a function that formats a Pandas DataFrame into a string representation suitable for console output. The function should take into account various display options set in Pandas and ensure that the output is neatly formatted according to the specified parameters.\n\nFunction signature:\n```python\ndef _clean_renderable_dataframe(output: pd.DataFrame, _num_rows: int, _num_columns: int) -> str:\n```\n\nConstant used in the main code:\n- The function utilizes several constants from the Pandas library, specifically the display options for maximum rows, minimum rows, maximum columns, maximum column width, and whether to show dimensions.\n\n\nInput format:\n- The function takes in a Pandas DataFrame `output`, an integer `_num_rows` representing the number of rows in the DataFrame, and an integer `_num_columns` representing the number of columns in the DataFrame.\n\nOutput format:\n- The function returns a string that represents the formatted DataFrame, including the specified number of rows and columns at the end if applicable.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a sample DataFrame\ndata = {\n    'col_0': [1, 2, 3],\n    'col_1': [4.5, 5.5, 6.5],\n    'col_2': ['apple', 'banana', 'cherry'],\n    'col_3': [True, False, True]\n}\ndf = pd.DataFrame(data)\n_num_rows = 3\n_num_columns = 4\n```\n\n**Output:**\n```\n   col_0  col_1   col_2  col_3\n0      1    4.5   apple   True\n1      2    5.5  banana  False\n2      3    6.5  cherry   True\n```\n\nThis example demonstrates a DataFrame with 3 rows and 4 columns, showcasing different data types, and the expected output format after processing through the `_clean_renderable_dataframe` function.", "ground_truth_code": "import pandas as pd\nfrom pandas.io.formats import console\n\n# main code\ndef _clean_renderable_dataframe(output, _num_rows, _num_columns):\n\n    max_rows = pd.get_option('display.max_rows')\n    min_rows = pd.get_option('display.min_rows')\n    max_cols = pd.get_option('display.max_columns')\n    max_colwidth = pd.get_option('display.max_colwidth')\n    show_dimensions = pd.get_option('display.show_dimensions')\n    if pd.get_option('display.expand_frame_repr'):\n        width, _ = console.get_console_size()\n    else:\n        width = None\n    output = output.to_string(max_rows=max_rows, min_rows=min_rows, max_cols=max_cols, line_width=width, max_colwidth=max_colwidth, show_dimensions=show_dimensions)\n    lines = output.split('\\n')\n    if lines[-1].startswith('['):\n        lines = lines[:-1]\n        lines.append('[%d rows x %d columns]' % (_num_rows, _num_columns))\n    return '\\n'.join(lines)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        \"\"\"Generate a random DataFrame with varying sizes and data types.\"\"\"\n        num_rows = random.randint(1, 500)  # Random number of rows\n        num_cols = random.randint(1, 20)  # Random number of columns\n\n        column_types = [int, float, str, bool, None]\n\n        data = {}\n        for i in range(num_cols):\n            col_type = random.choice(column_types)\n            if col_type == int:\n                data[f'col_{i}'] = np.random.randint(0, 100, size=num_rows)\n            elif col_type == float:\n                data[f'col_{i}'] = np.random.rand(num_rows) * 100\n            elif col_type == str:\n                data[f'col_{i}'] = [random.choice(['apple', 'banana', 'cherry', 'date']) for _ in range(num_rows)]\n            elif col_type == bool:\n                data[f'col_{i}'] = np.random.choice([True, False], size=num_rows)\n            elif col_type is None:\n                data[f'col_{i}'] = [None] * num_rows\n\n        df = pd.DataFrame(data)\n        test_cases.append((df, num_rows, num_cols))\n    return test_cases"}
{"problem_id": "pandas_52", "library": "pandas", "code_problem": "You are tasked with creating a function that adds NA (Not Available) indicators to a given DataFrame while handling missing values based on specified replacement values. The function should ensure that certain conditions are met before modifying the DataFrame.\n\nFunction Signature:\n```python\ndef add_na_indicator(df: pd.DataFrame, replace_val_obj: str, replace_val_num: float) -> pd.DataFrame:\n```\n\nConstants:\n- The constant used in the main code is the string prefix `'_is_na_'`, which is used to create the names of the NA indicator columns.\n\n\nInput Format:\n- `df`: A pandas DataFrame that may contain missing values.\n- `replace_val_obj`: A string value used to replace missing values in object or string columns.\n- `replace_val_num`: A numeric value used to replace missing values in numeric columns.\n\nOutput Format:\n- The function returns a pandas DataFrame that includes the original data with NA indicators added for columns that had missing values.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test DataFrame\ndata = {\n    'col_0': [1, 2, np.nan, 4, 5],\n    'col_1': ['A', 'B', None, 'D', 'E'],\n    'col_2': pd.Series([None, 'X', 'Y', 'Z', 'W'], dtype=\"category\")\n}\ndf = pd.DataFrame(data)\n\n# Replace values\nreplace_val_obj = \"MISSING\"\nreplace_val_num = -999\n\n# Function call\nresult_df = add_na_indicator(df, replace_val_obj, replace_val_num)\n```\n\n**Output:**\n```python\n# Resulting DataFrame\nresult_df = pd.DataFrame({\n    'col_0': [1., 2., -999., 4., 5.],\n    'col_1': ['A', 'B', 'MISSING', 'D', 'E'],\n    'col_2': pd.Series(['MISSING', 'X', 'Y', 'Z', 'W'], dtype=\"category\"),\n    '_is_na_col_0': [False, False, True, False, False],\n    '_is_na_col_1': [False, False, True, False, False],\n    '_is_na_col_2': [True, False, False, False, False]\n})\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef add_na_indicator(df, replace_val_obj, replace_val_num):\n    na = df.isnull()\n    na_cols = list(df.columns[na.any(axis='index')])\n    na_indicators = na.loc[:, na_cols]\n    na_indicators.columns = ('_is_na_' + c for c in na_indicators.columns)\n    categorical_cols = list(df.columns[df.dtypes == 'category'])\n    non_numeric_cols = list(df.columns[(df.dtypes == 'object') | (df.dtypes == 'string')])\n    for c in list(na_cols):\n        if replace_val_obj in set(df[c]):\n            raise Exception(f\"Can't add NA indicator to columns containing NAs and the value '{replace_val_obj}', i.e. column: {c}\")\n        if c in categorical_cols:\n            df[c] = df[c].cat.add_categories(replace_val_obj).fillna(replace_val_obj)\n        elif c in non_numeric_cols:\n            df[c] = df[c].fillna(replace_val_obj)\n        else:\n            df[c] = df[c].fillna(replace_val_num)\n    return pd.concat((df, na_indicators), axis=1)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_rows = random.randint(5, 100)\n        num_cols = random.randint(2, 10)\n\n        columns = [f\"col_{i}\" for i in range(num_cols)]\n\n        data = {}\n        for col in columns:\n            col_type = random.choice([\"int\", \"float\", \"category\", \"string\", \"object\"])\n\n            if col_type == \"int\":\n                values = np.random.randint(0, 100, size=num_rows).astype(float)\n            elif col_type == \"float\":\n                values = np.random.randn(num_rows) * 100\n            elif col_type == \"category\":\n                values = pd.Series(np.random.choice([\"A\", \"B\", \"C\", None], size=num_rows, p=[0.3, 0.3, 0.3, 0.1]),\n                                   dtype=\"category\")\n            elif col_type in [\"string\", \"object\"]:\n                values = np.random.choice([\"X\", \"Y\", \"Z\", None], size=num_rows, p=[0.3, 0.3, 0.3, 0.1])\n\n            # Introduce missing values randomly\n            mask = np.random.rand(num_rows) < 0.1  # 10% missing values\n            if col_type in [\"int\", \"float\"]:\n                values[mask] = np.nan\n            else:\n                values = pd.Series(values)\n                values[mask] = None\n\n            data[col] = values\n\n        df = pd.DataFrame(data)\n        replace_val_obj = random.choice([\"MISSING\", \"UNKNOWN\", \"NULL_VAL\"])\n        replace_val_num = random.choice([-999, -1e6, -12345])\n\n        test_cases.append((df, replace_val_obj, replace_val_num))\n    return test_cases"}
{"problem_id": "pandas_53", "library": "pandas", "code_problem": "You are tasked with creating a function that generates a series of event windows based on a given time column in a DataFrame. The function will create new DataFrames that represent events occurring before and after the original events, based on a specified time delta. \n\nFunction signature:\n```python\ndef add_event_window(df, time_col, label_col, time_delta, pre_num, post_num, events_name):\n```\n\n### Constants:\n- `pd_time_delta`: This constant is derived from the `time_delta` parameter and is used to calculate the time adjustments for the event windows.\n\n\n### Input Format:\n- `df`: A pandas DataFrame containing at least two columns specified by `time_col` and `label_col`.\n- `time_col`: A string representing the name of the column in `df` that contains time information.\n- `label_col`: A string representing the name of the column in `df` that contains event labels.\n- `time_delta`: A string representing the time duration to be used for creating event windows (e.g., '1H' for one hour).\n- `pre_num`: An integer representing the number of pre-event windows to create.\n- `post_num`: An integer representing the number of post-event windows to create.\n- `events_name`: A string that will be used as a prefix for the keys in the returned dictionary.\n\n### Output Format:\n- The function returns a dictionary where:\n  - Each key is a string representing the event window (e.g., 'event_name_minus_1', 'event_name_plus_1').\n  - Each value is a pandas DataFrame containing the adjusted time and corresponding labels for that event window.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    \"timestamp\": [\n        pd.Timestamp(\"2025-01-01 00:00:00\"),\n        pd.Timestamp(\"2025-01-01 00:01:00\"),\n        pd.Timestamp(\"2025-01-01 00:02:00\")\n    ],\n    \"label\": [0, 1, 0]\n}\ndf = pd.DataFrame(data)\n\ntime_col = \"timestamp\"\nlabel_col = \"label\"\ntime_delta = \"5s\"  # 5 seconds\npre_num = 2\npost_num = 2\nevents_name = \"event_42\"\n\n# Call the function\noutput = add_event_window(df, time_col, label_col, time_delta, pre_num, post_num, events_name)\n```\n\n**Output:**\n```python\n{\n    'event_42_minus_1': pd.DataFrame({\n        'timestamp': [\n            pd.Timestamp(\"2024-12-31 23:59:55\"),\n            pd.Timestamp(\"2025-01-01 00:00:55\"),\n            pd.Timestamp(\"2025-01-01 00:01:55\")\n        ],\n        'label': [0, 1, 0]\n    }),\n    'event_42_minus_2': pd.DataFrame({\n        'timestamp': [\n            pd.Timestamp(\"2024-12-31 23:59:50\"),\n            pd.Timestamp(\"2025-01-01 00:00:50\"),\n            pd.Timestamp(\"2025-01-01 00:01:50\")\n        ],\n        'label': [0, 1, 0]\n    }),\n    'event_42_plus_1': pd.DataFrame({\n        'timestamp': [\n            pd.Timestamp(\"2025-01-01 00:00:05\"),\n            pd.Timestamp(\"2025-01-01 00:01:05\"),\n            pd.Timestamp(\"2025-01-01 00:02:05\")\n        ],\n        'label': [0, 1, 0]\n    }),\n    'event_42_plus_2': pd.DataFrame({\n        'timestamp': [\n            pd.Timestamp(\"2025-01-01 00:00:10\"),\n            pd.Timestamp(\"2025-01-01 00:01:10\"),\n            pd.Timestamp(\"2025-01-01 00:02:10\")\n        ],\n        'label': [0, 1, 0]\n    })\n}\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef add_event_window(df, time_col, label_col, time_delta, pre_num, post_num, events_name):\n    df_dict = {}\n    pd_time_delta = pd.to_timedelta(time_delta)\n    for num in range(pre_num):\n        df0 = pd.DataFrame()\n        df0[time_col] = df[time_col] - (num + 1) * pd_time_delta\n        df0[label_col] = df[label_col]\n        df_dict[events_name + '_minus_' + f'{num + 1:.0f}'] = df0\n    for num in range(post_num):\n        df0 = pd.DataFrame()\n        df0[time_col] = df[time_col] + (num + 1) * pd_time_delta\n        df0[label_col] = df[label_col]\n        df_dict[events_name + '_plus_' + f'{num + 1:.0f}'] = df0\n    return df_dict", "test_script": "\nimport pandas as pd\nimport random\nfrom datetime import datetime, timedelta\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(rows):\n        \"\"\"Generate a random DataFrame with a datetime column and a label column.\"\"\"\n        start_time = datetime(2025, 1, 1)\n        time_deltas = [timedelta(minutes=random.randint(0, 1000)) for _ in range(rows)]\n        time_col_values = [start_time + delta for delta in time_deltas]\n        label_col_values = [random.choice([0, 1]) for _ in range(rows)]\n\n        return pd.DataFrame({\n            \"timestamp\": time_col_values,\n            \"label\": label_col_values\n        })\n\n    test_cases = []\n\n    for _ in range(n):\n        df = generate_random_dataframe(rows=random.randint(5, 50))\n        time_col = \"timestamp\"\n        label_col = \"label\"\n        time_delta = f\"{random.randint(1, 10)}s\"  # Random seconds, minutes, or hours\n        pre_num = random.randint(0, 5)\n        post_num = random.randint(0, 5)\n        events_name = f\"event_{random.randint(1, 100)}\"\n\n        test_cases.append((df, time_col, label_col, time_delta, pre_num, post_num, events_name))\n\n    return test_cases"}
{"problem_id": "pandas_54", "library": "pandas", "code_problem": "You are tasked with creating a function that filters out rows from a given DataFrame based on the values present in one or more other DataFrames. The function should take two parameters: the main DataFrame from which rows will be filtered and one or more DataFrames that contain the values to be excluded.\n\nFunction signature:\n```python\ndef filter_out_rows(df1, other_dfs):\n```\n\nIn the main code, the constant used is `orient='list'`, which is a parameter for the `to_dict` method of a DataFrame.\n\nInput format:\n- The function takes two parameters:\n  - `df1`: A pandas DataFrame from which rows will be filtered.\n  - `other_dfs`: A single pandas DataFrame or a list of pandas DataFrames containing values to be excluded from `df1`.\n\nOutput format:\n- The function returns a pandas DataFrame that contains the rows from `df1` that do not match any rows in the provided `other_dfs`.\n\n**Input:**\n```python\ndf1 = pd.DataFrame({\n    'col0': [1, 2, 3, 4, 5],\n    'col1': ['apple', 'banana', 'cherry', 'date', 'elderberry']\n})\n\nother_dfs = [\n    pd.DataFrame({\n        'col0': [2, 4],\n        'col1': ['banana', 'date']\n    }),\n    pd.DataFrame({\n        'col0': [5],\n        'col1': ['elderberry']\n    })\n]\n```\n\n**Output:**\n```python\nfiltered_df = pd.DataFrame({\n    'col0': [1, 3],\n    'col1': ['apple', 'cherry']\n})\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef filter_out_rows(df1, other_dfs):\n    filtered_df = df1\n    if not isinstance(other_dfs, list):\n        other_dfs = [other_dfs]\n    for other_df in other_dfs:\n        mask = df1.isin(other_df.to_dict(orient='list')).all(axis=1)\n        filtered_df = filtered_df[~mask]\n    filtered_df.reset_index(drop=True, inplace=True)\n    return filtered_df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(rows, cols, dtype):\n        if dtype == 'int':\n            data = np.random.randint(0, 100, size=(rows, cols))\n        elif dtype == 'float':\n            data = np.random.rand(rows, cols) * 100\n        elif dtype == 'str':\n            data = np.random.choice(['apple', 'banana', 'cherry', 'date', 'elderberry'], size=(rows, cols))\n        else:\n            raise ValueError(\"Unsupported dtype\")\n        return pd.DataFrame(data, columns=[f'col{i}' for i in range(cols)])\n\n    test_cases = []\n    for _ in range(n):\n        rows1 = np.random.randint(5, 20)\n        cols1 = np.random.randint(2, 10)\n        dtype = np.random.choice(['int', 'float', 'str'])\n        df1 = generate_random_dataframe(rows1, cols1, dtype)\n\n        num_other_dfs = np.random.randint(1, 4)\n        other_dfs = [generate_random_dataframe(np.random.randint(3, 10), cols1, dtype) for _ in range(num_other_dfs)]\n\n        test_cases.append((df1, other_dfs))\n\n    return test_cases"}
{"problem_id": "pandas_55", "library": "pandas", "code_problem": "You are tasked with creating a function that processes frequency data and combines it with taxonomy information to generate a DataFrame that summarizes taxonomic abundance and estimated counts. The function signature is as follows:\n\n```python\ndef freq_to_lineage_df(freq, taxonomy_df, mapped_count, unmapped_count, mapped_unclassified_count, counts):\n```\n\n### Constants Used:\n- The constant used in the main code is the string values 'unmapped' and 'mapped_unclassified', which are added to the keys and values of the frequency dictionary.\n\n### Input and Output Format:\n- **Input Format**:\n  - `freq`: A dictionary (e.g., {tax_id1: abundance1, tax_id2: abundance2, ...}).\n  - `taxonomy_df`: A pandas DataFrame with taxonomic information.\n  - `mapped_count`: An integer.\n  - `unmapped_count`: An integer.\n  - `mapped_unclassified_count`: An integer.\n  - `counts`: A boolean.\n\n- **Output Format**:\n  - A pandas DataFrame containing the following columns: 'tax_id', 'abundance', taxonomy-related columns from `taxonomy_df`, and optionally 'estimated counts' if `counts` is True.\n\n**Input:**\n```python\nfreq = {\n    '1001': 25.0,\n    '1002': 30.5,\n    '1003': 15.0\n}\ntaxonomy_df = pd.DataFrame({\n    'tax_id': ['1001', '1002', '1003', '1004'],\n    'lineage': ['Taxon_A;Taxon_B', 'Taxon_C;Taxon_D', 'Taxon_E;Taxon_F', 'Taxon_G;Taxon_H']\n}).set_index('tax_id')\nmapped_count = 200\nunmapped_count = 20\nmapped_unclassified_count = 10\ncounts = True\n```\n\n**Output:**\n```python\n                tax_id  abundance          lineage  estimated counts\n0                 1001       25.0  Taxon_A;Taxon_B            4750.0\n1                 1002       30.5  Taxon_C;Taxon_D            5795.0\n2                 1003       15.0  Taxon_E;Taxon_F            2850.0\n3             unmapped        0.0              NaN              20.0\n4  mapped_unclassified        0.0              NaN              10.0\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef freq_to_lineage_df(freq, taxonomy_df, mapped_count, unmapped_count, mapped_unclassified_count, counts):\n\n    results_df = pd.DataFrame(zip(list(freq.keys()) + ['unmapped', 'mapped_unclassified'], list(freq.values()) + [0, 0]), columns=['tax_id', 'abundance']).set_index('tax_id')\n    results_df = results_df.join(taxonomy_df, how='left').reset_index()\n    if counts:\n        classified_count = mapped_count - mapped_unclassified_count\n        counts_series = pd.concat([(results_df['abundance'] * classified_count)[:-2], pd.Series(unmapped_count), pd.Series(mapped_unclassified_count)], ignore_index=True)\n        results_df['estimated counts'] = counts_series\n    return results_df", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    def generate_random_freq():\n        \"\"\"Generate a random freq dictionary with tax_id as keys and random abundance values.\"\"\"\n        num_entries = random.randint(1, 10)  # Random number of entries\n        return {str(random.randint(1000, 9999)): random.uniform(0.1, 100.0) for _ in range(num_entries)}\n\n    def generate_random_taxonomy_df():\n        \"\"\"Generate a random taxonomy DataFrame.\"\"\"\n        num_entries = random.randint(5, 15)\n        tax_ids = [str(random.randint(1000, 9999)) for _ in range(num_entries)]\n        lineage = [\";\".join([f\"Taxon_{i}\" for i in range(1, random.randint(2, 5) + 1)]) for _ in range(num_entries)]\n        df = pd.DataFrame({'tax_id': tax_ids, 'lineage': lineage})\n        return df.set_index('tax_id')\n\n    def generate_random_counts():\n        \"\"\"Generate random values for counts.\"\"\"\n        mapped_count = random.randint(50, 500)\n        unmapped_count = random.randint(10, 50)\n        mapped_unclassified_count = random.randint(1, mapped_count // 2)\n        counts_flag = random.choice([True, False])\n        return mapped_count, unmapped_count, mapped_unclassified_count, counts_flag\n\n    \"\"\"Generate n test cases.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        freq = generate_random_freq()\n        taxonomy_df = generate_random_taxonomy_df()\n        mapped_count, unmapped_count, mapped_unclassified_count, counts_flag = generate_random_counts()\n        test_cases.append((freq, taxonomy_df, mapped_count, unmapped_count, mapped_unclassified_count, counts_flag))\n    return test_cases"}
{"problem_id": "pandas_56", "library": "pandas", "code_problem": "You are tasked with implementing a function that corrects measurement drift in a dataset of well measurements based on manual measurements taken at specific time intervals. The function will identify breakpoints in the well data, calculate the drift between the well measurements and the manual measurements, and apply corrections to the well data accordingly.\n\nFunction Signature:\n```python\ndef fix_drift(well: pd.DataFrame, manualfile: pd.DataFrame, meas: str, corrwl: str, manmeas: str, outcolname: str) -> Tuple[pd.DataFrame, pd.DataFrame]:\n```\n\nConstants Used:\n- A constant value of `1e-06` is used in the calculation of drift.\n\n\nInput Format:\n- `well`: A pandas DataFrame containing well measurements with a datetime index.\n- `manualfile`: A pandas DataFrame containing manual measurements with a datetime index.\n- `meas`: A string representing the column name of the measurements in the `well` DataFrame.\n- `corrwl`: A string representing the column name in the `well` DataFrame used for identifying valid measurements.\n- `manmeas`: A string representing the column name in the `manualfile` DataFrame for manual measurements.\n- `outcolname`: A string representing the name of the output column where corrected measurements will be stored.\n\nOutput Format:\n- The function returns a tuple containing:\n  1. A pandas DataFrame with corrected well measurements.\n  2. A pandas DataFrame with drift information for each segment.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Well DataFrame\nwell_index = pd.date_range(start=\"2023-01-01\", periods=10, freq='H')\nwell_data = {\n    \"Depth\": [150, 160, 155, 158, 162, 165, 170, 175, 180, 185],\n    \"Measurement\": [20, 22, 21, 23, 24, 25, 26, 27, 28, 29]\n}\nwell_df = pd.DataFrame(well_data, index=well_index)\n\n# Manual DataFrame\nmanual_index = pd.date_range(start=\"2023-01-02\", periods=3, freq='12H')\nmanual_data = {\n    \"ManualDepth\": [155, 160, 165],\n    \"ManualMeasurement\": [21, 23, 25]\n}\nmanual_df = pd.DataFrame(manual_data, index=manual_index)\n\n# Parameters\nmeas = \"Measurement\"\ncorrwl = \"Depth\"\nmanmeas = \"ManualMeasurement\"\noutcolname = \"CorrectedMeasurement\"\n\n# Call the function\nresult = fix_drift(well_df, manual_df, meas, corrwl, manmeas, outcolname)\n```\n\n**Output:**\n```python\n# wellbarofixed DataFrame\nwellbarofixed = \n                     level_0  Depth  ...  DRIFTCORRECTION  CorrectedMeasurement\nDateTime                             ...                                       \n2023-01-01 01:00:00        0    160  ...              0.0                  15.0\n2023-01-01 02:00:00        0    155  ...              0.0                  14.0\n2023-01-01 03:00:00        0    158  ...              0.0                  16.0\n2023-01-01 04:00:00        0    162  ...              0.0                  17.0\n2023-01-01 05:00:00        0    165  ...              0.0                  18.0\n2023-01-01 06:00:00        0    170  ...              0.0                  19.0\n2023-01-01 07:00:00        0    175  ...              0.0                  20.0\n2023-01-01 08:00:00        0    180  ...              0.0                  21.0\n[8 rows x 7 columns]\n\n# drift_info DataFrame\ndrift_info = \n                           t_beg              man_beg  ... first_trans last_trans\n0  2023-01-01T00:00:00.000000000  2023-01-02 00:00:00  ...          22         28\n[1 rows x 14 columns]\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\ndef fcl(df, dtObj):\n    return df.iloc[np.argmin(np.abs(pd.to_datetime(df.index) - dtObj))]\n\n# main code\ndef fix_drift(well, manualfile, meas, corrwl, manmeas, outcolname):\n    breakpoints = []\n    manualfile.index = pd.to_datetime(manualfile.index)\n    manualfile.sort_index(inplace=True)\n    wellnona = well.dropna(subset=[corrwl])\n    if manualfile.first_valid_index() > wellnona.first_valid_index():\n        breakpoints.append(wellnona.first_valid_index())\n    for i in range(len(manualfile)):\n        breakpoints.append(fcl(wellnona, manualfile.index[i]).name)\n    if manualfile.last_valid_index() < wellnona.last_valid_index():\n        breakpoints.append(wellnona.last_valid_index())\n    breakpoints = pd.Series(breakpoints)\n    breakpoints = pd.to_datetime(breakpoints)\n    breakpoints.sort_values(inplace=True)\n    breakpoints.drop_duplicates(inplace=True)\n    bracketedwls, drift_features = ({}, {})\n    if well.index.name:\n        dtnm = well.index.name\n    else:\n        dtnm = 'DateTime'\n        well.index.name = 'DateTime'\n    breakpoints = breakpoints.values\n    manualfile.loc[:, 'julian'] = manualfile.index.to_julian_date()\n    for i in range(len(breakpoints) - 1):\n        bracketedwls[i] = well.loc[(pd.to_datetime(well.index) > breakpoints[i]) & (pd.to_datetime(well.index) < breakpoints[i + 1])]\n        df = bracketedwls[i]\n        if len(df) > 0:\n            df.sort_index(inplace=True)\n            df.loc[:, 'julian'] = df.index.to_julian_date()\n            last_trans = df.loc[df.last_valid_index(), meas]\n            first_trans = df.loc[df.first_valid_index(), meas]\n            first_trans_date = df.loc[df.first_valid_index(), 'julian']\n            last_trans_date = df.loc[df.last_valid_index(), 'julian']\n            first_man = fcl(manualfile, breakpoints[i])\n            last_man = fcl(manualfile, breakpoints[i + 1])\n            if df.first_valid_index() < manualfile.first_valid_index():\n                first_man[manmeas] = None\n            if df.last_valid_index() > manualfile.last_valid_index():\n                last_man[manmeas] = None\n            if pd.isna(first_man[manmeas]):\n                b = last_trans - last_man[manmeas]\n                drift = 1e-06\n                slope_man = 0\n                slope_trans = 0\n                new_slope = 0\n            elif pd.isna(last_man[manmeas]):\n                b = first_trans - first_man[manmeas]\n                drift = 1e-06\n                slope_man = 0\n                slope_trans = 0\n                new_slope = 0\n            else:\n                b = first_trans - first_man[manmeas]\n                drift = last_trans - last_man[manmeas] - b\n                slope_man = (first_man[manmeas] - last_man[manmeas]) / (first_man['julian'] - last_man['julian'])\n                slope_trans = (first_trans - last_trans) / (first_trans_date - last_trans_date)\n                new_slope = slope_trans - slope_man\n            m = drift / (last_trans_date - first_trans_date)\n            df.loc[:, 'datechange'] = df['julian'].apply(lambda x: x - df.loc[df.index[0], 'julian'], 1)\n            df.loc[:, 'DRIFTCORRECTION'] = df['datechange'].apply(lambda x: new_slope * x, 1)\n            df.loc[:, outcolname] = df[meas] - (df['DRIFTCORRECTION'] + b)\n            drift_features[i] = {'t_beg': breakpoints[i], 'man_beg': first_man.name, 't_end': breakpoints[i + 1], 'man_end': last_man.name, 'slope_man': slope_man, 'slope_trans': slope_trans, 'intercept': b, 'slope': m, 'new_slope': new_slope, 'first_meas': first_man[manmeas], 'last_meas': last_man[manmeas], 'drift': drift, 'first_trans': first_trans, 'last_trans': last_trans}\n        else:\n            pass\n    wellbarofixed = pd.concat(bracketedwls)\n    wellbarofixed.reset_index(inplace=True)\n    wellbarofixed.set_index(dtnm, inplace=True)\n    drift_info = pd.DataFrame(drift_features).T\n    return (wellbarofixed, drift_info)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate random time series index\n        start_date = pd.Timestamp(\"2023-01-01\")\n        well_index = pd.date_range(start=start_date, periods=random.randint(50, 200), freq='H')\n        manual_index = pd.date_range(start=start_date + pd.Timedelta(days=random.randint(1, 10)),\n                                     periods=random.randint(5, 30), freq='12H')\n\n        # Create well dataframe\n        well_data = {\n            \"Depth\": np.random.uniform(100, 500, size=len(well_index)),\n            \"Measurement\": np.random.uniform(10, 50, size=len(well_index))\n        }\n        well_df = pd.DataFrame(well_data, index=well_index)\n\n        # Create manualfile dataframe\n        manual_data = {\n            \"ManualDepth\": np.random.uniform(100, 500, size=len(manual_index)),\n            \"ManualMeasurement\": np.random.uniform(10, 50, size=len(manual_index))\n        }\n        manual_df = pd.DataFrame(manual_data, index=manual_index)\n\n        # Define parameters\n        meas = \"Measurement\"\n        corrwl = \"Depth\"\n        manmeas = \"ManualMeasurement\"\n        outcolname = \"CorrectedMeasurement\"\n\n        test_cases.append((well_df, manual_df, meas, corrwl, manmeas, outcolname))\n    return test_cases"}
{"problem_id": "pandas_57", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes and analyzes a dataset to categorize numerical values into groups based on specified criteria. The function will also compute various statistics related to these groups, including Weight of Evidence (WoE) and Information Value (IV). \n\nThe function signature is as follows:\n\n```python\ndef numericexist(input_data: pd.DataFrame, col: str, group_info_old: pd.DataFrame, target: str, modify: bool, add_value: float, data_only: bool) -> tuple:\n```\n\n### Constants Used:\n- The constant used in the main code is `-99`, which is assigned to the `s_group` for missing data.\n\n### Input and Output Format:\n- **Input Format**:\n  - `input_data`: A pandas DataFrame with at least one column specified by `col`.\n  - `col`: A string representing the name of the column in `input_data`.\n  - `group_info_old`: A pandas DataFrame containing group information.\n  - `target`: A string representing the target variable.\n  - `modify`: A boolean indicating whether to modify the group mapping.\n  - `add_value`: A float value to be added to the group mapping if `modify` is True.\n  - `data_only`: A boolean indicating whether to return only the data.\n\n- **Output Format**:\n  - A tuple containing:\n    - A DataFrame with group information and statistics.\n    - A DataFrame with the output data, including WoE and group information, excluding the original WoE and group columns.\n\n**Input:**\n```python\ninput_data = pd.DataFrame({\n    'feature': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    'target': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n\ncol_name = 'feature'\n\ngroup_info_old = pd.DataFrame({\n    'f_group': [0, 1, 2],\n    'woe': [0.5, -0.5, 1.0],\n    'miss_s': [False, False, True],\n    'value': [np.nan, 'special', 'miss'],\n    's_group': [0, 1, 2],\n    's_max': [30, 70, 100],\n    's_min': [0, 40, 90]\n})\n\nmodify = False\nadd_value = 0\ndata_only = False\ngroup_info, output_data = numericexist(input_data, col_name, group_info_old, 'target', modify, add_value, data_only)\n```\n\n**Output:**\n```python\n# group_info\n   s_group  s_max  s_min  f_group  ...  miss_s  miss_f  value       woe\n0        0     30      0        0  ...   False   False    NaN -2.772589\n1        1     70     40        1  ...   False   False    NaN -2.772589\n[2 rows x 10 columns]\n\n# output_data\n   feature  target  s_group  s_min  ...   miss  value  woe_feature  f_group_feature\n0       10       0        0      0  ...  False    NaN    -2.772589                0\n1       20       1        0      0  ...  False    NaN    -2.772589                0\n2       30       0        0      0  ...  False    NaN    -2.772589                0\n3       50       0        1     40  ...  False    NaN    -2.772589                1\n4       60       1        1     40  ...  False    NaN    -2.772589                1\n5       70       0        1     40  ...  False    NaN    -2.772589                1\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef binning(group_data, input_data, col, input_max, input_min, input_group, special_codes):\n    s_group_data = pd.DataFrame()\n    group_data = group_data.reset_index(drop=True)\n\n    if special_codes:\n        input_data = input_data[~input_data[col].isin(special_codes)]\n    input_data = input_data.dropna(subset=[col])\n\n    for _, row in group_data.iterrows():\n        temp_data = input_data.copy()\n        temp_data[input_group] = row[input_group]\n        temp_data[input_min] = row[input_min]\n        temp_data[input_max] = row[input_max]\n        temp_data['f_max'] = row.get('f_max', np.nan)\n        temp_data['f_min'] = row.get('f_min', np.nan)\n        temp_data = temp_data[(temp_data[col] > temp_data[input_min]) & (temp_data[col] <= temp_data[input_max])]\n        s_group_data = pd.concat([s_group_data, temp_data])\n\n    return s_group_data\n\n# main code\ndef numericexist(input_data, col, group_info_old, target, modify, add_value, data_only):\n    woe_data = group_info_old[['f_group', 'woe']]\n    special_codes = group_info_old.loc[group_info_old['miss_s'], 'value'].tolist()\n    group_info_num = group_info_old[~group_info_old['miss_s']]\n    s_group_map = group_info_num[['s_group', 's_max', 's_min']].drop_duplicates()\n\n    if modify:\n        unique_values = sorted(set(s_group_map['s_max']).union(s_group_map['s_min']).union({add_value}))\n        s_group_map = pd.DataFrame({\n            's_group': range(len(unique_values) - 1),\n            's_min': unique_values[:-1],\n            's_max': unique_values[1:]\n        })\n\n    f_group_map = group_info_num.groupby('f_group').agg({'s_max': 'max', 's_min': 'min'}).reset_index()\n    f_group_map.rename(columns={'s_max': 'f_max', 's_min': 'f_min'}, inplace=True)\n\n    group_info_base_list = [\n        s_group_map.assign(f_group=row['f_group'], f_min=row['f_min'], f_max=row['f_max'])\n        [(s_group_map['s_min'] >= row['f_min']) & (s_group_map['s_max'] <= row['f_max'])]\n        for _, row in f_group_map.iterrows()\n    ]\n\n    if group_info_base_list:\n        group_info_base = pd.concat(group_info_base_list)\n    else:\n        group_info_base = pd.DataFrame(columns=['s_group', 's_min', 's_max', 'f_group', 'f_min', 'f_max'])\n\n    group_info_base[['miss_s', 'miss_f', 'value']] = [False, False, np.nan]\n\n    s_group_data = binning(s_group_map, input_data, col, 's_max', 's_min', 's_group', special_codes)\n    f_group_data = binning(f_group_map, s_group_data, col, 'f_max', 'f_min', 'f_group', special_codes) \\\n        if not s_group_data.empty else pd.DataFrame()\n\n    if f_group_data.empty or 'f_max' not in f_group_data.columns or 'f_min' not in f_group_data.columns:\n        f_group_data['f_max'], f_group_data['f_min'] = np.nan, np.nan\n\n    f_group_data[['miss', 'value']] = [False, np.nan]\n\n    for value in special_codes:\n        temp = input_data[input_data[col].isnull() if value == 'miss' else input_data[col] == value].copy()\n        if not temp.empty:\n            temp['s_group'] = group_info_old.loc[group_info_old['value'] == value, 's_group'].values[0]\n            temp['f_group'] = group_info_old.loc[group_info_old['value'] == value, 'f_group'].values[0]\n            temp[['miss', 'value']] = [True, value]\n            f_group_data = pd.concat([f_group_data, temp])\n            group_info_base = pd.concat([group_info_base, pd.DataFrame(\n                {'s_group': temp['s_group'].iloc[0], 'f_group': temp['f_group'].iloc[0], 'value': value, 'miss_s': True,\n                 'miss_f': True}, index=[0])])\n\n    if 'miss' not in group_info_old['value'].values and input_data[col].isnull().any():\n        missing_data = input_data[input_data[col].isnull()].copy()\n        missing_data['s_group'], missing_data['f_group'] = -99, group_info_old.loc[\n            group_info_old['woe'].idxmax(), 'f_group']\n        missing_data[['miss', 'value']] = [True, 'miss']\n        f_group_data = pd.concat([f_group_data, missing_data])\n        group_info_base = pd.concat([group_info_base, pd.DataFrame(\n            {'s_group': -99, 'f_group': missing_data['f_group'].iloc[0], 'value': 'miss', 'miss_s': True,\n             'miss_f': True}, index=[0])])\n\n    if data_only:\n        output_data = f_group_data.merge(woe_data, on='f_group', how='left')\n        output_data[f'woe_{col}'] = output_data['woe']\n        output_data[f'f_group_{col}'] = output_data['f_group']\n        return output_data[[col, f'woe_{col}', f'f_group_{col}']]\n\n    f_summary = f_group_data.groupby('f_group').agg(\n        {target: ['mean', 'count', 'sum'], 'f_max': 'max', 'f_min': 'min'}\n    ).reset_index()\n\n    f_summary.columns = ['f_group', 'f_Bad_rate', 'f_N_obs', 'f_N_bad', 'f_max', 'f_min']\n\n    total_bad, total_good = f_summary['f_N_bad'].sum(), f_summary['f_N_obs'].sum() - f_summary['f_N_bad'].sum()\n    f_summary['woe'] = np.log(np.maximum(1, f_summary['f_N_bad']) / total_bad /\n                              np.maximum(1, f_summary['f_N_obs'] - f_summary['f_N_bad']) / total_good)\n    f_summary['woe'] = f_summary['woe'].round(8)\n    f_summary['iv'] = ((f_summary['f_N_bad'] / total_bad -\n                       (f_summary['f_N_obs'] - f_summary['f_N_bad']) / total_good)\n                       * f_summary['woe']).sum()\n\n    group_info = group_info_base.merge(f_summary[['f_group', 'woe']], on='f_group', how='left')\n    output_data = f_group_data.merge(f_summary[['f_group', 'woe']], on='f_group', how='left')\n    output_data[f'woe_{col}'] = output_data['woe']\n    output_data[f'f_group_{col}'] = output_data['f_group']\n\n    return group_info, output_data.drop(columns=['woe', 'f_group'])", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(50, 200)\n        col_name = \"feature\"\n        input_data = pd.DataFrame({\n            col_name: np.random.uniform(-100, 100, num_rows),\n            \"target\": np.random.choice([0, 1], num_rows)\n        })\n\n        modify = random.choice([True, False])\n        add_value = np.random.uniform(-100, 100)\n        data_only = random.choice([True, False])\n\n\n        group_info_old = pd.DataFrame({\n            'f_group': np.random.randint(0, 10, num_rows),\n            'woe': np.random.uniform(-2, 2, num_rows),\n            'miss_s': np.random.choice([True, False], num_rows),\n            'value': np.random.choice(['miss', np.nan, 'special'], num_rows),\n            's_group': np.random.randint(0, 5, num_rows),\n            's_max': np.random.uniform(-100, 100, num_rows),\n            's_min': np.random.uniform(-100, 100, num_rows)\n        })\n\n        test_cases.append((input_data, col_name, group_info_old, 'target', modify, add_value, data_only))\n    return test_cases"}
{"problem_id": "pandas_58", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the Directional Movement Index (DMI) and the Average Directional Index (ADX) for a given financial dataset. The DMI is used to determine the strength of a trend in the price of a financial instrument, while the ADX indicates the strength of the trend without regard to its direction.\n\nFunction signature:\n```python\ndef cal_dmi(data: pd.DataFrame, n: int, n_ADX: int) -> tuple:\n```\n\nConstants used in the main code:\n- The constant `0` is used to initialize the `UpD` and `DoD` values when there are no upward or downward movements.\n\nInput format:\n- `data`: A Pandas DataFrame containing at least three columns: 'High', 'Low', and 'Close', representing the high, low, and closing prices of a financial instrument over time.\n- `n`: An integer representing the period for calculating the DMI.\n- `n_ADX`: An integer representing the period for calculating the ADX.\n\nOutput format:\n- The function returns a tuple containing three Pandas Series: `PosDI`, `NegDI`, and `ADX`.\n\n**Input:**\n```python\ndata = pd.DataFrame({\n    'High': [100, 102, 101, 103, 104],\n    'Low': [99, 98, 97, 99, 100],\n    'Close': [100, 101, 100, 102, 103]\n})\nn = 3\nn_ADX = 2\n```\n\n**Output:**\n```python\n(PosDI, NegDI, ADX) = cal_dmi(data, n, n_ADX)\n\n# Expected Output Values\nPosDI = [0.250000, 0.416667, 0.321429, NaN]\nNegDI = [0.250000, 0.083333, 0.035714, NaN]\nADX = [NaN, 0.000000, 0.707692, 0.707692]\n```\n", "ground_truth_code": "import pandas as pd\n\n# main code\ndef cal_dmi(data, n, n_ADX):\n    i = 0\n    UpI = []\n    DoI = []\n    while i + 1 <= data.index[-1]:\n        UpMove = data.loc[i + 1, 'High'] - data.loc[i, 'High']\n        DoMove = data.loc[i, 'Low'] - data.loc[i + 1, 'Low']\n        if UpMove > DoMove and UpMove > 0:\n            UpD = UpMove\n        else:\n            UpD = 0\n        UpI.append(UpD)\n        if DoMove > UpMove and DoMove > 0:\n            DoD = DoMove\n        else:\n            DoD = 0\n        DoI.append(DoD)\n        i = i + 1\n    i = 0\n    TR_l = [0]\n    while i < data.index[-1]:\n        TR = max(data.loc[i + 1, 'High'], data.loc[i, 'Close']) - min(data.loc[i + 1, 'Low'], data.loc[i, 'Close'])\n        TR_l.append(TR)\n        i = i + 1\n    TR_s = pd.Series(TR_l)\n    ATR = pd.Series(TR_s.ewm(span=n, min_periods=1).mean())\n    UpI = pd.Series(UpI)\n    DoI = pd.Series(DoI)\n    PosDI = pd.Series(UpI.ewm(span=n, min_periods=1).mean() / ATR)\n    NegDI = pd.Series(DoI.ewm(span=n, min_periods=1).mean() / ATR)\n    ADX = pd.Series((abs(PosDI - NegDI) / (PosDI + NegDI)).ewm(span=n_ADX, min_periods=1).mean(), name='ADX_' + str(n) + '_' + str(n_ADX))\n    return (PosDI, NegDI, ADX)", "test_script": "import pandas as pd\nimport random\n\ndef generate_test_case(num_rows, n, n_ADX):\n    \"\"\"Generate a single test case with synthetic stock price data.\"\"\"\n    data = pd.DataFrame(index=range(num_rows), columns=['High', 'Low', 'Close'])\n    base_price = random.uniform(50, 150)\n\n    for i in range(num_rows):\n        high = base_price + random.uniform(0, 5)\n        low = base_price - random.uniform(0, 5)\n        close = random.uniform(low, high)\n        data.loc[i] = [high, low, close]\n        base_price = close  # Move base price for next row to simulate real market behavior\n\n    return data, n, n_ADX\n\ndef test_case_input_generator(n=200):\n    \"\"\"Generate multiple test cases and store them in a list.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(10, 500)  # Random data length between 10 and 500 rows\n        n_ = random.randint(5, 50)  # Random n between 5 and 50\n        n_ADX = random.randint(5, 50)  # Random n_ADX between 5 and 50\n        test_cases.append(generate_test_case(num_rows, n_, n_ADX))\n    return test_cases"}
{"problem_id": "pandas_59", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a DataFrame to remove outliers from a specified column based on the interquartile range (IQR) method. The function will utilize a helper function to identify outliers and return a new DataFrame without these outliers.\n\nFunction Signature:\n```python\ndef outliers_proc(data: pd.DataFrame, col_name: str, scale: float) -> pd.DataFrame:\n```\n\nConstant Used:\n- The constant used in the main code is `box_scale`, which is passed as the `scale` parameter to the `box_plot_outliers` function.\n\nInput Format:\n- `data`: A pandas DataFrame containing the data.\n- `col_name`: A string representing the name of the column from which to remove outliers.\n- `scale`: A float that determines the scaling factor for the IQR calculation.\n\nOutput Format:\n- The function returns a pandas DataFrame that contains the original data without the outliers from the specified column.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test DataFrame\ndata = pd.DataFrame({\n    'col_0': [10, 12, 14, 15, 100, 16, 18, 20, 22, 24],\n    'col_1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n})\n\ncol_name = 'col_0'\nscale = 1.5\n```\n\n**Output:**\n```python\n# Processed DataFrame after removing outliers\noutput = pd.DataFrame({\n    'col_0': [10, 12, 14, 15, 16, 18, 20, 22, 24],\n    'col_1': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10]\n})\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\ndef box_plot_outliers(data_ser, box_scale):\n    iqr = box_scale * (data_ser.quantile(0.75) - data_ser.quantile(0.25))\n    val_low = data_ser.quantile(0.25) - iqr\n    val_up = data_ser.quantile(0.75) + iqr\n    rule_low = data_ser < val_low\n    rule_up = data_ser > val_up\n    return ((rule_low, rule_up), (val_low, val_up))\n\n# main code\ndef outliers_proc(data, col_name, scale):\n    data_n = data.copy()\n    data_series = data_n[col_name]\n    rule, value = box_plot_outliers(data_series, box_scale=scale)\n    index = np.arange(data_series.shape[0])[rule[0] | rule[1]]\n    data_n = data_n.drop(index)\n    data_n.reset_index(drop=True, inplace=True)\n    return data_n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate random number of rows (10 to 500) and columns (1 to 5)\n        num_rows = random.randint(10, 500)\n        num_cols = random.randint(1, 5)\n\n        # Generate random column names\n        col_names = [f'col_{j}' for j in range(num_cols)]\n\n        # Generate random numerical data\n        data = {col: np.random.normal(loc=random.uniform(-100, 100), scale=random.uniform(1, 50), size=num_rows) for col\n                in col_names}\n        df = pd.DataFrame(data)\n\n        # Randomly select a column for outlier processing\n        col_name = random.choice(col_names)\n\n        # Randomly select a scale factor (between 1.0 and 3.0)\n        scale = random.uniform(1.0, 3.0)\n\n        # Store the generated test case\n        test_cases.append((df, col_name, scale))\n\n    return test_cases"}
{"problem_id": "pandas_60", "library": "pandas", "code_problem": "You are tasked with creating a function that transforms a DataFrame by applying a multi-level index to its columns based on a mapping provided in a dictionary. The function will take in a DataFrame and several parameters to format the column names into a multi-index structure.\n\nFunction signature:\n```python\ndef make_multiindex(df: pd.DataFrame, colmap: dict, headers: list, region: str, variable: str, attribute: str) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- `df`: A pandas DataFrame containing the data to be transformed.\n- `colmap`: A dictionary where keys are column names and values are lists of formatting strings for each level of the multi-index.\n- `headers`: A list of strings representing the names of the levels in the multi-index.\n- `region`: A string representing the region to be included in the column names.\n- `variable`: A string representing the variable to be included in the column names.\n- `attribute`: A string representing the attribute to be included in the column names.\n\nOutput format:\n- The function returns a pandas DataFrame with a MultiIndex applied to its columns based on the provided parameters.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ndf = pd.DataFrame({\n    'A': [1, 2, 3],\n    'B': [4, 5, 6],\n    'C': [7, 8, 9]\n})\n\ncolmap = {\n    'A': {'level1': 'region1_var1_attr1', 'level2': 'region1_var1_attr2'},\n    'B': {'level1': 'region1_var2_attr1', 'level2': 'region1_var2_attr2'},\n    'C': {'level1': 'region1_var3_attr1', 'level2': 'region1_var3_attr2'}\n}\n\nheaders = ['level1', 'level2']\nregion = 'region1'\nvariable = 'var'\nattribute = 'attr'\n\noutput_df = make_multiindex(df, colmap, headers, region, variable, attribute)\n```\n\n**Output:**\n```python\n# Expected output DataFrame\npd.DataFrame({\n    ('region1_var1_attr1', 'region1_var1_attr2'): [1, 2, 3],\n    ('region1_var2_attr1', 'region1_var2_attr2'): [4, 5, 6],\n    ('region1_var3_attr1', 'region1_var3_attr2'): [7, 8, 9]\n})\n```\n\nThis output DataFrame will have a MultiIndex for the columns based on the provided `colmap`, `region`, `variable`, and `attribute`.", "ground_truth_code": "import pandas as pd\n\n# main code\ndef make_multiindex(df, colmap, headers, region, variable, attribute):\n    df = df[[key for key in colmap.keys() if key in df.columns]]\n    cols = [tuple((colmap[col_name][level].format(region=region, variable=variable, attribute=attribute, region_from_col=col_name) for level in headers)) for col_name in df.columns]\n    df.columns = pd.MultiIndex.from_tuples(cols, names=headers)\n    return df", "test_script": "import pandas as pd\nimport random\nimport string\n\ndef test_case_input_generator(n=200):\n    def random_string(length=5):\n        return ''.join(random.choices(string.ascii_letters, k=length))\n\n    def random_dataframe(num_cols=5, num_rows=10):\n        columns = [random_string() for _ in range(num_cols)]\n        data = {col: [random.randint(1, 100) for _ in range(num_rows)] for col in columns}\n        return pd.DataFrame(data)\n\n    def random_colmap(columns):\n        return {col: {level: f\"{{region}}_{random_string()}\" for level in ['level1', 'level2']} for col in columns}\n\n    def random_headers():\n        return ['level1', 'level2']\n\n    test_cases = []\n    for _ in range(n):\n        df = random_dataframe()\n        colmap = random_colmap(df.columns)\n        headers = random_headers()\n        region = random_string()\n        variable = random_string()\n        attribute = random_string()\n        test_cases.append((df, colmap, headers, region, variable, attribute))\n    return test_cases"}
{"problem_id": "pandas_61", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a dataset to perform binning and grouping of numeric variables based on specified criteria. The function will utilize decision tree classification to create rough bins and calculate various statistics related to the target variable. The function signature is as follows:\n\n```python\ndef numericvar(inputdata, col, s_bin_num, target, criterion, splitter, max_depth, min_samples_leaf, max_leaf_nodes, specialcode_list):\n```\n\n### Constants Used:\n- The constant `float('-inf')` is used to represent negative infinity.\n- The constant `float('inf')` is used to represent positive infinity.\n\n### Input Format:\n- `inputdata`: A pandas DataFrame containing the dataset.\n- `col`: A string representing the name of the column to be processed.\n- `s_bin_num`: An integer specifying the number of bins for fine binning.\n- `target`: A string representing the name of the target variable.\n- `criterion`: A string specifying the function to measure the quality of a split (e.g., \"gini\" or \"entropy\").\n- `splitter`: A string indicating the strategy used to choose the split at each node (e.g., \"best\" or \"random\").\n- `max_depth`: An integer representing the maximum depth of the tree.\n- `min_samples_leaf`: An integer representing the minimum number of samples required to be at a leaf node.\n- `max_leaf_nodes`: An integer representing the maximum number of leaf nodes.\n- `specialcode_list`: A list of special codes to be excluded from processing.\n\n### Output Format:\nThe function returns a tuple containing:\n1. A DataFrame with group information and statistics.\n2. A DataFrame with the original data, including the calculated WoE and group assignments, excluding the columns 'woe' and 'f_group'.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    \"feature\": [10, 20, 30, 40, 50, None, 70, 80, 90, 100],\n    \"target\": [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n}\ndf = pd.DataFrame(data)\n\n# Parameters\ncol_name = \"feature\"\ns_bin_num = 5\ntarget_name = \"target\"\ncriterion = \"gini\"\nsplitter = \"best\"\nmax_depth = 3\nmin_samples_leaf = 1\nmax_leaf_nodes = None\nspecial_codes = []\n\n# Call the function\noutput = numericvar(df, col_name, s_bin_num, target_name, criterion, splitter, max_depth, min_samples_leaf, max_leaf_nodes, special_codes)\n```\n\n**Output:**\n```python\n# The output will be a tuple containing two DataFrames\ngroup_info, outputdata = output\n# group_info\n   s_group  s_min  s_max  f_group  f_min  ...   25%   50%   75%    max  miss_count\n0        0   -inf   20.0        0   -inf  ...  30.0  50.0  80.0  100.0           1\n1        1   20.0   40.0        1   20.0  ...  30.0  50.0  80.0  100.0           1\n2        2   40.0   70.0        2   40.0  ...  30.0  50.0  80.0  100.0           1\n3        3   70.0   90.0        3   70.0  ...  30.0  50.0  80.0  100.0           1\n4        4   90.0    inf        4   90.0  ...  30.0  50.0  80.0  100.0           1\n5       -1    NaN    NaN       -1    NaN  ...  30.0  50.0  80.0  100.0           1\n[6 rows x 28 columns]\n\n# outputdata\n   feature  woe_feature  f_group_feature\n0     10.0     0.000000                0\n1     20.0     0.000000                0\n2     30.0     0.000000                1\n3     40.0     0.000000                1\n4     50.0    -0.693147                2\n5     70.0    -0.693147                2\n6     80.0     0.000000                3\n7     90.0     0.000000                3\n8    100.0     0.000000                4\n9      NaN     0.000000               -1\n```\n", "ground_truth_code": "from sklearn.tree import DecisionTreeClassifier\nimport pandas as pd\nimport math\nimport numpy as np\n\ndef num_finebin_group(inputdata, col, s_bin_num, specialcode_list):\n    if specialcode_list != []:\n        inputdata = inputdata[inputdata.isin({col: specialcode_list}) == False]\n    sort_df = inputdata[col][inputdata[col].isnull() == False]\n    if len(sort_df.unique()) <= 1:\n        old_list = set([float('-inf'), float('inf')])\n    elif len(sort_df.unique()) <= s_bin_num:\n        old_list = set(list(sort_df.unique()))\n        old_list.remove(max(old_list))\n        old_list.remove(min(old_list))\n        old_list.add(float('-inf'))\n        old_list.add(float('inf'))\n    else:\n        old_list = set()\n        num = sort_df.size\n        sort_df = sort_df.sort_values(ascending=True).reset_index().drop(columns='index')\n        for i in range(1, s_bin_num):\n            loca = int(i / s_bin_num * num)\n            value = sort_df.iloc[loca].values[0]\n            old_list.add(value)\n        old_list.add(float('-inf'))\n        old_list.add(float('inf'))\n    new_list = list(old_list)\n    new_list.sort()\n    new_s_group = []\n    for i in range(len(new_list) - 1):\n        temp = {'s_group': i, 's_min': new_list[i], 's_max': new_list[i + 1]}\n        new_s_group.append(temp)\n    s_group_map = pd.DataFrame(new_s_group)\n    return s_group_map\n\ndef binning(group_data, inputdata, col, inputmax, inputmin, inputgroup, specialcode_list):\n    s_group_data = pd.DataFrame()\n    group_data = group_data.reset_index()\n    if specialcode_list != []:\n        inputdata = inputdata[inputdata.isin({col: specialcode_list}) == False]\n    inputdata = inputdata.loc[inputdata[col].isnull() == False]\n    for lins in range(len(group_data)):\n        temp = inputdata.copy()\n        temp[inputgroup] = group_data.loc[lins, inputgroup]\n        temp[inputmin] = group_data.loc[lins, inputmin]\n        temp[inputmax] = group_data.loc[lins, inputmax]\n        temp_data = temp[(temp[col] <= temp[inputmax]) & (temp[col] > temp[inputmin])]\n        s_group_data = pd.concat([s_group_data, temp_data])\n    return s_group_data\n\ndef roughbin_group(inputdata, s_group_col, col, target, specialcode_list, criterion, splitter, max_depth, min_samples_leaf, max_leaf_nodes):\n    if specialcode_list != []:\n        inputdata = inputdata[inputdata.isin({col: specialcode_list}) == False]\n    inputdata = inputdata[inputdata[col].isnull() == False]\n    if len(inputdata) > 2:\n        X_train = inputdata[[s_group_col]]\n        y_train = inputdata[[target]]\n        dtc = DecisionTreeClassifier(criterion=criterion, splitter=splitter, max_depth=max_depth, min_samples_leaf=min_samples_leaf, max_leaf_nodes=max_leaf_nodes)\n        dtc.fit(X_train, y_train)\n        n_nodes = dtc.tree_.node_count\n        children_left = dtc.tree_.children_left\n        children_right = dtc.tree_.children_right\n        feature = dtc.tree_.feature\n        threshold = dtc.tree_.threshold\n        max_v = []\n        min_v = []\n        min_v.append(float('-inf'))\n        max_v.append(float('inf'))\n        df = pd.DataFrame()\n        if n_nodes > 1:\n            for i in range(1, n_nodes):\n                for p in range(n_nodes):\n                    if children_left[p] == i:\n                        max_vv = threshold[p]\n                        min_vv = min_v[p]\n                        min_v.append(min_vv)\n                        max_v.append(max_vv)\n                for m in range(n_nodes):\n                    if children_right[m] == i:\n                        min_vv = threshold[m]\n                        max_vv = max_v[m]\n                        min_v.append(min_vv)\n                        max_v.append(max_vv)\n                if children_left[i] == -1 and children_right[i] == -1:\n                    if max_vv == np.nan:\n                        max_vv = float('inf')\n                    if min_vv == np.nan:\n                        max_vv = float('-inf')\n                    a = pd.DataFrame({'node_id': i, 'f_max': max_vv, 'f_min': min_vv, 'name': feature[i]}, index=[0])\n                    df = df._append(a)\n        if n_nodes == 1:\n            df = pd.DataFrame({'node_id': 1, 'f_max': float('inf'), 'f_min': float('-inf'), 'name': col}, index=[0])\n    else:\n        df = pd.DataFrame({'node_id': 1, 'f_max': float('inf'), 'f_min': float('-inf'), 'name': col}, index=[0])\n    rough_group = df.sort_values(by='f_max').reset_index().reset_index()[['level_0', 'f_max', 'f_min']].rename({'level_0': 'f_group'}, axis=1)\n    return rough_group\n\n# main code\ndef numericvar(inputdata, col, s_bin_num, target, criterion, splitter, max_depth, min_samples_leaf, max_leaf_nodes, specialcode_list):\n    s_group_map = num_finebin_group(inputdata=inputdata, col=col, s_bin_num=s_bin_num, specialcode_list=specialcode_list)\n    s_group_data = binning(group_data=s_group_map, inputdata=inputdata, col=col, inputmax='s_max', inputmin='s_min', inputgroup='s_group', specialcode_list=specialcode_list)\n    f_group_map_pre = roughbin_group(inputdata=s_group_data, s_group_col='s_group', specialcode_list=specialcode_list, col=col, target=target, criterion=criterion, splitter=splitter, max_depth=max_depth, min_samples_leaf=min_samples_leaf, max_leaf_nodes=max_leaf_nodes)\n    f_group_data_pre = binning(group_data=f_group_map_pre, inputdata=s_group_map, col='s_group', inputmax='f_max', inputmin='f_min', inputgroup='f_group', specialcode_list=[])\n    f_group_map = f_group_data_pre.groupby('f_group').agg({'s_min': 'min', 's_max': 'max'}).reset_index().rename({'s_min': 'f_min', 's_max': 'f_max'}, axis=1)\n    f_group_data = binning(group_data=f_group_map, inputdata=s_group_data, col=col, inputmax='f_max', inputmin='f_min', inputgroup='f_group', specialcode_list=specialcode_list)\n    f_group_data['value'] = np.nan\n    group_info_base = pd.merge(f_group_data_pre[['s_group', 's_min', 's_max', 'f_group']], f_group_map, how='left', on=['f_group'])\n    group_info_base['miss_s'] = False\n    group_info_base['miss_f'] = False\n    group_info_base['value'] = np.nan\n    if len(inputdata[inputdata[col].isnull()]) > 0:\n        miss_data = inputdata[inputdata[col].isnull()]\n        miss_data.loc[:, 's_group'] = -1\n        miss_data.loc[:, 'f_group'] = -1\n        miss_data['value'] = 'miss'\n        tempg = pd.DataFrame({'s_group': -1, 'f_group': -1, 'value': 'miss', 'miss_s': True, 'miss_f': True}, index=[0])\n        f_group_data = f_group_data._append(miss_data)\n        group_info_base = group_info_base._append(tempg)\n    if specialcode_list != []:\n        i = -2\n        for special_value in specialcode_list:\n            temp = inputdata[inputdata[col] == special_value].copy()\n            temp['s_group'] = i\n            temp['f_group'] = i\n            temp['value'] = special_value\n            temps = pd.DataFrame({'s_group': i, 'f_group': i, 'value': special_value, 'miss_s': True, 'miss_f': True}, index=[0])\n            f_group_data = f_group_data._append(temp)\n            group_info_base = group_info_base._append(temps)\n            i = i - 1\n    f_group_data['miss'] = f_group_data['s_group'] < 0\n    tt = f_group_data.groupby(['s_group', 'f_group']).agg({target: ['mean', 'count', 'sum'], 'miss': 'max', 's_max': 'max', 's_min': 'min', 'value': 'max'}).reset_index()\n    tt1 = f_group_data.groupby(['f_group']).agg({target: ['mean', 'count', 'sum'], 'f_max': 'max', 'f_min': 'min', 'miss': 'max'}).reset_index()\n    s_data = pd.DataFrame()\n    s_data['s_group'] = tt['s_group']\n    s_data['s_Bad_rate'] = tt[target]['mean']\n    s_data['s_N_obs'] = tt[target]['count']\n    s_data['s_N_bad'] = tt[target]['sum']\n    s_data['variable_name'] = '%s' % col\n    f_data = pd.DataFrame()\n    f_data['f_group'] = tt1['f_group']\n    f_data['f_Bad_rate'] = tt1[target]['mean']\n    f_data['f_N_obs'] = tt1[target]['count']\n    f_data['f_N_bad'] = tt1[target]['sum']\n    f_data['variable_name'] = '%s' % col\n    total_bad = f_data['f_N_bad'].sum()\n    total_good = f_data['f_N_obs'].sum() - f_data['f_N_bad'].sum()\n    f_data['woe'] = f_data.apply(lambda x: math.log(max(1, x['f_N_bad']) / total_bad / (max(1, x['f_N_obs'] - x['f_N_bad']) / total_good)), axis=1)\n    f_data['iv_g'] = (f_data['f_N_bad'] / total_bad - (f_data['f_N_obs'] - f_data['f_N_bad']) / total_good) * f_data['woe']\n    iv = f_data['iv_g'].sum()\n    f_data['iv'] = iv\n    dd = inputdata[col].describe()\n    ds = pd.DataFrame(dd).T.reset_index().rename({'index': 'variable_name'}, axis=1)\n    ds['miss_count'] = inputdata[col].isnull().sum()\n    group_info = pd.merge(group_info_base, f_data, how='left', on=['f_group'])\n    group_info = pd.merge(group_info, s_data, how='left', on=['variable_name', 's_group'])\n    group_info = pd.merge(group_info, ds, how='left', on=['variable_name'])\n    outputdata = pd.merge(f_group_data[[col, 'f_group']], f_data[['f_group', 'woe']], how='left', on=['f_group'])\n    outputdata['woe_%s' % col] = outputdata['woe']\n    outputdata['f_group_%s' % col] = outputdata['f_group']\n    return (group_info, outputdata.drop(columns=['woe', 'f_group']))", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = random.randint(10, 1000)  # Number of rows in the dataset\n        col_name = \"feature\"\n        target_name = \"target\"\n\n        # Generate a random dataset\n        df = pd.DataFrame({\n            col_name: np.random.uniform(-100, 100, num_rows),  # Random numeric values\n            target_name: np.random.choice([0, 1], num_rows)  # Binary target variable\n        })\n\n        # Introduce missing values with some probability\n        if random.random() < 0.5:\n            df.loc[random.sample(range(num_rows), random.randint(1, num_rows // 10)), col_name] = np.nan\n\n        # Introduce special codes\n        special_codes = []\n        if random.random() < 0.5:\n            special_codes = list(np.random.uniform(-100, 100, random.randint(1, 5)))\n\n        # Define parameters\n        s_bin_num = random.randint(2, 10)  # Number of fine bins\n        criterion = random.choice([\"gini\", \"entropy\"])  # Decision tree criterion\n        splitter = random.choice([\"best\", \"random\"])  # Splitter type\n        max_depth = random.choice([None, random.randint(2, 10)])  # Max depth of tree\n        min_samples_leaf = random.randint(1, 5)  # Min samples per leaf\n        max_leaf_nodes = random.choice([None, random.randint(5, 20)])  # Max leaf nodes\n\n        test_cases.append((df, col_name, s_bin_num, target_name, criterion, splitter, max_depth, min_samples_leaf, max_leaf_nodes, special_codes))\n    return test_cases\n"}
{"problem_id": "pandas_62", "library": "pandas", "code_problem": "You are tasked with analyzing ownership and control interests of entities based on provided data. The goal is to determine the jurisdictions in which these entities are incorporated and count the occurrences of each jurisdiction. If no relevant data is found, a specific message should be returned.\n\nFunction Signature:\n```python\ndef q122(ownershipOrControlInterest, ownershipOrControlStatement, entityStatement):\n```\n\nConstant Used:\n- The constant used in the main code is the string `'Missing'`, which is used to fill in missing values in the output DataFrame.\n\nInput Format:\n- The function expects three pandas DataFrames as input:\n  1. `ownershipOrControlInterest`: A DataFrame containing information about ownership or control interests.\n  2. `ownershipOrControlStatement`: A DataFrame containing statements related to ownership or control.\n  3. `entityStatement`: A DataFrame containing statements about entities and their jurisdictions.\n\nOutput Format:\n- The function returns a pandas DataFrame with two columns: `incorporatedInJurisdiction_name` and `count`, where `count` represents the number of occurrences of each jurisdiction. If no relevant data is found, it returns the string `'No table returned'`.\n\n**Input:**\n```python\nownershipOrControlInterest = pd.DataFrame({\n    '_link_ooc_statement': ['statement_0', 'statement_1', 'statement_2', 'statement_3'],\n    'beneficialOwnershipOrControl': [True, False, True, True]\n})\n\nownershipOrControlStatement = pd.DataFrame({\n    '_link': ['statement_0', 'statement_1', 'statement_2', 'statement_3'],\n    'subject_describedByEntityStatement': ['entity_0', 'entity_1', 'entity_0', 'entity_2'],\n    'interestedParty_describedByEntityStatement': ['party_0', None, 'party_1', 'party_2']\n})\n\nentityStatement = pd.DataFrame({\n    'statementID': ['entity_0', 'entity_1', 'entity_2'],\n    'incorporatedInJurisdiction_name': ['Country_1', None, 'Country_2']\n})\n```\n\n**Output:**\n```python\n# Expected output DataFrame\npd.DataFrame({\n    'count': [1, 1, 2]\n}, index=['Country_1', 'Country_2', 'All'])\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef q122(ownershipOrControlInterest, ownershipOrControlStatement, entityStatement):\n    df = pd.merge(ownershipOrControlInterest[ownershipOrControlInterest['beneficialOwnershipOrControl'] == True]['_link_ooc_statement'], ownershipOrControlStatement[['_link', 'subject_describedByEntityStatement', 'interestedParty_describedByEntityStatement']], how='left', left_on='_link_ooc_statement', right_on='_link')\n    df = df.loc[df['interestedParty_describedByEntityStatement'].notnull()]\n    if len(df) > 0:\n        df = pd.merge(df, entityStatement[['statementID', 'incorporatedInJurisdiction_name']], how='left', left_on='subject_describedByEntityStatement', right_on='statementID')\n        df = df.drop_duplicates(subset=['statementID'])\n        out = df['incorporatedInJurisdiction_name'].fillna('Missing').value_counts().to_frame(name='count')\n        # Adding a row with the total count\n        total_count = pd.DataFrame({'count': [out['count'].sum()]}, index=['All'])\n        # Use pd.concat instead of _append\n        out = pd.concat([out, total_count])\n        return out\n    else:\n        return 'No table returned'", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    # Function to generate a random DataFrame for ownershipOrControlInterest\n    def generate_ownership_or_control_interest(size):\n        return pd.DataFrame({\n            '_link_ooc_statement': [f'statement_{i}' for i in range(size)],\n            'beneficialOwnershipOrControl': np.random.choice([True, False], size=size)\n        })\n\n    # Function to generate a random DataFrame for ownershipOrControlStatement\n    def generate_ownership_or_control_statement(size):\n        return pd.DataFrame({\n            '_link': [f'statement_{i}' for i in range(size)],\n            'subject_describedByEntityStatement': [f'entity_{random.randint(0, size // 2)}' for _ in range(size)],\n            'interestedParty_describedByEntityStatement': np.random.choice(\n                [f'party_{i}' for i in range(size // 2)] + [None], size=size)\n        })\n\n    # Function to generate a random DataFrame for entityStatement\n    def generate_entity_statement(size):\n        return pd.DataFrame({\n            'statementID': [f'entity_{i}' for i in range(size)],\n            'incorporatedInJurisdiction_name': np.random.choice([f'Country_{i}' for i in range(10)] + [None], size=size)\n        })\n\n    test_cases = []\n\n    for _ in range(n):\n        size = random.randint(10, 100)  # Random size for diversity\n        ownershipOrControlInterest = generate_ownership_or_control_interest(size)\n        ownershipOrControlStatement = generate_ownership_or_control_statement(size)\n        entityStatement = generate_entity_statement(size)\n\n        test_cases.append((ownershipOrControlInterest, ownershipOrControlStatement, entityStatement))\n    return test_cases"}
{"problem_id": "pandas_63", "library": "pandas", "code_problem": "You are tasked with creating a function that generates a synthetic dataset of spherical feature data, which can be used for classification tasks. The dataset will consist of points distributed in a spherical manner, with each point assigned a label based on its position in relation to certain thresholds.\n\nFunction Signature:\n```python\ndef generate_spherical_feature_data(nsamples: int, nfeatures: int, nbatch: int, label_col: str, radius_min: float, radius_max: float) -> pd.DataFrame:\n```\n\nConstants Used:\n- `nsamples_per_class`: This constant is calculated as the total number of samples divided by the number of features, determining how many samples will be generated for each class.\n\n\nInput Format:\n- `nsamples`: An integer representing the total number of samples to generate.\n- `nfeatures`: An integer representing the number of features (or classes) in the dataset.\n- `nbatch`: An integer representing the number of batches to create for generating points.\n- `label_col`: A string representing the name of the column to store the labels in the DataFrame.\n- `radius_min`: A float representing the minimum radius for generating points.\n- `radius_max`: A float representing the maximum radius for generating points.\n\nOutput Format:\n- The function returns a pandas DataFrame containing the generated spherical feature data, with each row representing a point and an additional column for the labels.\n\nInput:\n```python\n(30, 5, 10, 'label', 1.0, 3.0)\n```\n\nOutput:\n```python\n          0         1         2         3         4  label\n0  0.210819  0.316228  0.421637  0.527046  0.632456      0\n1  0.773001  0.257667  0.386501  0.515334  0.644168      0\n2  0.761289  0.913547  0.304516  0.456773  0.609031      0\n3  0.702728  0.878410  1.054093  0.351364  0.527046      0\n4  0.597319  0.796425  0.995532  1.194638  0.398213      0\n5  0.445061  0.667592  0.890123  1.112653  1.335184      0\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef generate_spherical_feature_data(nsamples, nfeatures, nbatch, label_col, radius_min, radius_max):\n    nsamples_per_class = nsamples // nfeatures\n    base_vector = np.linspace(radius_min, radius_max, nfeatures)\n    rotations = np.array([np.roll(base_vector, i % nfeatures) for i in range(nbatch)])\n    norms = np.linalg.norm(rotations, axis=1, keepdims=True)\n    unit_vectors = rotations / norms\n    scales = np.linspace(radius_min, radius_max, nbatch).reshape(-1, 1)\n    points = unit_vectors * scales\n    df = pd.DataFrame(points)\n    thresholds = np.linspace(np.min(points), np.max(points), nfeatures)\n    weighted = df.mul(thresholds, axis=1)\n    labels = (weighted.sum(axis=1) // (radius_max * nfeatures)).astype(int)\n    labels = labels.clip(upper=nfeatures - 1)\n    df[label_col] = labels\n    grouped = df.groupby(label_col)\n    selected = [group.iloc[:nsamples_per_class] for (_, group) in grouped]\n    result = pd.concat(selected, ignore_index=True)\n    return result", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nfeatures = np.random.randint(2, 10)\n        nsamples_per_class = np.random.randint(5, 20)\n        nsamples = nsamples_per_class * nfeatures\n        nbatch = np.random.randint(nfeatures, nsamples)\n        label_col = 'label'\n        radius_min = np.random.uniform(0.5, 2.0)\n        radius_max = radius_min + np.random.uniform(1.0, 5.0)\n        test_case = (nsamples, nfeatures, nbatch, label_col, radius_min, radius_max)\n        test_cases.append(test_case)\n    return test_cases"}
{"problem_id": "pandas_64", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the entropy of a dataset based on certain parameters. The function will take in a DataFrame and compute two entropy values: the overall entropy (h0) and the conditional entropy (h1) based on a specified realized probability distribution.\n\nFunction signature:\n```python\ndef _entropy(data, realised_pd, count):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the natural logarithm base, which is represented by `np.log()` from the NumPy library.\n\nInput format:\n- The function expects a DataFrame `data` with at least two columns specified by the `realised_pd` and `count` parameters.\n\nOutput format:\n- The function returns a tuple containing two float values: the overall entropy (h0) and the conditional entropy (h1).\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'count': [10, 20, 30, 40, 50],\n    'realised_pd': [0.1, 0.2, 0.3, 0.4, 0.5]\n})\n\nrealised_pd = 'realised_pd'\ncount = 'count'\n```\n\n**Output:**\n```python\n(0.6571577614973405, 0.6210842198312838)\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef _entropy(data, realised_pd, count):\n    data['perc'] = data[count] / data[count].sum()\n    pd = (data[count] * data[realised_pd]).sum() / data[count].sum()\n    h0 = -(pd * np.log(pd) + (1 - pd) * np.log(1 - pd))\n    data['hc'] = -(data[realised_pd] * np.log(data[realised_pd]) + (1 - data[realised_pd]) * np.log(1 - data[realised_pd]))\n    h1 = sum(data['perc'] * data['hc'])\n    return (h0, h1)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly determine the number of rows (between 5 and 50 for variety)\n        num_rows = random.randint(5, 50)\n\n        # Generate 'count' column with positive integers\n        count_values = np.random.randint(1, 100, size=num_rows)\n\n        # Generate 'realised_pd' column with values between 0 and 1 (probabilities)\n        realised_pd_values = np.clip(np.random.rand(num_rows), 1e-6, 1 - 1e-6)  # Avoid log(0) issue\n\n        # Create DataFrame\n        data = pd.DataFrame({\n            'count': count_values,\n            'realised_pd': realised_pd_values\n        })\n        test_cases.append((data.copy(), 'realised_pd', 'count'))\n\n    return test_cases"}
{"problem_id": "pandas_65", "library": "pandas", "code_problem": "You are tasked with creating a function that modifies the columns of a given pandas DataFrame by appending units to the column names. The function should allow for an optional index label for the MultiIndex created from the original column names and the provided units.\n\nFunction signature:\n```python\ndef add_units(df: pd.DataFrame, units: dict, index_label: str = None) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- `df`: A pandas DataFrame with potentially multi-level column names.\n- `units`: A dictionary where keys are the original column names and values are the corresponding units to be appended.\n- `index_label`: An optional string that specifies the name for the first level of the MultiIndex.\n\nOutput format:\n- The function returns a pandas DataFrame with updated column names, where each column name is a tuple consisting of the original name and its corresponding unit, organized as a MultiIndex.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ndf = pd.DataFrame({\n    'A': [1.0, 2.0, 3.0],\n    'B': [4.0, 5.0, 6.0]\n})\nunits = {'A': 'kg', 'B': 'm'}\nindex_label = 'Measurement'\n\n# Call to the function\noutput_df = add_units(df, units, index_label)\n```\n\n**Output:**\n```python\n# Expected output DataFrame\npd.DataFrame({\n    ('A', 'kg'): [1.0, 2.0, 3.0],\n    ('B', 'm'): [4.0, 5.0, 6.0]\n})\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef add_units(df, units, index_label):\n    variables = df.columns.get_level_values(0)\n    if index_label == None:\n        idx = pd.MultiIndex.from_tuples(zip(variables, [units[q] for q in variables]))\n    else:\n        idx = pd.MultiIndex.from_tuples(zip(variables, [units[q] for q in variables]), names=[index_label, '-'])\n    df_out = df.copy()\n    df_out.columns = idx\n    return df_out", "test_script": "import pandas as pd\nimport numpy as np\nimport random\nimport string\n\n# Function to generate random column names\ndef random_column_names(n):\n    return [''.join(random.choices(string.ascii_uppercase, k=5)) for _ in range(n)]\n\n# Function to generate random units\ndef random_units(columns):\n    return {col: random.choice([\"m\", \"kg\", \"s\", \"A\", \"K\", \"mol\", \"cd\"]) for col in columns}\n\n# Function to generate random DataFrame\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_rows = random.randint(5, 100)\n        n_cols = random.randint(2, 20)\n        columns = random_column_names(n_cols)\n        data = np.random.rand(n_rows, n_cols)  # Random float values\n        df = pd.DataFrame(data, columns=columns)\n        units = random_units(columns)\n        index_label = random.choice([None, \"Variable\"])\n        test_cases.append((df, units, index_label))\n    return test_cases"}
{"problem_id": "pandas_66", "library": "pandas", "code_problem": "You are tasked with creating a function that generates a frequency DataFrame of n-grams from a list of text sentences. The function should count how many times each n-gram appears in the provided sentences, while also allowing for the exclusion of specified stopwords. The output should be a DataFrame containing the most frequent n-grams along with their counts.\n\nFunction Signature:\n```python\ndef generate_freq_df(value, n_gram, top_n, stopwords, verbose) -> pd.DataFrame:\n```\n\nConstants Used:\n- `defaultdict(int)`: This constant is used to create a dictionary that will hold n-grams as keys and their corresponding counts as values, initialized to zero.\n\n\nInput Format:\n- `value`: A list of strings, where each string is a sentence.\n- `n_gram`: An integer representing the size of the n-grams to generate.\n- `top_n`: An integer specifying how many of the most frequent n-grams to return.\n- `stopwords`: A list of strings representing words to be excluded from the n-gram generation.\n- `verbose`: A boolean indicating whether to print additional processing information.\n\nOutput Format:\n- The function returns a pandas DataFrame containing two columns: 'word' and 'word_count', representing the most frequent n-grams and their counts, respectively. The DataFrame will contain at most `top_n` rows.\n\nInput:\n```python\nvalue = [\"apple banana cherry\", \"date fig grape\", \"honey ice juice\"]\nn_gram = 2\ntop_n = 3\nstopwords = {\"the\", \"is\", \"at\", \"on\", \"and\", \"a\", \"of\", \"in\", \"to\", \"for\"}\nverbose = True\n```\n\nOutput:\n```\n        word  word_count\n0  ice juice           1\n1  honey ice           1\n2  fig grape           1\n```", "ground_truth_code": "from collections import defaultdict\nimport pandas as pd\n\ndef generate_ngrams(text, n_gram, stopwords) -> list:\n\n    token = [token for token in text.lower().split(' ') if token != '' if token not in stopwords]\n    ngrams = zip(*[token[i:] for i in range(n_gram)])\n    return [' '.join(ngram) for ngram in ngrams]\n\n# main code\ndef generate_freq_df(value, n_gram, top_n, stopwords, verbose):\n    freq_dict = defaultdict(int)\n    if verbose:\n        for sent in value:\n            for word in generate_ngrams(str(sent), n_gram, stopwords):\n                freq_dict[word] += 1\n    else:\n        for sent in value:\n            for word in generate_ngrams(str(sent), n_gram, stopwords):\n                freq_dict[word] += 1\n    output_df = pd.DataFrame(sorted(freq_dict.items(), key=lambda x: x[1])[::-1])\n    output_df.columns = ['word', 'word_count']\n    return output_df.head(top_n)", "test_script": "import random\n\n\n# Generate random test cases\ndef test_case_input_generator(n=200):\n    # Generate random sentences\n    def random_sentence(word_count, word_list):\n        return ' '.join(random.choices(word_list, k=word_count))\n\n    word_list = [\"apple\", \"banana\", \"cherry\", \"date\", \"elephant\", \"fig\", \"grape\", \"honey\", \"ice\", \"juice\"]\n    stopwords = {\"the\", \"is\", \"at\", \"on\", \"and\", \"a\", \"of\", \"in\", \"to\", \"for\"}\n\n    test_cases = []\n\n    for _ in range(n):\n        value = [random_sentence(random.randint(5, 15), word_list) for _ in range(random.randint(1, 10))]\n        n_gram = random.randint(1, 3)\n        top_n = random.randint(1, 5)\n        verbose = random.choice([True, False])\n\n        test_cases.append((value, n_gram, top_n, stopwords, verbose))\n\n    return test_cases"}
{"problem_id": "pandas_67", "library": "pandas", "code_problem": "You are tasked with creating a function that augments a given DataFrame by generating new rows based on specific transformations of its existing data. The function should manipulate the columns of the DataFrame in various ways to create new entries while ensuring that the resulting DataFrame contains unique rows.\n\nFunction Signature:\n```python\ndef augment(df: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant Used:\n- There are no constants explicitly defined in the code.\n\nInput Format:\n- The input to the function is a pandas DataFrame `df` that contains at least the columns 'A', 'B', 'C', and 'label'.\n\nOutput Format:\n- The output of the function is a pandas DataFrame that contains the original rows along with the newly generated rows, ensuring all rows are unique and shuffled.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a sample DataFrame\ninput_df = pd.DataFrame({\n    'A': [10, 20, 30],\n    'B': [40, 50, 60],\n    'C': [70, 80, 90],\n    'label': ['A', 'B', 'C']\n})\n```\n\n**Output:**\n```python\noutput_df = pd.DataFrame({\n    'A': [90, 10, 20, 70, 30, 80, 30, 90, 70, 50, 70, 70, 90, 20, 10, 80, 50, 90],\n    'B': [30, 40, 50, 10, 90, 80, 60, 60, 70, 80, 10, 40, 30, 80, 70, 20, 20, 90],\n    'C': [90, 70, 80, 70, 60, 20, 90, 30, 10, 20, 40, 10, 60, 50, 40, 80, 80, 30],\n    'label': ['C', 'A', 'B', 'C', 'B', 'B', 'C', 'C', 'B', 'C', 'B', 'C', 'B', 'C', 'B', 'C', 'B', 'B']\n})\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef augment(df):\n    df_cp1 = df.copy()\n    df_cp1['B'] = df['C']\n    df_cp1['C'] = df['B']\n    df_cp1['label'] = df_cp1['label'].apply(lambda label: 'C' if label == 'B' else 'B')\n    df_cp2 = df.copy()\n    df_cp2['A'] = df['C']\n    df_cp2['B'] = df['C']\n    df_cp2['C'] = df['A']\n    df_cp2['label'] = 'B'\n    df_cp3 = df.copy()\n    df_cp3['A'] = df['C']\n    df_cp3['B'] = df['A']\n    df_cp3['C'] = df['C']\n    df_cp3['label'] = 'C'\n    df_cp4 = df.copy()\n    df_cp4 = df_cp4.apply(lambda x: pd.Series((x['B'], x['A'], x['C'], 'B')) if x['label'] == 'B' else pd.Series((x['C'], x['B'], x['A'], 'C')), axis=1, result_type='broadcast')\n    df_cp5 = df.copy()\n    df_cp5 = df_cp5.apply(lambda x: pd.Series((x['B'], x['C'], x['A'], 'C')) if x['label'] == 'B' else pd.Series((x['C'], x['A'], x['B'], 'B')), axis=1, result_type='broadcast')\n    df = pd.concat([df, df_cp1, df_cp2, df_cp3, df_cp4, df_cp5])\n    df = df.drop_duplicates()\n    df = df.sample(frac=1)\n    return df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        \"\"\"Generates a random DataFrame with columns A, B, C, and label.\"\"\"\n        size = np.random.randint(5, 20)  # Random size between 5 and 20 rows\n        df = pd.DataFrame({\n            'A': np.random.randint(1, 100, size),\n            'B': np.random.randint(1, 100, size),\n            'C': np.random.randint(1, 100, size),\n            'label': np.random.choice(['A', 'B', 'C'], size)\n        })\n        test_cases.append(df)\n    return test_cases"}
{"problem_id": "pandas_68", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a DataFrame containing categorical data and computes the counts of occurrences for specified categories. The function should handle both single and multiple categorical variables and return a structured output that summarizes the counts along with margins.\n\nFunction Signature:\n```python\ndef categorical_value_counts(df: pd.DataFrame, is_single: bool, x_is_multi: bool, y_is_multi: bool) -> pd.DataFrame:\n```\n\nConstants Used:\n- The constant used in the main code is `0`, which is used to initialize counts in cases where there are no valid entries in the DataFrame.\n\n\nInput Format:\n- The input to the function is a pandas DataFrame `df` with at least three columns, where the first two columns contain categorical data and the last column contains numerical values to be aggregated.\n\nOutput Format:\n- The output of the function is a pandas DataFrame that summarizes the counts of occurrences for the specified categories, including margins, with appropriate multi-indexing for clarity.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case\ndf = pd.DataFrame({\n    'X': ['1;2', '2', '1;3', '3', '2;3'],\n    'Y': ['0;1', '1', '0', '1;2', '2'],\n    'W': [5, 3, 2, 4, 1]\n})\nis_single = False\nx_is_multi = True\ny_is_multi = True\n```\n\n**Output:**\n```python\nQuestion         Y           \nValues           0   1  2 All\nQuestion Values              \nX        1       7   5  0  12\n         2       5   8  1  14\n         3       2   4  5  11\n         All     7  12  5  24\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef categorical_value_counts(df, is_single, x_is_multi, y_is_multi):\n    if is_single:\n        if len(df.dropna().index) == 0:\n            ct = pd.DataFrame(0, ['@1'], ['nan']).T\n            margin = 0\n        else:\n            margin = df.dropna()[df.columns[-1]].sum()\n            if x_is_multi:\n                ct = pd.DataFrame(df[df.columns[0]].str.get_dummies(';').astype(int).mul(df[df.columns[-1]], axis=0).sum(axis=0), columns=['@1'])\n            else:\n                ct = pd.DataFrame(pd.get_dummies(df[df.columns[0]].dropna().astype(int)).mul(df[df.columns[-1]], axis=0).sum(axis=0), columns=['@1'])\n    elif len(df.dropna().index) == 0:\n        ct = pd.DataFrame(0, ['nan'], ['nan']).T\n        margin = 0\n    elif x_is_multi and y_is_multi:\n        df = df.dropna()\n        dummy_x_df = df[df.columns[0]].str.get_dummies(';').astype(int).mul(df[df.columns[-1]], axis=0)\n        dummy_y_df = df[df.columns[1]].str.get_dummies(';').astype(int)\n        dummy_y_df_columns = dummy_y_df.columns\n        dummy_y_df.columns = [df.columns[1] + '_' + code for code in dummy_y_df.columns]\n        dummy_full_df = pd.concat([dummy_x_df, dummy_y_df, df[df.columns[-1]]], axis=1)\n        margin = [dummy_full_df[dummy_full_df[code] == 1][df.columns[-1]].sum(axis=0) for code in dummy_y_df.columns]\n        ct = pd.concat([dummy_full_df[dummy_full_df[code] == 1][dummy_x_df.columns].sum(axis=0) for code in dummy_y_df.columns], axis=1)\n        ct.columns = dummy_y_df_columns\n    elif y_is_multi:\n        dummy_x_df = pd.DataFrame(pd.get_dummies(df[df.columns[0]]).mul(df[df.columns[-1]], axis=0))\n        dummy_y_df = df[df.columns[1]].str.get_dummies(';').astype(int)\n        dummy_y_df_columns = dummy_y_df.columns\n        dummy_y_df.columns = [df.columns[1] + '_' + code for code in dummy_y_df.columns]\n        dummy_full_df = pd.concat([dummy_x_df, dummy_y_df], axis=1)\n        ct = pd.concat([dummy_full_df[dummy_full_df[code] == 1][dummy_x_df.columns].sum(axis=0) for code in dummy_y_df.columns], axis=1)\n        ct.index = ct.index.astype(int)\n        margin = ct.sum(axis=0).values\n        ct.columns = dummy_y_df_columns\n    elif x_is_multi:\n        df = df.dropna()\n        dummy_x_df = df[df.columns[0]].str.get_dummies(';').astype(int).mul(df[df.columns[-1]], axis=0)\n        dummy_y_df = pd.DataFrame(pd.get_dummies(df[df.columns[1]].astype(int)))\n        dummy_y_df_columns = dummy_y_df.columns\n        dummy_y_df.columns = [df.columns[1] + '_' + str(code) for code in dummy_y_df.columns]\n        dummy_full_df = pd.concat([dummy_x_df, dummy_y_df, df[df.columns[-1]]], axis=1)\n        margin = [dummy_full_df[dummy_full_df[code] == 1][df.columns[-1]].sum(axis=0) for code in dummy_y_df.columns]\n        ct = pd.concat([dummy_full_df[dummy_full_df[code] == 1][dummy_x_df.columns].sum(axis=0) for code in dummy_y_df.columns], axis=1)\n        ct.columns = dummy_y_df_columns\n    else:\n        df = df.dropna()\n        ct = pd.crosstab(index=df[df.columns[0]].astype(int), columns=df[df.columns[1]].astype(int), values=df[df.columns[2]], aggfunc='sum')\n        margin = ct.sum(axis=0)\n    ct = ct.T\n    ct['All'] = margin\n    ct = ct.T\n    ct['All'] = ct.sum(axis=1)\n    ct.index = pd.MultiIndex.from_product([[df.columns[0]], ct.index.astype(str)], names=['Question', 'Values'])\n    ct.columns = pd.MultiIndex.from_product([[df.columns[-2]], ct.columns.astype(str)], names=['Question', 'Values'])\n    return ct", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_dataframe(x_is_multi, y_is_multi):\n        num_rows = random.randint(1, 10)  # Small sample size for controlled testing\n\n        # Generate X column\n        if x_is_multi:\n            x_values = [';'.join(map(str, random.sample(range(5), random.randint(1, 3)))) for _ in range(num_rows)]\n        else:\n            x_values = np.random.randint(0, 5, num_rows)\n\n        # Generate Y column\n        if y_is_multi:\n            y_values = [';'.join(map(str, random.sample(range(5), random.randint(1, 3)))) for _ in range(num_rows)]\n        else:\n            y_values = np.random.randint(0, 5, num_rows)\n\n        # Generate weights column\n        weights = np.random.randint(1, 10, num_rows)\n\n        df = pd.DataFrame({\n            'X': x_values,\n            'Y': y_values,\n            'W': weights\n        })\n        return df\n\n    test_cases = []\n    for _ in range(n):\n        is_single = random.choice([True, False])\n        x_is_multi = random.choice([True, False])\n        y_is_multi = random.choice([True, False])\n        df = generate_random_dataframe(x_is_multi, y_is_multi)\n        test_cases.append((df, is_single, x_is_multi, y_is_multi))\n\n    return test_cases"}
{"problem_id": "pandas_69", "library": "pandas", "code_problem": "You are tasked with implementing a function that manages the addition of new data associated with financial symbols into a DataFrame while ensuring that existing data is preserved and updated correctly. The function should also handle the removal of symbols if they already exist and the user opts not to overwrite them.\n\nFunction signature:\n```python\ndef append_df_symbol(df: pd.DataFrame, symbol_name: str, overwrite: bool, symbols: list, data_d: pd.DataFrame) -> pd.DataFrame:\n```\n\n### Constants:\n- The constant used in the main code is `None`, which is used to check for the absence of data in the `data_q` parameter.\n\n### Input Format:\n- `df`: A pandas DataFrame containing new data to be added.\n- `symbol_name`: A string representing the financial symbol to be added.\n- `overwrite`: A boolean indicating whether to overwrite existing data for the symbol.\n- `symbols`: A list of strings representing the currently managed symbols.\n- `data_d`: A pandas DataFrame containing existing data associated with the symbols.\n\n### Output Format:\n- Returns a pandas DataFrame that contains the updated data, including the new symbol and its associated data, while preserving existing data.\n\n**Input:**\n```python\ndf = pd.DataFrame({\n    'Field_0': [0.1, 0.2, 0.3],\n    'Field_1': [0.4, 0.5, 0.6]\n})\nsymbol_name = \"SYM_1\"\noverwrite = False\nsymbols = []\ndata_d = pd.DataFrame()\n\n# Call the function\ndata_d = append_df_symbol(df, symbol_name, overwrite, symbols, data_d)\n```\n\n**Output:**\n```python\ndata_d\n# Expected Output:\n#          SYM_1          \n#       Field_0 Field_1\n# 0        0.1      0.4\n# 1        0.2      0.5\n# 2        0.3      0.6\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef add_symbol(symbol_name, symbols):\n    if symbol_name not in symbols:\n        symbols.append(symbol_name)\n\n\ndef remove_symbol(symbols, data_q, data_d):\n    if isinstance(symbols, str):\n        symbols = symbols.split(',')\n\n    # Iterate over a copy to avoid modifying the list during iteration\n    for symbol in symbols.copy():\n        if symbol not in symbols:  # This check is redundant\n            continue\n\n        if data_d is not None and not data_d.empty:\n            if isinstance(data_d.columns, pd.MultiIndex):\n                if symbol in data_d.columns.get_level_values(0):\n                    data_d.drop(symbol, axis=1, level=0, inplace=True)\n                    data_d.columns = data_d.columns.remove_unused_levels()\n            else:\n                if symbol in data_d.columns:\n                    data_d.drop(symbol, axis=1, inplace=True)\n\n        if data_q is not None and not data_q.empty:\n            if isinstance(data_q.columns, pd.MultiIndex):\n                if symbol in data_q.columns.get_level_values(0):\n                    data_q.drop(symbol, axis=1, level=0, inplace=True)\n                    data_q.columns = data_q.columns.remove_unused_levels()\n            else:\n                if symbol in data_q.columns:\n                    data_q.drop(symbol, axis=1, inplace=True)\n\n        symbols.remove(symbol)\n\n\n# main code\ndef append_df_symbol(df, symbol_name, overwrite, symbols, data_d):\n    if symbol_name in symbols:\n        if overwrite:\n            remove_symbol([symbol_name], data_q=None, data_d=data_d)\n        else:\n            return data_d\n\n    df = df.copy()\n\n    # Ensure data_d is not empty and has a MultiIndex\n    if not data_d.empty and isinstance(data_d.columns, pd.MultiIndex):\n        exist_fields = data_d.columns.levels[1]\n    else:\n        exist_fields = df.columns  # Default to df's columns if data_d is empty or not MultiIndex\n\n    # Ensure all existing fields are present in df\n    if set(exist_fields) - set(df.columns):\n        df2 = pd.DataFrame(index=df.index, columns=exist_fields, data=np.nan)\n        df2.update(df)\n        df = df2\n\n    # Create MultiIndex and merge data\n    df.columns = pd.MultiIndex.from_product([[symbol_name], exist_fields])\n\n    if data_d.empty:\n        data_d = df\n    else:\n        data_d = pd.merge(data_d, df, left_index=True, right_index=True, how='left').sort_index(axis=1)\n\n    add_symbol(symbol_name, symbols)\n    return data_d", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    symbols = []  # Simulating the existing symbols list\n    data_d = pd.DataFrame()  # Simulating the existing data_d DataFrame\n\n    for i in range(n):\n        symbol_name = f\"SYM_{random.randint(1, 50)}\"\n        overwrite = random.choice([True, False])\n\n        # Generate a random dataframe\n        num_rows = random.randint(5, 100)\n        num_cols = random.randint(2, 10)\n        col_names = [f\"Field_{j}\" for j in range(num_cols)]\n        df = pd.DataFrame(np.random.rand(num_rows, num_cols), columns=col_names)\n\n        test_cases.append((df, symbol_name, overwrite, symbols, data_d))\n    return test_cases"}
{"problem_id": "pandas_70", "library": "pandas", "code_problem": "You are tasked with implementing a function that fits an Elastic Net regression model to a given dataset and optionally adjusts the input features based on a Bayesian covariance approach. The function should return the coefficients of the fitted model, the adjusted input features, and the residuals of the predictions.\n\nFunction signature:\n```python\ndef run_model_bycol(Y, X, EM_cols, modalpha, verbose):\n```\n\n### Constants:\n- The constant used in the main code is `0.0004`, which is the alpha parameter for the second Elastic Net model fitting when `EM_cols` is provided.\n\n### Input Format:\n- `Y`: A DataFrame representing the target variable.\n- `X`: A DataFrame representing the input features.\n- `EM_cols`: A list of column names in `X` to be adjusted using the Bayesian covariance approach (can be `None`).\n- `modalpha`: A float representing the alpha parameter for the first Elastic Net model.\n- `verbose`: An integer (0 or 1) indicating whether to print model scores.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A DataFrame of coefficients from the fitted model.\n  - A DataFrame of adjusted input features.\n  - A DataFrame of residuals from the predictions.\n\n**Input:**\n```python\nY = pd.DataFrame({\n    'Y0': [1.2, 0.5, 1.5, 2.0, 1.8],\n    'Y1': [0.8, 1.0, 1.2, 1.5, 1.1]\n})\nX = pd.DataFrame({\n    'X0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'X1': [1.0, 1.1, 1.2, 1.3, 1.4],\n    'X2': [0.5, 0.6, 0.7, 0.8, 0.9]\n})\nEM_cols = ['X0', 'X1']\nmodalpha = 0.001\nverbose = 1\n```\n\n**Output:**\n```python\n# Be\n          X0        X1        X2\nY0 -0.765129  2.883395  1.730785\nY1  4.087757 -0.647586  0.816268\n\n# X_adjust\n         X0        X1   X2\n0  0.511405  0.773275  0.5\n1  0.460780  0.495371  0.6\n2  0.536976  0.820203  0.7\n3  0.612437  0.923465  0.8\n4  0.496497  0.738726  0.9\n\n# RES_out\n         Y0        Y1\n0  0.070302 -0.091882\n1 -0.040206  0.053469\n2 -0.091604  0.070728\n3 -0.004689  0.047505\n4  0.066198 -0.079819\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport sklearn\n\ndef bayes_cov_col(Y, X, cols, lm):\n    Yhat = pd.DataFrame(lm.predict(X))\n    Yhat.index = Y.index\n    Yhat.columns = Y.columns\n    SSE_all = np.square(Y.subtract(Yhat))\n    X_adjust = X.copy()\n    df_SSE = []\n    df_logit = []\n    for curcov in cols:\n        curcells = X[X[curcov] > 0].index\n        if len(curcells) > 2:\n            X_notcur = X.copy()\n            X_notcur[curcov] = [0] * len(X_notcur)\n            X_sub = X_notcur.loc[curcells]\n            Y_sub = Y.loc[curcells]\n            GENE_var = 2.0 * Y_sub.var(axis=0)\n            vargenes = GENE_var[GENE_var > 0].index\n            Yhat_notcur = pd.DataFrame(lm.predict(X_sub))\n            Yhat_notcur.index = Y_sub.index\n            Yhat_notcur.columns = Y_sub.columns\n            SSE_notcur = np.square(Y_sub.subtract(Yhat_notcur))\n            SSE = SSE_all.loc[curcells].subtract(SSE_notcur)\n            SSE_sum = SSE.sum(axis=1)\n            SSE_transform = SSE.div(GENE_var + 0.5)[vargenes].sum(axis=1)\n            logitify = np.divide(1.0, 1.0 + np.exp(SSE_transform))\n            df_SSE.append(SSE_sum)\n            df_logit.append(logitify)\n            X_adjust[curcov].loc[curcells] = logitify\n    return X_adjust\n\n# main code\ndef run_model_bycol(Y, X, EM_cols, modalpha, verbose):\n    enet = sklearn.linear_model.ElasticNet(precompute=True, l1_ratio=0.5, alpha=modalpha, max_iter=10000)\n    enet.fit(X, Y)\n    if verbose == 1:\n        print(enet.score(X, Y))\n    Be = pd.DataFrame(enet.coef_)\n    Be.columns = X.columns\n    Be.index = Y.columns\n    Yhat = pd.DataFrame(enet.predict(X))\n    Yhat.index = Y.index\n    Yhat.columns = Y.columns\n    if EM_cols is not None:\n        X_adjust = bayes_cov_col(Y, X, EM_cols, enet)\n        enet = sklearn.linear_model.ElasticNet(precompute=True, l1_ratio=0.5, alpha=0.0004, max_iter=10000)\n        enet.fit(X_adjust, Y)\n        Yhat = pd.DataFrame(enet.predict(X_adjust))\n        Yhat.index = Y.index\n        Yhat.columns = Y.columns\n        if verbose == 1:\n            print(enet.score(X_adjust, Y))\n        Be = pd.DataFrame(enet.coef_)\n        Be.columns = X_adjust.columns\n        Be.index = Y.columns\n    else:\n        X_adjust = X.copy()\n    RES_out = Y.subtract(Yhat)\n    return (Be, X_adjust, RES_out)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\n# Function to generate a single test case\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_features = np.random.randint(5, 20)\n        n_targets = np.random.randint(2, 10)\n        n_samples = np.random.randint(10, 100)\n\n        X = pd.DataFrame(np.random.randn(n_samples, n_features))\n        X.columns = [f'X{i}' for i in range(n_features)]\n\n        Y = pd.DataFrame(np.random.randn(n_samples, n_targets))\n        Y.columns = [f'Y{i}' for i in range(n_targets)]\n\n        num_cols = random.randint(1, n_features // 2)\n        EM_cols = random.sample(list(X.columns), num_cols)\n\n        modalpha = np.random.uniform(0.0001, 0.01)\n        verbose = random.choice([0, 1])\n        test_cases.append((Y, X, EM_cols, modalpha, verbose))\n\n    return test_cases"}
{"problem_id": "pandas_71", "library": "pandas", "code_problem": "You are tasked with analyzing the time difference between two sets of dates related to ownership or control interests and their corresponding statements. The goal is to compute the duration in days between the statement date and the start date for each record, and then summarize this information.\n\nFunction Signature:\n```python\ndef q812(ownershipOrControlInterest, ownershipOrControlStatement):\n```\n\nConstant Used:\n- The constant used in the main code is `1`, which is utilized in the division operation to convert the time difference from a timedelta object to a number of days.\n\nInput Format:\n- The function takes two parameters:\n  - `ownershipOrControlInterest`: A DataFrame containing at least the columns `_link_ooc_statement` and `startDate`.\n  - `ownershipOrControlStatement`: A DataFrame containing at least the columns `_link` and `statementDate`.\n\nOutput Format:\n- The function returns a DataFrame containing descriptive statistics of the duration in days between `statementDate` and `startDate`, excluding the standard deviation.\n\n**Input:**\n```python\nownershipOrControlInterest = pd.DataFrame({\n    '_link_ooc_statement': ['link_1', 'link_2', 'link_3'],\n    'startDate': [pd.Timestamp('2020-01-10'), pd.Timestamp('2020-02-15'), pd.Timestamp('2020-03-20')]\n})\n\nownershipOrControlStatement = pd.DataFrame({\n    '_link': ['link_1', 'link_2', 'link_3', 'link_4'],\n    'statementDate': [pd.Timestamp('2020-01-20'), pd.Timestamp('2020-02-25'), pd.Timestamp('2020-04-01'), pd.Timestamp('2020-05-01')]\n})\n```\n\n**Output:**\n```python\n       statementDate-startDate\ncount                 3.000000\nmean                 10.666667\nmin                  10.000000\n25%                  10.000000\n50%                  10.000000\n75%                  11.000000\nmax                  12.000000\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef q812(ownershipOrControlInterest, ownershipOrControlStatement):\n    oocMerged = pd.merge(ownershipOrControlInterest[['_link_ooc_statement', 'startDate']], ownershipOrControlStatement[['_link', 'statementDate']], left_on='_link_ooc_statement', right_on='_link', how='left')\n    oocMerged['startDate'] = pd.to_datetime(oocMerged['startDate'])\n    oocMerged['statementDate'] = pd.to_datetime(oocMerged['statementDate'])\n    oocMerged['statementDate-startDate'] = oocMerged['statementDate'] - oocMerged['startDate']\n    oocMerged['statementDate-startDate'] = oocMerged['statementDate-startDate'] / np.timedelta64(1, 'D')\n    out = oocMerged['statementDate-startDate'].to_frame().describe().drop(index=['std'])\n    return out", "test_script": "import pandas as pd\nimport numpy as np\nimport random\nfrom datetime import datetime, timedelta\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_rows_interest = random.randint(5, 50)\n        n_rows_statement = random.randint(5, 50)\n\n        links = [f\"link_{i}\" for i in range(max(n_rows_interest, n_rows_statement))]\n        random.shuffle(links)\n\n        ownershipOrControlInterest = pd.DataFrame({\n            '_link_ooc_statement': np.random.choice(links, n_rows_interest),\n            'startDate': [datetime(2020, 1, 1) + timedelta(days=random.randint(0, 1000)) for _ in range(n_rows_interest)]\n        })\n\n        ownershipOrControlStatement = pd.DataFrame({\n            '_link': np.random.choice(links, n_rows_statement),\n            'statementDate': [datetime(2020, 1, 1) + timedelta(days=random.randint(0, 1000)) for _ in\n                              range(n_rows_statement)]\n        })\n        test_cases.append((ownershipOrControlInterest, ownershipOrControlStatement))\n    return test_cases"}
{"problem_id": "pandas_72", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a pandas Series by grouping it based on another Series and applying a lumping operation to the groups. The goal is to combine small categories into a single category labeled as '_lumped_other' based on a specified proportion threshold.\n\nFunction Signature:\n```python\ndef fct_lump_by(s: pd.Series, by: pd.Series, prop: float) -> pd.Series:\n```\n\nConstant Used:\n- The constant used in the main code is the string `'_lumped_other'`, which serves as the label for the combined category of small groups.\n\nInput Format:\n- The function expects two pandas Series (`s` and `by`) and a float (`prop`) as input.\n\nOutput Format:\n- The function returns a pandas Series with the same index as the input Series `s`, where small categories have been replaced with the lumped category name.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ns = pd.Series(['cat_0', 'cat_1', 'cat_0', 'cat_2', 'cat_1', 'cat_3', 'cat_0', 'cat_4', 'cat_1', 'cat_5'])\nby = pd.Series(['group_1', 'group_1', 'group_1', 'group_2', 'group_2', 'group_2', 'group_1', 'group_2', 'group_1', 'group_2'])\nprop = 0.2\n```\n\n**Output:**\n```python\n# Expected output\n0    cat_0\n1    cat_1\n2    cat_0\n3    cat_0\n4    cat_1\n5    cat_2\n6    cat_1\n7    cat_3\n8    cat_4\n9    cat_5\ndtype: object\n```", "ground_truth_code": "import pandas as pd\n\ndef fct_lump(s, prop):\n    props = s.value_counts() / s.shape[0]\n    small_categories = props[props < prop].index.tolist()\n    remainder_category_name = '_lumped_other'\n    while remainder_category_name in props.index:\n        remainder_category_name = remainder_category_name * 2\n    if s.dtype.name == 'category':\n        s = s.astype('object')\n    s.loc[s.apply(lambda x: x in small_categories)] = remainder_category_name\n    return s\n\n# main code\ndef fct_lump_by(s, by, prop):\n    s_index = s.index\n    s = s.reset_index(drop=True)\n    by = by.reset_index(drop=True)\n    res = s.groupby(by).apply(lambda x: fct_lump(x, prop=prop))\n    res.index = s_index\n    return res", "test_script": "import pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Randomly determine the number of unique categories\n        num_categories = random.randint(5, 20)\n        category_labels = [f\"cat_{i}\" for i in range(num_categories)]\n\n        # Randomly determine the number of data points\n        num_data_points = random.randint(10, 100)\n\n        # Generate the categorical series\n        s_values = random.choices(category_labels, k=num_data_points)\n        s = pd.Series(s_values)\n\n        # Generate the grouping factor\n        num_groups = random.randint(1, min(num_data_points, 10))\n        group_labels = [f\"group_{i}\" for i in range(num_groups)]\n        by_values = random.choices(group_labels, k=num_data_points)\n        by = pd.Series(by_values)\n\n        # Randomly choose a prop value\n        prop = round(random.uniform(0.01, 0.5), 2)\n\n        test_cases.append((s, by, prop))\n    return test_cases"}
{"problem_id": "pandas_73", "library": "pandas", "code_problem": "You are tasked with creating a function that filters out specific data points from a time series DataFrame based on a list of dropped points. The function will take two DataFrames as input: one representing the time series data and another representing the points to be dropped. The function will replace the values in the time series DataFrame with NaN for the specified dates associated with each transect ID in the dropped points DataFrame.\n\nFunction signature:\n```python\ndef filter_dropped_points_out_of_timeseries(timeseries_df, dropped_points_df):\n```\n\nConstant used in the main code:\n- `np.nan`: This constant from the NumPy library is used to represent missing values in the DataFrame.\n\nInput format:\n- `timeseries_df`: A pandas DataFrame with at least two columns: 'dates' and one or more columns representing different transect IDs.\n- `dropped_points_df`: A pandas DataFrame with at least two columns: 'transect_id' and 'dates', where 'transect_id' corresponds to the columns in `timeseries_df`.\n\nOutput format:\n- The function returns a pandas DataFrame that is a modified version of `timeseries_df`, with NaN values in place of the dropped points for the specified transect IDs.\n\n**Input:**\n```python\ntimeseries_df = pd.DataFrame({\n    'dates': pd.date_range(start='2020-01-01', periods=5, freq='D'),\n    'transect_1': [10, 20, 30, 40, 50],\n    'transect_2': [15, 25, 35, 45, 55]\n})\n\ndropped_points_df = pd.DataFrame({\n    'transect_id': ['transect_1', 'transect_1', 'transect_2'],\n    'dates': [pd.Timestamp('2020-01-02'), pd.Timestamp('2020-01-04'), pd.Timestamp('2020-01-03')]\n})\n```\n\n**Output:**\n```python\n       dates  transect_1  transect_2\n0 2020-01-01        10.0        15.0\n1 2020-01-02         NaN        25.0\n2 2020-01-03        30.0         NaN\n3 2020-01-04         NaN        45.0\n4 2020-01-05        50.0        55.0\n```\n", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef filter_dropped_points_out_of_timeseries(timeseries_df, dropped_points_df):\n\n    for t_id in dropped_points_df['transect_id'].unique():\n        dates_to_drop = dropped_points_df.loc[dropped_points_df['transect_id'] == t_id, 'dates']\n        timeseries_df.loc[timeseries_df['dates'].isin(dates_to_drop), t_id] = np.nan\n    return timeseries_df", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_dates = np.random.randint(50, 100)\n        n_transects = np.random.randint(2, 5)\n        drop_ratio = random.uniform(0.1, 0.5)\n        # Generate a set of random dates\n        dates = pd.date_range(start='2020-01-01', periods=n_dates, freq='D')\n\n        # Generate timeseries data with random values\n        transect_ids = [f'transect_{i}' for i in range(1, n_transects + 1)]\n        data = {t_id: np.random.rand(n_dates) * 100 for t_id in transect_ids}\n        timeseries_df = pd.DataFrame(data, index=dates).reset_index()\n        timeseries_df.rename(columns={'index': 'dates'}, inplace=True)\n\n        # Determine random points to drop\n        dropped_data = []\n        for t_id in transect_ids:\n            drop_dates = random.sample(list(dates), int(n_dates * drop_ratio))\n            dropped_data.extend([(t_id, d) for d in drop_dates])\n\n        dropped_points_df = pd.DataFrame(dropped_data, columns=['transect_id', 'dates'])\n        test_cases.append((timeseries_df, dropped_points_df))\n    return test_cases"}
{"problem_id": "pandas_74", "library": "pandas", "code_problem": "You are tasked with implementing a function that applies a specified function to certain fields of a DataFrame and concatenates the results back to the original DataFrame. The function signature is as follows:\n\n```python\ndef apply_and_concat(df, fields, func, column_names, func_args):\n```\n\n### Constants:\n- The constant used in the main code is the `axis` parameter in the `pd.concat` function, which is set to `1` to concatenate along the columns.\n\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `df`: A pandas DataFrame containing the data.\n  - `fields`: A list of column names in `df` to which the function will be applied.\n  - `func`: A function that takes a row and additional arguments, returning a list or tuple of values.\n  - `column_names`: A list of names for the new columns that will be created in the resulting DataFrame.\n  - `func_args`: A tuple of additional arguments to be passed to `func`.\n\n- **Output**: The function returns a pandas DataFrame that includes the original data along with the new columns generated by applying `func` to the specified fields.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndf = pd.DataFrame({\n    'col_0': [10, 20, 30],\n    'col_1': [40, 50, 60],\n    'col_2': [70, 80, 90]\n})\n\nfields = ['col_0', 'col_1']\nfunc = lambda row, factor: [val * factor for val in row]\ncolumn_names = ['out_0', 'out_1']\nfunc_args = (2,)\n\n# Call to the function\nresult_df = apply_and_concat(df, fields, func, column_names, func_args)\n```\n\n**Output:**\n```python\n   col_0  col_1  col_2  out_0  out_1\n0     10     40     70     20     80\n1     20     50     80     40    100\n2     30     60     90     60    120\n```\n", "ground_truth_code": "import pandas as pd\n\n# main code\ndef apply_and_concat(df, fields, func, column_names, func_args):\n    d = {column_name: [] for column_name in column_names}\n    for _, row in df[fields].iterrows():\n        out_values = func(row, *func_args)\n        for ind, column_name in enumerate(column_names):\n            d[column_name].append(out_values[ind])\n    df2 = pd.DataFrame(d, index=df.index)\n    return pd.concat((df, df2), axis=1, sort=True)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    def sample_func(row, factor):\n        return [val * factor for val in row]\n\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = random.randint(5, 100)\n        num_cols = random.randint(5, 10)\n\n        columns = [f'col_{i}' for i in range(num_cols)]\n\n        df = pd.DataFrame(np.random.randint(1, 100, size=(num_rows, num_cols)), columns=columns)\n\n        num_fields = random.randint(1, num_cols)\n        fields = random.sample(columns, num_fields)\n\n        column_names = [f'out_{i}' for i in range(len(fields))]\n\n        func_args = (random.randint(1, 5),)\n        test_cases.append((df, fields, sample_func, column_names, func_args))\n\n    return test_cases"}
{"problem_id": "pandas_75", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the pairwise differences between the rows of a given DataFrame. The function should return a new DataFrame that includes the original data along with the computed differences.\n\nFunction signature:\n```python\ndef row_pairwise_diffs(df):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the `combinations` function from the `itertools` module, which is utilized to generate all possible pairs of row indices from the DataFrame.\n\nInput format:\n- The input to the function is a pandas DataFrame `df` with numerical values.\n\nOutput format:\n- The output of the function is a pandas DataFrame that includes the original data along with additional rows representing the pairwise differences between the rows of the input DataFrame. Each difference row is labeled with the corresponding source indices.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'col_0': [10, 20, 30],\n    'col_1': [5, 15, 25]\n}\nindex = [0, 1, 2]\ndf = pd.DataFrame(data, index=index)\n```\n\n**Output:**\n```python\n       col_0  col_1\n0         10      5\n1         20     15\n2         30     25\n1 - 0     10     10\n2 - 0     20     20\n2 - 1     10     10\n```", "ground_truth_code": "from itertools import combinations\nimport pandas as pd\n\n# main code\ndef row_pairwise_diffs(df):\n    c = combinations(sorted(df.index), 2)\n    diffs = []\n    for j, i in c:\n        d = df.loc[i] - df.loc[j]\n        d = d.to_frame().transpose().assign(source=f'{i} - {j}').set_index('source')\n        diffs.append(d)\n    return pd.concat([df] + diffs)", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(5, 20)  # Ensure at least 2 rows\n        num_cols = np.random.randint(2, 10)  # Ensure at least 1 column\n\n        index_values = np.random.choice(range(100), num_rows, replace=False)  # Unique index values\n        column_names = [f'col_{i}' for i in range(num_cols)]\n\n        data = np.random.randint(-100, 100, size=(num_rows, num_cols))  # Random integer values\n        df = pd.DataFrame(data, index=sorted(index_values), columns=column_names)\n        test_cases.append(df)\n    return test_cases"}
{"problem_id": "pandas_76", "library": "pandas", "code_problem": "You are tasked with creating a function that processes a pandas Series to group infrequent categories into a single category labeled as '_lumped_other'. The function should take in a Series and a threshold proportion, and it should replace categories that appear less frequently than the specified proportion with the lumped category name. The function should also ensure that the lumped category name is unique by appending a number if it already exists in the Series.\n\nFunction signature:\n```python\ndef fct_lump(s: pd.Series, prop: float) -> pd.Series:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the string `'_lumped_other'`, which serves as the base name for the lumped category.\n\nInput format:\n- The function takes a pandas Series `s` and a float `prop`.\n\nOutput format:\n- The function returns a pandas Series with the small categories replaced by a single lumped category.\n\nInput:\n```python\nimport pandas as pd\n\n# Test case input\ntest_case = (\n    pd.Series(['cat_0', 'cat_1', 'cat_0', 'cat_2', 'cat_1', 'cat_0', 'cat_3', 'cat_4', 'cat_0', 'cat_5'], dtype=\"category\"),\n    0.2\n)\n```\n\nOutput:\n```python\npd.Series(['cat_0', 'cat_1', 'cat_0', '_lumped_other', 'cat_1', 'cat_0', '_lumped_other', '_lumped_other', 'cat_0', '_lumped_other'], dtype=\"object\")\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef fct_lump(s, prop):\n    props = s.value_counts() / s.shape[0]\n    small_categories = props[props < prop].index.tolist()\n    remainder_category_name = '_lumped_other'\n    while remainder_category_name in props.index:\n        remainder_category_name = remainder_category_name * 2\n    if s.dtype.name == 'category':\n        s = s.astype('object')\n    s.loc[s.apply(lambda x: x in small_categories)] = remainder_category_name\n    return s", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Randomly determine the number of unique categories\n        num_categories = np.random.randint(2, 20)\n\n        # Generate a categorical distribution with some dominant and some rare categories\n        values = np.random.choice([f'cat_{i}' for i in range(num_categories)],\n                                  size=np.random.randint(10, 500),\n                                  p=np.random.dirichlet(np.ones(num_categories)))\n\n        # Convert to pandas Series\n        series = pd.Series(values, dtype=\"category\")\n\n        # Generate a random proportion threshold between 0.01 and 0.2\n        prop = np.random.uniform(0.01, 0.2)\n\n        test_cases.append((series, prop))\n\n    return test_cases"}
{"problem_id": "pandas_77", "library": "pandas", "code_problem": "You are tasked with creating a function that summarizes statistical information about a given pandas Series. The function will compute various statistics such as minimum, median, mean, mode, and maximum values, and return them in a structured format. \n\nFunction signature:\n```python\ndef summarize_time(data: pd.Series, raw_output: bool) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- `index_list`: A list containing the strings `['min', 'median', 'mean', 'mode', 'max']`, which represents the statistical measures to be calculated.\n\nInput format:\n- `data`: A pandas Series containing numerical values.\n- `raw_output`: A boolean indicating whether to return the raw output or a formatted output.\n\nOutput format:\n- A pandas DataFrame containing the summarized statistics, with appropriate labels and formatting based on the `raw_output` parameter.\n\n**Input:**\n```python\ndata = pd.Series([timedelta(seconds=10), timedelta(seconds=20), timedelta(seconds=30), timedelta(seconds=40), timedelta(seconds=50)], name=\"time_data\")\nraw_output = False\n```\n\n**Output:**\n```python\n                    count             mean  ...              max            Total\nQuestion  Values                            ...                                  \ntime_data time_data     5  0 days 00:00:30  ...  0 days 00:00:50              NaN\n          min         NaN              NaN  ...              NaN  0 days 00:00:10\n          median      NaN              NaN  ...              NaN  0 days 00:00:30\n          mean        NaN              NaN  ...              NaN  0 days 00:00:30\n          mode        NaN              NaN  ...              NaN  0 days 00:00:10\n          max         NaN              NaN  ...              NaN  0 days 00:00:50\n[6 rows x 9 columns]\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef summarize_time(data, raw_output):\n    index_list = ['min', 'median', 'mean', 'mode', 'max']\n    summary = [data.min(), data.median(), data.mean(), data.mode(), data.max()]\n    mode_value = summary[3].iloc[0] if not summary[3].empty else None\n    summary[3] = mode_value\n    summary_df = pd.DataFrame(summary, index=index_list, columns=['Total'])\n    summary_df['Total'] = summary_df['Total'].astype(str)\n    describe_df = data.describe().to_frame().T\n    df = pd.concat([describe_df, summary_df])\n    if not raw_output:\n        df.index = pd.MultiIndex.from_product([[data.name], df.index], names=['Question', 'Values'])\n    return df", "test_script": "import pandas as pd\nimport random\nfrom datetime import timedelta\n\ndef test_case_input_generator(n=200):\n    def generate_random_timedelta_series(size, name=\"time_data\"):\n        \"\"\"Generate a pandas Series of random timedelta values.\"\"\"\n        time_deltas = [timedelta(seconds=random.randint(1, 1000000)) for _ in range(size)]\n        return pd.Series(time_deltas, name=name)\n\n    \"\"\"Generate n test cases with different timedelta distributions.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        size = random.randint(5, 1000)  # Varying sizes of input data\n        raw_output = random.choice([True, False])  # Random choice for raw_output\n        data = generate_random_timedelta_series(size)\n        test_cases.append((data, raw_output))\n    return test_cases"}
{"problem_id": "pandas_78", "library": "pandas", "code_problem": "You are tasked with implementing a function that infers intra-factoid totals from a given set of calculation components and metadata dimensions. The function will analyze the relationships between different dimensions and their corresponding totals, and return a modified DataFrame that includes inferred totals.\n\nFunction signature:\n```python\ndef infer_intra_factoid_totals(calc_components, meta_w_dims, table_dimensions, dimensions):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is assigned as the weight for the inferred totals.\n\nInput format:\n- `calc_components`: A DataFrame containing calculation components.\n- `meta_w_dims`: A DataFrame containing metadata with dimensions.\n- `table_dimensions`: A DataFrame containing dimensions related to tables.\n- `dimensions`: A list of dimension names to be used for calculations.\n\nOutput format:\n- A DataFrame that includes the original calculation components along with any inferred totals, marked appropriately with the `is_total_to_subdimensions_calc` column.\n\n**Input:**\n```python\ncalc_components = pd.DataFrame({\n    \"table_name\": [\"table1\", \"table2\", \"table3\"],\n    \"xbrl_factoid\": [\"fact1\", \"fact2\", \"fact3\"],\n    \"is_total_to_subdimensions_calc\": [False, True, False]\n})\n\nmeta_w_dims = pd.DataFrame({\n    \"table_name\": [\"table1\", \"table2\", \"table3\"],\n    \"xbrl_factoid\": [\"fact1\", \"fact2\", \"fact3\"],\n    \"dim1\": [\"total\", \"A\", \"B\"],\n    \"dim2\": [\"X\", \"total\", \"Y\"],\n    \"dim3\": [None, \"M\", \"total\"]\n})\n\ntable_dimensions = pd.DataFrame({\n    \"table_name\": [\"table1\", \"table2\", \"table3\"],\n    \"xbrl_factoid\": [\"fact1\", \"fact2\", \"fact3\"],\n    \"dim1\": [\"total\", \"A\", \"B\"],\n    \"dim2\": [\"X\", \"total\", \"Y\"],\n    \"dim3\": [\"M\", \"N\", \"total\"]\n})\n\ndimensions = [\"dim1\", \"dim2\", \"dim3\"]\n```\n\n**Output:**\n```python\n  table_name xbrl_factoid  ...  is_within_table_calc weight\n0     table1        fact1  ...                   NaN    NaN\n1     table2        fact2  ...                   NaN    NaN\n2     table3        fact3  ...                   NaN    NaN\n[3 rows x 13 columns]\n```", "ground_truth_code": "import pandas as pd\nimport itertools\n\n# main code\ndef infer_intra_factoid_totals(calc_components, meta_w_dims, table_dimensions, dimensions):\n    mask_non_total = ~(table_dimensions[dimensions] == 'total').any(axis=1)\n    mask_no_correction = ~table_dimensions.xbrl_factoid.str.endswith('_correction')\n    child_candidates = table_dimensions[mask_non_total & mask_no_correction]\n    total_comps = []\n    for total_dims in itertools.chain.from_iterable(\n            itertools.combinations(dimensions, i + 1) for i in range(len(dimensions))\n    ):\n        total_dims = list(total_dims)\n        parents = meta_w_dims.dropna(subset=total_dims)\n        parents = parents.loc[(parents[total_dims] == 'total').all(axis=1)]\n\n        if parents.empty:\n            continue\n        non_total_cols = ['table_name', 'xbrl_factoid'] + [d for d in dimensions if d not in total_dims]\n        merged_df = pd.merge(\n            left=parents,\n            right=child_candidates,\n            on=non_total_cols,\n            how='inner',\n            suffixes=('_parent', '')\n        )\n        merged_df = merged_df.assign(\n            is_within_table_calc=True,\n            weight=1,\n            table_name_parent=merged_df.table_name,\n            xbrl_factoid_parent=merged_df.xbrl_factoid\n        )\n\n        total_comps.append(merged_df)\n    if not total_comps:\n        return calc_components.assign(is_total_to_subdimensions_calc=False)\n\n    child_node_pk = ['table_name', 'xbrl_factoid'] + dimensions\n    parent_node_pk = [f'{col}_parent' for col in child_node_pk]\n    relationship_cols = ['is_within_table_calc', 'weight']\n    all_expected_cols = parent_node_pk + child_node_pk + relationship_cols\n    inferred_totals = pd.concat(total_comps).reindex(columns=all_expected_cols).reset_index(drop=True)\n    child_values = inferred_totals[child_node_pk].rename(lambda dim: f'{dim}_parent', axis=1)\n    inferred_totals = inferred_totals.fillna(child_values)\n    calcs_with_totals = pd.concat([\n        calc_components.assign(is_total_to_subdimensions_calc=False),\n        inferred_totals.assign(is_total_to_subdimensions_calc=True)\n    ])\n    return calcs_with_totals.drop_duplicates(parent_node_pk + child_node_pk, keep='first')", "test_script": "import pandas as pd\n\nimport random\nimport string\n\ndef test_case_input_generator(n=200):\n    def generate_random_string(length=5):\n        return ''.join(random.choices(string.ascii_letters, k=length))\n\n    def generate_test_case():\n        # Define possible dimensions\n        dimensions = [\"dim1\", \"dim2\", \"dim3\"]\n        num_rows = random.randint(10, 100)\n\n        # Generate random table_dimensions DataFrame\n        table_names = [generate_random_string() for _ in range(num_rows)]\n        factoids = [generate_random_string() for _ in range(num_rows)]\n\n        table_dimensions = pd.DataFrame({\n            \"table_name\": table_names,\n            \"xbrl_factoid\": factoids,\n            \"dim1\": random.choices([\"total\", \"A\", \"B\", \"C\"], k=num_rows),\n            \"dim2\": random.choices([\"total\", \"X\", \"Y\", \"Z\"], k=num_rows),\n            \"dim3\": random.choices([\"total\", \"M\", \"N\", \"O\"], k=num_rows),\n        })\n\n        # Generate random meta_w_dims DataFrame\n        meta_w_dims = pd.DataFrame({\n            \"table_name\": table_names,\n            \"xbrl_factoid\": factoids,\n            \"dim1\": random.choices([\"total\", \"A\", \"B\", \"C\", None], k=num_rows),\n            \"dim2\": random.choices([\"total\", \"X\", \"Y\", \"Z\", None], k=num_rows),\n            \"dim3\": random.choices([\"total\", \"M\", \"N\", \"O\", None], k=num_rows),\n        })\n\n        # Generate calc_components DataFrame\n        calc_components = pd.DataFrame({\n            \"table_name\": table_names,\n            \"xbrl_factoid\": factoids,\n            \"is_total_to_subdimensions_calc\": random.choices([True, False], k=num_rows)\n        })\n\n        return calc_components, meta_w_dims, table_dimensions, dimensions\n\n    test_cases = []\n    for _ in range(n):\n        test_cases.append(generate_test_case())\n    return test_cases"}
{"problem_id": "pandas_79", "library": "pandas", "code_problem": "You are tasked with implementing a function that ranks the values in a DataFrame while allowing for the application of a mask to filter which values are considered in the ranking process. The function should also have the option to normalize the ranks based on the maximum rank value.\n\nFunction signature:\n```python\ndef rank_with_mask(df, axis, mask, normalize, method):\n```\n\nConstants used in the main code:\n- `SUB = 1`\n\nInput format:\n- `df`: A pandas DataFrame containing numerical values.\n- `axis`: An integer (0 for index-wise, 1 for column-wise).\n- `mask`: A boolean array or None, indicating which values to consider for ranking.\n- `normalize`: A boolean indicating whether to normalize the ranks.\n- `method`: A string specifying the ranking method (e.g., 'average', 'min', 'max', etc.).\n\nOutput format:\n- The function returns a DataFrame containing the ranks of the values based on the specified parameters.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case\ndf = pd.DataFrame({\n    0: [1, 2, np.nan, 4],\n    1: [np.nan, 5, 6, 7],\n    2: [8, 9, 10, np.nan]\n})\naxis = 0\nmask = pd.DataFrame({\n    0: [True, True, False, True],\n    1: [False, True, True, True],\n    2: [True, True, True, False]\n})\nnormalize = True\nmethod = 'average'\n```\n\n**Output:**\n```python\npd.DataFrame({\n    0: [0.0, 0.5, np.nan, 1.0],\n    1: [np.nan, 0.0, 0.5, 1.0],\n    2: [0.0, 0.5, 1.0, np.nan]\n})\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef rank_with_mask(df, axis, mask, normalize, method):\n    not_nan_mask = ~df.isnull()\n    if mask is None:\n        mask = not_nan_mask\n    else:\n        mask = np.logical_and(not_nan_mask, mask)\n    rank = df[mask].rank(axis=axis, na_option='keep', method=method)\n    if normalize:\n        dividend = rank.max(axis=axis)\n        SUB = 1\n        dividend.loc[dividend > SUB] = dividend.loc[dividend > SUB] - SUB\n        rank = rank.sub(SUB).div(dividend, axis=1 - axis)\n    return rank", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(10, 100)\n        num_cols = np.random.randint(5, 20)\n        data = np.random.randn(num_rows, num_cols)  # Generate random values\n        df = pd.DataFrame(data)\n\n        # Introduce some NaN values randomly\n        nan_mask = np.random.rand(num_rows, num_cols) < 0.2\n        df[nan_mask] = np.nan\n\n        # Generate a random mask\n        mask = np.random.rand(num_rows, num_cols) < 0.8\n        mask = pd.DataFrame(mask)\n\n        axis = np.random.choice([0, 1])\n        normalize = np.random.choice([True, False])\n        method = np.random.choice(['average', 'min', 'max', 'first', 'dense'])\n        test_cases.append((df, axis, mask, normalize, method))\n    return test_cases"}
{"problem_id": "pandas_80", "library": "pandas", "code_problem": "```python\ndef stratified_group_shuffle_split(df_main, train_proportion, val_proportion,\n                                   hparam_mse_wgt, df_group, y_var):\n```\n\nIn this function, the goal is to split a given DataFrame into three subsets: training, validation, and testing, while maintaining the distribution of a specified target variable across these subsets. The splitting is done in a stratified manner based on groups defined in the DataFrame.\n\n### Constant Used:\n- `random_state`: A constant value of `42` is used to ensure reproducibility of the random sampling process.\n\n### Input Format:\n- `df_main`: A pandas DataFrame containing the data to be split.\n- `train_proportion`: A float representing the proportion of data to be used for training.\n- `val_proportion`: A float representing the proportion of data to be used for validation.\n- `hparam_mse_wgt`: A float representing the weight for the MSE loss in the final loss calculation.\n- `df_group`: A string representing the column name in `df_main` that defines the groups for stratification.\n- `y_var`: A string representing the column name in `df_main` that contains the target variable.\n\n### Output Format:\n- Returns a tuple of three pandas DataFrames: `(train_df, val_df, test_df)`, representing the training, validation, and testing datasets, respectively.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndf = pd.DataFrame({\n    'id': [0, 1, 2, 3, 4, 5, 6, 7, 8, 9],\n    'group': ['G0', 'G0', 'G1', 'G1', 'G2', 'G2', 'G3', 'G3', 'G4', 'G4'],\n    'target': [0, 1, 0, 1, 2, 2, 0, 1, 1, 2]\n})\n\ntrain_proportion = 0.5\nval_proportion = 0.3\nhparam_mse_wgt = 0.7\ndf_group = 'group'\ny_var = 'target'\n\n# Call the function\ntrain_df, val_df, test_df = stratified_group_shuffle_split(df, train_proportion, val_proportion, hparam_mse_wgt, df_group, y_var)\n```\n\n**Output:**\n```python\n# Expected output DataFrames (the actual output may vary due to randomness)\ntrain_df:\n   id group  target\n0   8    G4       1\n1   9    G4       2\n\nval_df:\n   id group  target\n0   1    G0       1\n1   0    G0       0\n\ntest_df:\n   id group  target\n0   5    G2       2\n1   4    G2       2\n2   7    G3       1\n3   6    G3       0\n4   2    G1       0\n5   3    G1       1\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n\ndef stratified_group_shuffle_split(df_main, train_proportion, val_proportion,\n                                   hparam_mse_wgt, df_group, y_var):\n    df_main = df_main.sample(frac=1, random_state=42).reset_index(drop=True)\n\n    train_df, val_df, test_df = pd.DataFrame(), pd.DataFrame(), pd.DataFrame()\n    test_proportion = 1 - train_proportion - val_proportion\n\n    subject_grouped = df_main.groupby(df_group, sort=False)\n    category_distribution = df_main[y_var].value_counts(normalize=True) * 100\n\n    def calc_mse_loss(df):\n        if df.empty:\n            return np.inf\n        group_dist = df[y_var].value_counts(normalize=True) * 100\n        diff = (category_distribution - group_dist).fillna(0) ** 2\n        return diff.mean()\n\n    i = 0\n    for _, group in subject_grouped:\n        if i < 3:\n            if i == 0:\n                train_df = pd.concat([train_df, group], ignore_index=True)\n            elif i == 1:\n                val_df = pd.concat([val_df, group], ignore_index=True)\n            else:\n                test_df = pd.concat([test_df, group], ignore_index=True)\n            i += 1\n            continue\n\n        # Compute MSE loss changes\n        mse_train_diff = calc_mse_loss(train_df) - calc_mse_loss(pd.concat([train_df, group], ignore_index=True))\n        mse_val_diff = calc_mse_loss(val_df) - calc_mse_loss(pd.concat([val_df, group], ignore_index=True))\n        mse_test_diff = calc_mse_loss(test_df) - calc_mse_loss(pd.concat([test_df, group], ignore_index=True))\n\n        # Compute size differences\n        total_groups = sum([train_df[df_group].nunique(), val_df[df_group].nunique(), test_df[df_group].nunique()])\n        size_diff_train = train_proportion - (train_df[df_group].nunique() / total_groups)\n        size_diff_val = val_proportion - (val_df[df_group].nunique() / total_groups)\n        size_diff_test = test_proportion - (test_df[df_group].nunique() / total_groups)\n\n        size_loss_train = size_diff_train * abs(size_diff_train)\n        size_loss_val = size_diff_val * abs(size_diff_val)\n        size_loss_test = size_diff_test * abs(size_diff_test)\n\n        # Compute final loss\n        loss_train = hparam_mse_wgt * mse_train_diff + (1 - hparam_mse_wgt) * size_loss_train\n        loss_val = hparam_mse_wgt * mse_val_diff + (1 - hparam_mse_wgt) * size_loss_val\n        loss_test = hparam_mse_wgt * mse_test_diff + (1 - hparam_mse_wgt) * size_loss_test\n\n        # Assign group to the best split\n        if max(loss_train, loss_val, loss_test) == loss_train:\n            train_df = pd.concat([train_df, group], ignore_index=True)\n        elif max(loss_train, loss_val, loss_test) == loss_val:\n            val_df = pd.concat([val_df, group], ignore_index=True)\n        else:\n            test_df = pd.concat([test_df, group], ignore_index=True)\n\n    return train_df, val_df, test_df", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomize number of rows and number of unique groups\n        num_rows = random.randint(50, 500)\n        num_groups = random.randint(5, min(50, num_rows // 2))\n\n        # Create a DataFrame with random groups and labels\n        df = pd.DataFrame({\n            'id': np.arange(num_rows),\n            'group': np.random.choice([f'G{i}' for i in range(num_groups)], size=num_rows),\n            'target': np.random.choice([0, 1, 2], size=num_rows, p=[0.5, 0.3, 0.2])\n        })\n\n        # Assign train, val proportions ensuring they don't exceed 1\n        train_proportion = random.uniform(0.4, 0.7)\n        val_proportion = random.uniform(0.1, 1 - train_proportion)\n\n        # Assign a random weight for MSE importance\n        hparam_mse_wgt = random.uniform(0, 1)\n        test_cases.append((df, train_proportion, val_proportion, hparam_mse_wgt, 'group', 'target'))\n\n    return test_cases"}
{"problem_id": "pandas_81", "library": "pandas", "code_problem": "You are tasked with implementing a function that processes a dataset to create bins for a specified numeric column and analyze the distribution of a target variable within those bins. The function should handle special codes and missing values appropriately, and return a summary of the binned data along with descriptive statistics.\n\nFunction signature:\n```python\ndef numericvar_apior(inputdata: pd.DataFrame, col: str, s_bin_num: int, target: str, specialcode_list: list) -> tuple:\n```\n\n### Constants Used:\n- The constant used in the main code is `float('-inf')` and `float('inf')`, which represent negative and positive infinity, respectively.\n\n\n### Input Format:\n- `inputdata`: A pandas DataFrame.\n- `col`: A string representing the column name to be binned.\n- `s_bin_num`: An integer representing the number of bins to create.\n- `target`: A string representing the target variable's column name.\n- `specialcode_list`: A list of special codes to exclude from the analysis.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A DataFrame with group information and statistics.\n  - A DataFrame with binned data and corresponding statistics, excluding the original group column.\n\n**Input:**\n```python\ninputdata = pd.DataFrame({\n    \"feature\": [10, 20, 30, 40, 50, np.nan, 60, 70, 80, 90],\n    \"target\": [0, 1, 0, 1, 0, 0, 1, 0, 1, 0]\n})\ncol = \"feature\"\ns_bin_num = 4\ntarget = \"target\"\nspecialcode_list = []\n```\n\n**Output:**\n```python\ngroup_info =\n   s_group  s_min  s_max  miss_s value  ...   25%   50%   75%   max  miss_count\n0        0   -inf   30.0   False   NaN  ...  30.0  50.0  70.0  90.0           1\n1        1   30.0   50.0   False   NaN  ...  30.0  50.0  70.0  90.0           1\n2        2   50.0   70.0   False   NaN  ...  30.0  50.0  70.0  90.0           1\n3        3   70.0    inf   False   NaN  ...  30.0  50.0  70.0  90.0           1\n4       -1    NaN    NaN    True  miss  ...  30.0  50.0  70.0  90.0           1\n[5 rows x 18 columns]\n\noutputdata = \n   feature  s_group_feature\n0     10.0                0\n1     20.0                0\n2     30.0                0\n3     40.0                1\n4     50.0                1\n5     60.0                2\n6     70.0                2\n7     80.0                3\n8     90.0                3\n9      NaN               -1\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\ndef num_finebin_group(inputdata, col, s_bin_num, specialcode_list):\n    if specialcode_list != []:\n        inputdata = inputdata[inputdata.isin({col: specialcode_list}) == False]\n    sort_df = inputdata[col][inputdata[col].isnull() == False]\n    if len(sort_df.unique()) <= 1:\n        old_list = set([float('-inf'), float('inf')])\n    elif len(sort_df.unique()) <= s_bin_num:\n        old_list = set(list(sort_df.unique()))\n        old_list.remove(max(old_list))\n        old_list.remove(min(old_list))\n        old_list.add(float('-inf'))\n        old_list.add(float('inf'))\n    else:\n        old_list = set()\n        num = sort_df.size\n        sort_df = sort_df.sort_values(ascending=True).reset_index().drop(columns='index')\n        for i in range(1, s_bin_num):\n            loca = int(i / s_bin_num * num)\n            value = sort_df.iloc[loca].values[0]\n            old_list.add(value)\n        old_list.add(float('-inf'))\n        old_list.add(float('inf'))\n    new_list = list(old_list)\n    new_list.sort()\n    new_s_group = []\n    for i in range(len(new_list) - 1):\n        temp = {'s_group': i, 's_min': new_list[i], 's_max': new_list[i + 1]}\n        new_s_group.append(temp)\n    s_group_map = pd.DataFrame(new_s_group)\n    return s_group_map\n\ndef binning(group_data, inputdata, col, inputmax, inputmin, inputgroup, specialcode_list):\n    s_group_data = pd.DataFrame()\n    group_data = group_data.reset_index()\n    if specialcode_list != []:\n        inputdata = inputdata[inputdata.isin({col: specialcode_list}) == False]\n    inputdata = inputdata.loc[inputdata[col].isnull() == False]\n    for lins in range(len(group_data)):\n        temp = inputdata.copy()\n        temp[inputgroup] = group_data.loc[lins, inputgroup]\n        temp[inputmin] = group_data.loc[lins, inputmin]\n        temp[inputmax] = group_data.loc[lins, inputmax]\n        temp_data = temp[(temp[col] <= temp[inputmax]) & (temp[col] > temp[inputmin])]\n        s_group_data = pd.concat([s_group_data, temp_data])\n    return s_group_data\n\n# main code\ndef numericvar_apior(inputdata, col, s_bin_num, target, specialcode_list):\n    s_group_map = num_finebin_group(inputdata=inputdata, col=col, s_bin_num=s_bin_num, specialcode_list=specialcode_list)\n    s_group_data = binning(group_data=s_group_map, inputdata=inputdata, col=col, inputmax='s_max', inputmin='s_min', inputgroup='s_group', specialcode_list=specialcode_list)\n    s_group_data['value'] = np.nan\n    group_info_base = s_group_map\n    group_info_base['miss_s'] = False\n    group_info_base['value'] = np.nan\n    if len(inputdata[inputdata[col].isnull()]) > 0:\n        miss_data = inputdata[inputdata[col].isnull()]\n        miss_data.loc[:, 's_group'] = -1\n        miss_data['value'] = 'miss'\n        tempg = pd.DataFrame({'s_group': -1, 'value': 'miss', 'miss_s': True}, index=[0])\n        s_group_data = s_group_data._append(miss_data)\n        group_info_base = group_info_base._append(tempg)\n    if specialcode_list != []:\n        i = -2\n        for special_value in specialcode_list:\n            temp = inputdata[inputdata[col] == special_value].copy()\n            temp['s_group'] = i\n            temp['value'] = special_value\n            temps = pd.DataFrame({'s_group': i, 'value': special_value, 'miss_s': True}, index=[0])\n            s_group_data = s_group_data._append(temp)\n            group_info_base = group_info_base._append(temps)\n            i = i - 1\n    s_group_data['miss'] = s_group_data['s_group'] < 0\n    tt = s_group_data.groupby(['s_group']).agg({target: ['mean', 'count', 'sum'], 'miss': 'max', 's_max': 'max', 's_min': 'min', 'value': 'max'}).reset_index()\n    s_data = pd.DataFrame()\n    s_data['s_group'] = tt['s_group']\n    s_data['s_Bad_rate'] = tt[target]['mean']\n    s_data['s_N_obs'] = tt[target]['count']\n    s_data['s_N_bad'] = tt[target]['sum']\n    s_data['variable_name'] = '%s' % col\n    dd = inputdata[col].describe()\n    ds = pd.DataFrame(dd).T.reset_index().rename({'index': 'variable_name'}, axis=1)\n    ds['miss_count'] = inputdata[col].isnull().sum()\n    group_info = pd.merge(group_info_base, s_data, how='left', on=['s_group'])\n    group_info = pd.merge(group_info, ds, how='left', on=['variable_name'])\n    outputdata = pd.merge(s_group_data[[col, 's_group']], s_data[['s_group']], how='left', on=['s_group'])\n    outputdata['s_group_%s' % col] = outputdata['s_group']\n    return (group_info, outputdata.drop(columns=['s_group']))", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(10, 500)\n        col_values = np.random.uniform(-1000, 1000, num_rows)\n        col_values[np.random.choice(num_rows, size=random.randint(0, num_rows // 10), replace=False)] = np.nan\n        special_values = [random.choice(col_values) for _ in range(random.randint(0, 5))]\n        target_values = np.random.choice([0, 1], size=num_rows, p=[0.7, 0.3])\n        inputdata = pd.DataFrame({\n            \"feature\": col_values,\n            \"target\": target_values\n        })\n        s_bin_num = random.randint(2, 20)\n        test_cases.append((inputdata, \"feature\", s_bin_num, \"target\", special_values))\n\n    return test_cases"}
{"problem_id": "pandas_82", "library": "pandas", "code_problem": "You are tasked with creating a function that processes a DataFrame containing information about various locations, specifically focusing on those that are at a distance of zero. The function will extract color information, convert it from hexadecimal format to RGB format, and compile a list of relevant details for each location.\n\nFunction signature:\n```python\ndef extractBFS(df: pd.DataFrame) -> list:\n```\n\nConstant used in the main code:\n- The header for the output list is defined as `header = ['', '', 'R', 'G', 'B', 'Nearest Town', 'Cell ID']`.\n\nInput format:\n- The input to the function is a pandas DataFrame with at least the following columns: 'distance', 'color', 'nearest_town', and 'id'.\n\nOutput format:\n- The output of the function is a list of lists, where the first sublist is the header, and each subsequent sublist contains the RGB values, nearest town, and cell ID for each location with a distance of zero.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'distance': [0, 1, 0, 0, 1],\n    'color': ['FF5733', 'C70039', '33FF57', '900C3F', '581845'],\n    'nearest_town': ['Town_1', 'Town_2', 'Town_3', 'Town_4', 'Town_5'],\n    'id': [1001, 1002, 1003, 1004, 1005]\n}\ndf = pd.DataFrame(data)\nresult = extractBFS(df)\nprint(result)\n```\n\n**Output:**\n```python\n[['', '', 'R', 'G', 'B', 'Nearest Town', 'Cell ID'], \n ['', '', 255, 87, 51, 'Town_1', 1001], \n ['', '', 51, 255, 87, 'Town_3', 1003], \n ['', '', 144, 12, 63, 'Town_4', 1004]]\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef extractBFS(df):\n    df = df[df['distance'] == 0].copy()\n    if df.empty:\n        return [['', '', 'R', 'G', 'B', 'Nearest Town', 'Cell ID']]\n    df[['R', 'G', 'B']] = df['color'].apply(lambda x: pd.Series(tuple((int(x[i:i + 2], 16) for i in (0, 2, 4))) if len(x) == 6 else (pd.NA, pd.NA, pd.NA)))\n    ws = []\n    header = ['', '', 'R', 'G', 'B', 'Nearest Town', 'Cell ID']\n    ws.append(header)\n    for row in df.itertuples(index=False):\n        ws.append(['', '', row.R, row.G, row.B, row.nearest_town, row.id])\n    return ws", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    def random_hex_color():\n        return ''.join(random.choices('0123456789ABCDEF', k=6))\n\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(1, 10)\n        data = {\n            'distance': [random.choice([0, 1]) for _ in range(num_rows)],\n            'color': [random_hex_color() for _ in range(num_rows)],\n            'nearest_town': [f'Town_{random.randint(1, 100)}' for _ in range(num_rows)],\n            'id': [random.randint(1000, 9999) for _ in range(num_rows)]\n        }\n        df = pd.DataFrame(data)\n        test_cases.append(df)\n    return test_cases\n"}
{"problem_id": "pandas_83", "library": "pandas", "code_problem": "You are tasked with creating a function that analyzes the distribution of a specific datetime feature from a given DataFrame. The function will take a DataFrame containing datetime values and extract the distribution of a specified feature (like year, month, day, etc.) from those datetime values. The results will be presented in a pivot table format, showing the normalized ratio of each feature value across different chunks of the data.\n\nFunction signature:\n```python\ndef extract_datetime_distribution(df: pd.DataFrame, time_column: str, datetime_feature: str) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `100`, which is used to determine the size of the chunks when splitting the DataFrame.\n\n\nInput format:\n- A pandas DataFrame `df` containing at least one column specified by `time_column`, which holds datetime values.\n- A string `time_column` representing the name of the column in `df` that contains the datetime values.\n- A string `datetime_feature` representing the specific feature to extract from the datetime values (e.g., 'year', 'month', 'day', etc.).\n\nOutput format:\n- A pandas DataFrame representing the pivot table of the normalized ratios of the specified datetime feature across different chunks of the input DataFrame. The index will represent the chunk number, and the columns will represent the unique values of the specified datetime feature.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Creating a test DataFrame\ndata = {\n    'timestamp': pd.date_range(start='2023-01-01', periods=100, freq='H')\n}\ndf = pd.DataFrame(data)\n\n# Specifying the time column and datetime feature\ntime_column = 'timestamp'\ndatetime_feature = 'hour'\n\n# Calling the function\nresult = extract_datetime_distribution(df, time_column, datetime_feature)\nprint(result)\n```\n\n**Output:**\n```\nhour     0     1     2     3     4     5   ...    18    19    20    21    22    23\nchunk                                      ...                                    \n0      0.05  0.05  0.05  0.05  0.04  0.04  ...  0.04  0.04  0.04  0.04  0.04  0.04\n[1 rows x 24 columns]\n```\n", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef extract_datetime_distribution(df, time_column, datetime_feature):\n    df = df[[time_column]].copy()\n    df[time_column] = pd.to_datetime(df[time_column], errors='coerce')\n\n    chunks = np.array_split(df, max(1, len(df) // 100))\n    results = []\n\n    for i, chunk in enumerate(chunks):\n        feature_series = getattr(chunk[time_column].dt, datetime_feature)\n        counts = feature_series.value_counts(normalize=True).sort_index()\n        stats = counts.reset_index()\n        stats.columns = [datetime_feature, 'ratio']\n        stats['chunk'] = i\n        results.append(stats)\n\n    combined = pd.concat(results, ignore_index=True)\n    result = combined.pivot_table(index='chunk', columns=datetime_feature, values='ratio', fill_value=0)\n\n    return result", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    datetime_features = ['year', 'month', 'day', 'hour', 'minute', 'second', 'weekday']\n\n    for _ in range(n):\n        num_rows = random.randint(50, 500)\n\n        start_date = pd.Timestamp('2000-01-01') + pd.to_timedelta(random.randint(0, 5000), unit='D')\n        end_date = start_date + pd.to_timedelta(random.randint(1, 365), unit='D')\n\n        time_column = 'timestamp'\n        datetime_series = pd.date_range(start=start_date, end=end_date, periods=num_rows)\n        df = pd.DataFrame({time_column: datetime_series})\n\n        datetime_feature = random.choice(datetime_features)\n        test_cases.append((df, time_column, datetime_feature))\n\n    return test_cases"}
{"problem_id": "pandas_84", "library": "pandas", "code_problem": "You are tasked with creating a function that prepares a sector distribution based on a series of values and their corresponding directional angles. The function will categorize these angles into specified sectors and compute the average value for each sector.\n\nFunction Signature:\n```python\ndef prepare_sector_distribution(series, directions, sectors):\n```\n\nConstant Used:\n- The constant used in the main code is `360`, which represents the full circle in degrees.\n\nInput Format:\n- The function takes three parameters: a numerical series (list or array), a list of directional angles (list or array), and an integer representing the number of sectors.\n\nOutput Format:\n- The function returns a pandas Series with sector labels as the index and the average values for each sector as the data.\n\nInput:\n```python\nseries = np.array([-50.5, 20.3, 15.0, -10.0, 30.5, 45.0, -25.0, 60.0])\ndirections = np.array([10, 50, 100, 150, 200, 250, 300, 350])\nsectors = 4\n```\n\nOutput:\n```python\nsector_distribution = {\n    '0-90': -15.10,\n    '90-180': 2.50,  # Mean of values in the range [90, 180)\n    '180-270': 37.75,  # Mean of values in the range [180, 270)\n    '270-360': 17.50   # Mean of values in the range [270, 360)\n}\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef prepare_sector_distribution(series, directions, sectors):\n    bins = np.linspace(0, 360, sectors + 1)\n    sector_labels = [f'{int(bins[i])}-{int(bins[i+1])}' for i in range(sectors)]\n    df = pd.DataFrame({'value': series, 'direction': directions})\n    df['sector'] = pd.cut(df['direction'], bins=bins, labels=sector_labels, include_lowest=True)\n    return df.groupby('sector')['value'].mean().reindex(sector_labels)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(10, 101)\n        series = np.random.uniform(low=-100, high=100, size=num_points)\n        directions = np.random.uniform(low=0, high=360, size=num_points)\n        sectors = np.random.choice([4, 6, 8, 12, 16, 18, 24, 36])\n\n        test_cases.append((series, directions, sectors))\n    return test_cases"}
{"problem_id": "pandas_85", "library": "pandas", "code_problem": "You are tasked with implementing a function that computes the rolling covariance between two time series datasets. The function should handle missing values appropriately and provide an adjusted covariance based on the number of valid observations within a specified rolling window.\n\nFunction signature:\n```python\ndef compute_rolling_covariance(asset_data, reference_data, window_size, ddof, center, closed):\n```\n\n### Constants:\n- `ddof`: This constant represents the \"Delta Degrees of Freedom\" used in the calculation of the covariance adjustment.\n\n\n### Input Format:\n- `asset_data`: A Pandas Series representing the first time series dataset.\n- `reference_data`: A Pandas Series representing the second time series dataset.\n- `window_size`: An integer specifying the size of the rolling window.\n- `ddof`: An integer representing the delta degrees of freedom for the covariance calculation.\n- `center`: A boolean indicating whether the labels should be centered in the window.\n- `closed`: A string indicating which side of the window is closed ('right', 'left', or 'both').\n\n### Output Format:\n- The function returns a Pandas Series containing the adjusted rolling covariance values, indexed by the original index of `asset_data`.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Asset data\nasset_data = pd.Series(\n    [1.0, 2.0, None, 4.0, 5.0, None, 7.0, 8.0, 9.0, None],\n    index=pd.date_range(start='2023-01-01', periods=10, freq='D')\n)\n\n# Reference da = pd.Series(\n    [1.0, None, 3.0, 4.0, None, 6.0, 7.0, 8.0, None, 10.0],\n    index=pd.date_range(start='2023-01-01', periods=10, freq='D')\n)\n\n# Parameters\nwindow_size = 3\nddof = 1\ncenter = True\nclosed = 'both'\n```\n\n**Output:**\n```python\n2023-01-01    0.000000\n2023-01-02    0.333333\n2023-01-03    1.583333\n2023-01-04    1.666667\n2023-01-05    1.333333\n2023-01-06    1.583333\n2023-01-07    2.250000\n2023-01-08    1.583333\n2023-01-09    0.916667\n2023-01-10    0.333333\nFreq: D, dtype: float64\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef compute_rolling_covariance(asset_data, reference_data, window_size, ddof, center, closed):\n    asset_data = asset_data.astype(float).fillna(method='ffill').fillna(method='bfill')\n    reference_data = reference_data.astype(float).fillna(method='ffill').fillna(method='bfill')\n    mean_asset = asset_data.rolling(window=window_size, center=center, closed=closed, min_periods=1).mean()\n    mean_ref = reference_data.rolling(window=window_size, center=center, closed=closed, min_periods=1).mean()\n\n    product = asset_data * reference_data\n    mean_product = product.rolling(window=window_size, center=center, closed=closed, min_periods=1).mean()\n\n    valid_counts = (asset_data.notna() & reference_data.notna()).rolling(\n        window=window_size, center=center, closed=closed, min_periods=1\n    ).sum()\n\n    cov = mean_product - mean_asset * mean_ref\n\n    denom = (valid_counts - ddof).clip(lower=1)\n    adjustment = valid_counts / denom\n    adjusted_cov = cov * adjustment\n\n    return pd.Series(adjusted_cov, index=asset_data.index, name=asset_data.name)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = random.randint(20, 100)\n        index = pd.date_range(start='2020-01-01', periods=length, freq='D')\n        asset_data = pd.Series(np.random.randn(length), index=index)\n        reference_data = pd.Series(np.random.randn(length), index=index)\n\n        for series in [asset_data, reference_data]:\n            nan_ratio = random.uniform(0, 0.2)\n            nan_indices = np.random.choice(length, size=int(length * nan_ratio), replace=False)\n            series.iloc[nan_indices] = np.nan\n        window_size = random.randint(2, min(20, length))\n        ddof = random.randint(0, 1)\n        center = random.choice([True, False])\n        closed = random.choice(['right', 'left', 'both', 'neither'])\n\n        test_cases.append((asset_data, reference_data, window_size, ddof, center, closed))\n    return test_cases"}
{"problem_id": "pandas_86", "library": "pandas", "code_problem": "You are tasked with processing and adjusting the capacity data of power generators based on various input datasets. The main function, `complex_generator_processing`, takes in several dataframes and settings to perform this operation. The function signature is as follows:\n\n```python\ndef complex_generator_processing(gens_860, gens_entity, bga, model_region_map, settings):\n```\n\n### Constants Used:\n- The constant used in the main code is `1e-6`, which is added to the initial capacity to prevent division by zero during calculations.\n\n### Input and Output Format:\n- **Input**: The function takes five parameters:\n  - `gens_860`: A dataframe containing generator data.\n  - `gens_entity`: A dataframe containing generator entity information.\n  - `bga`: A dataframe containing boiler and generator association data.\n  - `model_region_map`: A dataframe mapping plants to regions.\n  - `settings`: A dictionary containing configuration settings, including the capacity column name.\n\n- **Output**: The function returns a dataframe that includes the adjusted generator capacity data, with relevant columns and updated capacity values based on the processing logic described.\n\n**Input:**\n```python\n# Input DataFrames\ngens_860 = pd.DataFrame({\n    'plant_id_eia': [1001, 1002, 1001, 1003],\n    'generator_id': ['G1', 'G2', 'G3', 'G4'],\n    'capacity_mw': [100, 200, 150, 300],\n    'nameplate_capacity_mw': [120, 220, 170, 320],\n    'energy_source_code_1': ['NG', 'WND', 'SUN', 'COL'],\n    'energy_source_code_2': [None, 'NG', 'WND', 'SUN'],\n    'minimum_load_mw': [10, 20, 15, 30],\n    'operational_status_code': ['OP', 'OP', 'PL', 'RE'],\n    'planned_new_capacity_mw': [0.0, 10.0, np.nan, 20.0],\n    'switch_oil_gas': [True, False, True, False],\n    'technology_description': ['CC', 'PV', 'ST', 'CT'],\n    'time_cold_shutdown_full_load_code': [1, 2, 3, 4],\n    'planned_retirement_date': pd.to_datetime(['2035-01-01', '2036-01-01', '2037-01-01', '2038-01-01']),\n    'prime_mover_code': ['CC', 'PV', 'ST', 'CT']\n})\n\ngens_entity = pd.DataFrame({\n    'plant_id_eia': [1001, 1002, 1001, 1003],\n    'generator_id': ['G1', 'G2', 'G3', 'G4'],\n    'prime_mover_code': ['CC', 'PV', 'ST', 'CT'],\n    'operating_date': pd.to_datetime(['2005-01-01', '2006-01-01', '2005-01-01', '2007-01-01']),\n    'generator_operating_date': pd.to_datetime(['2006-01-01', '2007-01-01', '2006-01-01', '2008-01-01']),\n    'original_planned_operating_date': pd.to_datetime(['2000-01-01', '2001-01-01', '2000-01-01', '2002-01-01']),\n    'original_planned_generator_operating_date': pd.to_datetime(['2001-01-01', '2002-01-01', '2001-01-01', '2003-01-01'])\n})\n\nbga = pd.DataFrame({\n    'plant_id_eia': [1001, 1002, 1001, 1003],\n    'generator_id': ['G1', 'G2', 'G3', 'G4'],\n    'boiler_id': ['B1', 'B2', 'B3', 'B4'],\n    'unit_id_eia': ['U1', 'U2', 'U3', 'U4'],\n    'unit_id_pudl': ['PUDL1', 'PUDL2', np.nan, 'PUDL4']\n})\n\nmodel_region_map = pd.DataFrame({\n    'plant_id_eia': [1001, 1002, 1003],\n    'region': ['East', 'West', 'Midwest']\n})\n\nsettings = {\n    'capacity_col': 'nameplate_capacity_mw'\n}\n\n# Call the function\noutput = complex_generator_processing(gens_860, gens_entity, bga, model_region_map, settings)\n```\n\n**Output:**\n```python\n# Output DataFrame\n   plant_id_eia generator_id  capacity_mw  ...  unit_id_eia unit_id_pudl unit_id_pg\n0          1001           G1          100  ...           U1        PUDL1      PUDL1\n1          1002           G2          200  ...           U2        PUDL2      PUDL2\n2          1001           G3          150  ...           U3          NaN    1001_G3\n3          1003           G4          300  ...           U4        PUDL4      PUDL4\n[4 rows x 23 columns]\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef complex_generator_processing(gens_860, gens_entity, bga, model_region_map, settings):\n    cap_col = settings['capacity_col']\n\n    region_plants = model_region_map[['plant_id_eia']].drop_duplicates()\n    capacity_data = gens_860.merge(region_plants, on='plant_id_eia')[\n        ['plant_id_eia', 'technology_description', cap_col]\n    ]\n    initial_capacity = capacity_data.groupby('technology_description')[cap_col].sum()\n\n    generator_cols = gens_860.columns.intersection([\n        'plant_id_eia', 'generator_id', cap_col, 'capacity_mw',\n        'energy_source_code_1', 'energy_source_code_2', 'minimum_load_mw',\n        'operational_status_code', 'planned_new_capacity_mw', 'switch_oil_gas',\n        'technology_description', 'time_cold_shutdown_full_load_code',\n        'planned_retirement_date', 'prime_mover_code'\n    ])\n    entity_cols = gens_entity.columns.intersection([\n        'plant_id_eia', 'generator_id', 'prime_mover_code',\n        'operating_date', 'generator_operating_date',\n        'original_planned_operating_date', 'original_planned_generator_operating_date'\n    ])\n    bga_cols = bga.columns.intersection([\n        'plant_id_eia', 'generator_id', 'boiler_id', 'unit_id_eia', 'unit_id_pudl'\n    ])\n\n    merged = gens_860[generator_cols].merge(\n        model_region_map.drop(columns='region', errors='ignore').drop_duplicates('plant_id_eia'),\n        on='plant_id_eia'\n    ).merge(\n        gens_entity[entity_cols], on=['plant_id_eia', 'generator_id']\n    ).merge(\n        bga[bga_cols], on=['plant_id_eia', 'generator_id'], how='left'\n    )\n\n    merged['unit_id_pg'] = merged['unit_id_pudl']\n    fallback_ids = merged['plant_id_eia'].astype(str) + '_' + merged['generator_id'].astype(str)\n    merged.loc[merged['unit_id_pg'].isna(), 'unit_id_pg'] = fallback_ids\n\n    null_cap_mask = merged[cap_col].isna()\n    group_cols = ['plant_id_eia', 'unit_id_pg']\n    for (pid, uid), group in merged[null_cap_mask].groupby(group_cols):\n        mask = (merged['plant_id_eia'] == pid) & (merged['unit_id_pg'] == uid)\n        if group[cap_col].isna().all():\n            merged.loc[mask, cap_col] = merged.loc[mask, 'capacity_mw']\n\n    adjusted = merged.copy()\n    tech_totals = adjusted.groupby('technology_description')[cap_col].sum()\n    scalars = (tech_totals / (initial_capacity + 1e-6)).clip(0.9, 1.1)\n    adjusted[cap_col] *= adjusted['technology_description'].map(scalars).fillna(1.0)\n\n    return adjusted", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n\n    for _ in range(n):\n        num_plants = np.random.randint(5, 15)\n        num_generators = num_plants * np.random.randint(1, 4)\n\n        plant_ids = np.random.choice(range(1000, 9999), size=num_plants, replace=False)\n        generator_ids = [f\"G{j}\" for j in range(num_generators)]\n\n        gens_860 = pd.DataFrame({\n            'plant_id_eia': np.random.choice(plant_ids, size=num_generators),\n            'generator_id': np.random.choice(generator_ids, size=num_generators),\n            'capacity_mw': np.random.uniform(10, 500, size=num_generators),\n            'nameplate_capacity_mw': np.random.uniform(10, 500, size=num_generators),\n            'energy_source_code_1': np.random.choice(['NG', 'COL', 'WND', 'SUN'], size=num_generators),\n            'energy_source_code_2': np.random.choice(['NG', 'COL', 'WND', 'SUN', None], size=num_generators),\n            'minimum_load_mw': np.random.uniform(1, 100, size=num_generators),\n            'operational_status_code': np.random.choice(['OP', 'PL', 'RE'], size=num_generators),\n            'planned_new_capacity_mw': np.random.choice([0.0, 10.0, 20.0, np.nan], size=num_generators),\n            'switch_oil_gas': np.random.choice([True, False], size=num_generators),\n            'technology_description': np.random.choice(['CC', 'CT', 'ST', 'PV', 'Wind'], size=num_generators),\n            'time_cold_shutdown_full_load_code': np.random.randint(1, 5, size=num_generators),\n            'planned_retirement_date': pd.to_datetime(\n                np.random.choice(pd.date_range('2030-01-01', '2040-12-31', freq='YS'), size=num_generators)\n            ),\n            'prime_mover_code': np.random.choice(['CC', 'CT', 'ST', 'PV', 'WT'], size=num_generators)\n        })\n\n        gens_entity = pd.DataFrame({\n            'plant_id_eia': gens_860['plant_id_eia'].values,\n            'generator_id': gens_860['generator_id'].values,\n            'prime_mover_code': gens_860['prime_mover_code'].values,\n            'operating_date': pd.to_datetime(\n                np.random.choice(pd.date_range('2000-01-01', '2020-12-31', freq='YS'), size=num_generators)\n            ),\n            'generator_operating_date': pd.to_datetime(\n                np.random.choice(pd.date_range('2001-01-01', '2021-12-31', freq='YS'), size=num_generators)\n            ),\n            'original_planned_operating_date': pd.to_datetime(\n                np.random.choice(pd.date_range('1995-01-01', '2025-12-31', freq='YS'), size=num_generators)\n            ),\n            'original_planned_generator_operating_date': pd.to_datetime(\n                np.random.choice(pd.date_range('1996-01-01', '2026-12-31', freq='YS'), size=num_generators)\n            )\n        })\n\n        bga = pd.DataFrame({\n            'plant_id_eia': gens_860['plant_id_eia'].values,\n            'generator_id': gens_860['generator_id'].values,\n            'boiler_id': [f\"B{i}\" for i in range(num_generators)],\n            'unit_id_eia': [f\"U{i}\" for i in range(num_generators)],\n            'unit_id_pudl': [f\"PUDL{i}\" if i % 2 == 0 else np.nan for i in range(num_generators)]\n        })\n\n        model_region_map = pd.DataFrame({\n            'plant_id_eia': plant_ids,\n            'region': np.random.choice(['East', 'West', 'Midwest', 'South'], size=num_plants)\n        })\n\n        settings = {\n            'capacity_col': 'nameplate_capacity_mw'\n        }\n\n        test_cases.append((gens_860, gens_entity, bga, model_region_map, settings))\n\n    return test_cases"}
{"problem_id": "pandas_87", "library": "pandas", "code_problem": "You are tasked with processing a dataset represented as a dictionary of lists, where each key corresponds to a specific coordinate in the format \"x1xy1\", \"x2xy2\", etc. The goal is to compute the mean values of the data points that are located near each coordinate based on a defined proximity rule. The proximity rule states that a coordinate (x, y) is considered \"nearby\" if the absolute difference in both x and y coordinates is less than or equal to 1.\n\nThe main function signature is as follows:\n```python\ndef process_data(input_data):\n```\n\nIn this function, the following constant is used:\n- The proximity threshold is implicitly defined as 1, which is used to determine if two coordinates are considered nearby.\n\n\nInput format:\n- The input to the function is a dictionary where keys are strings representing coordinates in the format \"x1xy1\", \"x2xy2\", etc., and values are lists of numerical data points.\n\nOutput format:\n- The output of the function is a tuple containing:\n  1. The original DataFrame created from the input data.\n  2. A NumPy array of the values from the original DataFrame.\n  3. A correlation matrix of the means calculated for each row based on the nearby coordinates.\n\n**Input:**\n```python\n[\n    {'0x0': 0.5, '0x1': 1.2, '0x2': -0.3, '1x0': 0.0, '1x1': 0.7, '1x2': 1.1},\n    {'0x0': -0.1, '0x1': 0.3, '0x2': 0.5, '1x0': 1.0, '1x1': -0.4, '1x2': 0.2},\n    {'0x0': 0.4, '0x1': -0.2, '0x2': 0.8, '1x0': 0.6, '1x1': 1.5, '1x2': -0.1}\n]\n```\n\n**Output:**\n```python\n\n# DataFrame (df)\n   0x0  0x1  0x2  1x0  1x1  1x2\n0  0.5  1.2 -0.3  0.0  0.7  1.1\n1 -0.1  0.3  0.5  1.0 -0.4  0.2\n2  0.4 -0.2  0.8  0.6  1.5 -0.1\n\n# Numpy array (df.values)\narray([[ 0.5,  1.2, -0.3,  0. ,  0.7,  1.1],\n       [-0.1,  0.3,  0.5,  1. , -0.4,  0.2],\n       [ 0.4, -0.2,  0.8,  0.6,  1.5, -0.1]])\n\n# Correlation DataFrame (result.corr())\n          0             1             2\n0  1.000000 -9.994238e-01 -3.394221e-02\n1 -0.999424  1.000000e+00  2.253472e-16\n2 -0.033942  2.253472e-16  1.000000e+00\n```", "ground_truth_code": "import pandas as pd\n\n# main code\ndef process_data(input_data):\n    df = pd.DataFrame(input_data)\n    coord_df = df.columns.to_series().str.extract(r'(?P<x>\\d+)x(?P<y>\\d+)').astype(int)\n    result = pd.DataFrame(index=coord_df.index)\n    for row_idx, row in df.iterrows():\n        means = []\n        for i, (x, y) in coord_df.iterrows():\n            nearby = ((coord_df['x'] - x).abs() <= 1) & ((coord_df['y'] - y).abs() <= 1)\n            means.append(row[nearby.index[nearby]].mean())\n        result[row_idx] = means\n    return df, df.values, result.corr()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(3, 10)\n        grid_x = np.random.randint(2, 6)\n        grid_y = np.random.randint(2, 6)\n\n        columns = [f\"{x}x{y}\" for x in range(grid_x) for y in range(grid_y)]\n        data = []\n        for _ in range(num_rows):\n            row = {col: float(np.random.randn()) for col in columns}\n            data.append(row)\n\n        test_cases.append(data)\n    return test_cases"}
{"problem_id": "pandas_88", "library": "pandas", "code_problem": "You are tasked with implementing a function that calculates the weighted diversity of numeric columns in a given DataFrame over specified sliding windows. The function will analyze the distribution of values within these windows and compute a diversity score based on the frequencies of the unique values.\n\nFunction signature:\n```python\ndef _weighted_diversity(df: pd.DataFrame, window_size: int) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used in the `np.log1p` function to compute the logarithm of one plus the frequencies.\n\nInput format:\n- The function takes two parameters: a pandas DataFrame `df` containing numeric data and an integer `window_size` representing the size of the sliding window.\n\nOutput format:\n- The function returns a pandas DataFrame where each column corresponds to a sliding window of the specified size, and each row contains the calculated diversity score for that window.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test DataFrame\ndata = {\n    'col_0': [1, 2, 1, 3, 2],\n    'col_1': [2, 1, 2, 1, 3],\n    'col_2': [3, 3, 1, 2, 1],\n    'col_3': [1, 2, 3, 3, 2],\n    'col_4': [2, 1, 2, 1, 3]\n}\ndf = pd.DataFrame(data)\n\n# Window size\nwindow_size = 3\n```\n\n**Output:**\n```python\n   span_0_3  span_1_4  span_2_5\n0 -0.287682 -0.287682 -0.287682\n1 -0.287682 -0.287682 -0.287682\n2 -0.436444 -0.287682 -0.287682\n3 -0.287682 -0.287682 -0.287682\n4 -0.287682 -0.287682 -0.287682\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef _weighted_diversity(df, window_size):\n    numeric_df = df.select_dtypes(include=[np.number]).copy()\n    total_cols = numeric_df.shape[1]\n    valid_ranges = range(0, total_cols - window_size + 1)\n    result = []\n\n    for start in valid_ranges:\n        end = start + window_size\n        window = numeric_df.iloc[:, start:end]\n        counts = window.apply(pd.Series.value_counts, axis=1).fillna(0)\n        frequencies = counts.div(counts.sum(axis=1), axis=0)\n        diversity = -1 * (frequencies * np.log1p(frequencies)).sum(axis=1)\n        result.append(diversity)\n\n    stacked = pd.concat(result, axis=1)\n    labels = [f'span_{i}_{i+window_size}' for i in valid_ranges]\n    stacked.columns = labels\n    return stacked", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(5, 100)\n        num_cols = random.randint(5, 20)\n        window_size = random.randint(1, num_cols)\n        numeric_data = np.random.randint(0, 10, size=(num_rows, num_cols))\n        numeric_df = pd.DataFrame(numeric_data, columns=[f'col_{i}' for i in range(num_cols)])\n        if random.random() < 0.3:\n            non_numeric = pd.Series(['label'] * num_rows, name='non_numeric_col')\n            df = pd.concat([numeric_df, non_numeric], axis=1)\n        else:\n            df = numeric_df\n\n        test_cases.append((df, window_size))\n    return test_cases"}
{"problem_id": "pandas_89", "library": "pandas", "code_problem": "You are tasked with implementing a function that performs a simple forecasting of a time series data using a weighted moving average approach. The function should also calculate upper and lower bounds for the forecast based on the standard deviation of the recent historical data.\n\nFunction Signature:\n```python\ndef simple_forecast_with_bounds(df: pd.DataFrame, column: str, forecast_steps: int, window_size: int, bound_multiplier: float) -> pd.DataFrame:\n```\n\nConstants Used:\n- The constant used in the main code is `1` and `2`, which are the start and end values for generating weights.\n\nInput Format:\n- A pandas DataFrame `df` with a datetime index and at least one column specified by `column`.\n- A string `column` representing the name of the column to forecast.\n- An integer `forecast_steps` indicating how many steps into the future to forecast.\n- An integer `window_size` indicating how many recent observations to use for the weighted average.\n- A float `bound_multiplier` used to calculate the bounds.\n\nOutput Format:\n- A pandas DataFrame containing three columns: 'Forecast', 'Lower Bound', and 'Upper Bound', indexed by the forecasted time steps.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\ndata = {\n    'value': [48.5, 52.3, 49.1, 50.0, 53.2, 47.8, 51.0, 54.1, 50.5, 49.9, \n              52.0, 53.5, 48.7, 51.2, 50.3, 49.8, 52.1, 53.0, 48.9, 51.5]\n}\ntime_index = pd.date_range(start='2023-01-01', periods=len(data['value']), freq='H')\ndf = pd.DataFrame(data, index=time_index)\n\ncolumn = 'value'\nforecast_steps = 5\nwindow_size = 10\nbound_multiplier = 1.5\n\n# Call the function\nresult = simple_forecast_with_bounds(df, column, forecast_steps, window_size, bound_multiplier)\n```\n\n**Output:**\n```python\n                      Forecast  Lower Bound  Upper Bound\n2023-01-01 20:00:00  51.051852    48.714546    53.389158\n2023-01-01 21:00:00  50.992099    48.698402    53.285795\n2023-01-01 22:00:00  50.842513    48.914005    52.771022\n2023-01-01 23:00:00  50.976004    49.342606    52.609402\n2023-01-02 00:00:00  50.963275    49.333911    52.592639\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\n\n# main code\ndef simple_forecast_with_bounds(df, column, forecast_steps, window_size, bound_multiplier):\n    series = df[column].dropna().values\n    weights = np.linspace(1, 2, window_size)\n    weights = weights / weights.sum()\n    forecast = []\n    std_devs = []\n    history = series[-window_size:].copy()\n    for _ in range(forecast_steps):\n        pred = np.dot(history, weights)\n        forecast.append(pred)\n        std_dev = np.std(history)\n        std_devs.append(std_dev)\n        history = np.roll(history, -1)\n        history[-1] = pred\n    forecast = np.array(forecast)\n    std_devs = np.array(std_devs)\n    lower = forecast - bound_multiplier * std_devs\n    upper = forecast + bound_multiplier * std_devs\n    forecast_index = pd.date_range(df.index[-1], periods=forecast_steps + 1, freq='h')[1:]\n    final_df = pd.DataFrame({'Forecast': forecast, 'Lower Bound': lower, 'Upper Bound': upper}, index=forecast_index)\n    return final_df", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        series_length = np.random.randint(30, 100)\n        window_size = np.random.randint(5, min(20, series_length))\n        forecast_steps = np.random.randint(5, 20)\n        bound_multiplier = np.random.uniform(0.5, 3.0)\n        start_time = pd.Timestamp('2023-01-01') + pd.to_timedelta(np.random.randint(0, 1000), unit='h')\n        time_index = pd.date_range(start=start_time, periods=series_length, freq='H')\n        data = np.random.normal(loc=50, scale=10, size=series_length)\n        df = pd.DataFrame({'value': data}, index=time_index)\n        test_case = (df, 'value', forecast_steps, window_size, bound_multiplier)\n        test_cases.append(test_case)\n    return test_cases"}
{"problem_id": "pandas_90", "library": "pandas", "code_problem": "You are tasked with creating a function that enriches metadata for power generators based on their operating information. The function will take two DataFrames as input: one containing generator details and another containing operating information. The goal is to fill in missing operating dates for generators and compute additional metadata such as the operating year and decade.\n\nFunction signature:\n```python\ndef enrich_generator_metadata(generators: pd.DataFrame, operating_info: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\nInput format:\n- The function takes two parameters:\n  - `generators`: A pandas DataFrame containing generator metadata.\n  - `operating_info`: A pandas DataFrame containing operating information for the generators.\n\nOutput format:\n- The function returns a pandas DataFrame that includes the enriched generator metadata with additional columns for 'operating_year', 'operating_decade', and 'avg_operating_year'.\n\n**Input:**\n```python\n# Generators DataFrame\ngenerators = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_date': [pd.NaT, pd.NaT, pd.NaT, pd.NaT]\n})\n\n# Operating Info DataFrame\noperating_info = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_year': [1985, 1990, 2000, 2005]\n})\n```\n\n**Output:**\n```python\n# Enriched DataFrame\nenriched = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_date': [Timestamp('1985-01-01 00:00:00'), Timestamp('1990-01-01 00:00:00'), Timestamp('2000-01-01 00:00:00'), Timestamp('2005-01-01 00:00:00')],\n    'operating_year': [1985, 1990, 2000, 2005],\n    'operating_decade': [1980, 1990, 2000, 2000],\n    'avg_operating_year': [1987.5, 1987.5, 2002.5, 2002.5]\n})\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef enrich_generator_metadata(generators, operating_info):\n    base_cols = generators.columns.intersection(['plant_id_eia', 'generator_id', 'operating_date'])\n    gen_core = generators[base_cols].copy()\n    op_cols = operating_info.columns.intersection(['plant_id_eia', 'generator_id', 'operating_year'])\n    op_core = operating_info[op_cols].copy()\n    gen_core.set_index(['plant_id_eia', 'generator_id'], inplace=True)\n    op_core.set_index(['plant_id_eia', 'generator_id'], inplace=True)\n    fill_idx = gen_core['operating_date'].isna()\n    joined = gen_core[fill_idx].join(op_core, how='left')\n    valid_years = joined['operating_year'].notna()\n    converted_dates = pd.to_datetime(joined.loc[valid_years, 'operating_year'].astype(int).astype(str), format='%Y')\n    gen_core.loc[joined.index[valid_years], 'operating_date'] = converted_dates\n    gen_core.reset_index(inplace=True)\n    if 'operating_date' in gen_core:\n        gen_core['operating_year'] = gen_core['operating_date'].dt.year\n        gen_core['operating_decade'] = (np.floor_divide(gen_core['operating_year'], 10) * 10).astype('Int64')\n    grouped_stats = gen_core.groupby('plant_id_eia', observed=True)['operating_year'].agg(['mean']).rename(columns={'mean': 'avg_operating_year'})\n    enriched = pd.merge(gen_core, grouped_stats, on='plant_id_eia', how='left')\n    return enriched", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(5, 50)\n        plant_ids = np.random.randint(1000, 2000, size=num_rows)\n        generator_ids = np.random.randint(1, 100, size=num_rows)\n        possible_dates = [np.datetime64('NaT')] + [np.datetime64(f'{year}-01-01') for year in range(1970, 2021)]\n        operating_dates = pd.to_datetime(np.random.choice(possible_dates, size=num_rows))\n        generators = pd.DataFrame({'plant_id_eia': plant_ids, 'generator_id': generator_ids, 'operating_date': operating_dates})\n        op_years = np.random.randint(1970, 2021, size=num_rows)\n        operating_info = pd.DataFrame({'plant_id_eia': plant_ids, 'generator_id': generator_ids, 'operating_year': op_years})\n        test_cases.append((generators, operating_info))\n    return test_cases\n\n"}
{"problem_id": "pandas_91", "library": "pandas", "code_problem": "You are tasked with creating a function that enriches generator metadata by filling in missing operating dates based on operating information. The function will take two DataFrames as input: one containing generator data and another containing operating information. The goal is to update the generator DataFrame with operating dates and additional derived columns.\n\nFunction signature:\n```python\ndef enrich_generator_metadata(generators: pd.DataFrame, operating_info: pd.DataFrame) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\nInput format:\n- The function takes two parameters:\n  - `generators`: A pandas DataFrame containing generator metadata.\n  - `operating_info`: A pandas DataFrame containing operating information.\n\nOutput format:\n- The function returns a pandas DataFrame that includes the enriched generator metadata with updated operating dates and additional derived columns.\n\n**Input:**\n```python\n# Generators DataFrame\ngenerators = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_date': [pd.NaT, pd.NaT, pd.NaT, pd.NaT]\n})\n\n# Operating Info DataFrame\noperating_info = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_year': [1985, 1990, 1995, 2000]\n})\n```\n\n**Output:**\n```python\n# Enriched DataFrame\nenriched = pd.DataFrame({\n    'plant_id_eia': [1001, 1001, 1002, 1002],\n    'generator_id': [1, 2, 1, 2],\n    'operating_date': [Timestamp('1985-01-01 00:00:00'), Timestamp('1990-01-01 00:00:00'), Timestamp('1995-01-01 00:00:00'), Timestamp('2000-01-01 00:00:00')],\n    'operating_year': [1985, 1990, 1995, 2000],\n    'operating_decade': [1980, 1990, 1990, 2000],\n    'avg_operating_year': [1987.5, 1987.5, 1997.5, 1997.5]\n})\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\n\n# main code\ndef enrich_generator_metadata(generators, operating_info):\n    base_cols = generators.columns.intersection(['plant_id_eia', 'generator_id', 'operating_date'])\n    gen_core = generators[base_cols].copy()\n    op_cols = operating_info.columns.intersection(['plant_id_eia', 'generator_id', 'operating_year'])\n    op_core = operating_info[op_cols].copy()\n    gen_core.set_index(['plant_id_eia', 'generator_id'], inplace=True)\n    op_core.set_index(['plant_id_eia', 'generator_id'], inplace=True)\n    fill_idx = gen_core['operating_date'].isna()\n    joined = gen_core[fill_idx].join(op_core, how='left')\n    valid_years = joined['operating_year'].notna()\n    converted_dates = pd.to_datetime(joined.loc[valid_years, 'operating_year'].astype(int).astype(str), format='%Y')\n    gen_core.loc[joined.index[valid_years], 'operating_date'] = converted_dates\n    gen_core.reset_index(inplace=True)\n    if 'operating_date' in gen_core:\n        gen_core['operating_year'] = gen_core['operating_date'].dt.year\n        gen_core['operating_decade'] = (np.floor_divide(gen_core['operating_year'], 10) * 10).astype('Int64')\n    grouped_stats = gen_core.groupby('plant_id_eia', observed=True)['operating_year'].agg(['mean']).rename(columns={'mean': 'avg_operating_year'})\n    enriched = pd.merge(gen_core, grouped_stats, on='plant_id_eia', how='left')\n    return enriched", "test_script": "import pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(5, 50)\n        plant_ids = np.random.randint(1000, 2000, size=num_rows)\n        generator_ids = np.random.randint(1, 100, size=num_rows)\n        possible_dates = [np.datetime64('NaT')] + [np.datetime64(f'{year}-01-01') for year in range(1970, 2021)]\n        operating_dates = pd.to_datetime(np.random.choice(possible_dates, size=num_rows))\n        generators = pd.DataFrame({'plant_id_eia': plant_ids, 'generator_id': generator_ids, 'operating_date': operating_dates})\n        op_years = np.random.randint(1970, 2021, size=num_rows)\n        operating_info = pd.DataFrame({'plant_id_eia': plant_ids, 'generator_id': generator_ids, 'operating_year': op_years})\n        test_cases.append((generators, operating_info))\n    return test_cases\n"}
{"problem_id": "scipy_0", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the z-scores of a given input array along different axes. The z-score is a statistical measurement that describes a value's relation to the mean of a group of values. The function will utilize the `scipy.stats` library to perform the calculations.\n\nFunction signature:\n```python\ndef test_zscore_constant_input(x):\n```\n\nIn this function, the following constant is used:\n- The input `x` is expected to be a numerical array (e.g., a list or a NumPy array).\n\nInput format:\n- The input to the function is a numerical array `x`.\n\nOutput format:\n- The output of the function is a tuple containing three arrays: the z-scores computed along the first axis, the second axis, and the entire array.\n\nInput:\n```python\narray([[5, 5, 5, 5, 5, 5],\n       [5, 5, 5, 5, 5, 5],\n       [5, 5, 5, 5, 5, 5]])\n```\n\nOutput:\n```python\n(\narray([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]]), \narray([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]]), \narray([[nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan],\n       [nan, nan, nan, nan, nan, nan]])\n)\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef test_zscore_constant_input(x):\n    z0 = stats.zscore(x, axis=0)\n    z1 = stats.zscore(x, axis=1)\n    z = stats.zscore(x, axis=None)\n\n    return z0, z1, z", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        x = np.random.randn(3, 6)\n        if np.random.rand() < 0.1:\n            constant_value = np.random.uniform(-10, 10)\n            x = np.full((3, 6), constant_value)\n\n        test_cases.append(x)\n\n    return test_cases"}
{"problem_id": "scipy_1", "library": "scipy", "code_problem": "You are tasked with implementing a function that validates the results of simulated data against real data. The function will perform statistical comparisons and assessments to determine the similarity and characteristics of the two datasets.\n\nFunction Signature:\n```python\ndef validate_results(real_sim_dict):\n```\n\n### Constants Used:\n- The constant value `0.2` is used to determine the acceptance rate based on the absolute differences between the real and simulated data.\n\n### Input Format:\n- A dictionary where each key is a string (variable name) and each value is a tuple containing:\n  - A list of real data (e.g., [1.0, 2.0, 3.0])\n  - A DataFrame of simulated data (e.g., pd.DataFrame({'simulated': [1.1, 2.1, 3.1]}))\n\n### Output Format:\n- A list of dictionaries, where each dictionary contains:\n  - \"variable\": the name of the variable (string)\n  - \"statistical_comparison\": a dictionary with mean, STD, and CV for both datasets\n  - \"ks_test_p_value\": the p-value from the KS test (float)\n  - \"distribution_similarity\": a string indicating if the distributions are similar or not\n  - \"acceptance_rate\": the acceptance rate as a percentage (float)\n  - \"normality_assessment\": a string indicating if the differences follow a normal distribution or not\n\n**Input:**\n```python\n{\n    \"var_0\": ([-0.5, 0.1, 0.3, 0.7, -1.2], pd.DataFrame({\"simulated\": [-0.4, 0.2, 0.5, 0.6, -1.0]})),\n    \"var_1\": ([1.5, 2.0, 1.8, 2.2, 1.9], pd.DataFrame({\"simulated\": [1.6, 2.1, 1.7, 2.3, 1.8]}))\n}\n```\n\n**Output:**\n```python\n[\n    {\n        'variable': 'var_0', \n        'statistical_comparison': {\n            'mean': {\n                'reality': -0.12000000000000002, \n                'simulated': -0.020000000000000018}, \n            'STD': {\n                'reality': 0.6645299090334459, \n                'simulated': 0.6013318551349164\n            }, \n            'CV': {\n                'reality': -5.537749241945381, \n                'simulated': -30.06659275674579\n            }\n        }, \n        'ks_test_p_value': 1.0, \n        'distribution_similarity': 'Two distributions are similar', \n        'acceptance_rate': 100.0, \n        'normality_assessment': 'Difference is not a normal distribution'\n    }, \n    {\n        'variable': 'var_1', \n        'statistical_comparison': {\n            'mean': {\n                'reality': 1.8800000000000001, \n                'simulated': 1.9\n            }, \n            'STD': {\n                'reality': 0.23151673805580456, \n                'simulated': 0.26076809620810587\n            }, \n            'CV': {\n                'reality': 0.12314720109351306, \n                'simulated': 0.13724636642531887\n            }\n        }, \n        'ks_test_p_value': 1.0, \n        'distribution_similarity': 'Two distributions are similar', \n        'acceptance_rate': 100.0, \n        'normality_assessment': 'Difference is not a normal distribution'\n    }\n]\n```", "ground_truth_code": "import pandas as pd\nfrom scipy.stats import ks_2samp\nimport numpy as np\nfrom scipy.stats import shapiro\nfrom scipy.stats import variation\n\n# main code\ndef validate_results(real_sim_dict):\n    val_results = []\n    for (vname, vvalue) in real_sim_dict.items():\n        real_list = np.array(vvalue[0]).flatten()\n        simulation_list = np.array(vvalue[1].values).flatten()\n        if len(real_list) == 0 or len(simulation_list) == 0:\n            val_results.append({\n                \"variable\": vname,\n                \"error\": \"Empty lists encountered\"\n            })\n            continue\n\n        if len(simulation_list) != len(real_list):\n            simulation_list = simulation_list[:len(real_list)]\n        sta, p_value = ks_2samp(real_list, simulation_list)\n        p_value = float(np.atleast_1d(p_value)[0])\n        similarity = \"Two distributions are similar\" if p_value >= 0.05 else \"Two distributions are not similar\"\n        statistical_compare = pd.DataFrame(\n            [[np.mean(real_list), np.std(real_list), variation(real_list)],\n             [np.mean(simulation_list), np.std(simulation_list), variation(simulation_list)]],\n            index=['reality', 'simulated'],\n            columns=['mean', 'STD', 'CV']\n        )\n        diff_list = abs(np.array(real_list) - np.array(simulation_list))\n        acceptance_rate = sum(i <= 0.2 for i in diff_list) / len(real_list) * 100\n        normality = \"Difference follows a normal distribution\" if shapiro(diff_list)[\n                                                                      1] > 0.5 else \"Difference is not a normal distribution\"\n\n        val_results.append({\n            \"variable\": vname,\n            \"statistical_comparison\": statistical_compare.to_dict(),\n            \"ks_test_p_value\": round(p_value, 2),\n            \"distribution_similarity\": similarity,\n            \"acceptance_rate\": round(acceptance_rate, 2),\n            \"normality_assessment\": normality\n        })\n    return val_results", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_vars = np.random.randint(1, 5)\n        real_sim_dict = {}\n\n        for i in range(num_vars):\n            var_name = f\"var_{i}\"\n            length = np.random.randint(10, 100)\n            real_data = np.random.normal(loc=0, scale=1, size=length).tolist()\n            simulated_data = pd.DataFrame({\n                \"simulated\": np.random.normal(loc=0, scale=1, size=length)\n            })\n            real_sim_dict[var_name] = (real_data, simulated_data)\n        test_cases.append(real_sim_dict)\n\n    return test_cases"}
{"problem_id": "scipy_2", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes various statistical minimum values for given datasets using the `scipy.stats` library. The function will take in two datasets and their corresponding modified datasets, and it will calculate the minimum values for different sample sizes. The function signature is as follows:\n\n```python\ndef test_tmin(x, y, xm, ym):\n```\n\n### Constants Used:\nThe constant used in the main code is a list of sample sizes: `[1000, 100, 10, 5]`.\n\n### Input Format:\n- The function takes four parameters:\n  - `x`: A dataset (e.g., a list or array of numerical values).\n  - `y`: Another dataset (e.g., a list or array of numerical values).\n  - `xm`: A modified version of dataset `x`.\n  - `ym`: A modified version of dataset `y`.\n\n### Output Format:\n- The function returns a list of dictionaries, where each dictionary contains:\n  - `'n'`: The sample size.\n  - `'tmin_x'`: The minimum value of dataset `x`.\n  - `'tmin_xm'`: The minimum value of modified dataset `xm`.\n  - `'tmin_y'`: The minimum value of dataset `y`.\n  - `'tmin_ym'`: The minimum value of modified dataset `ym`.\n  - `'tmin_x_ll'`: The minimum value of dataset `x` with a lower limit of -1.0.\n  - `'tmin_xm_ll'`: The minimum value of modified dataset `xm` with a lower limit of -1.0.\n  - `'tmin_y_ll'`: The minimum value of dataset `y` with a lower limit of -1.0.\n  - `'tmin_ym_ll'`: The minimum value of modified dataset `ym` with a lower limit of -1.0.\n\nInput:\n```python\nx = np.array([0.5, -1.2, 3.4, 2.1, -0.5])\ny = np.array([-0.3, 1.5, 2.2, -2.1, 0.0])\nxm = np.ma.array(x, mask=[0, 1, 0, 0, 0])  # Masking the second element\nym = np.ma.array(y, mask=[0, 0, 1, 0, 0])  # Masking the third element\n```\n\nOutput:\n```python\n[{\n    'n': 1000, \n    'tmin_x': -1.2, \n    'tmin_xm': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n    'tmin_y': -2.1, \n    'tmin_ym': masked_array(data=-2.1,mask=False, fill_value=1e+20), \n    'tmin_x_ll': -0.5, \n    'tmin_xm_ll': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n    'tmin_y_ll': -0.3, \n    'tmin_ym_ll': masked_array(data=-0.3, mask=False, fill_value=1e+20)\n}, \n {\n     'n': 100, \n     'tmin_x': -1.2, \n     'tmin_xm': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n     'tmin_y': -2.1, \n     'tmin_ym': masked_array(data=-2.1, mask=False, fill_value=1e+20), \n     'tmin_x_ll': -0.5, \n     'tmin_xm_ll': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n     'tmin_y_ll': -0.3, \n     'tmin_ym_ll': masked_array(data=-0.3, mask=False, fill_value=1e+20)}, \n {\n     'n': 10, \n     'tmin_x': -1.2, \n     'tmin_xm': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n     'tmin_y': -2.1, \n     'tmin_ym': masked_array(data=-2.1, mask=False, fill_value=1e+20), \n     'tmin_x_ll': -0.5, \n     'tmin_xm_ll': masked_array(data=-0.5, mask=False, fill_value=1e+20), 'tmin_y_ll': -0.3, 'tmin_ym_ll': masked_array(data=-0.3, mask=False, fill_value=1e+20)\n }, \n {\n     'n': 5, \n     'tmin_x': -1.2, \n     'tmin_xm': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n     'tmin_y': -2.1, \n     'tmin_ym': masked_array(data=-2.1, mask=False, fill_value=1e+20), \n     'tmin_x_ll': -0.5, \n     'tmin_xm_ll': masked_array(data=-0.5, mask=False, fill_value=1e+20), \n     'tmin_y_ll': -0.3, \n     'tmin_ym_ll': masked_array(data=-0.3, mask=False, fill_value=1e+20)\n  }\n]\n```", "ground_truth_code": "from scipy import stats\n\n# main code\ndef test_tmin(x, y, xm, ym):\n    results = []\n    for n in [1000, 100, 10, 5]:\n        results.append({\n            'n': n,\n            'tmin_x': stats.tmin(x),\n            'tmin_xm': stats.mstats.tmin(xm),\n            'tmin_y': stats.tmin(y),\n            'tmin_ym': stats.mstats.tmin(ym),\n            'tmin_x_ll': stats.tmin(x, lowerlimit=-1.0),\n            'tmin_xm_ll': stats.mstats.tmin(xm, lowerlimit=-1.0),\n            'tmin_y_ll': stats.tmin(y, lowerlimit=-1.0),\n            'tmin_ym_ll': stats.mstats.tmin(ym, lowerlimit=-1.0)\n        })\n    return results\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(10, 1001)\n        x = np.random.randn(size)\n        y = np.random.randn(size)\n        xm = np.ma.array(x, mask=np.random.rand(size) < 0.1)\n        ym = np.ma.array(y, mask=np.random.rand(size) < 0.1)\n\n        test_cases.append((x, y, xm, ym))\n\n    return test_cases"}
{"problem_id": "scipy_3", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs the Kolmogorov-Smirnov (KS) two-sample test for different modes and alternative hypotheses. The function will take two datasets as input and return the results of the KS test for each combination of mode and alternative hypothesis.\n\nFunction signature:\n```python\ndef test_ks_2samp(x, y):\n```\n\nConstant used in the main code:\n- The constant lists used in the main code are `['auto', 'exact', 'asymp']` for modes and `['less', 'greater', 'two-sided']` for alternative hypotheses.\n\nInput format:\n- The function takes two inputs, `x` and `y`, which are both expected to be arrays or lists of numerical values.\n\nOutput format:\n- The function returns a list of results, where each result corresponds to the output of the KS test for a specific combination of mode and alternative hypothesis. Each result is typically an object containing the KS statistic and the p-value.\n\nInput:\n```python\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.0])\ny = np.array([2.1, 2.9, 3.5, 4.0, 4.8])\n```\n\nOutput:\n```python\n[\n    KstestResult(statistic=0.2, pvalue=0.8333333333333334, statistic_location=4.0, statistic_sign=-1), \n    KstestResult(statistic=0.2, pvalue=0.8333333333333334, statistic_location=1.2, statistic_sign=1), \n    KstestResult(statistic=0.2, pvalue=1.0, statistic_location=4.0, statistic_sign=-1), \n    KstestResult(statistic=0.2, pvalue=0.8333333333333334, statistic_location=4.0, statistic_sign=-1), \n    KstestResult(statistic=0.2, pvalue=0.8333333333333334, statistic_location=1.2, statistic_sign=1), \n    KstestResult(statistic=0.2, pvalue=1.0, statistic_location=4.0, statistic_sign=-1), \n    KstestResult(statistic=0.20000000000000007, pvalue=0.6703200460356391, statistic_location=4.0, statistic_sign=-1), \n    KstestResult(statistic=0.2, pvalue=0.6703200460356392, statistic_location=1.2, statistic_sign=1), \n    KstestResult(statistic=0.20000000000000007, pvalue=1.0, statistic_location=4.0, statistic_sign=-1)\n]\n``` \n", "ground_truth_code": "from scipy import stats\n\n\n# main code\ndef test_ks_2samp(x, y):\n    results = []\n\n    for mode in ['auto', 'exact', 'asymp']:\n        for alternative in ['less', 'greater', 'two-sided']:\n            res1 = stats.ks_2samp(x, y, alternative=alternative, mode=mode)\n            results.append(res1)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        size_x = np.random.randint(5, 500)\n        size_y = np.random.randint(5, 500)\n        dist_x = np.random.choice(['normal', 'uniform', 'exponential', 'poisson'])\n        dist_y = np.random.choice(['normal', 'uniform', 'exponential', 'poisson'])\n        if dist_x == 'normal':\n            x = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(0.1, 5), size=size_x)\n        elif dist_x == 'uniform':\n            x = np.random.uniform(low=-10, high=10, size=size_x)\n        elif dist_x == 'exponential':\n            x = np.random.exponential(scale=np.random.uniform(0.1, 5), size=size_x)\n        else:\n            x = np.random.poisson(lam=np.random.uniform(1, 10), size=size_x)\n        if dist_y == 'normal':\n            y = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(0.1, 5), size=size_y)\n        elif dist_y == 'uniform':\n            y = np.random.uniform(low=-10, high=10, size=size_y)\n        elif dist_y == 'exponential':\n            y = np.random.exponential(scale=np.random.uniform(0.1, 5), size=size_y)\n        else:\n            y = np.random.poisson(lam=np.random.uniform(1, 10), size=size_y)\n\n        test_cases.append((x, y))\n\n    return test_cases\n"}
{"problem_id": "scipy_4", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that performs one-sample t-tests on a three-dimensional array of random values. The function will generate random values from a normal distribution and then conduct various t-tests on these values, returning the results in a structured format.\n\nFunction Signature:\n```python\ndef perform_ttest_1samp(n1: int, n2: int, n3: int) -> dict:\n```\n\nConstants:\n- The mean (`loc`) of the normal distribution is set to 5.\n- The standard deviation (`scale`) of the normal distribution is set to 10.\n\nInput Format:\n- The function takes three integer parameters: `n1`, `n2`, and `n3`, which define the dimensions of the three-dimensional array of random values.\n\nOutput Format:\n- The function returns a dictionary containing the results of the t-tests, structured by the different axes and test types. Each entry in the dictionary consists of tuples containing t-statistics and p-values.\n\nInput: (5, 4, 3)\n\nOutput: \n{'alt_greater': (array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n                 array([[0.19234771, 0.03005156, 0.05627498],\n       [0.7846658 , 0.59890438, 0.03951929],\n       [0.03350303, 0.25745947, 0.12392745],\n       [0.27385706, 0.14003034, 0.22160752]]),\n                 array([[0.19234771, 0.03005156, 0.05627498],\n       [0.7846658 , 0.59890438, 0.03951929],\n       [0.03350303, 0.25745947, 0.12392745],\n       [0.27385706, 0.14003034, 0.22160752]])),\n 'alt_less': (array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n              array([[0.80765229, 0.96994844, 0.94372502],\n       [0.2153342 , 0.40109562, 0.96048071],\n       [0.96649697, 0.74254053, 0.87607255],\n       [0.72614294, 0.85996966, 0.77839248]]),\n              array([[0.80765229, 0.96994844, 0.94372502],\n       [0.2153342 , 0.40109562, 0.96048071],\n       [0.96649697, 0.74254053, 0.87607255],\n       [0.72614294, 0.85996966, 0.77839248]])),\n 'axis_0': (array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n            array([[0.38469541, 0.06010313, 0.11254996],\n       [0.4306684 , 0.80219123, 0.07903858],\n       [0.06700605, 0.51491893, 0.2478549 ],\n       [0.54771411, 0.28006068, 0.44321504]]),\n            array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n            array([[0.38469541, 0.06010313, 0.11254996],\n       [0.4306684 , 0.80219123, 0.07903858],\n       [0.06700605, 0.51491893, 0.2478549 ],\n       [0.54771411, 0.28006068, 0.44321504]]),\n            0.9751665203227726,\n            0.38469541071804114),\n 'axis_1': (array([[ 1.62985696,  1.65176949,  0.96912212],\n       [ 0.51462154,  1.24147322,  1.22829769],\n       [-0.50354862,  0.87099347,  2.05632933],\n       [ 0.94854922,  0.7973818 ,  0.83880797],\n       [ 1.10725784,  0.15846372,  1.57912737]]),\n            array([[0.20162356, 0.19714926, 0.40396823],\n       [0.642331  , 0.30265217, 0.3069095 ],\n       [0.64922767, 0.4478529 , 0.13195974],\n       [0.41282875, 0.48350781, 0.46315105],\n       [0.34898429, 0.88415766, 0.21242588]]),\n            array([[ 1.62985696,  1.65176949,  0.96912212],\n       [ 0.51462154,  1.24147322,  1.22829769],\n       [-0.50354862,  0.87099347,  2.05632933],\n       [ 0.94854922,  0.7973818 ,  0.83880797],\n       [ 1.10725784,  0.15846372,  1.57912737]]),\n            array([[0.20162356, 0.19714926, 0.40396823],\n       [0.642331  , 0.30265217, 0.3069095 ],\n       [0.64922767, 0.4478529 , 0.13195974],\n       [0.41282875, 0.48350781, 0.46315105],\n       [0.34898429, 0.88415766, 0.21242588]]),\n            1.6298569601440167,\n            0.20162355640260082),\n 'axis_2': (array([[ 1.00486685,  1.2812521 ,  1.01318936,  1.45037554],\n       [ 5.33367851, -1.0533368 , -1.45491583,  2.51498769],\n       [-0.39815539, -0.12846501, 17.8969758 ,  0.19014442],\n       [ 2.54830417, -0.47643851,  1.30776681, -1.31787215],\n       [ 1.91509057,  1.37495195,  0.16620125, -1.52937797]]),\n            array([[0.42078103, 0.32858961, 0.41760653, 0.2840239 ],\n       [0.03340054, 0.40266125, 0.28293416, 0.12835531],\n       [0.72899719, 0.909534  , 0.00310751, 0.86674664],\n       [0.12562272, 0.6807379 , 0.32106455, 0.31825163],\n       [0.19556529, 0.30291585, 0.88328123, 0.26579023]]),\n            array([[ 1.00486685,  1.2812521 ,  1.01318936,  1.45037554],\n       [ 5.33367851, -1.0533368 , -1.45491583,  2.51498769],\n       [-0.39815539, -0.12846501, 17.8969758 ,  0.19014442],\n       [ 2.54830417, -0.47643851,  1.30776681, -1.31787215],\n       [ 1.91509057,  1.37495195,  0.16620125, -1.52937797]]),\n            array([[0.42078103, 0.32858961, 0.41760653, 0.2840239 ],\n       [0.03340054, 0.40266125, 0.28293416, 0.12835531],\n       [0.72899719, 0.909534  , 0.00310751, 0.86674664],\n       [0.12562272, 0.6807379 , 0.32106455, 0.31825163],\n       [0.19556529, 0.30291585, 0.88328123, 0.26579023]]),\n            1.004866850822531,\n            0.4207810325338299),\n 'nan_policy_greater': (array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n                        array([[0.19234771, 0.03005156, 0.05627498],\n       [0.7846658 , 0.59890438, 0.03951929],\n       [0.03350303, 0.25745947, 0.12392745],\n       [0.27385706, 0.14003034, 0.22160752]]),\n                        array([[0.19234771, 0.03005156, 0.05627498],\n       [0.7846658 , 0.59890438, 0.03951929],\n       [0.03350303, 0.25745947, 0.12392745],\n       [0.27385706, 0.14003034, 0.22160752]])),\n 'nan_policy_less': (array([[ 0.97516652,  2.59913021,  2.02736342],\n       [-0.87562047, -0.26766653,  2.34392238],\n       [ 2.49665011,  0.71356595,  1.35169257],\n       [ 0.65587545,  1.24811366,  0.84998888]]),\n                     array([[0.80765229, 0.96994844, 0.94372502],\n       [0.2153342 , 0.40109562, 0.96048071],\n       [0.96649697, 0.74254053, 0.87607255],\n       [0.72614294, 0.85996966, 0.77839248]]),\n                     array([[0.80765229, 0.96994844, 0.94372502],\n       [0.2153342 , 0.40109562, 0.96048071],\n       [0.96649697, 0.74254053, 0.87607255],\n       [0.72614294, 0.85996966, 0.77839248]])),\n 'single_test': (-inf, 0.0)}\n", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef perform_ttest_1samp(n1, n2, n3):\n    rvn1 = stats.norm.rvs(loc=5, scale=10, size=(n1, n2, n3))\n\n    results = {}\n\n    (t1, p1) = stats.ttest_1samp(rvn1[:, :, :], np.ones((n2, n3)), axis=0)\n    (t2, p2) = stats.ttest_1samp(rvn1[:, :, :], 1, axis=0)\n    (t3, p3) = stats.ttest_1samp(rvn1[:, 0, 0], 1)\n    results['axis_0'] = (t1, p1, t2, p2, t3, p3)\n\n    (t1, p1) = stats.ttest_1samp(rvn1[:, :, :], np.ones((n1, 1, n3)), axis=1)\n    (t2, p2) = stats.ttest_1samp(rvn1[:, :, :], 1, axis=1)\n    (t3, p3) = stats.ttest_1samp(rvn1[0, :, 0], 1)\n    results['axis_1'] = (t1, p1, t2, p2, t3, p3)\n\n    (t1, p1) = stats.ttest_1samp(rvn1[:, :, :], np.ones((n1, n2, 1)), axis=2)\n    (t2, p2) = stats.ttest_1samp(rvn1[:, :, :], 1, axis=2)\n    (t3, p3) = stats.ttest_1samp(rvn1[0, 0, :], 1)\n    results['axis_2'] = (t1, p1, t2, p2, t3, p3)\n\n    (t, p) = stats.ttest_1samp([0, 0, 0], 1)\n    results['single_test'] = (t, p)\n\n    def convert(t, p, alt):\n        if t < 0 and alt == 'less' or (t > 0 and alt == 'greater'):\n            return p / 2\n        return 1 - p / 2\n\n    converter = np.vectorize(convert)\n\n    (tr, pr) = stats.ttest_1samp(rvn1[:, :, :], 1)\n    (t, p) = stats.ttest_1samp(rvn1[:, :, :], 1, alternative='greater')\n    pc = converter(tr, pr, 'greater')\n    results['alt_greater'] = (t, p, pc)\n\n    (t, p) = stats.ttest_1samp(rvn1[:, :, :], 1, alternative='less')\n    pc = converter(tr, pr, 'less')\n    results['alt_less'] = (t, p, pc)\n\n    rvn1[0:2, 1:3, 4:8] = np.nan\n    (tr, pr) = stats.ttest_1samp(rvn1[:, :, :], 1, nan_policy='omit')\n    (t, p) = stats.ttest_1samp(rvn1[:, :, :], 1, nan_policy='omit', alternative='greater')\n    pc = converter(tr, pr, 'greater')\n    results['nan_policy_greater'] = (t, p, pc)\n\n    (t, p) = stats.ttest_1samp(rvn1[:, :, :], 1, nan_policy='omit', alternative='less')\n    pc = converter(tr, pr, 'less')\n    results['nan_policy_less'] = (t, p, pc)\n\n    return results", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        n1 = random.randint(2, 20)\n        n2 = random.randint(2, 20)\n        n3 = random.randint(2, 20)\n\n        test_cases.append((n1, n2, n3, ))\n\n    return test_cases"}
{"problem_id": "scipy_5", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the mode of a given array while handling various edge cases. The function should be able to return the mode for different scenarios, including empty inputs and arrays containing NaN values. The function signature is as follows:\n\n```python\ndef compute_mode(a):\n```\n\nIn this function, the constant used is `nan_policy`, which determines how to handle NaN values in the input array. The `nan_policy` can take two values: `'omit'` to ignore NaN values when calculating the mode, and `'propagate'` to return NaN if any NaN values are present in the input.\n\nThe function returns a dictionary containing the results of these computations, with keys corresponding to each case.\n\nInput format:\n- The input to the function is a 2D array-like structure (e.g., a list of lists or a NumPy array).\n\nOutput format:\n- The output of the function is a dictionary with the following keys:\n  - `'empty_case'`: Result of the mode computation for an empty list.\n  - `'nan_case'`: Result of the mode computation for an array containing a single NaN value.\n  - `'mode_omit'`: Result of the mode computation for the input array `a` with NaN values omitted.\n  - `'mode_propagate'`: Result of the mode computation for the input array `a` with NaN values propagated.\n  - `'empty_array_case'`: Result of the mode computation for an empty 2D array.\n\nInput:\n```python\narray([[ 1.,  2.,  2.],\n       [ 3.,  3.,  4.],\n       [ 5.,  5.,  5.],\n       [ 6.,  7.,  8.]])\n```\n\nOutput:\n```python\n{\n 'empty_array_case': ModeResult(mode=array([nan, nan]), count=array([0., 0.])),\n 'empty_case': ModeResult(mode=nan, count=0.0),\n 'mode_omit': ModeResult(mode=array([2., 3., 5., 6.]), count=array([2., 2., 3., 1.])),\n 'mode_propagate': ModeResult(mode=array([2., 3., 5., 6.]), count=array([2., 2., 3., 1.])),\n 'nan_case': ModeResult(mode=nan, count=0.0)\n}\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef compute_mode(a):\n    results = {\n        'empty_case': stats.mode([]),\n        'nan_case': stats.mode([np.nan], nan_policy='omit'),\n        'mode_omit': stats.mode(a, axis=1, nan_policy='omit'),\n        'mode_propagate': stats.mode(a, axis=1, nan_policy='propagate'),\n        'empty_array_case': stats.mode(np.array([[], []]), axis=1)\n    }\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = np.random.randint(1, 10)\n        num_cols = np.random.randint(1, 10)\n        if np.random.rand() < 0.2:\n            a = np.array([[]] * num_rows)\n        elif np.random.rand() < 0.3:\n            a = np.random.randint(0, 10, (num_rows, num_cols)).astype(float)\n            nan_indices = np.random.choice(a.size, size=np.random.randint(1, a.size + 1), replace=False)\n            a.ravel()[nan_indices] = np.nan\n        else:\n            a = np.random.randint(0, 10, (num_rows, num_cols))\n\n        test_cases.append(a)\n    return test_cases"}
{"problem_id": "scipy_6", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs multiple independent t-tests on a given dataset. The function will utilize both the standard `scipy.stats` library and the `scipy.stats.mstats` module, which is designed for masked statistics. The function will return the results of these tests in a structured format.\n\nFunction signature:\n```python\ndef test_vs_nonmasked(outcome: np.ndarray) -> dict:\n```\n\nInput format:\n- The input to the function is a 2D NumPy array `outcome`, where each column represents a different group of data for comparison.\n\nOutput format:\n- The output of the function is a dictionary containing the results of the t-tests, with keys indicating the specific test performed and values being the results of those tests. Each result includes statistics such as the t-statistic and p-value.\n\n**Input:**\n```python\nimport numpy as np\n\n# Generating a test case\noutcome = np.array([\n    [1.2, 2.3, 3.1, 4.5],\n    [1.5, 2.1, 3.3, 4.0],\n    [1.8, 2.5, 3.0, 4.2],\n    [1.0, 2.2, 3.5, 4.1],\n    [1.3, 2.4, 3.2, 4.3]\n])\n```\n\n**Output:**\n```python\n{\n    'res1_1': TtestResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263, df=8.0),\n    'res1_2': TtestResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263, df=8.0),\n    'res1_3': TtestResult(statistic=array([-11.53523032, -17.24210899]), pvalue=array([2.89521808e-06, 1.30307545e-07]), df=array([8., 8.])),\n    'res2_1': Ttest_indResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263),\n    'res2_2': Ttest_indResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263),\n    'res2_3': Ttest_indResult(statistic=masked_array(data=[-11.535230316796389, -17.242108994570387], mask=[False, False], fill_value=1e+20), pvalue=masked_array(data=[2.89521808e-06, 1.30307545e-07], mask=False, fill_value=1e+20)),\n    'res4_1': TtestResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263, df=8.0),\n    'res4_2': TtestResult(statistic=-6.118878816098725, pvalue=0.0008669263199776029, df=6.005607073538923),\n    'res5_1': Ttest_indResult(statistic=-6.118878816098725, pvalue=0.00028351760963143263),\n    'res5_2': Ttest_indResult(statistic=-6.118878816098725, pvalue=0.0008669263199776029)\n}\n```", "ground_truth_code": "from scipy import stats\nimport scipy.stats.mstats as mstats\n\n\n# main code\ndef test_vs_nonmasked(outcome):\n    res1_1 = stats.ttest_ind(outcome[:, 0], outcome[:, 1])\n    res2_1 = mstats.ttest_ind(outcome[:, 0], outcome[:, 1])\n    res1_2 = stats.ttest_ind(outcome[:, 0], outcome[:, 1], axis=None)\n    res2_2 = mstats.ttest_ind(outcome[:, 0], outcome[:, 1], axis=None)\n    res1_3 = stats.ttest_ind(outcome[:, :2], outcome[:, 2:], axis=0)\n    res2_3 = mstats.ttest_ind(outcome[:, :2], outcome[:, 2:], axis=0)\n    res4_1 = stats.ttest_ind(outcome[:, 0], outcome[:, 1], equal_var=True)\n    res5_1 = mstats.ttest_ind(outcome[:, 0], outcome[:, 1], equal_var=True)\n    res4_2 = stats.ttest_ind(outcome[:, 0], outcome[:, 1], equal_var=False)\n    res5_2 = mstats.ttest_ind(outcome[:, 0], outcome[:, 1], equal_var=False)\n\n    return {\n        \"res1_1\": res1_1, \"res2_1\": res2_1,\n        \"res1_2\": res1_2, \"res2_2\": res2_2,\n        \"res1_3\": res1_3, \"res2_3\": res2_3,\n        \"res4_1\": res4_1, \"res5_1\": res5_1,\n        \"res4_2\": res4_2, \"res5_2\": res5_2\n    }\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(10, 101)\n        outcome = np.random.normal(loc=0, scale=1, size=(m, 4))\n\n        test_cases.append(outcome)\n\n    return test_cases"}
{"problem_id": "scipy_7", "library": "scipy", "code_problem": "Implement a function that performs various statistical t-tests on two sets of random variables. The function should be able to handle both 1D and multi-dimensional arrays, as well as scalars. It should also account for missing values (NaNs) in the data.\n\nFunction signature:\n```python\ndef test_ttest_ind(rvs1, rvs2):\n```\n\nIn the main code, the constant used is:\n- `4.0` and `3.0` for scalar t-tests.\n- \nInput format:\n- Two arrays `rvs1` and `rvs2`, which can be 1D, 2D, or 3D numpy arrays or scalars.\n\nOutput format:\n- A dictionary containing the results of various t-tests, where each key corresponds to a specific test and the value is a tuple of (t-statistic, p-value).\n\n```python\n# Input\nrvs1 = np.array([5.1, 6.2, 7.3, 4.8, 5.9])\nrvs2 = np.array([3.4, 2.8, 4.1, 3.9, 2.5])\n\n# Output\n{\n    't_p_single': (4.685990420825294, 0.001569652707082195), \n    't_p_2D': (array([ 4.68599042, -4.68599042]), array([0.00156965, 0.00156965])), \n    't_p_2D_axis1': (array([ 4.68599042, -4.68599042]), array([0.00156965, 0.00156965])), \n    't_p_scalar': (nan, nan), \n    't_p_3D': (array([[ 4.68599042,  4.68599042,  4.68599042],\n       [-4.68599042, -4.68599042, -4.68599042]]), array([[0.00156965, 0.00156965, 0.00156965],\n       [0.00156965, 0.00156965, 0.00156965]])), \n    't_p_less': (4.685990420825294, 0.9992151736464588), \n    't_p_greater': (4.685990420825294, 0.0007848263535410975), \n    't_p_nan_less': (array([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]]), array([[0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5]])), \n    't_p_nan_greater': (array([[0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.],\n       [0., 0., 0.]]), array([[0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5],\n       [0.5, 0.5, 0.5]]))\n}\n``` \n", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n\ndef _stats(x, axis=0):\n    x = np.asarray(x)\n    mu = np.mean(x, axis=axis)\n    std = np.std(x, axis=axis, ddof=1)\n    nobs = x.shape[axis]\n    return (mu, std, nobs)\n\n\ndef _desc_stats(x1, x2, axis=0):\n    def _stats(x, axis=0):\n        x = np.asarray(x)\n        mu = np.mean(x, axis=axis)\n        std = np.std(x, axis=axis, ddof=1)\n        nobs = x.shape[axis]\n        return (mu, std, nobs)\n\n    return _stats(x1, axis) + _stats(x2, axis)\n\n\n# main code\ndef test_ttest_ind(rvs1, rvs2):\n    rvs1_2D = np.array([rvs1, rvs2])\n    rvs2_2D = np.array([rvs2, rvs1])\n    results = {}\n    (t, p) = stats.ttest_ind(rvs1, rvs2, axis=0)\n    results['t_p_single'] = (t, p)\n    (t, p) = stats.ttest_ind(rvs1_2D.T, rvs2_2D.T, axis=0)\n    results['t_p_2D'] = (t, p)\n    (t, p) = stats.ttest_ind(rvs1_2D, rvs2_2D, axis=1)\n    results['t_p_2D_axis1'] = (t, p)\n    (t, p) = stats.ttest_ind(4.0, 3.0)\n    results['t_p_scalar'] = (t, p)\n    rvs1_3D = np.dstack([rvs1_2D, rvs1_2D, rvs1_2D])\n    rvs2_3D = np.dstack([rvs2_2D, rvs2_2D, rvs2_2D])\n    (t, p) = stats.ttest_ind(rvs1_3D, rvs2_3D, axis=1)\n    results['t_p_3D'] = (t, p)\n    (t, p) = stats.ttest_ind(rvs1, rvs2, alternative='less')\n    results['t_p_less'] = (t, p)\n    (t, p) = stats.ttest_ind(rvs1, rvs2, alternative='greater')\n    results['t_p_greater'] = (t, p)\n    rvs1_3D[:, :, 10:15] = np.nan\n    rvs2_3D[:, :, 6:12] = np.nan\n    (t, p) = stats.ttest_ind(rvs1_3D, rvs2_3D, 0, nan_policy='omit', alternative='less')\n    results['t_p_nan_less'] = (t, p)\n    (t, p) = stats.ttest_ind(rvs1_3D, rvs2_3D, 0, nan_policy='omit', alternative='greater')\n    results['t_p_nan_greater'] = (t, p)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        mean1, std1 = np.random.uniform(0, 10), np.random.uniform(0.5, 5)\n        mean2, std2 = np.random.uniform(0, 10), np.random.uniform(0.5, 5)\n        size = np.random.randint(10, 100, size=1)[0]\n        rvs1 = np.random.normal(mean1, std1, size=size)\n        rvs2 = np.random.normal(mean2, std2, size=size)\n\n        test_cases.append((rvs1, rvs2))\n\n    return test_cases"}
{"problem_id": "scipy_8", "library": "scipy", "code_problem": "The task is to implement a function that calculates the variance of a dataset using the `scipy.stats` library. The function will compute the variance under various conditions, including specific limits and axes. The function signature is as follows:\n\n```python\ndef test_tvar(X):\n```\n\nIn this function, the constant used is a 2D array `x_2d`, which is created using `numpy` and has a shape of (9, 7). This array is generated by reshaping a range of 63 floating-point numbers.\n\nThe input format for the function is a single argument `X`, which can be a 1D or 2D array-like structure. The output format is a dictionary containing the results of the variance calculations, with keys corresponding to the different calculations performed.\n\nInput:\n```python\nX = np.array([1.5, 2.5, 3.5, 4.5, 5.5])\n```\n\nOutput:\n```python\n{\n    'y_limits_2_8': 1.6666666666666667, \n    'y_no_limits': 2.5, \n    'y_axis_none': 336.0, \n    'y_axis_0': array([367.5, 367.5, 367.5, 367.5, 367.5, 367.5, 367.5]), \n    'y_axis_1': array([4.66666667, 4.66666667, 4.66666667, 4.66666667, 4.66666667, 4.66666667, 4.66666667, 4.66666667, 4.66666667]), \n    'y_x_2d_row_3': 4.666666666666667, \n    'y_limits_1_5_axis_1': array([2.5, nan, nan, nan, nan, nan, nan, nan, nan]), \n    'y_limits_0_6_axis_1': array([4.66666667, nan, nan, nan, nan, nan, nan, nan, nan])\n}\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_tvar(X):\n    results = {}\n    results[\"y_limits_2_8\"] = stats.tvar(X, limits=(2, 8), inclusive=(True, True))\n    results[\"y_no_limits\"] = stats.tvar(X, limits=None)\n    x_2d = np.arange(63, dtype=float).reshape((9, 7))\n    results[\"y_axis_none\"] = stats.tvar(x_2d, axis=None)\n    results[\"y_axis_0\"] = stats.tvar(x_2d, axis=0)\n    results[\"y_axis_1\"] = stats.tvar(x_2d, axis=1)\n    results[\"y_x_2d_row_3\"] = stats.tvar(x_2d[3, :])\n    results[\"y_limits_1_5_axis_1\"] = stats.tvar(x_2d, limits=(1, 5), axis=1, inclusive=(True, True))\n    results[\"y_limits_0_6_axis_1\"] = stats.tvar(x_2d, limits=(0, 6), axis=1, inclusive=(True, True))\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X = np.random.uniform(0, 10, size=np.random.randint(5, 20))\n\n        test_cases.append(X)\n\n    return test_cases"}
{"problem_id": "scipy_9", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes Theil-Sen slope estimates for a given set of data points. The function will utilize the `scipy.stats` library to perform the calculations. The function signature is as follows:\n\n```python\ndef test_theilslopes(x, y, alpha=0.07):\n```\n\nIn this function, a constant `alpha` is used, which defaults to `0.07`. This constant is utilized in the calculation of the Theil-Sen slope estimates when using the 'separate' and 'joint' methods.\n\n\nThe input format for the function is two lists or arrays, `x` and `y`, representing the independent and dependent variables, respectively. The optional input is a float `alpha`, which defaults to `0.07`.\n\nThe output format of the function is a dictionary containing the following keys and their corresponding values:\n- `'default'`: The default Theil-Sen slope estimate.\n- `'joint'`: The Theil-Sen slope estimate using the 'joint' method.\n- `'separate'`: The Theil-Sen slope estimate using the 'separate' method with the specified `alpha`.\n- `'joint_x_y'`: The Theil-Sen slope estimate using the 'joint' method with the specified `alpha`.\n\nInput:\n```python\nx = np.array([-95.12, -54.67, -23.45, 12.34, 45.67])\ny = np.array([-10.5, 20.3, 15.0, 30.1, 25.5])\nalpha = 0.07\n```\n\nOutput:\n```python\n{\n    'default': TheilslopesResult(slope=0.2038048504569453, intercept=25.07922374321537, low_slope=-0.16976297245355543, high_slope=0.761433868974042), \n    'joint': TheilslopesResult(slope=0.2038048504569453, intercept=19.77922374321537, low_slope=-0.16976297245355543, high_slope=0.761433868974042), \n    'separate': TheilslopesResult(slope=0.2038048504569453, intercept=25.07922374321537, low_slope=-0.16976297245355543, high_slope=0.761433868974042), \n    'joint_x_y': TheilslopesResult(slope=0.2038048504569453, intercept=19.77922374321537, low_slope=-0.16976297245355543, high_slope=0.761433868974042)\n}\n```", "ground_truth_code": "import scipy.stats as stats\n\n\n# main code\ndef test_theilslopes(x, y, alpha=0.07):\n    results = {}\n\n    results['default'] = stats.theilslopes(y, x)\n    results['joint'] = stats.theilslopes(y, x, method='joint')\n    results['separate'] = stats.theilslopes(y, x, alpha, method='separate')\n    results['joint_x_y'] = stats.theilslopes(y, x, alpha, method='joint')\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(2, 100)\n        x = np.sort(np.random.uniform(-100, 100, size))\n        y = np.random.uniform(-100, 100, size)\n        alpha = np.random.uniform(0.01, 0.2)\n\n        test_cases.append((x, y, alpha))\n\n    return test_cases"}
{"problem_id": "scipy_10", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that evaluates the normality of three datasets using the Jarque-Bera test. The function will compute the test statistics and p-values for each dataset and compare the p-values to determine which dataset has a higher p-value.\n\nFunction signature:\n```python\ndef test_jarque_bera_stats(x, y, z):\n```\n\nIn this function, the constant used is the Jarque-Bera test, which is a statistical test that checks whether a sample comes from a normal distribution.\n\nInput format:\n- The function accepts three parameters: `x`, `y`, and `z`, which are lists or arrays of numerical values.\n\nOutput format:\n- The function returns a dictionary containing:\n  - The Jarque-Bera test statistics and p-values for each dataset.\n  - A dictionary of comparisons indicating which dataset has a higher p-value.\n\nInput:\n```python\nx = np.array([-0.123, 0.456, 0.789, -0.234, 0.567])\ny = np.array([-1.5, 0.0, 1.5, -1.0, 1.0])\nz = np.array([0.5, 1.0, 1.5, 2.0, 2.5])\n```\n\nOutput:\n```python\n{\n    'x_statistic': 0.5966856223853244, \n    'x_pvalue': 0.7420469141526432, \n    'y_statistic': 0.5103130871934926, \n    'y_pvalue': 0.7747951992398288, \n    'z_statistic': 0.35208333333333336, \n    'z_pvalue': 0.8385830416490585, \n    'comparisons': {\n        'x_vs_y_pvalue': False, \n        'x_vs_z_pvalue': False, \n        'y_vs_z_pvalue': False\n    }\n}\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef test_jarque_bera_stats(x, y, z):\n    x_statistic, x_pvalue = stats.jarque_bera(x)\n    y_statistic, y_pvalue = stats.jarque_bera(y)\n    z_statistic, z_pvalue = stats.jarque_bera(z)\n\n    comparisons = {\n        \"x_vs_y_pvalue\": x_pvalue > y_pvalue,\n        \"x_vs_z_pvalue\": x_pvalue > z_pvalue,\n        \"y_vs_z_pvalue\": y_pvalue > z_pvalue,\n    }\n\n    results = {\n        \"x_statistic\": x_statistic,\n        \"x_pvalue\": x_pvalue,\n        \"y_statistic\": y_statistic,\n        \"y_pvalue\": y_pvalue,\n        \"z_statistic\": z_statistic,\n        \"z_pvalue\": z_pvalue,\n        \"comparisons\": comparisons\n    }\n\n    return results", "test_script": "import numpy as np\nimport scipy.stats as stats\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sample_size = np.random.randint(30, 501)\n        x = np.random.normal(loc=0, scale=1, size=sample_size)\n        y = np.random.uniform(low=-2, high=2, size=sample_size)\n        z = stats.skewnorm.rvs(a=5, loc=0, scale=1, size=sample_size)\n\n        test_cases.append((x, y, z))\n    return test_cases"}
{"problem_id": "scipy_11", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs a Page trend test on a given dataset. The function will take in a dataset, a list of predicted ranks, a boolean indicating whether the data is already ranked, and a method for the test. The function should handle the input data appropriately, rank it if necessary, and then apply the Page trend test using the specified parameters.\n\nFunction signature:\n```python\ndef validate_page_trend_test(data, predicted_ranks, ranked, method):\n```\n\nConstant used in the main code:\n- `None`: This constant is used to check if the `predicted_ranks` parameter is provided or not.\n\nInput format:\n- `data`: A list or NumPy array of numerical values representing the dataset.\n- `predicted_ranks`: A list of predicted ranks (can be `None`).\n- `ranked`: A boolean indicating whether the data is already ranked.\n- `method`: A string specifying the method to be used for the Page trend test.\n\nOutput format:\n- The function returns the result of the Page trend test, which is typically a statistical test result indicating whether there is a trend in the data based on the provided parameters.\n\nInput:\n```python\ndata = np.array([[3.2, 1.5, 4.8],\n                 [2.1, 3.3, 5.0],\n                 [4.0, 2.2, 3.7]])\npredicted_ranks = [1, 2, 3]\nranked = True\nmethod = 'exact'\n```\n\nOutput:\n```python\nPageTrendTestResult(statistic=38.0, pvalue=0.2777777777777778, method='exact')\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef validate_page_trend_test(data, predicted_ranks, ranked, method):\n    data = np.asarray(data, dtype=float) if not isinstance(data, np.ndarray) else data\n\n    if predicted_ranks is not None:\n        predicted_ranks = np.unique(predicted_ranks).tolist()\n\n    if ranked:\n        data = np.apply_along_axis(stats.rankdata, 1, data)\n\n    return stats.page_trend_test(data, predicted_ranks=predicted_ranks, ranked=ranked, method=method)\n", "test_script": "import scipy.stats as stats\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    methods = ['asymptotic', 'exact', 'auto']\n    for _ in range(n):\n        m = np.random.randint(3, 10)\n        k = np.random.randint(3, 6)\n        data = np.random.rand(m, k) * 10\n        ranked = np.random.choice([True, False])\n        if ranked:\n            data = np.apply_along_axis(stats.rankdata, 0, data)\n            ranked = True\n        else:\n            ranked = False\n        if np.random.rand() > 0.5:\n            predicted_ranks = np.random.permutation(np.arange(1, k + 1)).tolist()\n        else:\n            predicted_ranks = None\n        method = np.random.choice(methods)\n        test_cases.append((data, predicted_ranks, ranked, method))\n\n    return test_cases"}
{"problem_id": "scipy_12", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the maximum values of two datasets, `x` and `y`, under certain conditions and limits. The function will also handle masked values to account for potential outliers or invalid data points.\n\nFunction signature:\n```python\ndef complex_benchmark_tmax(x: np.ndarray, y: np.ndarray, n: int, limits: list) -> dict:\n```\n\n### Constants:\n- A constant value of `1e+16` is used to initialize the masked arrays for `x` and `y`.\n- A probability of `0.05` is used to randomly mask some of the values in the datasets.\n\n### Input Format:\n- `x`: A NumPy array of numerical values.\n- `y`: A NumPy array of numerical values.\n- `n`: An integer representing the number of elements to consider from `x` and `y`.\n- `limits`: A list of numerical values representing the upper limits for the maximum calculations.\n\n### Output Format:\n- The function returns a dictionary where each key is a string indicating the dataset and limit, and each value is the computed maximum value for that dataset under the specified limit.\n\nInput:\n```python\nx = np.array([1, 2, 3, 4, 5])\ny = np.array([5, 4, 3, 2, 1])\nn = 5\nlimits = [2, 4]\n```\n\nOutput:\n```python\n{\n    'tmax_x_2': 2, \n    'tmax_masked_x_2': masked_array(data=2.,mask=False,fill_value=1e+20), \n    'tmax_y_2': 2, \n    'tmax_masked_y_2': masked_array(data=2., mask=False, fill_value=1e+20), \n    'tmax_x_4': 4, \n    'tmax_masked_x_4': masked_array(data=4., mask=False, fill_value=1e+20), \n    'tmax_y_4': 4, \n    'tmax_masked_y_4': masked_array(data=4., mask=False, fill_value=1e+20)}\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n# main code\ndef complex_benchmark_tmax(x, y, n, limits):\n    masked_x = np.full(n, 1e+16)\n    masked_y = np.full(n, 1e+16)\n    masked_x[:n] = x\n    masked_y[:n] = y\n    mask = np.logical_or(masked_x > 9e15, np.random.choice([True, False], size=n, p=[0.05, 0.95]))\n    masked_x = np.ma.array(masked_x, mask=mask)\n    masked_y = np.ma.array(masked_y, mask=mask)\n\n    res = {}\n    for limit in limits:\n        if np.all(x > limit):\n            limit = np.max(x)\n        if np.all(y > limit):\n            limit = np.max(y)\n\n        res[f\"tmax_x_{limit}\"] = stats.tmax(x, upperlimit=limit, inclusive=True)\n        res[f\"tmax_masked_x_{limit}\"] = stats.mstats.tmax(masked_x, upperlimit=limit, inclusive=True)\n        res[f\"tmax_y_{limit}\"] = stats.tmax(y, upperlimit=limit, inclusive=True)\n        res[f\"tmax_masked_y_{limit}\"] = stats.mstats.tmax(masked_y, upperlimit=limit, inclusive=True)\n\n    return res", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        tensor_size = np.random.randint(5, 50)\n        x = np.random.uniform(-1e16, 1e16, size=tensor_size)\n        y = np.random.uniform(-1e16, 1e16, size=tensor_size)\n        num_limits = np.random.randint(1, 5)\n        sorted_x = np.sort(x)\n        percentiles = np.linspace(10, 90, num_limits)\n        valid_limits = np.percentile(sorted_x, percentiles).tolist()\n\n\n        test_cases.append((x, y, tensor_size, valid_limits))\n    return test_cases"}
{"problem_id": "scipy_13", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that processes a given dataset and computes various statistical metrics. The function will apply a logarithmic transformation to the input data, standardize it, and then calculate specific statistical properties.\n\nFunction Signature:\n```python\ndef test_tmax(x, upperlimit, inclusive, nan_policy, axis):\n```\n\n### Constants:\n- The constant used in the main code is the natural logarithm transformation applied through `np.log1p(x)`.\n\n### Input Format:\n- The input to the function consists of:\n  - A numerical dataset `x` (array-like).\n  - A numerical value `upperlimit`.\n  - A boolean value `inclusive`.\n  - A string `nan_policy`.\n  - An integer `axis`.\n\n### Output Format:\n- The output of the function is a dictionary containing the following keys and their corresponding values:\n  - `'tmax'`: The maximum t-value.\n  - `'mean'`: The mean of the standardized dataset.\n  - `'std_dev'`: The standard deviation of the standardized dataset.\n  - `'skewness'`: The skewness of the standardized dataset.\n  - `'kurtosis'`: The kurtosis of the standardized dataset.\n\nInput:\n```python\nx = np.array([[1.5, 2.3, 3.1], [4.0, 5.2, 6.1]])\nupperlimit = 5.0\ninclusive = True\nnan_policy = 'omit'\naxis = 0\n```\n\nOutput:\n```python\n{\n    'tmax': array([0.34487746, 0.94530265, 1.32364121]),\n    'mean': -2.9605947323337506e-16,\n    'std_dev': 1.0,\n    'skewness': array([ 0.00000000e+00,  0.00000000e+00, -3.08354868e-16]),\n    'kurtosis': array([-2., -2., -2.])\n}\n\n```\n", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_tmax(x, upperlimit, inclusive, nan_policy, axis):\n    results = {}\n\n    x = np.log1p(x)\n    x = (x - np.mean(x)) / np.std(x)\n\n    results['tmax'] = stats.tmax(x, upperlimit=upperlimit, inclusive=inclusive, nan_policy=nan_policy, axis=axis)\n    results['mean'] = np.mean(x)\n    results['std_dev'] = np.std(x)\n    results['skewness'] = stats.skew(x)\n    results['kurtosis'] = stats.kurtosis(x)\n\n    return results", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        shape = (np.random.randint(5, 20),)\n        if np.random.rand() > 0.5:\n            shape += (np.random.randint(5, 20),)\n        x = np.abs(np.random.randn(*shape)) * 10\n        upperlimit = np.random.uniform(np.min(x), np.max(x))\n        inclusive = np.random.choice([True, False])\n        nan_policy = np.random.choice(['propagate', 'omit', 'raise'])\n        axis = None if np.random.rand() > 0.5 else np.random.choice(len(shape))\n\n        test_cases.append((x, upperlimit, inclusive, nan_policy, axis))\n\n    return test_cases"}
{"problem_id": "scipy_14", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that performs t-tests and Kolmogorov-Smirnov tests on two sets of observations. The function will also compute the percentile of p-values from the t-tests. The function signature is as follows:\n\n```python\ndef test_ttest_single_observation(x, y, q):\n```\n\n### Constants Used:\n- The constant used in the main code is the fixed list of values `[2, 3, 5]` and `[1.5]` for the third t-test.\n\n### Input and Output Format:\n- **Input Format**:\n  - The function takes in two lists or arrays of numerical values (`x` and `y`) and a float (`q`).\n\n- **Output Format**:\n  - The function returns a dictionary containing the results of the statistical tests and calculations as described above.\n\nInput:\n```python\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.0])\ny = np.array([2.1, 2.9, 3.5, 4.0, 4.8])\nq = 0.5\n```\n\nOutput:\n```python\n{\n    'ttest_x_y': TtestResult(statistic=-0.2868548662402542, pvalue=0.7815127028314709, df=8.0), \n    'ks_test_pvalue1': 0.4369745943370582, \n    'pvalue_percentile1': 0.7815127028314709, \n    'ttest_y_x': TtestResult(statistic=0.2868548662402542, pvalue=0.7815127028314709, df=8.0), \n    'ks_test_pvalue2': 0.4369745943370582, \n    'pvalue_percentile2': 0.7815127028314709, \n    'ttest_fixed_values': TtestResult(statistic=1.039402300775375, pvalue=0.4077799077360179, df=2.0)\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n\n# Main code\ndef test_ttest_single_observation(x, y, q):\n    res1 = stats.ttest_ind(x, y, equal_var=True, axis=-1)\n    ks_test_pvalue1 = stats.ks_1samp(res1.pvalue, stats.uniform().cdf).pvalue\n    pvalue_percentile1 = np.percentile(res1.pvalue, q * 100)\n\n    res2 = stats.ttest_ind(y, x, equal_var=True, axis=-1)\n    ks_test_pvalue2 = stats.ks_1samp(res2.pvalue, stats.uniform().cdf).pvalue\n    pvalue_percentile2 = np.percentile(res2.pvalue, q * 100)\n\n    res3 = stats.ttest_ind([2, 3, 5], [1.5], equal_var=True)\n\n    return {\n        \"ttest_x_y\": res1,\n        \"ks_test_pvalue1\": ks_test_pvalue1,\n        \"pvalue_percentile1\": pvalue_percentile1,\n        \"ttest_y_x\": res2,\n        \"ks_test_pvalue2\": ks_test_pvalue2,\n        \"pvalue_percentile2\": pvalue_percentile2,\n        \"ttest_fixed_values\": res3\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_x = np.random.randint(5, 100)\n        size_y = np.random.randint(5, 100)\n        x = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(0.5, 5), size=size_x)\n        y = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(0.5, 5), size=size_y)\n        q = np.random.uniform(0.01, 0.99)\n        test_cases.append((x, y, q))\n\n    return test_cases"}
{"problem_id": "scipy_15", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs statistical trimming on a given array of numerical data. The function will utilize the `trim1` method from the `scipy.stats` library to remove a specified proportion of the data from both ends of the dataset, which helps in reducing the influence of outliers.\n\nFunction Signature:\n```python\ndef test_trim1(a):\n```\n\n### Constants Used:\n- The constant `3 / 11.0` is used in the trimming process to specify a trimming proportion.\n\n### Input Format:\n- The input to the function is a single argument `a`, which can be a list or a NumPy array of numerical values.\n\n### Output Format:\n- The output of the function is a dictionary where the keys are strings representing the type of trimming performed, and the values are the corresponding trimmed and sorted results. If the input array is empty or contains only `NaN` values, the function returns `None`.\n\nInput:\n```python\na = [1.5, 2.3, 3.7, 4.1, 5.0, np.nan, 6.2, 7.8]\n```\n\nOutput:\n```python\n{\n    'trim1_0.1': array([1.5, 2.3, 3.7, 4.1, 5. , 6.2, 7.8]),\n    'trim1_0.2': array([1.5, 2.3, 3.7, 4.1, 5. , 6.2]),\n    'trim1_0.2_left': array([2.3, 3.7, 4.1, 5. , 6.2, 7.8]),\n    'trim1_3_11_left': array([2.3, 3.7, 4.1, 5. , 6.2, 7.8]),\n    'trim1_1.0': [],\n    'trim1_1.0_left': [],\n    'trim1_empty_0.1': array([], dtype=float64),\n    'trim1_empty_3_11_left': array([], dtype=float64),\n    'trim1_empty_4_6': array([], dtype=float64)\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n\n# main code\ndef test_trim1(a):\n    results = {}\n\n    a = np.asarray(a, dtype=np.float64)\n    a = a[~np.isnan(a)]\n\n    if a.size == 0:\n        return None\n    results[\"trim1_0.1\"] = np.sort(stats.trim1(a, 0.1))\n    results[\"trim1_0.2\"] = np.sort(stats.trim1(a, 0.2))\n    results[\"trim1_0.2_left\"] = np.sort(stats.trim1(a, 0.2, tail='left'))\n    results[\"trim1_3_11_left\"] = np.sort(stats.trim1(a, 3 / 11.0, tail='left'))\n    results[\"trim1_1.0\"] = stats.trim1(a, 1.0)\n    results[\"trim1_1.0_left\"] = stats.trim1(a, 1.0, tail='left')\n    results[\"trim1_empty_0.1\"] = stats.trim1([], 0.1)\n    results[\"trim1_empty_3_11_left\"] = stats.trim1([], 3 / 11.0, tail='left')\n    results[\"trim1_empty_4_6\"] = stats.trim1([], 4 / 6.0)\n\n    if a.ndim > 1:\n        axis = 0\n        trimmed = stats.trim1(a, 0.2, tail='left', axis=axis)\n        results[\"trim1_matrix_axis_0\"] = np.sort(trimmed, axis=axis)\n\n        axis = 1\n        trimmed = stats.trim1(a.T, 0.2, tail='left', axis=axis)\n        results[\"trim1_matrix_axis_1\"] = np.sort(trimmed, axis=axis)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        case_type = np.random.choice([\"empty\", \"1D\", \"2D\", \"with_nan\"], p=[0.1, 0.5, 0.3, 0.1])\n\n        if case_type == \"empty\":\n            a = []\n        elif case_type == \"1D\":\n            size = np.random.randint(1, 100)\n            a = np.random.randn(size)\n        elif case_type == \"2D\":\n            rows = np.random.randint(2, 10)\n            cols = np.random.randint(2, 10)\n            a = np.random.randn(rows, cols)\n        elif case_type == \"with_nan\":\n            size = np.random.randint(5, 50)\n            a = np.random.randn(size)\n            num_nans = np.random.randint(1, max(2, size // 5))\n            nan_indices = np.random.choice(size, num_nans, replace=False)\n            a[nan_indices] = np.nan\n\n        test_cases.append(a)\n\n    return test_cases"}
{"problem_id": "scipy_16", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the interquartile range (IQR) of a dataset while handling missing values in various ways. The function will utilize the `scipy.stats` library to compute the IQR based on different policies for dealing with NaN (Not a Number) values.\n\nFunction signature:\n```python\ndef process_nanpolicy(x, x_masked):\n```\n\nIn this function, the following constant is used:\n- `nan_policy`: This constant is used to specify how to handle NaN values during the IQR calculation. It can take the values 'propagate', 'omit', or 'raise'.\n\nInput format:\n- The function takes two inputs:\n  - `x`: A list or array-like structure containing numerical values, which may include NaN values.\n  - `x_masked`: A list or array-like structure containing numerical values, which may also include NaN values.\n\nOutput format:\n- The function returns a dictionary containing the computed IQR values for both datasets under various NaN handling policies. The keys in the dictionary correspond to the different IQR calculations performed.\n\nInput:\n```python\nimport numpy as np\nx = np.array([[ 0.49671415, -0.1382643 ,  0.64768854],\n              [ 1.52302986,  0.32533033, -0.57635013],\n              [ 0.35778736,  0.56078453, -0.5297602 ],\n              [ 0.37853736,  0.0675282 , -0.15579551],\n              [ 0.24196227, -1.91328024, -0.52420543]])\n\nx_masked = np.array([[ 0.49671415, -0.1382643 ,  0.64768854],\n                     [ 1.52302986,  0.32533033, -0.57635013],\n                     [ 0.35778736,  0.56078453, -0.5297602 ],\n                     [        np.nan,  0.0675282 , -0.15579551],\n                     [ 0.24196227, -1.91328024,         np.nan]])\n```\n\nOutput:\n```python\n{\n    'iqr_propagate': 0.777626225, \n    'iqr_omit': 0.777626225, \n    'iqr_raise': 0.777626225, \n    'iqr_propagate_nan': nan, \n    'iqr_propagate_axis0': array([       nan, 0.46359463,        nan]), \n    'iqr_propagate_axis1': array([0.39297642, 1.04969   , 0.54527236,        nan,        nan]), \n    'iqr_omit_nan': 0.65250966, \n    'iqr_omit_axis0': array([0.42446199, 0.46359463, 0.58648319]), \n    'iqr_omit_axis1': array([0.39297642, 1.04969   , 0.54527236, 0.11166185, 1.07762125])\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef process_nanpolicy(x, x_masked):\n    results = {}\n    results['iqr_propagate'] = stats.iqr(x, nan_policy='propagate')\n    results['iqr_omit'] = stats.iqr(x, nan_policy='omit')\n    results['iqr_raise'] = stats.iqr(x, nan_policy='raise')\n\n    results['iqr_propagate_nan'] = stats.iqr(x_masked, nan_policy='propagate')\n    results['iqr_propagate_axis0'] = stats.iqr(x_masked, axis=0, nan_policy='propagate')\n    results['iqr_propagate_axis1'] = stats.iqr(x_masked, axis=1, nan_policy='propagate')\n\n\n    results['iqr_omit_nan'] = stats.iqr(x_masked, nan_policy='omit')\n    results['iqr_omit_axis0'] = stats.iqr(x_masked, axis=0, nan_policy='omit')\n    results['iqr_omit_axis1'] = stats.iqr(x_masked, axis=1, nan_policy='omit')\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_row = np.random.randint(5, 10)\n        n_col = np.random.randint(5, 10)\n        x = np.random.randn(n_row, n_col)\n\n        nan_mask = np.random.rand(n_row, n_col) < 0.2\n        x_masked = x.copy()\n        x_masked[nan_mask] = np.nan\n\n        test_cases.append((x, x_masked))\n\n    return test_cases"}
{"problem_id": "scipy_17", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes and computes statistical metrics for four input arrays. The function will preprocess the data to handle any missing values and normalize the values, then calculate various statistics for each array.\n\nFunction signature:\n```python\ndef test_gmean(x, y, xm, ym):\n```\n\n### Constants:\n- A small constant `1e-8` is used to prevent division by zero during normalization.\n\n### Input Format:\n- The function accepts four lists or arrays: `x`, `y`, `xm`, and `ym`.\n\n### Output Format:\n- The function returns a dictionary containing the computed statistics for each of the four input arrays, structured as follows:\n```python\n{\n    \"x_stats\": { ... },\n    \"y_stats\": { ... },\n    \"xm_stats\": { ... },\n    \"ym_stats\": { ... }\n}\n```\n\nInput:\n```python\n(\n    [[1.0, 2.0, 3.0, 4.0], [5.0, np.nan, 7.0, 8.0], [9.0, 10.0, 11.0, 12.0], [np.nan, 14.0, 15.0, 16.0]],\n    [[2.0, 3.0, 4.0, 5.0], [6.0, 7.0, np.nan, 9.0], [10.0, 11.0, 12.0, 13.0], [14.0, 15.0, np.nan, 17.0]],\n    [[3.0, 4.0, 5.0, 6.0], [7.0, 8.0, 9.0, np.nan], [11.0, 12.0, 13.0, 14.0], [15.0, 16.0, 17.0, 18.0]],\n    [[4.0, 5.0, 6.0, 7.0], [8.0, 9.0, 10.0, 11.0], [12.0, 13.0, 14.0, 15.0], [np.nan, 17.0, 18.0, 19.0]]\n)\n```\n\nOutput:\n```python\n{\n    'x_stats': {\n        'geometric_mean': array([0.        , 0.36110417, 0.42681145, 0.51148694]), \n        'geometric_mean_mstats': array([0.        , 0.36110417, 0.42681145, 0.51148694]), \n        'median': 0.49047619014920635, \n        'variance': 0.08700396813796295, \n        'standard_deviation': 0.29496435062217763\n    }, \n    'y_stats': {\n        'geometric_mean': array([0.        , 0.327867  , 0.37679248, 0.51148694]), \n        'geometric_mean_mstats': array([0.        , 0.327867  , 0.37679248, 0.51148694]), \n        'median': 0.47619047587301583, \n        'variance': 0.0815873014785185, \n        'standard_deviation': 0.28563490941850667\n    }, \n    'xm_stats': {\n        'geometric_mean': array([0.        , 0.327867  , 0.42681145, 0.52096295]), \n        'geometric_mean_mstats': array([0.        , 0.327867  , 0.42681145, 0.52096295]), \n        'median': 0.5177777774325926, \n        'variance': 0.0943703702445432, \n        'standard_deviation': 0.3071976078105805\n    }, \n    'ym_stats': {\n        'geometric_mean': array([0.        , 0.327867  , 0.42681145, 0.51148694]), \n        'geometric_mean_mstats': array([0.        , 0.327867  , 0.42681145, 0.51148694]), \n        'median': 0.4733333330177777, \n        'variance': 0.08844444432651852, \n        'standard_deviation': 0.2973961067776754\n    }\n}\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n\ndef preprocess_data(arr):\n    arr = np.array(arr, dtype=np.float64)\n    arr = np.nan_to_num(arr, nan=np.nanmean(arr))\n    return (arr - np.min(arr)) / (np.max(arr) - np.min(arr) + 1e-8)\n\ndef compute_statistics(arr):\n    return {\n        'geometric_mean': stats.gmean(abs(arr)),\n        'geometric_mean_mstats': stats.mstats.gmean(abs(arr)),\n        'median': np.median(arr),\n        'variance': np.var(arr),\n        'standard_deviation': np.std(arr),\n    }\n\n\n# main code\ndef test_gmean(x, y, xm, ym):\n    x, y, xm, ym = map(preprocess_data, [x, y, xm, ym])\n    stats_x = compute_statistics(x)\n    stats_y = compute_statistics(y)\n    stats_xm = compute_statistics(xm)\n    stats_ym = compute_statistics(ym)\n    results = {\n        \"x_stats\": stats_x,\n        \"y_stats\": stats_y,\n        \"xm_stats\": stats_xm,\n        \"ym_stats\": stats_ym\n    }\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 4)))\n        x = np.random.randn(*shape) * np.random.randint(1, 100)\n        y = np.random.randn(*shape) * np.random.randint(1, 100)\n        xm = np.random.randn(*shape) * np.random.randint(1, 100)\n        ym = np.random.randn(*shape) * np.random.randint(1, 100)\n        nan_mask = np.random.rand(*shape) < 0.1\n        x[nan_mask] = np.nan\n        y[nan_mask] = np.nan\n        xm[nan_mask] = np.nan\n        ym[nan_mask] = np.nan\n\n        test_cases.append((x.tolist(), y.tolist(), xm.tolist(), ym.tolist()))\n\n    return test_cases"}
{"problem_id": "scipy_18", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the skewness of various datasets using the `scipy.stats` library. The function will take in multiple datasets and return their skewness values in a structured format.\n\nFunction signature:\n```python\ndef test_skewness(testcase, scalar_testcase, testmathworks, x_masked):\n```\n\nIn this function, the following constant is used:\n- `bias`: This constant is set to `0` when calculating the skewness of `testmathworks` to adjust the bias correction.\n\nInput format:\n- The function takes four parameters:\n  - `testcase`: A dataset (e.g., a list or array-like structure).\n  - `scalar_testcase`: A dataset (e.g., a list or array-like structure).\n  - `testmathworks`: A dataset (e.g., a list or array-like structure).\n  - `x_masked`: A dataset (e.g., a list or array-like structure) that may contain NaN values.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `\"scalar_testcase\"`: Skewness of `scalar_testcase`.\n  - `\"testmathworks\"`: Skewness of `testmathworks`.\n  - `\"testmathworks_bias0\"`: Skewness of `testmathworks` with bias correction set to `0`.\n  - `\"testcase\"`: Skewness of `testcase`.\n  - `\"skew_x\"`: Skewness of `x_masked`, ignoring invalid values.\n  - `\"skew_x_omit\"`: Skewness of `x_masked`, omitting NaN values.\n\nInput:\n```python\ntestcase = np.array([-1.2, 0.5, 1.5, -0.3, 2.1])\nscalar_testcase = np.array([0.1, -0.2, 0.3, 0.4, 0.5])\ntestmathworks = np.array([[0.1, -0.1], [0.2, -0.2], [0.3, -0.3]])\nx_masked = np.ma.array([1.0, 2.0, np.nan, 3.0, 4.0], mask=[0, 0, 1, 0, 0])\n```\n\nOutput:\n```python\n{\n    'scalar_testcase': -0.6216348579624366, \n    'testmathworks': array([-1.59344526e-15,  1.59344526e-15]), \n    'testmathworks_bias0': array([-3.90312782e-15,  3.90312782e-15]), \n    'testcase': -0.08938302770180208, \n    'skew_x': 0.0, \n    'skew_x_omit': 0.0\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef test_skewness(testcase, scalar_testcase, testmathworks, x_masked):\n    results = {}\n    y1 = stats.skew(scalar_testcase)\n    results[\"scalar_testcase\"] = y1\n    y2 = stats.skew(testmathworks)\n    results[\"testmathworks\"] = y2\n    y3 = stats.skew(testmathworks, bias=0)\n    results[\"testmathworks_bias0\"] = y3\n    y4 = stats.skew(testcase)\n    results[\"testcase\"] = y4\n    with np.errstate(invalid='ignore'):\n        results[\"skew_x\"] = stats.skew(x_masked)\n    results[\"skew_x_omit\"] = stats.skew(x_masked, nan_policy='omit')\n\n    return results\n", "test_script": "import scipy.stats as stats\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        scalar_testcase = np.random.randn(np.random.randint(5, 20))\n        testmathworks = np.random.randn(np.random.randint(5, 20), np.random.randint(5, 20))\n        testcase = np.random.randn(np.random.randint(5, 50))\n        x_masked = np.random.randn(np.random.randint(5, 50))\n        mask = np.random.choice([True, False], size=x_masked.shape, p=[0.1, 0.9])\n        x_masked = np.ma.array(x_masked, mask=mask)\n        test_cases.append((testcase, scalar_testcase, testmathworks, x_masked))\n    return test_cases"}
{"problem_id": "scipy_19", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes three 2D input arrays and performs a one-way ANOVA test on them. The function will determine if there are any statistically significant differences between the means of the groups represented by the input arrays. The function should also handle the transposition of the input arrays based on the specified axis.\n\nFunction signature:\n```python\ndef process_2d_inputs(a: np.ndarray, b: np.ndarray, c: np.ndarray, axis: int) -> list:\n```\n\nConstant used in the main code:\n- The constant values used for indexing in the results list are `0`, `1`, `2`, and `3`.\n\nInput format:\n- The function accepts three 2D numpy arrays `a`, `b`, and `c`, and an integer `axis`.\n\nOutput format:\n- The function returns a list of tuples, where each tuple contains four elements: the F-statistic and p-value from the initial ANOVA test, followed by the F-statistic and p-value from the subsequent ANOVA tests for the specified indices.\n\nInput:\n```python\na = np.array([[1.2, 2.3, 3.1, 4.1],\n              [4.5, 5.6, 6.7, 7.7],\n              [7.8, 8.9, 9.0, 9.9]])\n\nb = np.array([[1.0, 2.0, 3.0, 4.0],\n              [4.0, 5.0, 6.0, 7.0],\n              [7.0, 8.0, 9.0, 9.8]])\n\nc = np.array([[0.5, 1.5, 2.5, 3.5],\n              [3.5, 4.5, 5.5, 6.5],\n              [6.5, 7.5, 8.5, 9.5]])\naxis = 0\n```\n\nOutput:\n```python\nresults = [\n    (0.0778816199376947, 0.9259936907082073, 0.0778816199376947, 0.9259936907082073), \n    (0.0944963655244029, 0.9111582951021915, 0.0944963655244029, 0.9111582951021915), \n    (0.05078852601514964, 0.9508838058028587, 0.05078852601514964, 0.9508838058028587), \n    (0.04707542329399692, 0.9543642251984332, 0.047075423293996936, 0.9543642251984332)\n]\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef process_2d_inputs(a, b, c, axis):\n    if axis in [-1, 1]:\n        a = a.T\n        b = b.T\n        c = c.T\n        take_axis = 0\n    else:\n        take_axis = 1\n\n    f, p = stats.f_oneway(a, b, c, axis=axis)\n    results = []\n\n    for j in [0, 1]:\n        fj, pj = stats.f_oneway(np.take(a, j, take_axis), np.take(b, j, take_axis), np.take(c, j, take_axis))\n        results.append((f[j], p[j], fj, pj))\n\n    for j in [2, 3]:\n        fj, pj = stats.f_oneway(np.take(a, j, take_axis), np.take(b, j, take_axis), np.take(c, j, take_axis))\n        results.append((f[j], p[j], fj, pj))\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(5, 20)\n        cols = np.random.randint(5, 20)\n        a = np.random.randn(rows, cols)\n        b = np.random.randn(rows, cols)\n        c = np.random.randn(rows, cols)\n        axis = np.random.choice([-1, 0, 1])\n\n        test_cases.append((a, b, c, axis))\n\n    return test_cases"}
{"problem_id": "scipy_20", "library": "scipy", "code_problem": "You are tasked with implementing a statistical test to determine if two datasets come from the same distribution. The main function you will implement is `test_nametuples_agree(data1, data2)`, which takes two lists of numerical data as input.\n\nFunction Signature:\n```python\ndef test_nametuples_agree(data1, data2):\n```\n\nIn this function, a constant value of `alpha` is used, which is set to `0.05`. This value represents the significance level for the statistical test.\n\n\nInput Format:\n- The function `test_nametuples_agree` takes two parameters:\n  - `data1`: A list of numerical values (can include NaN values).\n  - `data2`: A list of numerical values (can include NaN values).\n\nOutput Format:\n- The function returns a string that either indicates whether the distributions of the two datasets are significantly different or states that there is insufficient data after preprocessing.\n\nInput:\n```python\ndata1 = [1.2, 2.3, 3.1, np.nan, 4.5, 5.0, np.nan, 6.7]\ndata2 = [1.0, 2.1, 3.5, 4.0, np.nan, 5.2, 6.0, 7.1]\n```\n\nOutput:\n```\n'No significant difference between distributions (p=0.92541, KS stat=0.26190)'\n```", "ground_truth_code": "from scipy import stats\nimport numpy as np\n\n\ndef preprocess_data(data):\n    data = [float(x) for x in data if not np.isnan(float(x))]\n    if len(data) > 1:\n        mean = np.mean(data)\n        std_dev = np.std(data)\n        data = [x for x in data if (mean - 3 * std_dev) <= x <= (mean + 3 * std_dev)]\n\n    return data\n\n\ndef interpret_result(statistic, p_value, alpha=0.05):\n    if p_value < alpha:\n        return f\"Distributions are significantly different (p={p_value:.5f}, KS stat={statistic:.5f})\"\n    else:\n        return f\"No significant difference between distributions (p={p_value:.5f}, KS stat={statistic:.5f})\"\n\n# main code\ndef test_nametuples_agree(data1, data2):\n    data1 = preprocess_data(data1)\n    data2 = preprocess_data(data2)\n\n    if len(data1) < 2 or len(data2) < 2:\n        return \"Insufficient data after preprocessing.\"\n\n    result = stats.kstest(data1, data2)\n\n    return interpret_result(result.statistic, result.pvalue)", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size1 = np.random.randint(5, 50)\n        size2 = np.random.randint(5, 50)\n        if np.random.rand() < 0.5:\n            data1 = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5), size=size1)\n            data2 = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5), size=size2)\n        else:\n            data1 = np.random.uniform(low=-10, high=10, size=size1)\n            data2 = np.random.uniform(low=-10, high=10, size=size2)\n\n        nan_indices1 = np.random.choice(size1, size1 // 10, replace=False)\n        nan_indices2 = np.random.choice(size2, size2 // 10, replace=False)\n        data1[nan_indices1] = np.nan\n        data2[nan_indices2] = np.nan\n\n        test_cases.append((data1.tolist(), data2.tolist()))\n\n    return test_cases"}
{"problem_id": "scipy_21", "library": "scipy", "code_problem": "You are tasked with implementing a function that identifies repeated elements in a given dataset and also handles masked arrays. The function will utilize the `scipy.stats` library to find repeats in both regular and masked data.\n\nFunction signature:\n```python\ndef test_find_repeats(data):\n```\n\nIn this function, the following constant is used:\n- `max(x)`: This constant is used to determine the maximum value in the input data array.\n\nInput format:\n- The input to the function is a list or array-like structure containing numerical values.\n\nOutput format:\n- The output of the function is a tuple consisting of:\n  1. The result of `stats.find_repeats(x)`, which includes unique repeated values and their indices.\n  2. The result of `stats.mstats.find_repeats(xm)`, which includes unique repeated values and their indices from the masked array.\n  3. The counts of repeated elements from an empty array, which will be an empty list.\n\nInput: `[3, 1, 2, 3, 2, 1, 3]`\n\nOutput: `(RepeatedResults(values=array([1., 2., 3.]), counts=array([2, 2, 3])), (array([1., 2.]), array([2, 2])), array(0))`", "ground_truth_code": "from scipy import stats\nimport numpy as np\n\n# main code\ndef test_find_repeats(data):\n    x = np.asarray(data).astype('float')\n    mask = x == max(x)\n    xm = np.ma.array(x, mask=mask)\n    r = stats.find_repeats(x)\n    rm = stats.mstats.find_repeats(xm)\n    _, counts = stats.mstats.find_repeats([])\n    return r, rm, counts\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(2, 101)\n        unique_size = max(1, length // 2)\n        unique_values = np.random.randint(-50, 50, size=unique_size)\n        repeated_size = length - len(unique_values)\n        if repeated_size > 0:\n            repeated_values = np.random.choice(unique_values, size=repeated_size, replace=True)\n        else:\n            repeated_values = np.array([])\n        data = np.concatenate((unique_values, repeated_values))\n        np.random.shuffle(data)\n        test_cases.append(data.tolist())\n\n    return test_cases"}
{"problem_id": "scipy_22", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the kurtosis of two datasets and their respective means. The kurtosis is a statistical measure that describes the shape of the distribution of data points in a dataset. The function will preprocess the input data to handle any missing values and standardize the data before calculating the kurtosis.\n\nFunction Signature:\n```python\ndef test_kurtosis(x, y, xm, ym):\n```\n\nIn the main code, the constant used is the `stats` module from the `scipy` library, which provides the `kurtosis` function for calculating the kurtosis of the datasets.\n\nInput Format:\n- The function accepts four parameters: `x`, `y`, `xm`, and `ym`, which can be lists or arrays of numerical values.\n\nOutput Format:\n- The function returns a tuple of four values, each representing the kurtosis of the respective datasets: `(r_x, rm_x, r_y, rm_y)`.\n\nInput:\n```python\nx = [0.5, -1.2, 3.3, np.nan, 2.1]\ny = [1.0, 2.5, 3.0, 4.5]\nxm = [0.0, 0.1, 0.2]\nym = [1.5, 2.0, 2.5, 3.5, np.nan]\n```\n\nOutput:\n```python\n(-1.3833986143625678, -1.5, -1.0783999999999998, -1.1542857142857141)\n```", "ground_truth_code": "from scipy import stats\nimport numpy as np\n\n\ndef preprocess_data(data):\n    data = np.array(data)\n    data = data[~np.isnan(data)]\n    if len(data) > 0:\n        data = (data - np.mean(data)) / np.std(data)\n    return data\n\n\n# main code\ndef test_kurtosis(x, y, xm, ym):\n    x, y, xm, ym = map(preprocess_data, [x, y, xm, ym])\n\n    r_x = stats.kurtosis(x)\n    rm_x = stats.mstats.kurtosis(xm)\n    r_y = stats.kurtosis(y)\n    rm_y = stats.mstats.kurtosis(ym)\n\n    return r_x, rm_x, r_y, rm_y", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        len_x = np.random.randint(0, 50)\n        len_y = np.random.randint(0, 50)\n        len_xm = np.random.randint(0, 50)\n        len_ym = np.random.randint(0, 50)\n        x = np.random.randn(len_x).tolist() if len_x > 0 else []\n        y = np.random.randn(len_y).tolist() if len_y > 0 else []\n        xm = np.random.randn(len_xm).tolist() if len_xm > 0 else []\n        ym = np.random.randn(len_ym).tolist() if len_ym > 0 else []\n\n        if np.random.rand() < 0.1:\n            x.append(np.nan)\n        if np.random.rand() < 0.1:\n            y.append(np.nan)\n        if np.random.rand() < 0.1:\n            xm.append(np.nan)\n        if np.random.rand() < 0.1:\n            ym.append(np.nan)\n        test_cases.append((x, y, xm, ym))\n\n    return test_cases"}
{"problem_id": "scipy_23", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the harmonic means of two sets of data points and their corresponding modified versions. The function should handle potential issues with zero values and NaN values in the input data.\n\nFunction signature:\n```python\ndef test_hmean(x, y, xm, ym):\n```\n\nIn this function, the following constant is used:\n- A small value of `1e-10` is used to replace any zero values in the input arrays to avoid division by zero when calculating the harmonic mean.\n\nInput format:\n- The function accepts four parameters: `x`, `y`, `xm`, and `ym`, which can be lists or NumPy arrays of numerical values.\n\nOutput format:\n- The function returns a tuple of four harmonic mean values: `(r_x, rm_x, r_y, rm_y)`, where each value is a float representing the harmonic mean of the respective input arrays.\n\nInput:\n```python\nx = np.array([[ 1.5, -2.3, np.nan], [ 0.0,  4.5,  3.2]])\ny = np.array([[ 2.1,  0.0, -1.1], [ 3.3, np.nan,  5.0]])\nxm = np.array([[ 0.0,  1.2,  3.4], [ 2.2, -3.0, np.nan]])\nym = np.array([[ 4.0, np.nan,  0.0], [ 1.1,  2.2,  3.3]])\n```\n\nOutput:\n```python\n(array([2.00000000e-10, 3.04411765e+00, 2.67636364e+00]), \n array([2.00000000e-10, 1.71428571e+00, 2.48656716e+00]), \n array([2.56666667e+00, 2.00000000e-10, 1.80327869e+00]), \n array([1.72549020e+00, 2.15925926e+00, 2.00000000e-10]))\n```", "ground_truth_code": "from scipy import stats\nimport numpy as np\n\n# main code\ndef test_hmean(x, y, xm, ym):\n    x, y, xm, ym = map(np.asarray, (x, y, xm, ym))\n    x, y, xm, ym = np.abs(x), np.abs(y), np.abs(xm), np.abs(ym)\n\n    x[x == 0] = 1e-10\n    y[y == 0] = 1e-10\n    xm[xm == 0] = 1e-10\n    ym[ym == 0] = 1e-10\n\n    for arr in [x, y, xm, ym]:\n        nan_mask = np.isnan(arr)\n        arr[nan_mask] = np.nanmean(arr)\n\n    r_x = stats.hmean(x)\n    rm_x = stats.mstats.hmean(xm)\n    r_y = stats.hmean(y)\n    rm_y = stats.mstats.hmean(ym)\n\n    return r_x, rm_x, r_y, rm_y", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 5, size=np.random.randint(1, 3)))\n\n        x = np.random.uniform(-10, 10, shape)\n        y = np.random.uniform(-10, 10, shape)\n        xm = np.random.uniform(-10, 10, shape)\n        ym = np.random.uniform(-10, 10, shape)\n\n        nan_mask = np.random.choice([True, False], size=shape, p=[0.1, 0.9])\n        x[nan_mask] = np.nan\n        y[nan_mask] = np.nan\n        xm[nan_mask] = np.nan\n        ym[nan_mask] = np.nan\n\n        zero_mask = np.random.choice([True, False], size=shape, p=[0.05, 0.95])\n        x[zero_mask] = 0\n        y[zero_mask] = 0\n        xm[zero_mask] = 0\n        ym[zero_mask] = 0\n\n        test_cases.append((x, y, xm, ym))\n\n    return test_cases"}
{"problem_id": "scipy_24", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the standard error of the mean (SEM) for two sets of data points, `x` and `y`, as well as two additional sets of data points, `xm` and `ym`. The function will compute the SEM using two different degrees of freedom (ddof): 0 and 1. The results will be returned as a tuple containing the SEM values for each dataset.\n\nFunction signature:\n```python\ndef test_sem(x, y, xm, ym):\n```\n\nConstants used in the main code:\n- The constant values for degrees of freedom used in the calculations are `0` and `1`.\n\nInput format:\n- The function accepts four parameters: `x`, `y`, `xm`, and `ym`, which are expected to be numerical arrays or lists.\n\nOutput format:\n- The function returns a tuple containing eight SEM values, corresponding to the calculations performed for each dataset with both degrees of freedom.\n\nInput:\n```python\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.0])\ny = np.array([2.1, 3.4, 1.5, 4.2, 5.3])\nxm = np.ma.array([1.2, 2.3, 3.1, 4.5, 5.0], mask=[0, 0, 0, 0, 0])\nym = np.ma.array([2.1, 3.4, 1.5, 4.2, 5.3], mask=[0, 0, 0, 0, 0])\n```\n\nOutput:\n```python\n(0.6244357452933008, 0.6244357452933008, 0.6164414002968975, 0.6164414002968975, 0.6981403870282825, 0.6981403870282825, 0.689202437604511, 0.689202437604511)\n\n```", "ground_truth_code": "from scipy import stats\n\n# main code\ndef test_sem(x, y, xm, ym):\n\n    sem_xm_ddof0 = stats.mstats.sem(xm, axis=None, ddof=0)\n    sem_x_ddof0 = stats.sem(x, axis=None, ddof=0)\n    sem_ym_ddof0 = stats.mstats.sem(ym, axis=None, ddof=0)\n    sem_y_ddof0 = stats.sem(y, axis=None, ddof=0)\n    sem_xm_ddof1 = stats.mstats.sem(xm, axis=None, ddof=1)\n    sem_x_ddof1 = stats.sem(x, axis=None, ddof=1)\n    sem_ym_ddof1 = stats.mstats.sem(ym, axis=None, ddof=1)\n    sem_y_ddof1 = stats.sem(y, axis=None, ddof=1)\n\n    res = (sem_xm_ddof0, sem_x_ddof0, sem_ym_ddof0, sem_y_ddof0,\n           sem_xm_ddof1, sem_x_ddof1, sem_ym_ddof1, sem_y_ddof1)\n\n\n    return res", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = (np.random.randint(5, 20),) if np.random.rand() < 0.5 else (\n        np.random.randint(5, 20), np.random.randint(5, 20))\n        x = np.random.randn(*shape)\n        y = np.random.randn(*shape)\n        xm = np.ma.array(x, mask=np.random.rand(*shape) < 0.1)\n        ym = np.ma.array(y, mask=np.random.rand(*shape) < 0.1)\n\n        test_cases.append((x, y, xm.filled(np.nan), ym.filled(np.nan)))\n\n    return test_cases"}
{"problem_id": "scipy_25", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the mode of a given array using the `scipy.stats` library. The function should handle different configurations for the mode calculation, including the axis along which to compute the mode and whether to keep the dimensions of the output. Additionally, the function should also consider how to handle NaN values in the input array.\n\nFunction signature:\n```python\ndef test_keepdims(a):\n```\n\nConstant used in the main code:\n- The constant `nan_policy='omit'` is used to specify that NaN values should be ignored during the mode calculation.\n\nInput format:\n- The function takes a single argument `a`, which is a multi-dimensional array (e.g., a NumPy array).\n\nOutput format:\n- The function returns a list of results, where each result corresponds to the mode computed under different configurations as described in the logic. Each result is an object that contains the mode values and their respective counts.\n\nInput:\n```python\narray([[1., 2., 2.],\n       [3., 3., 4.],\n       [5., 5., 5.],\n       [6., 7., 7.]])\n```\n\nOutput:\n```python\n[ModeResult(mode=array([2., 3., 5., 7.]), count=array([2., 2., 3., 2.])), \n ModeResult(mode=array([[2.],[3.],[5.],[7.]]), count=array([[2.],[2.],[3.],[2.]])), \n ModeResult(mode=5.0, count=3), \n ModeResult(mode=5.0, count=3), \n ModeResult(mode=array([[5.]]), count=array([[3]])), \n ModeResult(mode=array([5.]), count=array([3])), \n ModeResult(mode=array([2., 3., 5., 7.]), count=array([2., 2., 3., 2.])), \n ModeResult(mode=array([[2.],[3.],[5.],[7.]]), count=array([[2.],[2.],[3.],[2.]])), \n ModeResult(mode=5.0, count=3), \n ModeResult(mode=5.0, count=3), \n ModeResult(mode=array([[5.]]), count=array([[3]])), \n ModeResult(mode=array([5.]), count=array([3]))\n]\n\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef test_keepdims(a):\n    results = []\n\n    res = stats.mode(a, axis=1, keepdims=False)\n    results.append(res)\n\n    res = stats.mode(a, axis=1, keepdims=True)\n    results.append(res)\n\n    res = stats.mode(a, axis=None, keepdims=False)\n    results.append(res)\n\n    ref = stats.mode(a.ravel(), keepdims=False)\n    results.append(ref)\n\n    res = stats.mode(a, axis=None, keepdims=True)\n    results.append(res)\n\n    ref = stats.mode(a.ravel(), keepdims=True)\n    results.append(ref)\n\n    res = stats.mode(a, axis=1, keepdims=False, nan_policy='omit')\n    results.append(res)\n\n    res = stats.mode(a, axis=1, keepdims=True, nan_policy='omit')\n    results.append(res)\n\n    res = stats.mode(a, axis=None, keepdims=False, nan_policy='omit')\n    results.append(res)\n\n    ref = stats.mode(a.ravel(), keepdims=False, nan_policy='omit')\n    results.append(ref)\n\n    res = stats.mode(a, axis=None, keepdims=True, nan_policy='omit')\n    results.append(res)\n\n    ref = stats.mode(a.ravel(), keepdims=True, nan_policy='omit')\n    results.append(ref)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        rows = np.random.randint(2, 10)\n        cols = np.random.randint(1, 10)\n        a = np.random.randint(0, 10, size=(rows, cols))\n\n        if np.random.rand() > 0.7:\n            mask = np.random.rand(rows, cols) < 0.2\n            a = a.astype(float)\n            a[mask] = np.nan\n\n        test_cases.append(a)\n\n    return test_cases\n"}
{"problem_id": "scipy_26", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs statistical tests on a given dataset using the Jarque-Bera test, which is used to check whether a sample comes from a normally distributed population. The function will analyze the input data in various ways and return the results in a structured format.\n\nFunction signature:\n```python\ndef test_axis(x):\n```\n\nIn this function, the following constant is used:\n- The constant `None` is used to specify that the analysis should be performed on the entire dataset without considering any specific axis.\n\nInput format:\n- The input to the function is a multi-dimensional array-like structure `x`.\n\nOutput format:\n- The output of the function is a dictionary containing the results of the Jarque-Bera tests in the specified format.\n\nInput:\n```python\narray([[ 0.49671415, -0.1382643 ,  0.64768854,  1.52302986, -0.23415337],\n       [-0.23413696,  1.57921282,  0.76743473, -0.46947439,  0.54256004]])\n```\n\nOutput:\n```python\n{\n    'result_none': SignificanceResult(statistic=0.6895355118642692, pvalue=0.7083848525448625), \n    'result_ravel': SignificanceResult(statistic=0.6895355118642692, pvalue=0.7083848525448625), \n    'res': SignificanceResult(statistic=array([0.42098538, 0.35806627]), pvalue=array([0.81018498, 0.8360782 ])), \n    's0_p0': (0.4209853838894649, 0.8101849760082943), \n    's1_p1': (0.3580662689557247, 0.836078195923594), \n    'resT': SignificanceResult(statistic=array([0.42098538, 0.35806627]), pvalue=array([0.81018498, 0.8360782 ]))\n}\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef test_axis(x):\n    result_none = stats.jarque_bera(x, axis=None)\n    result_ravel = stats.jarque_bera(x.ravel())\n\n    res = stats.jarque_bera(x, axis=1)\n    s0, p0 = stats.jarque_bera(x[0, :])\n    s1, p1 = stats.jarque_bera(x[1, :])\n\n    resT = stats.jarque_bera(x.T, axis=0)\n\n    return {\n        \"result_none\": result_none,\n        \"result_ravel\": result_ravel,\n        \"res\": res,\n        \"s0_p0\": (s0, p0),\n        \"s1_p1\": (s1, p1),\n        \"resT\": resT\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(2, 10)\n        cols = np.random.randint(5, 20)\n        x = np.random.normal(loc=0, scale=1, size=(rows, cols))\n\n        test_cases.append(x)\n    return test_cases"}
{"problem_id": "scipy_27", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the kurtosis of various datasets after preprocessing them to handle missing values and standardize their values. The function will take in multiple datasets and return the kurtosis values for each dataset based on specific parameters.\n\nFunction Signature:\n```python\ndef test_kurtosis(x, testcase, scalar_testcase, testmathworks):\n```\n\nConstant Used:\n- The constant used in the main code is `0`, which is used as a parameter in the kurtosis calculations.\n\nInput Format:\n- The function takes four parameters: `x`, `testcase`, `scalar_testcase`, and `testmathworks`, all of which are expected to be iterable datasets (like lists or NumPy arrays).\n\nOutput Format:\n- The function returns a dictionary where the keys are strings representing the names of the datasets and the values are the corresponding kurtosis values calculated from those datasets.\n\nInput:\n```python\nx = [0.5, -1.2, 3.3, 2.1, 0.0, -0.5, 1.5]\ntestcase = [1.0, 2.0, np.nan, 4.0, 5.0]\nscalar_testcase = [5.5, 6.0, 4.5, np.nan, 7.0]\ntestmathworks = [1.0, 2.0, 3.0, 4.0, 5.0, np.nan]\n```\n\nOutput:\n```python\n{\n    'kurtosis_x': -1.0624862244018238, \n    'kurtosis_x_omit': -1.0624862244018238, \n    'scalar_testcase': -1.1479289940828403, \n    'testmathworks_fisher0_bias1': 1.7, \n    'testmathworks_fisher0_bias0': 1.8000000000000007, \n    'testcase_fisher0_bias0': 1.3600000000000003\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n\ndef preprocess_data(data):\n    data = np.array(data)\n    data = data[~np.isnan(data)]\n    if len(data) > 0:\n        data = (data - np.mean(data)) / np.std(data)\n    return data\n\n# main code\ndef test_kurtosis(x, testcase, scalar_testcase, testmathworks):\n    results = {}\n\n    testcase = preprocess_data(testcase)\n    scalar_testcase = preprocess_data(scalar_testcase)\n    testmathworks = preprocess_data(testmathworks)\n\n    x = preprocess_data(x)\n\n    results['kurtosis_x'] = stats.kurtosis(x)\n    results['kurtosis_x_omit'] = stats.kurtosis(x, nan_policy='omit')\n\n    y = stats.kurtosis(scalar_testcase)\n    results['scalar_testcase'] = y\n\n    y = stats.kurtosis(testmathworks, 0, fisher=0, bias=1)\n    results['testmathworks_fisher0_bias1'] = y\n\n    y = stats.kurtosis(testmathworks, fisher=0, bias=0)\n    results['testmathworks_fisher0_bias0'] = y\n\n    y = stats.kurtosis(testcase, 0, 0)\n    results['testcase_fisher0_bias0'] = y\n\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        x = np.random.normal(loc=0, scale=1, size=np.random.randint(10, 100))\n\n        testcase = np.random.uniform(-10, 10, size=np.random.randint(10, 100))\n        if np.random.rand() < 0.2:\n            testcase[np.random.randint(0, len(testcase), size=np.random.randint(1, 5))] = np.nan\n\n        scalar_testcase = np.random.normal(loc=5, scale=2, size=np.random.randint(10, 100))\n        if np.random.rand() < 0.2:  # Introduce some NaNs\n            scalar_testcase[np.random.randint(0, len(scalar_testcase), size=np.random.randint(1, 5))] = np.nan\n\n        testmathworks = np.random.gamma(shape=2, scale=1.5, size=np.random.randint(10, 100))\n        if np.random.rand() < 0.2:\n            testmathworks[np.random.randint(0, len(testmathworks), size=np.random.randint(1, 5))] = np.nan\n        test_cases.append((x, testcase, scalar_testcase, testmathworks))\n\n    return test_cases\n"}
{"problem_id": "scipy_28", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the Spearman rank correlation coefficient for multiple pairs of datasets. The function will take a list of tuples, where each tuple contains two datasets. The datasets may contain invalid values, which should be handled appropriately.\n\nFunction signature:\n```python\ndef test_spearmanr(data_pairs):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the method `ma.fix_invalid`, which is used to handle invalid values in the datasets.\n\nInput format:\n- The input to the function is a list of tuples, where each tuple contains two datasets (arrays).\n\nOutput format:\n- The output of the function is a list of floating-point numbers, where each number represents the Spearman rank correlation coefficient for the corresponding pair of datasets.\n\nInput:\n```python\n[\n    (masked_array(data=[0.8133949788914016, 0.5112673508045944, --,\n                   0.6882265871197717, 0.9552319993785651], mask=[False, False,  True, False, False], fill_value=1e+20), \n     masked_array(data=[0.7214608416948504, 0.6356164796166208, --,\n                   0.7149973601871641, 0.6651781548179189], mask=[False, False,  True, False, False], fill_value=1e+20)\n     )\n]\n```\n\nOutput:\n```python\n[0.4]\n```", "ground_truth_code": "import scipy.stats.mstats as mstats\nimport numpy.ma as ma\n\n# main code\ndef test_spearmanr(data_pairs):\n    results = []\n\n    for x, y in data_pairs:\n        x, y = ma.fix_invalid(x), ma.fix_invalid(y)\n        results.append(mstats.spearmanr(x, y)[0])\n\n    return results", "test_script": "import numpy as np\nimport numpy.ma as ma\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        size = np.random.randint(5, 100)\n        x = np.random.rand(size)\n        y = np.random.rand(size)\n        if np.random.rand() < 0.3:\n            num_nans = np.random.randint(1, max(2, size // 10))\n            nan_indices = np.random.choice(size, num_nans, replace=False)\n            x[nan_indices] = np.nan\n            y[nan_indices] = np.nan\n\n        x_masked = ma.masked_invalid(x)\n        y_masked = ma.masked_invalid(y)\n\n        test_cases.append([(x_masked, y_masked)])\n\n    return test_cases\n\n"}
{"problem_id": "scipy_29", "library": "scipy", "code_problem": "You are tasked with analyzing the skewness of two datasets and their corresponding masked arrays. Skewness is a measure of the asymmetry of the probability distribution of a real-valued random variable. The goal is to compute the skewness for each dataset and return the results in a structured format.\n\nThe main function signature is as follows:\n```python\ndef test_skew(x, y, xm, ym):\n```\n\nIn this function, the following constant is used:\n- `0`: This constant is used to fill any NaN values in the masked arrays during preprocessing.\n\nInput format:\n- The function takes four parameters:\n  - `x`: A NumPy array of numerical values.\n  - `y`: A NumPy array of numerical values.\n  - `xm`: A masked NumPy array of numerical values.\n  - `ym`: A masked NumPy array of numerical values.\n\nOutput format:\n- The function returns a dictionary with the following keys and their corresponding skewness values:\n  - \"skew_x\": Skewness of array `x`.\n  - \"skew_xm\": Skewness of masked array `xm`.\n  - \"skew_y\": Skewness of array `y`.\n  - \"skew_ym\": Skewness of masked array `ym`.\n\nInput:\n```python\nx = np.array([1.2, 2.3, np.nan, 4.5, 5.1])\ny = np.array([2.1, 3.4, 1.2, np.nan, 4.8])\nxm_data = np.array([0.5, 1.5, 2.5, 3.5, 4.5])\nym_data = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\nxm_mask = np.array([0, 0, 1, 0, 0])  # Masking the third element\nym_mask = np.array([0, 1, 0, 0, 0])  # Masking the second element\nxm = np.ma.array(xm_data, mask=xm_mask)\nym = np.ma.array(ym_data, mask=ym_mask)\n```\n\nOutput:\n```python\n{\n    'skew_x': 0.028190840185760225, \n    'skew_xm': masked_array(data=0.28867513, mask=False, fill_value=1e+20), \n    'skew_y': 0.14726923936441658, \n    'skew_ym': masked_array(data=-0.15798755, mask=False, fill_value=1e+20)\n}\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n\ndef preprocess_data(x, y, xm, ym):\n    x = np.nan_to_num(x)\n    y = np.nan_to_num(y)\n    xm = np.nan_to_num(xm.filled(0))\n    ym = np.nan_to_num(ym.filled(0))\n    return x, y, xm, ym\n\n# main code\ndef test_skew(x, y, xm, ym):\n    x, y, xm, ym = preprocess_data(x, y, xm, ym)\n\n    results = {\n        \"skew_x\": stats.skew(x),\n        \"skew_xm\": stats.mstats.skew(xm),\n        \"skew_y\": stats.skew(y),\n        \"skew_ym\": stats.mstats.skew(ym),\n    }\n\n    return results", "test_script": "import numpy as np\nfrom scipy import stats\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(5, 100)\n        x = np.random.randn(size) * np.random.randint(1, 10)\n        y = np.random.randn(size) * np.random.randint(1, 10)\n        xm_data = np.random.randn(size)\n        ym_data = np.random.randn(size)\n        xm_mask = np.random.choice([0, 1], size=size, p=[0.9, 0.1])\n        ym_mask = np.random.choice([0, 1], size=size, p=[0.9, 0.1])\n        xm = np.ma.array(xm_data, mask=xm_mask)\n        ym = np.ma.array(ym_data, mask=ym_mask)\n        test_cases.append((x, y, xm, ym))\n\n    return test_cases"}
{"problem_id": "scipy_30", "library": "scipy", "code_problem": "```python\ndef apply_signal(signal_function: np.ndarray, volume_signal: np.ndarray) -> np.ndarray:\n```\n\nIn this code, the function `apply_signal` takes two parameters: `signal_function`, which is a 2D NumPy array representing a set of timecourses for a signal, and `volume_signal`, which is a 3D NumPy array representing a volume of data (e.g., a 3D image or a voxel grid). The function processes these inputs to produce a 4D array of convolved signals.\n\n### Constant Used:\n- The constant used in the main code is `1`, which is used in the `np.ones(1)` function call during the convolution operation.\n\n### Input and Output Format:\n- **Input**: \n  - `signal_function`: A 2D NumPy array of shape (timepoints, timecourses).\n  - `volume_signal`: A 3D NumPy array representing the volume data.\n\n- **Output**: \n  - A 4D NumPy array of shape (x_dim, y_dim, z_dim, timepoints), where each voxel contains the convolved signal.\n\n**Input:**\n```python\nsignal_function = np.array([[0.5, 1.0, -0.5],\n                             [1.5, 0.0, 0.5],\n                             [0.0, -1.0, 1.0]])\n\nvolume_signal = np.array([[[0.0, 0.0, 0.0],\n                            [1.0, 0.0, 0.0],\n                            [0.0, 0.0, 0.0]],\n\n                           [[0.0, 0.0, 0.0],\n                            [0.0, 1.5, 0.0],\n                            [0.0, 0.0, 0.0]],\n\n                           [[0.0, 0.0, 0.0],\n                            [0.0, 0.0, 0.0],\n                            [2.0, 0.0, 0.0]]])\n```\n\n**Output:**\n```python\narray([[[[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]],\n        [[ 0.5,  1.5,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]],\n        [[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]]],\n       [[[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]],\n        [[ 0. ,  0. ,  0. ],\n         [ 1.5,  0. , -1.5],\n         [ 0. ,  0. ,  0. ]],\n        [[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]]],\n       [[[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]],\n        [[ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]],\n        [[-1. ,  1. ,  2. ],\n         [ 0. ,  0. ,  0. ],\n         [ 0. ,  0. ,  0. ]]]])\n```", "ground_truth_code": "import numpy as np\nfrom scipy.signal import convolve\n\n# main code\ndef apply_signal(signal_function, volume_signal):\n    timepoints, timecourses = signal_function.shape\n    signal = np.zeros((*volume_signal.shape, timepoints))\n    idxs = np.where(volume_signal != 0)\n    num_voxels = len(idxs[0])\n\n    # Ensure signal_function has enough timecourses\n    if timecourses < num_voxels:\n        tile_factor = -(-num_voxels // timecourses)  # Equivalent to math.ceil(num_voxels / timecourses)\n        signal_function = np.tile(signal_function, (1, tile_factor))[:, :num_voxels]\n\n    for idx_counter, (x, y, z) in enumerate(zip(*idxs)):\n        convolved_signal = convolve(volume_signal[x, y, z] * signal_function[:, idx_counter], np.ones(1), mode='same')\n        signal[x, y, z, :] = convolved_signal\n\n    return signal", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        timepoints = np.random.randint(5, 50)\n        timecourses = np.random.randint(1, 10)\n        signal_function = np.random.randn(timepoints, timecourses)\n        shape_x = np.random.randint(3, 10)\n        shape_y = np.random.randint(3, 10)\n        shape_z = np.random.randint(3, 10)\n\n        volume_signal = np.random.choice([0, 1], size=(shape_x, shape_y, shape_z), p=[0.7, 0.3])\n        volume_signal = volume_signal * np.random.uniform(0.5, 2.0, size=(shape_x, shape_y, shape_z))\n\n        test_cases.append((signal_function, volume_signal))\n\n    return test_cases"}
{"problem_id": "scipy_31", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that computes the trimmed standard error of the mean (TSEM) for two datasets and their corresponding means. The function will preprocess the input data to handle any missing values and normalize the datasets before calculating the TSEM.\n\nFunction Signature:\n```python\ndef test_tsem(x: np.ndarray, y: np.ndarray, xm: np.ndarray, ym: np.ndarray) -> list:\n```\n\nConstant Used:\n- The constant used in the main code for limiting the TSEM calculation is `(-2.0, 2.0)`.\n\nInput Format:\n- The function takes four numpy arrays as input: `x`, `y`, `xm`, and `ym`.\n\nOutput Format:\n- The function returns a list of tuples, where each tuple contains the label of the TSEM calculation and the corresponding TSEM value for the datasets.\n\nInput:\n```python\nx = np.array([1.2, 2.3, np.nan, 4.5, 5.1, np.nan, 3.3, 2.2])\ny = np.array([np.nan, 1.1, 2.2, 3.3, 4.4, 5.5, np.nan, 2.1])\nxm = np.array([0.5, 1.5, 2.5, 3.5])\nym = np.array([1.0, 2.0, 3.0, 4.0])\n```\n\nOutput:\n```python\n[\n    ('tsem_x', nan, 'tsem_xm', 0.6454972243679028), \n    ('tsem_y', nan, 'tsem_ym', 0.6454972243679028), \n    ('tsem_x_limited', nan, 'tsem_xm_limited', 0.5)\n]\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n\ndef preprocess_data(x, y, xm, ym):\n    x = np.nan_to_num(x, nan=np.mean(x))\n    y = np.nan_to_num(y, nan=np.mean(y))\n    x = (x - np.mean(x)) / np.std(x)\n    y = (y - np.mean(y)) / np.std(y)\n\n    return x, y, xm, ym\n\n\n# main code\ndef test_tsem(x, y, xm, ym):\n    x, y, xm, ym = preprocess_data(x, y, xm, ym)\n\n    results = []\n\n    results.append((\"tsem_x\", stats.tsem(x), \"tsem_xm\", stats.mstats.tsem(xm)))\n    results.append((\"tsem_y\", stats.tsem(y), \"tsem_ym\", stats.mstats.tsem(ym)))\n    results.append((\"tsem_x_limited\", stats.tsem(x, limits=(-2.0, 2.0)),\n                    \"tsem_xm_limited\", stats.mstats.tsem(xm, limits=(-2.0, 2.0))))\n\n\n    return results", "test_script": "import numpy as np\nfrom scipy import stats\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(10, 100)\n        x = np.random.randn(size)\n        y = np.random.randn(size)\n        xm = np.random.randn(size)\n        ym = np.random.randn(size)\n        x[np.random.choice(size, size // 10, replace=False)] = np.nan\n        y[np.random.choice(size, size // 10, replace=False)] = np.nan\n\n        test_cases.append((x, y, xm, ym))\n\n    return test_cases"}
{"problem_id": "scipy_32", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs statistical analysis using Kendall's tau correlation coefficient. The function will compute the Kendall's tau correlation for two datasets, `x1` and `x2`, and provide results for both two-sided and one-sided tests (less and greater) in both original and reversed orders of the second dataset.\n\nFunction signature:\n```python\ndef test_kendalltau_alternative_asymptotic(x1, x2):\n```\n\nIn the main code, the constant used is the string `'two-sided'`, which is utilized to specify the type of hypothesis test being performed.\n\nInput format:\n- The function takes two lists or arrays, `x1` and `x2`, which represent the datasets for which the Kendall's tau correlation is to be computed.\n\nOutput format:\n- The function returns a dictionary containing the following keys and their corresponding values:\n  - `'two_sided'`: A tuple with the Kendall's tau correlation coefficient and the two-sided p-value.\n  - `'less'`: A tuple with the correlation coefficient for the 'less' test and its adjusted p-value.\n  - `'greater'`: A tuple with the correlation coefficient for the 'greater' test and its adjusted p-value.\n  - `'two_sided_reversed'`: A tuple with the Kendall's tau correlation coefficient and the two-sided p-value for the reversed datasets.\n  - `'greater_reversed'`: A tuple with the correlation coefficient for the 'greater_reversed' test and its adjusted p-value.\n  - `'less_reversed'`: A tuple with the correlation coefficient for the 'less_reversed' test and its adjusted p-value.\n\nInput:\n```python\n([12, -5, 3, 8, 0], [3, 8, -5, 12, 0])\n```\n\nOutput:\n```python\n{\n    'two_sided': SignificanceResult(statistic=0.0, pvalue=1.0), \n    'less': (0.0, 0.5), \n    'greater': (0.0, 0.5), \n    'two_sided_reversed': SignificanceResult(statistic=-0.39999999999999997, pvalue=0.48333333333333334), \n    'greater_reversed': (-0.39999999999999997, 0.7583333333333333), \n    'less_reversed': (-0.39999999999999997, 0.24166666666666667)\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef test_kendalltau_alternative_asymptotic(x1, x2):\n    results = {}\n    results['two_sided'] = stats.kendalltau(x1, x2, alternative='two-sided')\n\n    res_less = stats.kendalltau(x1, x2, alternative='less')\n    res_greater = stats.kendalltau(x1, x2, alternative='greater')\n\n    results['less'] = (res_less[0], 1 - results['two_sided'][1] / 2)\n    results['greater'] = (res_greater[0], results['two_sided'][1] / 2)\n\n    x2.reverse()\n    results['two_sided_reversed'] = stats.kendalltau(x1, x2, alternative='two-sided')\n\n    res_greater_reversed = stats.kendalltau(x1, x2, alternative='greater')\n    res_less_reversed = stats.kendalltau(x1, x2, alternative='less')\n\n    results['greater_reversed'] = (res_greater_reversed[0], 1 - results['two_sided_reversed'][1] / 2)\n    results['less_reversed'] = (res_less_reversed[0], results['two_sided_reversed'][1] / 2)\n\n    return results", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        array_length = random.randint(2, 100)\n        x1 = np.random.randint(-1000, 1000, size=array_length).tolist()\n        x2 = np.random.randint(-1000, 1000, size=array_length).tolist()\n\n        test_cases.append((x1, x2))\n\n    return test_cases"}
{"problem_id": "scipy_33", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes various statistics related to the maximum value of a dataset using the `scipy.stats.tmax` function. The function should handle different scenarios, including empty inputs, arrays with NaN values, and provide results based on specific conditions.\n\nFunction signature:\n```python\ndef test_tmax(data):\n```\n\n### Constants:\n- The constant used in the main code is `None`, which is used to represent the absence of a value.\n\n\n### Input Format:\n- The input to the function is a single parameter `data`, which is expected to be a list or array-like structure containing numerical values.\n\n### Output Format:\n- The output of the function is a dictionary containing various computed statistics or error messages, with keys such as `'error'`, `'single_value'`, `'full_array'`, `'upperlimit_max'`, `'upperlimit_max_exclusive'`, `'axis_1'`, `'axis_none'`, and `'nan_policy_omit'`.\n\nInput: `[3.5, 2.1, 5.7, 4.3, 6.0]`\n\nOutput: \n```json\n{\n  'single_value': 6.0, \n  'full_array': 6.0, \n  'upperlimit_max': 6.0, \n  'upperlimit_max_exclusive': 5.7, \n  'axis_1': array([3.5, 5.7]), \n  'axis_none': 6.0\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n\n# main code\ndef test_tmax(data):\n    results = {}\n    if len(data) == 0:\n        results['error'] = \"Empty array provided\"\n        return results\n    x = np.array(data)\n    if np.all(np.isnan(x)):\n        results['error'] = \"All values are NaN\"\n        return results\n    try:\n        results['single_value'] = stats.tmax(x)\n        results['full_array'] = stats.tmax(x)\n        max_x = np.max(x[np.isfinite(x)]) if np.any(np.isfinite(x)) else None\n        if max_x is not None:\n            results['upperlimit_max'] = stats.tmax(x, upperlimit=max_x)\n            if np.any(x < max_x):\n                results['upperlimit_max_exclusive'] = stats.tmax(x, upperlimit=max_x, inclusive=False)\n        if x.ndim == 1 and len(x) > 1:\n            reshaped_x = x.reshape(-1, 2) if x.size % 2 == 0 else x[:-1].reshape(-1, 2)\n            results['axis_1'] = stats.tmax(reshaped_x, axis=1)\n        results['axis_none'] = stats.tmax(x, axis=None)\n        if np.isnan(x).any():\n            results['nan_policy_omit'] = stats.tmax(x, nan_policy='omit')\n    except ValueError as e:\n        results['error'] = str(e)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        choice = np.random.choice(['1D', '2D', 'nan', 'edge'])\n\n        if choice == '1D':\n            size = np.random.randint(1, 20)\n            data = np.random.randn(size)\n\n        elif choice == '2D':\n            rows = np.random.randint(1, 10)\n            cols = 2\n            data = np.random.randn(rows * cols).reshape(rows, cols)\n\n        elif choice == 'nan':\n            size = np.random.randint(1, 20)\n            data = np.random.randn(size)\n            nan_indices = np.random.choice(size, size // 3, replace=False)\n            data[nan_indices] = np.nan\n\n        else:\n            if np.random.rand() > 0.5:\n                data = np.array([])\n            else:\n                data = np.array([42])\n        test_cases.append(data.tolist())\n\n    return test_cases"}
{"problem_id": "scipy_34", "library": "scipy", "code_problem": "You are tasked with implementing a statistical testing function that performs the Kolmogorov-Smirnov test for a one-sample scenario. The function will utilize a preprocessing step to handle input data before applying the statistical test. \n\nThe function signature of the main code is:\n```python\ndef test_kstest_1samp(x, mode, alternative):\n```\n\nIn this code, the following constant is used:\n- `fill_value = 1e+16`: This constant is used to initialize an array that will hold the input data with additional space for extra elements.\n\nInput format:\n- The function takes three parameters:\n  - `x`: A 1D array-like structure containing numerical data.\n  - `mode`: A string that specifies the mode of the test.\n  - `alternative`: A string that specifies the alternative hypothesis for the test.\n\nOutput format:\n- The function returns a tuple containing three results from the Kolmogorov-Smirnov tests, where each result is an object that includes the test statistic and the p-value.\n\nInput:\n```python\nx = np.array([-0.5, 0.0, 1.5, -1.0, 0.5])\nmode = 'auto'\nalternative = 'two-sided'\n```\n\nOutput:\n```python\n(\n    KstestResult(statistic=0.15865525393145707, pvalue=0.9973339651582757, statistic_location=-1.0, statistic_sign=-1), \n    KstestResult(statistic=0.15865525393145707, pvalue=0.9973339651582757, statistic_location=-1.0, statistic_sign=-1), \n    KstestResult(statistic=0.15865525393145707, pvalue=0.9973339651582757, statistic_location=-1.0, statistic_sign=-1)\n)\n\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n\ndef preprocess_data(x, fill_value=1e+16, mask_threshold=9e+15, extra_length=5):\n    xm = np.full(len(x) + extra_length, fill_value)\n    xm[:len(x)] = x\n    mask = xm > mask_threshold\n    xm = np.ma.array(xm, mask=mask)\n    return xm\n\n# main code\ndef test_kstest_1samp(x, mode, alternative):\n    xm = preprocess_data(x)\n    res1 = stats.kstest(x, 'norm', alternative=alternative, mode=mode)\n    res2 = stats.mstats.kstest(xm, 'norm', alternative=alternative, mode=mode)\n    res3 = stats.kstest(xm, 'norm', alternative=alternative, mode=mode)\n    return res1, res2, res3", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    modes = ['auto', 'exact', 'asymp']\n    alternatives = ['two-sided', 'less', 'greater']\n\n    for _ in range(n):\n        size = np.random.randint(5, 101)\n        x = np.random.normal(loc=0, scale=1, size=size)\n        mode = np.random.choice(modes)\n        alternative = np.random.choice(alternatives)\n\n        test_cases.append((x, mode, alternative))\n\n    return test_cases\n"}
{"problem_id": "scipy_35", "library": "scipy", "code_problem": "You are tasked with implementing an all-pass filter using the provided function signature. The all-pass filter is a type of filter that allows all frequencies to pass through it but alters the phase of the input signal. The function you need to implement is defined as follows:\n\n```python\ndef allpass_filter(cutoff_hz, q, signal, fs):\n```\n\n### Constants:\n- The constant `2.0` is used in the calculation of `w0` and `alpha`.\n\n### Input and Output Format:\n- **Input**: The function takes four parameters: `cutoff_hz` (float), `q` (float), `signal` (NumPy array), and `fs` (float).\n- **Output**: The function returns a NumPy array representing the filtered output signal.\n\n```python\n# Input\ncutoff_hz = 1500.0\nq = 2.5\nsignal = np.array([0.1, -0.2, 0.3, -0.4, 0.5])\nfs = 44100\n\n# Output\noutput = np.array([ 0.09186159, -0.19898243,  0.29310716, -0.39758179,  0.49458912])\n```", "ground_truth_code": "import numpy as np\nfrom scipy.signal import lfilter\n\n# main code\ndef allpass_filter(cutoff_hz, q, signal, fs):\n    w0 = 2.0 * np.pi * cutoff_hz / fs\n    alpha = np.sin(w0) / (2.0 * q)\n    cos_w0 = np.cos(w0)\n    a0 = 1.0 + alpha\n    a = np.array([1, -2.0 * cos_w0 / a0, (1.0 - alpha) / a0])\n    b = np.array([(1.0 - alpha) / a0, -2.0 * cos_w0 / a0, 1.0])\n    output = lfilter(b, a, signal)\n    return output", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        cutoff_hz = np.random.uniform(100, 5000)\n        q = np.random.uniform(0.1, 10)\n        fs = np.random.choice([8000, 16000, 44100, 48000])\n        signal_length = np.random.randint(100, 10000)\n        signal = np.random.randn(signal_length)\n        test_cases.append((cutoff_hz, q, signal, fs))\n\n    return test_cases\n"}
{"problem_id": "scipy_36", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the z-scores for two datasets and their respective means. The function will also compute the z-scores using the `scipy` library for comparison. The function signature is as follows:\n\n```python\ndef test_zscore(x, y, xm, ym):\n```\n\n### Constants Used:\n- The constant used in the main code is the `stats` module from the `scipy` library, which provides statistical functions including z-score calculations.\n\n### Input and Output Format:\n- **Input**: The function accepts four parameters: `x`, `y`, `xm`, and `ym`, all of which are array-like structures containing numerical data.\n- **Output**: The function returns a dictionary containing the computed z-scores for `x`, `y`, `xm`, and `ym`.\n\nInput:\n```python\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.0])\ny = np.array([2.1, 3.4, 1.8, 4.0, 5.2])\nxm = np.array([1.0, 2.0, 3.0, 4.0, 5.0, 6.0])\nym = np.array([2.0, 3.0, 1.0, 4.0, 5.0, 6.0])\n```\n\nOutput:\n```python\n{\n    'zscore_x': array([-1.44670043, -0.65889327, -0.0859426 ,  0.91672107,  1.27481523]), \n    'computed_zx': array([-1.44670043, -0.65889327, -0.0859426 ,  0.91672107,  1.27481523]), \n    'zscore_y': array([-0.96076892,  0.08006408, -1.20096115,  0.56044854,  1.52121746]), \n    'computed_zy': array([-0.96076892,  0.08006408, -1.20096115,  0.56044854,  1.52121746]), \n    'zscore_xm': array([-1.41421356, -0.70710678,  0.        ,  0.70710678,  1.41421356]), \n    'zscore_ym': array([-0.70710678,  0.        , -1.41421356,  0.70710678,  1.41421356])\n}\n\n```", "ground_truth_code": "from scipy import stats\n\n# main code\ndef test_zscore(x, y, xm, ym):\n    zx = (x - x.mean()) / x.std()\n    zy = (y - y.mean()) / y.std()\n\n    results = {\n        'zscore_x': stats.zscore(x),\n        'computed_zx': zx,\n        'zscore_y': stats.zscore(y),\n        'computed_zy': zy,\n        'zscore_xm': stats.mstats.zscore(xm[:len(x)]),\n        'zscore_ym': stats.mstats.zscore(ym[:len(y)])\n    }\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        len_x = np.random.randint(5, 100)\n        len_y = np.random.randint(5, 100)\n        x = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5), size=len_x)\n        y = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5), size=len_y)\n        xm = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5),\n                              size=len_x + np.random.randint(0, 10))\n        ym = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5),\n                              size=len_y + np.random.randint(0, 10))\n\n        test_cases.append((x, y, xm, ym))\n    return test_cases"}
{"problem_id": "scipy_37", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that computes Siegel's slopes for two sets of data. The function should handle missing values gracefully and provide results based on specified methods.\n\nFunction Signature:\n```python\ndef test_siegelslopes(x, y, method='both'):\n```\n\nConstant used in the main code:\n- The string constants `'both'`, `'standard'`, and `'separate'` are used to determine the method of calculation for Siegel's slopes.\n\nInput Format:\n- The function accepts two inputs, `x` and `y`, which can be lists or arrays of numerical values. An optional parameter `method` can be provided to specify the calculation method.\n\nOutput Format:\n- The function returns a dictionary containing the results of the Siegel's slopes calculations. The keys of the dictionary will be `\"standard\"` and/or `\"separate\"` depending on the method specified, and the values will be the corresponding slope results.\n\nInput:\n```python\n(\n    [12.5, -3.2, np.nan, 7.1, 4.8, np.nan, 15.0, -8.3],\n    [5.0, 2.1, 3.3, np.nan, -1.5, 4.2, np.nan, 6.7],\n    'both'\n)\n```\n\nOutput:\n```python\n{\n    'standard': SiegelslopesResult(slope=-0.45, intercept=1.8125), \n    'separate': SiegelslopesResult(slope=-0.45, intercept=1.0822900763358776)\n}\n\n``` \n", "ground_truth_code": "import numpy as np\nimport scipy.stats.mstats as mstats\n\ndef preprocess_data(x, y):\n    x = np.asarray(x)\n    y = np.asarray(y)\n\n    mask = ~np.isnan(x) & ~np.isnan(y)\n    x, y = x[mask], y[mask]\n\n    return x, y\n\n# main code\ndef test_siegelslopes(x, y, method='both'):\n    x, y = preprocess_data(x, y)\n\n    results = {}\n    if method in ('both', 'standard'):\n        results[\"standard\"] = mstats.siegelslopes(y, x)\n    if method in ('both', 'separate'):\n        results[\"separate\"] = mstats.siegelslopes(y, x, method='separate')\n\n    return results", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        length = np.random.randint(5, 100)\n        x = np.random.uniform(-100, 100, size=length)\n        y = np.random.uniform(-100, 100, size=length)\n        nan_mask_x = np.random.rand(length) < 0.1\n        nan_mask_y = np.random.rand(length) < 0.1\n        x[nan_mask_x] = np.nan\n        y[nan_mask_y] = np.nan\n        method = np.random.choice(['both', 'standard', 'separate'])\n        test_cases.append((x.tolist(), y.tolist(), method))\n\n    return test_cases"}
{"problem_id": "scipy_38", "library": "scipy", "code_problem": "You are tasked with implementing a statistical testing function that compares two datasets using the Kolmogorov-Smirnov test. The function will preprocess the input data to handle large values and then perform the test using both the original and preprocessed datasets.\n\nFunction signature:\n```python\ndef test_kstest_2samp(x, y, alternative, mode):\n```\n\nConstant used in the main code:\n- `9e15`: This constant is used as a threshold to mask values in the input arrays that are considered excessively large.\n\nInput format:\n- `x`: A list or array-like structure containing numerical data for the first dataset.\n- `y`: A list or array-like structure containing numerical data for the second dataset.\n- `alternative`: A string indicating the alternative hypothesis for the test (e.g., 'two-sided', 'less', 'greater').\n- `mode`: A string indicating the mode of the test (e.g., 'auto', 'exact', 'asymptotic').\n\nOutput format:\n- The function returns a tuple containing three results from the Kolmogorov-Smirnov tests, where each result is an object that includes the test statistic and the p-value.\n\n**Input:**\n```python\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.6])\ny = np.array([2.1, 3.4, 4.2, 5.8, 6.0])\nalternative = 'two-sided'\nmode = 'auto'\n```\n\n**Output:**\n```python\nres1 = KstestResult(statistic=0.4, pvalue=0.873015873015873, statistic_location=5.6, statistic_sign=1)\nres2 = KstestResult(statistic=0.4, pvalue=0.873015873015873, statistic_location=5.6, statistic_sign=1)\nres3 = KstestResult(statistic=0.4, pvalue=0.873015873015873, statistic_location=5.6, statistic_sign=1)\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\ndef preprocess_data(x, y):\n    len_x = len(x)\n    len_y = len(y)\n\n    xm = np.full(len_x + 5, np.inf)\n    ym = np.full(len_y + 5, np.inf)\n\n    xm[:len_x] = x\n    ym[:len_y] = y\n\n    mask_x = xm > 9e15\n    mask_y = ym > 9e15  # Ensure mask is of the same length as ym\n\n    xm = np.ma.array(xm, mask=mask_x)\n    ym = np.ma.array(ym, mask=mask_y)\n\n    return xm, ym\n\n# main code\ndef test_kstest_2samp(x, y, alternative, mode):\n    xm, ym = preprocess_data(x, y)\n    res1 = stats.kstest(x, y, alternative=alternative, mode=mode)\n    res2 = stats.mstats.kstest(xm, ym, alternative=alternative, mode=mode)\n    res3 = stats.kstest(xm, y, alternative=alternative, mode=mode)\n\n    return res1, res2, res3\n", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    alternatives = ['two-sided', 'less', 'greater']\n    modes = ['auto', 'exact', 'asymp']\n\n    for _ in range(n):\n        # Generate random sizes for input arrays\n        size_x = random.randint(5, 100)\n        size_y = random.randint(5, 100)\n\n        # Generate random distributions for x and y\n        dist_x = random.choice([\n            np.random.normal, np.random.uniform, np.random.exponential, np.random.gamma, np.random.beta\n        ])\n        dist_y = random.choice([\n            np.random.normal, np.random.uniform, np.random.exponential, np.random.gamma, np.random.beta\n        ])\n\n        # Generate data for x and y with reasonable parameters\n        if dist_x == np.random.normal:\n            x = dist_x(loc=random.uniform(-10, 10), scale=random.uniform(1, 5), size=size_x)\n        elif dist_x == np.random.uniform:\n            x = dist_x(low=random.uniform(-10, 0), high=random.uniform(0, 10), size=size_x)\n        elif dist_x == np.random.exponential:\n            x = dist_x(scale=random.uniform(1, 5), size=size_x)\n        elif dist_x == np.random.gamma:\n            x = dist_x(shape=random.uniform(1, 5), scale=random.uniform(1, 5), size=size_x)\n        elif dist_x == np.random.beta:\n            x = dist_x(a=random.uniform(1, 5), b=random.uniform(1, 5), size=size_x)\n\n        if dist_y == np.random.normal:\n            y = dist_y(loc=random.uniform(-10, 10), scale=random.uniform(1, 5), size=size_y)\n        elif dist_y == np.random.uniform:\n            y = dist_y(low=random.uniform(-10, 0), high=random.uniform(0, 10), size=size_y)\n        elif dist_y == np.random.exponential:\n            y = dist_y(scale=random.uniform(1, 5), size=size_y)\n        elif dist_y == np.random.gamma:\n            y = dist_y(shape=random.uniform(1, 5), scale=random.uniform(1, 5), size=size_y)\n        elif dist_y == np.random.beta:\n            y = dist_y(a=random.uniform(1, 5), b=random.uniform(1, 5), size=size_y)\n\n        # Randomly choose parameters for KS test\n        alternative = random.choice(alternatives)\n        mode = random.choice(modes)\n\n        test_cases.append((x, y, alternative, mode))\n\n    return test_cases\n"}
{"problem_id": "scipy_39", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the third statistical moment of two datasets and their corresponding modified datasets. The third moment is a measure of the asymmetry of the probability distribution of a real-valued random variable about its mean.\n\nFunction Signature:\n```python\ndef test_moment(x, y, xm, ym):\n```\n\nConstants Used:\n- The constant used in the main code is the moment value, which is set to 3 for calculating the third moment.\n\nInput Format:\n- The function accepts four parameters: `x`, `y`, `xm`, and `ym`. Each parameter can be a list, tuple, or any array-like structure containing numerical values.\n\nOutput Format:\n- The function returns a list of tuples. Each tuple contains two numerical values: the third moment of the original dataset and the third moment of the modified dataset.\n\nInput:\n```python\n(\n    [0.1, 0.2, 0.3, 0.4, 0.5], \n    [0.6, 0.7, 0.8, 0.9, 1.0], \n    [1.6, 1.7, 1.8, 1.9, 2.0], \n    [1.1, 1.2, 1.3, 1.4, 1.5]\n)\n```\n\nOutput:\n```python\n[\n    (1.0408340855860842e-18, -1.3877787807814458e-18), \n    (3.469446951953614e-18, -1.3877787807814458e-18)\n]\n``` \n", "ground_truth_code": "from scipy import stats\nimport numpy as np\n\n# main code\ndef test_moment(x, y, xm, ym):\n    x, y, xm, ym = map(np.array, [x, y, xm, ym])\n    results = []\n    for data, mod_data in [(x, xm), (y, ym)]:\n        r = stats.moment(data, moment=3)\n        rm = stats.moment(mod_data, moment=3)\n        results.append((r, rm))\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(5, 20)\n        x = np.random.rand(shape)\n        y = np.random.rand(shape)\n\n        # Introduce variation by shifting and scaling\n        xm = x + np.random.uniform(0.5, 1.5, shape)\n        ym = y + np.random.uniform(0.5, 1.5, shape)\n\n        test_cases.append((x.tolist(), y.tolist(), xm.tolist(), ym.tolist()))\n\n    return test_cases"}
{"problem_id": "scipy_40", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that performs various chi-squared tests on masked arrays and other datasets. The function will compute chi-squared statistics and p-values for different scenarios, including masked observations, unmasked observations, and empty datasets. \n\nThe function signature is as follows:\n\n```python\ndef test_chisquare_masked_arrays(obs, mask, obs1, exp1, scalar_data, empty_data):\n```\n\n### Constants Used:\n- The constant `lambda_` is set to `'log-likelihood'` for the power divergence test.\n\n### Input Format:\n- `obs`: A numpy array of observed frequencies.\n- `mask`: A boolean array indicating which elements of `obs` should be masked.\n- `obs1`: A numpy array of additional observed frequencies.\n- `exp1`: A numpy array of expected frequencies corresponding to `obs1`.\n- `scalar_data`: A numpy array of scalar observed frequencies.\n- `empty_data`: A numpy array that may be empty or contain no valid observations.\n\n### Output Format:\nThe function returns a dictionary with the following keys:\n- `\"chisq\"`: Chi-squared statistic for masked observations.\n- `\"p\"`: P-value for masked observations.\n- `\"g\"`: G statistic for masked observations.\n- `\"expected_chisq\"`: Expected chi-squared values.\n- `\"expected_g\"`: Expected G values.\n- `\"chisq_T\"`: Chi-squared statistic for transposed masked observations.\n- `\"p_T\"`: P-value for transposed masked observations.\n- `\"g_T\"`: G statistic for transposed masked observations.\n- `\"p_1\"`: P-value for additional observations.\n- `\"chi2_1\"`: Chi-squared statistic for additional observations.\n- `\"chisq_scalar\"`: Chi-squared statistic for scalar data.\n- `\"p_scalar\"`: P-value for scalar data.\n- `\"chisq_empty\"`: Chi-squared statistic for empty data.\n- `\"p_empty\"`: P-value for empty data.\n- `\"chisq_empty3_T\"`: Chi-squared statistic for transposed empty data.\n- `\"p_empty3_T\"`: P-value for transposed empty data.\n\n**Input:**\n```python\nobs = np.array([[10, 20, 30], [40, 50, 60]])\nmask = np.array([[False, False, True], [False, True, False]])\nobs1 = np.array([50, 90])\nexp1 = np.array([40, 100])\nscalar_data = np.array([25])\nempty_data = np.array([]).reshape(0, 3)\n\nresult = test_chisquare_masked_arrays(obs, mask, obs1, exp1, scalar_data, empty_data)\n```\n\n**Output:**\n```python\n{\n    'chisq': masked_array(data=[18.0, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'p': array([1.13209705e-05,            nan,            nan]), \n    'g': masked_array(data=[19.27447570217575, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'expected_chisq': masked_array(data=[18.0, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'expected_g': masked_array(data=[19.27447570217575, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'chisq_T': masked_array(data=[18.0, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'p_T': array([1.13209705e-05,            nan,            nan]), \n    'g_T': masked_array(data=[19.27447570217575, 0.0, 0.0], mask=[False, False, False], fill_value=1e+20), \n    'p_1': 0.0613688291394023, \n    'chi2_1': 3.5, \n    'chisq_scalar': 0.0, \n    'p_scalar': nan, \n    'chisq_empty': array([0., 0., 0.]), \n    'p_empty': array([nan, nan, nan]), \n    'chisq_empty3_T': array([], dtype=float64), \n    'p_empty3_T': array([], dtype=float64)\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_chisquare_masked_arrays(obs, mask, obs1, exp1, scalar_data, empty_data):\n    mobs = np.ma.masked_array(obs, mask)\n    expected_chisq = np.sum((mobs - mobs.mean(axis=0)) ** 2 / mobs.mean(axis=0), axis=0)\n    expected_g = 2 * np.sum(mobs * np.log(mobs / mobs.mean(axis=0)), axis=0)\n\n    chisq, p = stats.chisquare(mobs)\n    g, p = stats.power_divergence(mobs, lambda_='log-likelihood')\n    chisq_T, p_T = stats.chisquare(mobs.T, axis=1)\n    g_T, p_T = stats.power_divergence(mobs.T, axis=1, lambda_='log-likelihood')\n\n    chi2_1, p_1 = stats.chisquare(obs1, f_exp=exp1)\n    chisq_scalar, p_scalar = stats.chisquare(scalar_data, axis=None)\n\n    chisq_empty, p_empty = stats.chisquare(empty_data)\n    chisq_empty3_T, p_empty3_T = stats.chisquare(empty_data.T)\n\n    return {\n        \"chisq\": chisq,\n        \"p\": p,\n        \"g\": g,\n        \"expected_chisq\": expected_chisq,\n        \"expected_g\": expected_g,\n        \"chisq_T\": chisq_T,\n        \"p_T\": p_T,\n        \"g_T\": g_T,\n        \"p_1\": p_1,\n        \"chi2_1\": chi2_1,\n        \"chisq_scalar\": chisq_scalar,\n        \"p_scalar\": p_scalar,\n        \"chisq_empty\": chisq_empty,\n        \"p_empty\": p_empty,\n        \"chisq_empty3_T\": chisq_empty3_T,\n        \"p_empty3_T\": p_empty3_T\n    }", "test_script": "import numpy as np\nimport scipy.stats as stats\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate random shape for obs (at least 2D)\n        shape = np.random.randint(2, 10, size=2)  # Ensuring 2D tensor\n        obs = np.random.randint(1, 100, size=shape)\n        mask = np.random.choice([True, False], size=shape, p=[0.1, 0.9])\n\n        # obs1 and exp1 should have the same sum\n        obs1 = np.random.randint(1, 100, size=shape[0])\n        exp1 = np.random.randint(1, 100, size=shape[0])\n\n        # Normalize exp1 to have the same sum as obs1\n        exp1 = exp1 * (obs1.sum() / exp1.sum())\n\n        # Scalar data should be a single-element array\n        scalar_data = np.array([np.random.randint(1, 100)])\n\n        # Empty data should be an empty array\n        empty_data = np.array([]).reshape(0, shape[1])\n\n        test_cases.append((obs, mask, obs1, exp1, scalar_data, empty_data))\n\n    return test_cases"}
{"problem_id": "scipy_41", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes descriptive statistics for a given dataset. The function should handle both one-dimensional and multi-dimensional arrays, and it should also account for the presence of NaN (Not a Number) values in the dataset.\n\nFunction Signature:\n```python\ndef test_describe_numbers(data):\n```\n\nConstant Used:\n- The constant used in the main code is `nan_policy='omit'`, which is utilized to ignore NaN values when calculating statistics.\n\nInput Format:\n- The input to the function is a single parameter `data`, which can be a one-dimensional or multi-dimensional array-like structure.\n\nOutput Format:\n- The output of the function is a dictionary containing the following keys:\n  - `\"stats_x\"`: Descriptive statistics for the original data.\n  - `\"stats_x_T\"`: Descriptive statistics for each dimension if applicable, or `None`.\n  - `\"stats_x_nan_omit\"`: Descriptive statistics with NaN values omitted, or `None`.\n\n**Input:**\n```python\ndata = np.array([1.2, 2.3, np.nan, 4.5, 5.1])\n```\n\n**Output:**\n```python\n{\n    'stats_x': DescribeResult(nobs=5, minmax=(nan, nan), mean=nan, variance=nan, skewness=nan, kurtosis=nan), \n    'stats_x_T': None, \n    'stats_x_nan_omit': DescribeResult(nobs=4, minmax=(masked_array(data=1.2, mask=False, fill_value=1e+20), masked_array(data=5.1, mask=False, fill_value=1e+20)), \n                                       mean=3.275, variance=3.3625000000000003, skewness=masked_array(data=-0.12137653, mask=False, fill_value=1e+20), kurtosis=-1.7111718559260745)}\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_describe_numbers(data):\n    stats_x = stats.describe(data)\n\n    stats_x_T = stats.describe(data.T, axis=1) if data.ndim > 1 else None\n\n    if np.isnan(data).any():\n        stats_x_nan_omit = stats.describe(data, nan_policy='omit')\n    else:\n        stats_x_nan_omit = None\n\n    return {\n        \"stats_x\": stats_x,\n        \"stats_x_T\": stats_x_T,\n        \"stats_x_nan_omit\": stats_x_nan_omit\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly choose between 1D and 2D input\n        if np.random.rand() > 0.5:\n            # 1D array\n            size = np.random.randint(5, 100)\n            data = np.random.randn(size)  # Normal distribution\n            if np.random.rand() > 0.8:  # Introduce NaNs occasionally\n                nan_indices = np.random.choice(size, size // 10, replace=False)\n                data[nan_indices] = np.nan\n        else:\n            # 2D array\n            rows = np.random.randint(5, 50)\n            cols = np.random.randint(5, 50)\n            data = np.random.randn(rows, cols)  # Normal distribution\n            if np.random.rand() > 0.8:  # Introduce NaNs occasionally\n                nan_indices = np.random.choice(rows * cols, (rows * cols) // 10, replace=False)\n                data.flat[nan_indices] = np.nan\n\n        test_cases.append(data)\n\n    return test_cases\n"}
{"problem_id": "scipy_42", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the mode of a dataset while handling missing values, normalizing the data, and applying a mask based on a specified condition. The function should also allow for reshaping the data before computing the mode.\n\nFunction signature:\n```python\ndef compute_mode(data, mask_condition, reshape_dims, axis):\n```\n\nConstant used in the main code:\n- The constant value used for identifying outliers is `3`, which is used in the z-score calculation to determine if a data point should be replaced with the median.\n\nInput format:\n- `data`: A numpy array containing the dataset, which may include NaN values.\n- `mask_condition`: A function that takes the data as input and returns a boolean array indicating which elements should be masked.\n- `reshape_dims`: A tuple specifying the new shape for the data, or `None` if no reshaping is required.\n- `axis`: An integer specifying the axis along which to compute the mode.\n\nOutput format:\n- The function returns the mode of the masked data as a result, which is a numpy array containing the most frequently occurring values along the specified axis.\n\n**Input:**\n```python\ndata = np.array([[1.0, 2.0, np.nan], [4.0, np.nan, 6.0], [7.0, 8.0, 9.0]])\nmask_condition = lambda x: x < 3.0\nreshape_dims = (3, 3)\naxis = 0\n```\n\n**Output:**\n```python\nModeResult(mode=masked_array(data=[[0, 0, 0]], mask=False,fill_value=999999), count=masked_array(data=[[0, 0, 0]], mask=False, fill_value=999999))\n```\n", "ground_truth_code": "import numpy as np\nimport numpy.ma as ma\nimport scipy.stats.mstats as mstats\n\n# main code\ndef compute_mode(data, mask_condition, reshape_dims, axis):\n    data = np.where(np.isnan(data), np.nanmedian(data), data)\n\n    data_min, data_max = np.min(data), np.max(data)\n    if data_max > data_min:\n        data = (data - data_min) / (data_max - data_min)\n\n    z_scores = np.abs((data - np.mean(data)) / np.std(data))\n    data = np.where(z_scores > 3, np.median(data), data)\n\n    if reshape_dims:\n        data = np.reshape(data, reshape_dims)\n    masked_data = ma.masked_where(mask_condition(data), data)\n    return mstats.mode(masked_data, axis=axis)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Randomly generate the shape of the tensor\n        shape = tuple(np.random.randint(2, 10, size=np.random.randint(2, 4)))  # 2D or 3D tensor\n\n        # Generate random data with NaNs\n        data = np.random.randn(*shape) * 10\n        data[np.random.rand(*shape) < 0.1] = np.nan  # Introduce NaNs\n\n        # Define a mask condition function\n        mask_condition = lambda x: x < np.random.uniform(-5, 5)  # Mask values below a threshold\n\n        # Randomly choose reshape dimensions that are compatible\n        reshape_dims = None\n        if np.random.rand() > 0.5:  # 50% chance to reshape\n            size = np.prod(shape)\n            reshape_dims = tuple(np.random.choice(range(2, min(size, 10)), size=np.random.randint(2, 4)))\n            if np.prod(reshape_dims) != size:\n                reshape_dims = None  # Ensure reshaped size matches original size\n\n        # Choose a valid axis\n        axis = np.random.choice(range(len(shape))) if len(shape) > 1 else 0\n\n        # Append to test cases\n        test_cases.append((data, mask_condition, reshape_dims, axis))\n\n    return test_cases"}
{"problem_id": "scipy_43", "library": "scipy", "code_problem": "You are tasked with implementing a function that utilizes the `obrientransform` method from the `scipy.stats` library to perform transformations on input data. The function will take two input arrays and return a dictionary containing various transformation results.\n\nFunction Signature:\n```python\ndef transformed_results(x1, x2):\n```\n\nConstant Used:\n- The constant used in the main code is `2`, which is used to create a new array by multiplying `x1` by 2.\n\nInput Format:\n- The function takes two parameters:\n  - `x1`: An array or list of numerical values.\n  - `x2`: An array or list of numerical values.\n\nOutput Format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - `\"t1\"`: The first element of the transformation result of `x1`.\n  - `\"t2\"`: The first element of the transformation result of `x2`.\n  - `\"a_b\"`: A tuple containing the first two elements of the transformation result of `x1` and `x2`.\n  - `\"a_b_c\"`: A tuple containing the first three elements of the transformation result of `x1`, `x2`, and `x1`.\n  - `\"matrix_result\"`: The transformation result of `x1` and `2 * x1`.\n\nInput:\n```python\nx1 = np.array([-0.5, 1.2, 0.3, -1.1, 0.7])\nx2 = np.array([0.4, -0.8, 1.5, 0.2, -0.3])\n```\n\nOutput:\n```python\n{\n    't1': array([ 0.41858333,  1.559     , -0.09475   ,  2.02858333,  0.34858333]), \n    't2': array([-0.06583333,  1.33416667,  2.34041667, -0.12416667,  0.24041667]), \n    'a_b': (array([ 0.41858333,  1.559     , -0.09475   ,  2.02858333,  0.34858333]), array([-0.06583333,  1.33416667,  2.34041667, -0.12416667,  0.24041667])), \n    'a_b_c': (array([ 0.41858333,  1.559     , -0.09475   ,  2.02858333,  0.34858333]), array([-0.06583333,  1.33416667,  2.34041667, -0.12416667,  0.24041667]), array([ 0.41858333,  1.559     , -0.09475   ,  2.02858333,  0.34858333])), \n    'matrix_result': array([[ 0.41858333,  1.559     , -0.09475   ,  2.02858333,  0.34858333], [ 1.67433333,  6.236     , -0.379     ,  8.11433333,  1.39433333]])}\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef transformed_results(x1, x2):\n    results = {}\n\n    t1 = stats.obrientransform(x1)\n    results[\"t1\"] = t1[0]\n\n    t2 = stats.obrientransform(x2)\n    results[\"t2\"] = t2[0]\n\n    a, b = stats.obrientransform(x1, x2)\n    results[\"a_b\"] = (a, b)\n\n    a, b, c = stats.obrientransform(x1, x2, x1)\n    results[\"a_b_c\"] = (a, b, c)\n\n    results[\"matrix_result\"] = stats.obrientransform(x1, 2 * x1)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(5, 20)\n\n        x1 = np.random.randn(size)\n        x2 = np.random.randn(size)\n\n        test_cases.append((x1, x2))\n\n    return test_cases\n"}
{"problem_id": "scipy_44", "library": "scipy", "code_problem": "You are tasked with implementing a function that evaluates the Spearman correlation coefficient between two datasets, while also considering the presence of NaN (Not a Number) values. The function should compute three different correlation results: one that includes NaN values, one that omits NaN values, and one that uses the original datasets without any modifications. \n\nThe function signature is as follows:\n\n```python\ndef alternative_nan_policy(x1, x2, alternative):\n```\n\n### Constants Used:\n- The constant `np.nan` is used to represent a NaN value in the datasets.\n\n### Input Format:\n- The function accepts two lists or arrays of numerical values (`x1` and `x2`) and a string (`alternative`).\n\n### Output Format:\n- The function returns a dictionary with three keys: `\"res_nan\"`, `\"res_actual\"`, and `\"res_expected\"`, each containing the respective Spearman correlation results.\n\nInput:\n```python\nx1 = [0.5, 1.2, 3.3, 4.0, 2.1]\nx2 = [1.0, 2.5, 3.0, 4.5, 2.0]\nalternative = 'two-sided'\n```\n\nOutput:\n```python\n{\n    'res_nan': SignificanceResult(statistic=nan, pvalue=nan),\n    'res_actual': SignificanceResult(statistic=0.9, pvalue=0.03738607346849863),\n    'res_expected': SignificanceResult(statistic=0.8999999999999998, pvalue=0.03738607346849874)\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef alternative_nan_policy(x1, x2, alternative):\n    x1nan = x1 + [np.nan]\n    x2nan = x2 + [np.nan]\n\n    res_nan = stats.spearmanr(x1nan, x2nan)\n    res_actual = stats.spearmanr(x1nan, x2nan, nan_policy='omit', alternative=alternative)\n    res_expected = stats.spearmanr(x1, x2, alternative=alternative)\n\n    return {\n        \"res_nan\": res_nan,\n        \"res_actual\": res_actual,\n        \"res_expected\": res_expected\n    }", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        length = random.randint(2, 50)\n\n        x1 = np.random.randn(length).tolist()\n        x2 = np.random.randn(length).tolist()\n\n        alternative = random.choice(['two-sided', 'greater', 'less'])\n\n        test_cases.append((x1, x2, alternative))\n\n    return test_cases\n"}
{"problem_id": "scipy_45", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the ranking of elements in a dataset while handling missing values. The function should be able to mask certain indices in the dataset, allowing for flexible handling of missing data. The rankings should be computed along a specified axis, and the function should provide options for how to treat missing values during the ranking process.\n\nFunction signature:\n```python\ndef compute_ranking(data, mask_indices, axis, use_missing):\n```\n\nConstant used in the main code:\n- `np.nan`: This constant is used to represent missing values in the output when all elements are masked or when a TypeError occurs.\n\nInput format:\n- `data`: A list or array-like structure containing numerical values.\n- `mask_indices`: A list of indices that should be masked (treated as missing).\n- `axis`: An integer specifying the axis along which to compute the rankings.\n- `use_missing`: A boolean indicating whether to consider missing values in the ranking computation.\n\nOutput format:\n- The function returns a NumPy array containing the ranks of the elements in `data`, with masked values represented as `np.nan`. The shape of the output array matches that of the input `data`.\n\n**Input:**\n```python\ndata = np.array([[10, 20, 30], [40, 50, 60]])\nmask_indices = [(0, 1), (1, 2)]  # Masking elements 20 and 60\naxis = 1\nuse_missing = True\n```\n\n**Output:**\n```python\narray([[1. , 1.5, 2. ],\n       [1. , 2. , 1.5]])\n```", "ground_truth_code": "import numpy as np\nimport numpy.ma as ma\nimport scipy.stats.mstats as mstats\n\n# main code\ndef compute_ranking(data, mask_indices, axis, use_missing):\n    x = ma.array(np.atleast_1d(data))\n\n    if mask_indices:\n        for idx in mask_indices:\n            x[idx] = ma.masked\n\n    if x.size == 0:\n        return np.array([])\n\n    if np.all(x.mask):\n        return np.full_like(x, np.nan, dtype=float)\n    if x.ndim == 1:\n        axis = 0\n\n    try:\n        return mstats.rankdata(x, axis=axis, use_missing=use_missing)\n    except TypeError:\n        return np.full_like(x, np.nan, dtype=float)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Randomly generate shape (1D, 2D, or 3D tensor)\n        num_dims = np.random.choice([1, 2, 3])\n        shape = tuple(np.random.randint(2, 10, size=num_dims))\n\n        # Generate random float data\n        data = np.random.rand(*shape) * 100  # Scale for variability\n\n        # Generate mask indices\n        mask_indices = []\n        num_masks = np.random.randint(0, max(1, np.prod(shape) // 3))  # Fix here\n\n        if num_masks > 0:\n            mask_flat_indices = np.random.choice(np.prod(shape), num_masks, replace=False)\n            mask_indices = [np.unravel_index(idx, shape) for idx in mask_flat_indices]\n\n        # Choose axis (valid for the given shape)\n        axis = np.random.choice(range(num_dims)) if num_dims > 1 else 0\n\n        # Choose use_missing randomly\n        use_missing = np.random.choice([True, False])\n\n        test_cases.append((data, mask_indices, axis, use_missing))\n\n    return test_cases"}
{"problem_id": "scipy_46", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes various kurtosis statistics for given datasets. The function will utilize the `scipy.stats.mstats` module to calculate kurtosis values under different conditions. The function signature is as follows:\n\n```python\ndef test_kurtosis(testcase, testcase_2d, testmathworks):\n```\n\n### Constants Used:\n- The constant `fisher` is set to `False` in some calculations to indicate that the Fisher definition of kurtosis is not being used.\n- The constant `bias` is set to `True` or `False` in different calculations to indicate whether bias correction is applied.\n\n\n### Input Format:\n- `testcase`: A 1D array-like structure (e.g., list or numpy array) representing a single dataset.\n- `testcase_2d`: A 2D array-like structure (e.g., list of lists or a 2D numpy array) representing multiple datasets.\n- `testmathworks`: A 1D array-like structure (e.g., list or numpy array) representing another dataset.\n\n### Output Format:\n- The function returns a dictionary where:\n  - Keys are strings indicating the type of kurtosis computed.\n  - Values are the corresponding kurtosis results, which can be floats or lists of floats depending on the input data structure.\n\n**Input:**\n```python\ntestcase = np.array([-0.5, 0.0, 1.5, 2.0, -1.0])\ntestcase_2d = np.array([[0.5, -1.5, 2.5, 0.0],\n                         [1.0, 0.0, -1.0, 1.5],\n                         [-0.5, 1.5, 0.5, -1.5]])\ntestmathworks = np.array([[1.0, -3.0, 4.0, 2.0],\n                           [0.5, 2.5, -1.5, 3.0],\n                           [-4.0, 1.0, 0.0, -2.0]])\n```\n\n**Output:**\n```python\n{'testmathworks_fisher_0_bias_1': masked_array(data=[1.5, 1.5, 1.5, 1.5], mask=False, fill_value=1e+20), \n 'testmathworks_fisher_0_bias_0': masked_array(data=[1.5, 1.5, 1.5, 1.5], mask=False, fill_value=1e+20), \n 'testcase': masked_array(data=1.39685899, mask=False, fill_value=1e+20), \n 'testcase_2d': masked_array(data=[-1.04457782, -1.42660155, -1.36      ], mask=False, fill_value=1e+20), \n 'testcase_2d_rows': [-1.0445778218052562, -1.4266015512783683, -1.36], \n 'testcase_2d_bias_corrected': masked_array(data=[ 1.16566634, -1.69951163, -1.2       ], mask=False, fill_value=1e+20), \n 'testcase_2d_rows_bias_corrected': [1.1656663364605784, -1.699511634587763, -1.1999999999999993], \n 'single_row_nulp': (-1.36, -1.36)\n}\n\n```\n", "ground_truth_code": "import scipy.stats.mstats as mstats\nfrom scipy import stats\n\n# main code\ndef test_kurtosis(testcase, testcase_2d, testmathworks):\n    results = {}\n\n    results[\"testmathworks_fisher_0_bias_1\"] = mstats.kurtosis(testmathworks, axis=0, fisher=False, bias=True)\n    results[\"testmathworks_fisher_0_bias_0\"] = mstats.kurtosis(testmathworks, fisher=False, bias=False)\n    results[\"testcase\"] = mstats.kurtosis(testcase, axis=0, fisher=False)\n    results[\"testcase_2d\"] = mstats.kurtosis(testcase_2d, axis=1)\n    row_results = [mstats.kurtosis(row) for row in testcase_2d]\n    results[\"testcase_2d_rows\"] = row_results\n    results[\"testcase_2d_bias_corrected\"] = mstats.kurtosis(testcase_2d, axis=1, bias=False)\n    bias_corrected_row_results = [mstats.kurtosis(row, bias=False) for row in testcase_2d]\n    results[\"testcase_2d_rows_bias_corrected\"] = bias_corrected_row_results\n    if testcase_2d.shape[0] > 2:\n        results[\"single_row_nulp\"] = (\n            mstats.kurtosis(testcase_2d[2, :]),\n            stats.kurtosis(testcase_2d[2, :])\n        )\n\n    return results", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate a 1D test case with at least 4 elements (minimum required for kurtosis)\n        testcase = np.random.normal(loc=0, scale=1, size=np.random.randint(4, 20))\n\n        # Generate a 2D test case with shape (m, n), ensuring m >= 3 for single row extraction\n        m, n = np.random.randint(3, 10), np.random.randint(4, 20)\n        testcase_2d = np.random.normal(loc=0, scale=1, size=(m, n))\n\n        # Generate a \"testmathworks\" dataset with a slightly different distribution\n        testmathworks = np.random.uniform(low=-5, high=5, size=(m, n))\n\n        test_cases.append((testcase, testcase_2d, testmathworks))\n\n    return test_cases"}
{"problem_id": "scipy_47", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes statistical tests on a given dataset. The function should accept an input dataset, which can either be a NumPy array or a list, and perform three different statistical tests: normality test, skewness test, and kurtosis test. The results of these tests should be returned in a structured format.\n\nFunction signature:\n```python\ndef process_data(input_data):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the dictionary `test_functions`, which maps the names of the statistical tests to their corresponding functions from the `scipy.stats.mstats` and `scipy.stats` modules.\n\nInput format:\n- The input to the function is a dataset, which can be either a list or a NumPy array containing numerical values.\n\nOutput format:\n- The output of the function is a dictionary where each key is the name of a statistical test (i.e., \"normaltest\", \"skewtest\", \"kurtosistest\") and each value is a tuple containing the results of the masked and non-masked versions of that test.\n\nInput:\n```python\n[[-1.17805869, -0.55557135,  1.32598654, -0.53688386, -0.4986811 ],\n[ 0.27643115, -0.84659155,  1.26442462, -0.66472178,  0.22129462],\n[ 0.35003211,  0.91948133,  0.0906696 , -0.0880142 ,  0.14408351],\n[-1.33754399, -0.26369689, -0.71362621, -0.89794489,  1.18382386],\n[-0.42553866, -0.17595574, -0.65525953,  2.67390578,  1.13250769],\n[ 0.55437979,  1.15871909, -0.62109693, -0.17660291, -1.22958956],\n[ 0.97010849, -0.02313385, -0.41955485, -0.36981687,  0.18475381],\n[ 1.08344007,  1.00980038,  1.70804708,  0.32144101,  1.02434064],\n[ 2.54015864,  0.78303926,  1.27394915,  0.38248577,  0.49979073],\n[-0.84631332,  0.64070953, -0.60614892, -0.10874079, -0.27854848]]\n```\n\nOutput:\n```python\n{'normaltest': (NormaltestResult(statistic=masked_array(data=[0.7402211375365443, 2.6041544641754975,\n                   5.56312429501423, 17.086585803251864,\n                   0.5619346591298453],\n             mask=[False, False, False, False, False],\n       fill_value=1e+20), pvalue=array([6.90657961e-01, 2.71966269e-01, 6.19416697e-02, 1.94847589e-04,\n       7.55053003e-01])), NormaltestResult(statistic=array([ 0.74022114,  2.60415446,  5.5631243 , 17.0865858 ,  0.56193466]), pvalue=array([6.90657961e-01, 2.71966269e-01, 6.19416697e-02, 1.94847589e-04,\n       7.55053003e-01]))), \n 'skewtest': (SkewtestResult(statistic=masked_array(data=[0.7915938740581469, -0.32598258873877867,\n                   0.5842216542131589, 3.0554220603029703,\n                   -0.7435508284978504],\n             mask=[False, False, False, False, False],\n       fill_value=1e+20), pvalue=array([0.42859752, 0.74443753, 0.55907119, 0.00224744, 0.45714826])), SkewtestResult(statistic=array([ 0.79159387, -0.32598259,  0.58422165,  3.05542206, -0.74355083]), pvalue=array([0.42859752, 0.74443753, 0.55907119, 0.00224744, 0.45714826]))), \n 'kurtosistest': (KurtosistestResult(statistic=masked_array(data=[0.3370464005002264, -1.580471390444845,\n                   -2.285127863766636, 2.784058518901105,\n                   0.0952198748686723],\n             mask=[False, False, False, False, False],\n       fill_value=1e+20), pvalue=array([0.73608192, 0.11399895, 0.02230533, 0.00536833, 0.92414018])), KurtosistestResult(statistic=array([ 0.3370464 , -1.58047139, -2.28512786,  2.78405852,  0.09521987]), pvalue=array([0.73608192, 0.11399895, 0.02230533, 0.00536833, 0.92414018])))\n}\n\n```\n", "ground_truth_code": "import numpy as np\nimport scipy.stats.mstats as mstats\nfrom scipy import stats\n\n# main code\ndef process_data(input_data):\n    if not isinstance(input_data, np.ndarray):\n        input_data = np.array(input_data)\n\n    test_functions = {\n        \"normaltest\": (mstats.normaltest, stats.normaltest),\n        \"skewtest\": (mstats.skewtest, stats.skewtest),\n        \"kurtosistest\": (mstats.kurtosistest, stats.kurtosistest)\n    }\n\n    results = {\n        name: (masked_func(input_data), nonmasked_func(input_data))\n        for name, (masked_func, nonmasked_func) in test_functions.items()\n    }\n\n    return results", "test_script": "import numpy as np\nfrom scipy import stats\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Randomly determine the shape of the input tensor\n        shape = np.random.randint(10, 100, size=np.random.randint(1, 3))  # 1D or 2D tensors\n\n        # Randomly generate the data using different distributions\n        distribution_type = np.random.choice([\"normal\", \"uniform\", \"exponential\", \"skewed\"])\n\n        if distribution_type == \"normal\":\n            data = np.random.normal(loc=0, scale=1, size=shape)\n        elif distribution_type == \"uniform\":\n            data = np.random.uniform(low=-1, high=1, size=shape)\n        elif distribution_type == \"exponential\":\n            data = np.random.exponential(scale=1.0, size=shape)\n        elif distribution_type == \"skewed\":\n            data = stats.skewnorm.rvs(a=10, size=shape)  # Skewed normal distribution\n\n        # Convert to list to ensure compatibility with different input types\n        test_cases.append(data.tolist())\n\n    return test_cases"}
{"problem_id": "scipy_48", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs statistical tests on a masked array of squared values derived from a given list of numbers. The function should handle input values, apply a mask, and return the results of normality, skewness, and kurtosis tests if sufficient valid data is available.\n\nFunction signature:\n```python\ndef test_maskedarray_input(values, repeat_count=4, inf_val=np.inf, mask_val=True):\n```\n\n### Constants:\n- `inf_val`: This constant is set to `np.inf`, which represents infinity and is used to create a masked array.\n- `repeat_count`: This parameter defaults to `4` and determines how many times the input values will be repeated in the array.\n- `mask_val`: This parameter defaults to `True` and indicates whether the first value in the masked array should be masked.\n\n### Input Format:\n- `values`: A list of numerical values (e.g., integers or floats).\n- `repeat_count`: An optional integer indicating how many times to repeat the input values (default is 4).\n- `inf_val`: An optional numerical value representing infinity (default is `np.inf`).\n- `mask_val`: An optional boolean indicating whether to mask the first value (default is `True`).\n\n### Output Format:\n- The function returns a tuple containing:\n  - The result of the normality test (or an error message).\n  - The result of the skewness test (or `None`).\n  - The result of the kurtosis test (or `None`).\n\nInput:\n```python\nvalues = [1, -2, 3, 4, 5]\nrepeat_count = 3\ninf_val = np.inf\nmask_val = True\n```\n\nOutput:\n```python\n(\n    NormaltestResult(statistic=2.405706609515285, pvalue=0.3003360379325525), \n    SkewtestResult(statistic=0.9386187264342908, pvalue=0.3479265346558813), \n    KurtosistestResult(statistic=-1.2347880368314859, pvalue=0.2169094008517779)\n)\n\n``` \n", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_maskedarray_input(values, repeat_count=4, inf_val=np.inf, mask_val=True):\n    x = np.array(values * repeat_count) ** 2\n    xm = np.ma.array(np.r_[inf_val, x, x.max() + 1], mask=np.r_[mask_val, [False] * x.size, mask_val])\n    valid_data = xm.compressed()\n    if len(valid_data) < 8:\n        return \"Insufficient data after masking\", None, None\n    try:\n        normal_test_result = stats.normaltest(valid_data)\n        skew_test_result = stats.skewtest(valid_data)\n        kurtosis_test_result = stats.kurtosistest(valid_data)\n    except Exception as e:\n        return f\"Statistical test failed: {e}\", None, None\n\n    return normal_test_result, skew_test_result, kurtosis_test_result", "test_script": "import numpy as np\n\n\n# Test case generator\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        values = np.random.randint(-100, 100, size=np.random.randint(5, 20)).tolist()\n        repeat_count = np.random.randint(2, 10)\n        inf_val = np.random.choice([np.inf, -np.inf, 0, np.random.uniform(-1000, 1000)])\n        mask_val = np.random.choice([True, False])\n        test_cases.append((values, repeat_count, inf_val, mask_val))\n    return test_cases\n"}
{"problem_id": "scipy_49", "library": "scipy", "code_problem": "You are tasked with implementing a function that estimates parameters based on a given log-likelihood function using optimization techniques. The function will also compute confidence intervals for the estimated parameters based on the likelihood ratio test.\n\nFunction signature:\n```python\ndef kon_ll(ll_kon, vals, start_estim, alph=0.05, N=100, scale_factor=5):\n```\n\n### Constants:\n- `cutoff`: This constant is derived from the chi-squared distribution and is calculated as `chi2.ppf(1 - alph, 1) / 2`, where `alph` is the significance level (default is 0.05).\n\n### Input and Output Format:\n- **Input**:\n  - `ll_kon`: A callable function representing the log-likelihood to be minimized.\n  - `vals`: An array of values used in the log-likelihood function.\n  - `start_estim`: A list or array containing initial estimates for the parameters.\n  - `alph`: A float representing the significance level (default is 0.05).\n  - `N`: An integer representing the number of iterations for searching confidence intervals (default is 100).\n  - `scale_factor`: A float used to scale the parameter adjustments (default is 5).\n\n- **Output**:\n  - A tuple containing:\n    - An array with the estimated parameter and interpolated values at the cutoff.\n    - An array of indexed parameter values.\n    - An array of likelihood ratios.\n\n**Input:**\n```python\n(\n    lambda x, kon, vals: np.sum((vals - kon) ** 2) + np.sum((x - 1) ** 2), \n    np.array([2.5, 3.0, 4.5, 1.0, 5.5]), \n    np.array([5.0, 50.0, 1e5]), \n    0.05, \n    100, \n    5.0\n)\n```\n\n**Output:**\n```python\n(\n    array([3.25,  nan,  nan]), \n    array([2.75, 3.  , 3.25, 3.5 , 3.75, 4.  , 4.25, 4.5 , 4.75, 5.  , 5.25]), \n    array([ 3.   ,  0.875,  0.   ,  0.375,  2.   ,  4.875,  9.   , 14.375, 21.   , 28.875, 38.   ])\n)\n```", "ground_truth_code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.stats import chi2\nfrom scipy.interpolate import interp1d\n\n\ndef get_h(param):\n    return 10 ** (np.log10(param) - 2)\n\n# main code\ndef kon_ll(ll_kon, vals, start_estim, alph=0.05, N=100, scale_factor=5):\n    cutoff = chi2.ppf(1 - alph, 1) / 2\n    x0 = [start_estim[1], start_estim[2]]\n    bnds = ((0.001, 1000.0), (1, 1e10))\n    start = start_estim[0]\n    h = scale_factor * get_h(start)\n\n    res = minimize(ll_kon, x0, args=(start, vals), method='L-BFGS-B', bounds=bnds)\n    ll_p = res.fun\n    ll_l = np.zeros(N)\n    kon_l = []\n\n    for i in range(N):\n        kon = start - h * i\n        if kon <= 0:\n            break\n        kon_l.append(kon)\n        res = minimize(ll_kon, res.x, args=(kon, vals), method='L-BFGS-B', bounds=bnds)\n        ll_l[i] = res.fun\n        if 2 * (ll_l[i] - min(ll_l[ll_l > 0])) > cutoff + 0.5 and ll_l[i] > ll_l[i - 1]:\n            break\n\n    ll_l = ll_l[:i + 1][::-1]\n    kon_l = np.array(kon_l[::-1])\n\n    res = minimize(ll_kon, x0, args=(start, vals), method='L-BFGS-B', bounds=bnds)\n    ll_u = np.zeros(N)\n    kon_u = []\n\n    for j in range(N):\n        kon = start + h * j\n        kon_u.append(kon)\n        res = minimize(ll_kon, res.x, args=(kon, vals), method='L-BFGS-B', bounds=bnds)\n        ll_u[j] = res.fun\n        if 2 * (ll_u[j] - min(ll_u[ll_u > 0])) > cutoff + 0.5 and ll_u[j] > ll_u[j - 1]:\n            break\n\n    ll_u = ll_u[:j + 1]\n    kon_u = np.array(kon_u)\n\n    ll = np.concatenate((ll_l[:-1], np.array([ll_p]), ll_u[1:]))\n    kon_indexed = np.concatenate((kon_l[:-1], np.array([start]), kon_u[1:])).squeeze()\n    ll_ratio = 2 * (ll - min(ll)).squeeze()\n\n    minimum_idx = np.argmin(ll_ratio)\n    ll_right_side = ll_ratio[minimum_idx:]\n    ll_left_side = ll_ratio[:minimum_idx]\n    minimum = kon_indexed[minimum_idx]\n    kon_right_side = kon_indexed[minimum_idx:]\n    kon_left_side = kon_indexed[:minimum_idx]\n\n    try:\n        f_1 = interp1d(ll_left_side, kon_left_side, kind='cubic')\n        f_2 = interp1d(ll_right_side, kon_right_side, kind='cubic')\n        res = np.array([minimum, f_1(cutoff), f_2(cutoff)])\n    except:\n        res = np.array([minimum, np.nan, np.nan])\n\n    return res, kon_indexed, ll_ratio", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    def sample_ll_kon(x, kon, vals):\n        return np.sum((vals - kon) ** 2) + np.sum((x - 1) ** 2)\n\n    for _ in range(n):\n        vals = np.random.uniform(0.1, 10, size=(np.random.randint(5, 20),))\n        start_estim = np.array([\n            np.random.uniform(0.1, 10),\n            np.random.uniform(0.001, 1000),\n            np.random.uniform(1, 1e10)\n        ])\n        alph = np.random.uniform(0.01, 0.1)\n        N = np.random.randint(50, 200)\n        scale_factor = np.random.uniform(1, 10)\n        test_case = (sample_ll_kon, vals, start_estim, alph, N, scale_factor)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "scipy_50", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the trimmed mean of a dataset and also evaluates the trimmed mean along specified axes. The function will take in a multi-dimensional array and a dictionary of datasets, and it will return a comprehensive summary of the trimmed means calculated in various ways.\n\nFunction signature:\n```python\ndef compute_trim_mean(a, data, proportion, axis_values):\n```\n\nConstants used in the main code:\n- The `proportion` parameter, which specifies the fraction of data to trim from both ends of the dataset when calculating the trimmed mean.\n\n\nInput format:\n- `a`: A multi-dimensional numpy array.\n- `data`: A dictionary where each key is a string and each value is a list or array of numerical data.\n- `proportion`: A float representing the proportion of data to trim from both ends.\n- `axis_values`: A list of integers representing the axes along which to compute the trimmed mean.\n\nOutput format:\n- A dictionary containing:\n  - Trimmed means for each dataset in `data` under keys formatted as `\"trim_mean_{key}\"`.\n  - Trimmed means calculated along specified axes under the key `\"axis_trim_means\"`, which itself is a dictionary.\n  - The overall trimmed mean of `a` under the key `\"trim_mean_none\"`.\n  - The trimmed mean of the flattened array `a` under the key `\"trim_mean_ravel\"`.\n\n**Input:**\n```python\na = np.array([[1.2, 2.3, 3.1], [4.5, 5.6, 6.7]])\ndata = {\n    \"data_0\": np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]),\n    \"data_1\": np.array([[1.0, 1.1, 1.2], [1.3, 1.4, 1.5]])\n}\nproportion = 0.2\naxis_values = [0, 1]\n```\n\n**Output:**\n```python\n{\n    'trim_mean_data_0': array([0.25, 0.35, 0.45]), \n    'trim_mean_data_1': array([1.15, 1.25, 1.35]), \n    'axis_trim_means': {'axis_0': (array([2.85, 3.95, 4.9 ]), array([2.85, 3.95, 4.9 ])), 'axis_1': (array([2.2, 5.6]), array([2.2, 5.6]))}, \n    'trim_mean_none': 3.875, \n    'trim_mean_ravel': 3.875\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef compute_trim_mean(a, data, proportion, axis_values):\n    results = {}\n\n    for key, value in data.items():\n        results[f\"trim_mean_{key}\"] = stats.trim_mean(value, proportion)\n\n    axis_results = {}\n\n    for axis in axis_values:\n        res1 = stats.trim_mean(a, proportion, axis=axis)\n        res2 = stats.trim_mean(np.moveaxis(a, axis, 0), proportion)\n        axis_results[f\"axis_{axis}\"] = (res1, res2)\n\n    results[\"axis_trim_means\"] = axis_results\n    results[\"trim_mean_none\"] = stats.trim_mean(a, proportion, axis=None)\n    results[\"trim_mean_ravel\"] = stats.trim_mean(a.ravel(), proportion)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_dims = np.random.randint(1, 5)\n        shape = tuple(np.random.randint(2, 10) for _ in range(num_dims))\n        a = np.random.randn(*shape)\n        data = {f\"data_{i}\": np.random.randn(*shape) for i in range(np.random.randint(1, 4))}\n        proportion = np.random.uniform(0, 0.5)\n        axis_values = list(range(num_dims))\n\n        test_cases.append((a, data, proportion, axis_values))\n\n    return test_cases\n"}
{"problem_id": "scipy_51", "library": "scipy", "code_problem": "You are tasked with implementing a function that converts a given sparse matrix into a skew-symmetric matrix. A skew-symmetric matrix is a square matrix \\( A \\) such that \\( A^T = -A \\), meaning that the transpose of the matrix is equal to its negative. The function should handle both dense and sparse matrix inputs.\n\nFunction signature:\n```python\ndef make_skew_symmetric(m):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the `coo_matrix` from the `scipy.sparse` library, which is used to create a sparse matrix in Coordinate format.\n\nInput format:\n- The input to the function is a matrix `m`, which can be either a dense matrix (e.g., a 2D NumPy array) or a sparse matrix in COO format.\n\nOutput format:\n- The output of the function is a COO sparse matrix that represents the skew-symmetric version of the input matrix `m`.\n\nInput:\n```python\nfrom scipy.sparse import coo_matrix\n\n# Creating a sparse matrix\nrows = [0, 1, 2, 3]\ncols = [1, 2, 0, 3]\nvalues = [1.0, 2.0, 3.0, 4.0]\nsparse_matrix = coo_matrix((values, (rows, cols)), shape=(4, 4))\n```\n\nOutput:\n```python\n<4x4 sparse matrix of type '<class 'numpy.float64'>'\n\twith 4 stored elements in COOrdinate format>\n  (0, 1)\t1.0\n  (1, 2)\t2.0\n  (1, 0)\t-1.0\n  (2, 1)\t-2.0\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy.sparse import coo_matrix\n\n# main code\ndef make_skew_symmetric(m):\n\n    m = coo_matrix(m) if not isinstance(m, coo_matrix) else m\n    r, c, v = m.row, m.col, m.data\n\n    mask_upper = c > r\n    ru, cu, vu = r[mask_upper], c[mask_upper], v[mask_upper]\n\n    rl, cl, vl = cu, ru, -vu\n\n    r_new = np.concatenate((ru, rl))\n    c_new = np.concatenate((cu, cl))\n    v_new = np.concatenate((vu, vl))\n\n    return coo_matrix((v_new, (r_new, c_new)), shape=m.shape)\n", "test_script": "import numpy as np\nfrom scipy.sparse import coo_matrix\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(2, 101)  # Random size between 2 and 100\n        num_elements = max(1, int(size * size * 0.05))  # Ensure at least one element\n        rows = np.random.randint(0, size, size=num_elements)\n        cols = np.random.randint(0, size, size=num_elements)\n        values = np.random.randn(num_elements)\n\n        sparse_matrix = coo_matrix((values, (rows, cols)), shape=(size, size))\n        test_cases.append(sparse_matrix)\n\n    return test_cases"}
{"problem_id": "scipy_52", "library": "scipy", "code_problem": "You are tasked with implementing a function that evaluates the effect of NaN values on the calculation of Kendall's tau correlation coefficient between two datasets. The function will compare the results of the correlation coefficient when NaN values are included versus when they are omitted.\n\nFunction signature:\n```python\ndef test_nan_policy(x1: list, x2: list, method: str, alternative: str) -> tuple:\n```\n\nIn this function, the following constant is used:\n- `nan_policy='omit'`: This constant is used to specify that NaN values should be ignored in the calculation of the correlation coefficient.\n\nInput format:\n- The function accepts two lists of numerical values (`x1` and `x2`), a string for the method (`method`), and a string for the alternative hypothesis (`alternative`).\n\nOutput format:\n- The function returns a tuple containing three results: the correlation coefficient with NaN included, the correlation coefficient with NaN omitted, and the correlation coefficient for the original datasets without NaN values. Each result is a statistical object returned by the `kendalltau` function from the `scipy.stats` module.\n\nInput:\n```python\nx1 = [0.5, 1.2, 3.3, 4.1]\nx2 = [1.0, 2.5, 3.0, 4.0]\nmethod = 'auto'\nalternative = 'two-sided'\n```\n\nOutput:\n```python\n(\n    SignificanceResult(statistic=nan, pvalue=nan), \n    SignificanceResult(statistic=1.0, pvalue=0.08333333333333333), \n    SignificanceResult(statistic=1.0, pvalue=0.08333333333333333)\n)\n\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\n\n# main code\ndef test_nan_policy(x1, x2, method, alternative):\n\n    x1nan = x1 + [np.nan]\n    x2nan = x2 + [np.nan]\n\n    res_actual_1 = stats.kendalltau(x1nan, x2nan, method=method, alternative=alternative)\n    res_actual_2 = stats.kendalltau(x1nan, x2nan, nan_policy='omit', method=method, alternative=alternative)\n    res_expected = stats.kendalltau(x1, x2, method=method, alternative=alternative)\n\n    return res_actual_1, res_actual_2, res_expected\n", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    methods = ['auto', 'asymptotic', 'exact']\n    alternatives = ['two-sided', 'less', 'greater']\n\n    for _ in range(n):\n        # Generate random length for the test input (at least 3 elements)\n        size = random.randint(3, 20)\n\n        # Generate two random lists of numbers\n        x1 = np.random.randn(size).tolist()  # Normally distributed random numbers\n        x2 = np.random.randn(size).tolist()\n\n        # Randomly select method and alternative values\n        method = random.choice(methods)\n        alternative = random.choice(alternatives)\n\n        # Append as a tuple to match function input signature\n        test_cases.append((x1, x2, method, alternative))\n\n    return test_cases"}
{"problem_id": "scipy_53", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the trimmed mean of two datasets, `x` and `y`, while also handling potential outliers by preprocessing the data. The preprocessing involves masking values that exceed a specified threshold. If no threshold is provided, the function will automatically determine a threshold based on the maximum absolute values in the datasets.\n\nThe function signature of the main code is:\n```python\ndef test_tmean(x, y):\n```\n\nIn the main code, the constant used is determined dynamically based on the input data. If `mask_threshold` is not provided, it is calculated as:\n```python\nmask_threshold = np.max([np.max(np.abs(x)), np.max(np.abs(y))]) * 10\n```\n\nThe input format for the function is two arrays (or lists) of numerical values, `x` and `y`. The output format is a dictionary containing the trimmed means for both datasets, with keys `\"tmean_x\"`, `\"tmean_xm\"`, `\"tmean_y\"`, and `\"tmean_ym\"`. Each key maps to the corresponding trimmed mean value.\n\nInput:\n```python\nx = np.array([10, 20, np.nan, 30, 40])\ny = np.array([5, 15, 25, np.nan, 35])\n```\n\nOutput:\n```python\n{\n    'tmean_x': 25.0, \n    'tmean_xm': nan, \n    'tmean_y': 20.0, \n    'tmean_ym': nan\n}\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n\ndef preprocess_data(x, y, mask_threshold=None):\n    if mask_threshold is None:\n        mask_threshold = np.max([np.max(np.abs(x)), np.max(np.abs(y))]) * 10\n\n    padding_x = len(x) // 10\n    padding_y = len(y) // 10\n\n    xm = np.full(len(x) + padding_x, mask_threshold)\n    ym = np.full(len(y) + padding_y, mask_threshold)\n\n    xm[:len(x)] = x\n    ym[:len(y)] = y\n\n    mask_xm = xm > mask_threshold\n    mask_ym = ym > mask_threshold\n\n    xm = np.ma.array(xm, mask=mask_xm)\n    ym = np.ma.array(ym, mask=mask_ym)\n\n    return xm, ym\n\n\n# main code\ndef test_tmean(x, y):\n    xm, ym = preprocess_data(x, y)\n\n    results = {\n        \"tmean_x\": stats.tmean(x, nan_policy='omit'),\n        \"tmean_xm\": stats.mstats.tmean(xm),\n        \"tmean_y\": stats.tmean(y, nan_policy='omit'),\n        \"tmean_ym\": stats.mstats.tmean(ym),\n    }\n\n    return results\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate random lengths for x and y (varying sizes)\n        len_x = np.random.randint(5, 50)\n        len_y = np.random.randint(5, 50)\n\n        # Generate random arrays for x and y\n        x = np.random.uniform(-100, 100, size=len_x)\n        y = np.random.uniform(-100, 100, size=len_y)\n\n        # Occasionally introduce NaNs or masked values\n        if np.random.rand() < 0.2:\n            x[np.random.randint(0, len_x, size=np.random.randint(1, len_x // 2))] = np.nan\n        if np.random.rand() < 0.2:\n            y[np.random.randint(0, len_y, size=np.random.randint(1, len_y // 2))] = np.nan\n\n        test_cases.append((x, y))\n\n    return test_cases"}
{"problem_id": "scipy_54", "library": "scipy", "code_problem": "The task is to implement a function that prepares a system of linear equations represented in matrix form. The function will ensure that the input matrix and vectors are in the correct format and type for further computations. The function signature is as follows:\n\n```python\ndef make_system(A, x, b, formats=None):\n```\n\n### Constants:\n- The constant used in the main code is `dtype`, which is set to `np.float64` if the data types of the matrix `A`, vector `x`, and vector `b` do not match.\n\n### Input and Output Format:\n- **Input**:\n  - `A`: A matrix (can be dense or sparse).\n  - `x`: A vector (can be a list or NumPy array).\n  - `b`: A vector (can be a list or NumPy array).\n  - `formats`: An optional list of strings specifying desired sparse matrix formats.\n\n- **Output**:\n  - Returns a tuple containing:\n    - The processed matrix `A` in the specified format.\n    - The processed vector `x` as a one-dimensional NumPy array.\n    - The processed vector `b` as a one-dimensional NumPy array.\n\n**Input:**\n```python\nA = sparse.coo_matrix([[1, 0, 0], [0, 2, 0], [0, 0, 3]])\nx = np.array([[1], [2], [3]])\nb = np.array([[1], [1], [1]])\nformats = ['csr']\n```\n\n**Output:**\n```python\n(<3x3 sparse matrix of type '<class 'numpy.int64'>'\n\twith 3 stored elements in Compressed Sparse Row format>, array([1, 2, 3]), array([1, 1, 1]))\n```", "ground_truth_code": "import numpy as np\nfrom scipy import sparse\n\n# main code\ndef make_system(A, x, b, formats=None):\n\n    if formats:\n        if formats == ['csr']:\n            if not sparse.isspmatrix_csr(A):\n                A = A.tocsr() if sparse.isspmatrix_bsr(A) else sparse.csr_matrix(A)\n        elif not (sparse.isspmatrix(A) and A.format in formats):\n            A = sparse.csr_matrix(A).asformat(formats[0])\n    x = np.asarray(x) if not isinstance(x, np.ndarray) else x\n    b = np.asarray(b) if not isinstance(b, np.ndarray) else b\n    M, N = A.shape\n    if M != N:\n        A = sparse.eye(M, format='csr')\n    x = np.ravel(x) if x.shape in [(M,), (M, 1)] else np.zeros(M)\n    b = np.ravel(b) if b.shape in [(M,), (M, 1)] else np.ones(M)\n    dtype = np.float64 if not (A.dtype == x.dtype == b.dtype) else A.dtype\n    A = A.astype(dtype)\n    x = x.astype(dtype)\n    b = b.astype(dtype)\n\n    return A, x, b", "test_script": "import numpy as np\nfrom scipy import sparse\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    formats_list = [None, ['csr'], ['csc'], ['bsr'], ['dia'], ['coo'], ['lil'], ['dok']]\n\n    for _ in range(n):\n        M = random.randint(1, 100)\n        density = random.uniform(0.01, 0.5)\n\n        A = sparse.random(M, M, density=density, format='coo', dtype=random.choice([np.float32, np.float64]))\n        if random.choice([True, False]):\n            A = A.asformat(random.choice(['csr', 'csc', 'bsr', 'dia', 'lil', 'dok', 'coo']))\n        x_shape = random.choice([(M,), (M, 1)])\n        b_shape = random.choice([(M,), (M, 1)])\n        x = np.random.randn(*x_shape).astype(A.dtype)\n        b = np.random.randn(*b_shape).astype(A.dtype)\n\n        formats = random.choice(formats_list)\n\n        test_cases.append((A, x, b, formats))\n\n    return test_cases\n"}
{"problem_id": "scipy_55", "library": "scipy", "code_problem": "You are tasked with implementing a statistical analysis function that evaluates trends in a dataset using permutation tests. The function will utilize the `scipy.stats` library to perform various trend tests on the provided data.\n\nFunction signature:\n```python\ndef test_options(data, predicted_ranks=None, perm=None):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used to create a range of predicted ranks starting from 1.\n\n### Input and Output Format:\n- **Input**: \n  - `data`: A 2D NumPy array of shape (m, n).\n  - `predicted_ranks`: (Optional) A 1D NumPy array of shape (n,).\n  - `perm`: (Optional) A 1D NumPy array of shape (n,).\n\n- **Output**: \n  - A dictionary containing the results of the five trend tests, where each key corresponds to a result (e.g., \"res1\", \"res2\", etc.) and each value is the output of the respective trend test.\n\nInput:\n```python\ndata = np.array([[10, 20, 30],\n                 [5, 15, 25]])\npredicted_ranks = np.array([2, 1, 3])\nperm = np.array([2, 0, 1])\n```\n\nOutput:\n```python\n{\n    'res1': PageTrendTestResult(statistic=28.0, pvalue=0.027777777777777776, method='exact'),\n    'res2': PageTrendTestResult(statistic=28.0, pvalue=0.027777777777777776, method='exact'),\n    'res3': PageTrendTestResult(statistic=28.0, pvalue=0.027777777777777776, method='exact'),\n    'res4': PageTrendTestResult(statistic=26.0, pvalue=0.25, method='exact'),\n    'res5': PageTrendTestResult(statistic=26.0, pvalue=0.25, method='exact')\n}\n\n```\n", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef test_options(data, predicted_ranks=None, perm=None):\n\n    m, n = data.shape\n    if predicted_ranks is None:\n        predicted_ranks = np.arange(1, n + 1)\n    if perm is None:\n        perm = np.arange(n)\n    ranks = stats.rankdata(data, axis=1)\n    results = {\n        \"res1\": stats.page_trend_test(ranks),\n        \"res2\": stats.page_trend_test(ranks, ranked=True),\n        \"res3\": stats.page_trend_test(data, ranked=False),\n        \"res4\": stats.page_trend_test(ranks, predicted_ranks=predicted_ranks),\n        \"res5\": stats.page_trend_test(ranks[:, perm], predicted_ranks=predicted_ranks[perm])\n    }\n    return results", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(2, 20)\n        n = np.random.randint(3, 15)\n        data = np.random.randint(0, 100, size=(m, n))\n        predicted_ranks = np.random.permutation(np.arange(1, n + 1)) if np.random.rand() > 0.5 else None\n        perm = np.random.permutation(n) if np.random.rand() > 0.5 else None\n\n        test_cases.append((data, predicted_ranks, perm))\n\n    return test_cases"}
{"problem_id": "scipy_56", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the weighted average Spearman correlation between two datasets across specified chromosomes. The function will consider the correlation in different segments of the chromosomes based on the provided parameters.\n\nFunction Signature:\n```python\ndef per_arm_correlation(data1, data2, do_by_arms, chromosome_starts, chromosome_count, centromere_positions, chromosome_ends):\n```\n\n### Constants Used:\n- The constant used in the main code is `total_correlation`, which accumulates the weighted correlation values, and `total_length`, which accumulates the lengths of the segments considered for correlation.\n\n### Input Format:\n- `data1`: A list or array of numerical values representing the first dataset.\n- `data2`: A list or array of numerical values representing the second dataset.\n- `do_by_arms`: A list of indices indicating which chromosomes should be processed by their arms.\n- `chromosome_starts`: A list of starting positions for each chromosome.\n- `chromosome_count`: An integer representing the total number of chromosomes.\n- `centromere_positions`: A list of positions indicating the centromere for each chromosome.\n- `chromosome_ends`: A list of ending positions for each chromosome.\n\n### Output Format:\n- The function returns a float representing the weighted average Spearman correlation, or `None` if no valid segments were processed.\n\n**Input:**\n```python\ndata1 = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6])\ndata2 = np.array([0.6, 0.5, 0.4, 0.3, 0.2, 0.1])\ndo_by_arms = {0}\nchromosome_starts = [0]\nchromosome_count = 1\ncentromere_positions = [3]\nchromosome_ends = [6]\n```\n\n**Output:**\n```python\n1.0\n```\n", "ground_truth_code": "from scipy.stats import spearmanr\n\n# main code\ndef per_arm_correlation(data1, data2, do_by_arms, chromosome_starts, chromosome_count, centromere_positions, chromosome_ends):\n    total_correlation = 0\n    total_length = 0\n\n    for i in range(chromosome_count):\n        start = chromosome_starts[i]\n        end = chromosome_ends[i]\n\n        if i in do_by_arms:\n            arm1_end = centromere_positions[i]\n            if arm1_end > start:\n                correlation = spearmanr(data1[start:arm1_end], data2[start:arm1_end])[0]\n                total_correlation += abs(correlation) * (arm1_end - start)\n                total_length += arm1_end - start\n\n            arm2_start = centromere_positions[i]\n            if end > arm2_start:\n                correlation = spearmanr(data1[arm2_start:end], data2[arm2_start:end])[0]\n                total_correlation += abs(correlation) * (end - arm2_start)\n                total_length += end - arm2_start\n        else:\n            if end > start:\n                correlation = spearmanr(data1[start:end], data2[start:end])[0]\n                total_correlation += abs(correlation) * (end - start)\n                total_length += end - start\n\n    return total_correlation / total_length if total_length > 0 else None\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        chromosome_count = np.random.randint(1, 25)  # Random number of chromosomes (1 to 24)\n        total_length = np.random.randint(100, 10000)  # Total length of data arrays\n\n        data1 = np.random.rand(total_length)  # Generate random data1\n        data2 = np.random.rand(total_length)  # Generate random data2\n\n        chromosome_starts = sorted(np.random.choice(range(0, total_length - 1), size=chromosome_count, replace=False))\n        chromosome_starts[0] = 0  # Ensure the first chromosome starts at 0\n        chromosome_ends = chromosome_starts[1:] + [total_length]  # Ensure ends are properly set\n\n        centromere_positions = [\n            np.random.randint(chromosome_starts[i] + 1, chromosome_ends[i]) if chromosome_ends[i] - chromosome_starts[\n                i] > 1 else chromosome_starts[i]\n            for i in range(chromosome_count)\n        ]\n\n        do_by_arms = set(\n            np.random.choice(range(chromosome_count), size=np.random.randint(0, chromosome_count + 1), replace=False))\n\n        test_cases.append((\n            data1, data2, do_by_arms, chromosome_starts, chromosome_count, centromere_positions, chromosome_ends\n        ))\n\n    return test_cases"}
{"problem_id": "scipy_57", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes a given array of numerical data to compute the Spearman correlation coefficient of the data after removing outliers. The function should handle missing values and ensure that there are enough valid data points to perform the correlation calculation.\n\nFunction signature:\n```python\ndef test_ndim_too_high(x):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1.5`, which is utilized in the calculation of the lower and upper bounds for outlier detection based on the interquartile range (IQR).\n\nInput format:\n- The input `x` is expected to be a list or array-like structure containing numerical values, which may include NaN values.\n\nOutput format:\n- The output is a `SpearmanrResult` object containing the Spearman correlation coefficient and the p-value associated with the correlation.\n\nInput:  \n```python\narray([-1.234, 0.456, 2.345, np.nan, 1.234, -0.567, np.nan, 0.123])\n```\n\nOutput:  \n```python\nSignificanceResult(statistic=1.0, pvalue=0.0)\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\nfrom sklearn.preprocessing import StandardScaler\n\n# main code\ndef test_ndim_too_high(x):\n\n    x = np.asarray(x, dtype=np.float64)\n    x = x[~np.isnan(x)]\n    if x.size < 2:\n        raise ValueError(\"Input data must have at least two valid values.\")\n    scaler = StandardScaler()\n    x = scaler.fit_transform(x.reshape(-1, 1)).flatten()\n    q1, q3 = np.percentile(x, [25, 75])\n    iqr = q3 - q1\n    lower_bound = q1 - 1.5 * iqr\n    upper_bound = q3 + 1.5 * iqr\n    x = x[(x >= lower_bound) & (x <= upper_bound)]\n\n    return stats.spearmanr(x, x, axis=None)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(3, 500)\n        dist_type = np.random.choice(['normal', 'uniform', 'exponential', 'integer', 'nan_mixed'])\n\n        if dist_type == 'normal':\n            x = np.random.normal(loc=0, scale=1, size=size)\n        elif dist_type == 'uniform':\n            x = np.random.uniform(low=-10, high=10, size=size)\n        elif dist_type == 'exponential':\n            x = np.random.exponential(scale=2, size=size)\n        elif dist_type == 'integer':\n            x = np.random.randint(-100, 100, size=size).astype(float)\n        elif dist_type == 'nan_mixed':\n            x = np.random.normal(loc=0, scale=1, size=size)\n            nan_count = np.random.randint(1, min(10, size - 2))\n            nan_indices = np.random.choice(size, nan_count, replace=False)\n            x[nan_indices] = np.nan\n        while np.sum(~np.isnan(x)) < 2:\n            x = np.random.normal(loc=0, scale=1, size=size)\n\n        test_cases.append(x)\n\n    return test_cases"}
{"problem_id": "scipy_58", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes a dataset to compute the minimum value of the data using various configurations. The function should handle different scenarios, including the presence of a lower limit, whether the lower limit is inclusive or exclusive, and the ability to work with multi-dimensional arrays. Additionally, the function should account for NaN values in the dataset.\n\nFunction Signature:\n```python\ndef process_tmin(data, lowerlimit, inclusive, axis):\n```\n\nConstants Used:\n- The constant `10` is used to generate a default dataset of random numbers if the input `data` is `None`.\n\nInput Format:\n- `data`: A NumPy array or `None`.\n- `lowerlimit`: A numeric value representing the lower limit.\n- `inclusive`: A boolean value (True or False).\n- `axis`: An integer representing the axis along which to compute the minimum (if applicable).\n\nOutput Format:\n- A dictionary containing the results of the minimum calculations, with keys indicating the scenario and values being the computed minimum or `np.nan` if an error occurred.\n\n**Input:**\n```python\ndata = np.array([[0.1, 0.5, np.nan], [0.3, 0.2, 0.4]])\nlowerlimit = 0.2\ninclusive = True\naxis = 0\n```\n\n**Output:**\n```python\n{\n    'default': array([0.1, 0.2, nan]), \n    'with_lowerlimit': array([0.3, 0.2, nan]), \n    'with_lowerlimit_exclusive': array([0.3, 0.2, nan]), \n    'axis_based': array([0.1, 0.2, nan]), \n    'flattened': nan, \n    'nan_omit': array([0.1, 0.2, 0.4])\n}\n``` \n", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n\n# main code\ndef process_tmin(data, lowerlimit, inclusive, axis):\n    if data is None:\n        rng = np.random.default_rng()\n        data = rng.random(10)\n\n    result = {}\n\n    try:\n        result[\"default\"] = stats.tmin(data)\n    except ValueError:\n        result[\"default\"] = np.nan\n\n    try:\n        result[\"with_lowerlimit\"] = stats.tmin(data, lowerlimit=lowerlimit)\n    except ValueError:\n        result[\"with_lowerlimit\"] = np.nan\n\n    try:\n        result[\"with_lowerlimit_exclusive\"] = stats.tmin(data, lowerlimit=lowerlimit, inclusive=inclusive)\n    except ValueError:\n        result[\"with_lowerlimit_exclusive\"] = np.nan\n\n    if isinstance(data, np.ndarray) and data.ndim > 1:\n        try:\n            result[\"axis_based\"] = stats.tmin(data, axis=axis)\n        except ValueError:\n            result[\"axis_based\"] = np.nan\n\n        try:\n            result[\"flattened\"] = stats.tmin(data, axis=None)\n        except ValueError:\n            result[\"flattened\"] = np.nan\n\n    if isinstance(data, np.ndarray) and np.isnan(data).any():\n        try:\n            result[\"nan_omit\"] = stats.tmin(data, nan_policy='omit')\n        except ValueError:\n            result[\"nan_omit\"] = np.nan\n\n    return result", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        if np.random.rand() < 0.5:\n            shape = (np.random.randint(5, 15),)\n        else:\n            shape = (np.random.randint(3, 10), np.random.randint(3, 10))\n\n        data = np.random.rand(*shape)\n        if np.random.rand() < 0.3:\n            num_nans = np.random.randint(1, max(2, data.size // 10))\n            nan_indices = np.random.choice(data.size, num_nans, replace=False)\n\n            data.flat[nan_indices] = np.nan\n        lowerlimit = np.random.uniform(0, 1) if np.random.rand() < 0.7 else None\n        inclusive = np.random.choice([True, False])\n        axis = None if len(shape) == 1 else np.random.choice([0, 1])\n\n        test_cases.append((data, lowerlimit, inclusive, axis))\n\n    return test_cases"}
{"problem_id": "scipy_59", "library": "scipy", "code_problem": "You are tasked with implementing a function that generates samples from two different probability distributions: a normal distribution and an exponential distribution. The function will utilize the `scipy.stats` library to achieve this.\n\nFunction signature:\n```python\ndef generate_distributions(size_norm: int, size_expon: int, ref_point_factor: float, exp_range: float) -> tuple\n```\n\nConstants used in the main code:\n- The constant `1000` is used to define the number of points for the x-values when generating the exponential distribution.\n\nInput format:\n- The function accepts four parameters: `size_norm` (int), `size_expon` (int), `ref_point_factor` (float), and `exp_range` (float).\n\nOutput format:\n- The function returns a tuple containing two arrays: the first array consists of samples from the normal distribution, and the second array consists of samples from the exponential distribution.\n\nInput: (size_norm=50, size_expon=30, ref_point_factor=2.5, exp_range=5.0)\n\nOutput: \n\n(array([ 0.76145109,  0.37006492, -0.59569353, -0.7543485 , -1.21376971,\n        0.16553001, -2.00345418, -2.56996483,  0.25506784,  2.67265018,\n        0.71517131, -2.31573251, -0.37865042, -1.2523474 ,  0.86871099,\n       -0.61818934,  1.41085344, -1.27604296,  0.10188044,  1.15804389,\n        0.63227288, -0.83228651,  0.24269126,  1.48806146,  0.25468546,\n       -1.58639068, -0.89647151,  0.00707007, -0.70575559,  1.02064154,\n       -1.36847523, -1.23964611,  0.33043201,  1.70871614, -0.75340176,\n       -0.25754021, -1.70644641,  0.94464659, -0.7242638 ,  0.2255483 ,\n       -1.32278658,  0.40047293, -0.31227475, -1.31629335, -0.80350725,\n       -1.28059117,  0.0884318 , -0.52760189, -0.7265336 , -0.70663968]), \narray([0.45205024, 0.27087455, 0.77858474, 0.53525757, 0.11599362,\n       0.2265352 , 0.09974305, 0.43924921, 0.14345098, 0.06711509,\n       0.35236922, 5.46478581, 0.2491323 , 0.01785602, 0.40448973,\n       0.15903532, 3.00958054, 0.03291846, 0.84946488, 0.07395272,\n       0.10365208, 1.96284404, 0.36254245, 0.08354189, 3.01299827,\n       1.45168595, 0.45423945, 0.43485029, 0.12649443, 0.19938785])\n)", "ground_truth_code": "import scipy.stats as stats\nfrom scipy.stats.sampling import RatioUniforms\nimport numpy as np\n\n# main code\ndef generate_distributions(size_norm, size_expon, ref_point_factor, exp_range):\n    f = stats.norm.pdf\n    ref_point = np.sqrt(ref_point_factor)\n    v_bound = np.sqrt(f(ref_point)) * ref_point\n    umax = np.sqrt(f(0))\n    (vmin, vmax) = (-v_bound, v_bound)\n\n\n    norm_sampler = RatioUniforms(f, umax=umax, vmin=vmin, vmax=vmax)\n    norm_samples = norm_sampler.rvs(size=size_norm)\n\n    exp_func = lambda x: np.exp(-x)\n    x_vals = np.linspace(0, exp_range, 1000)\n    exp_umax = max(exp_func(x_vals))\n    (exp_vmin, exp_vmax) = (0, 2 * exp_umax)\n\n    expon_sampler = RatioUniforms(exp_func, umax=exp_umax, vmin=exp_vmin, vmax=exp_vmax)\n    expon_samples = expon_sampler.rvs(size=size_expon)\n\n    return (norm_samples, expon_samples)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_norm = np.random.randint(1, 1000)\n        size_expon = np.random.randint(1, 1000)\n        ref_point_factor = np.random.uniform(0.1, 10.0)\n        exp_range = np.random.uniform(0.1, 10.0)\n        test_cases.append((size_norm, size_expon, ref_point_factor, exp_range))\n\n    return test_cases"}
{"problem_id": "scipy_60", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes various properties related to expectiles based on given input parameters. The function will utilize the `scipy.stats` library to calculate expectiles for different scenarios involving two datasets.\n\nFunction Signature:\n```python\ndef compute_expectile_properties(alpha: float, n: int, x: np.ndarray, y: np.ndarray, constant: float, coefficient: float) -> dict:\n```\n\nConstant Used:\n- The constant used in the main code is a floating-point number referred to as `constant`.\n\nInput Format:\n- `alpha`: A float representing the expectile level.\n- `n`: An integer representing the size of the array to be filled with the constant.\n- `x`: A NumPy array of numerical values.\n- `y`: A NumPy array of numerical values.\n- `constant`: A float value used to create an array of a constant value.\n- `coefficient`: A float value used for interpolation between `x` and `y`.\n\nOutput Format:\n- The function returns a dictionary containing the computed expectile properties, with keys corresponding to the different calculations performed.\n\nInput:\n```python\nalpha = 0.5\nn = 10\nx = np.array([1.2, 2.3, 3.1, 4.5, 5.0, 6.7, 7.8, 8.9, 9.0, 10.1])\ny = np.array([0.5, 1.5, 2.5, 3.5, 4.5, 5.5, 6.5, 7.5, 8.5, 9.5])\nconstant = 2.0\ncoefficient = 0.3\n```\n\nOutput:\n```python\n{\n    'expectile_constant': 2.0, \n    'expectile_x_plus_mean': 11.719999999999999, \n    'expectile_x_minus_mean': -1.776356839400251e-16, \n    'expectile_mean_times_x': 34.3396, \n    'expectile_x_y_sum': 10.860000000000001, \n    'expectile_x_vs_y': (5.86, 5.0), \n    'interpolation': [(5.602, 5.602)], \n    'neg_expectile': -5.86, \n    'neg_expectile_complement': -5.86\n}\n\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef compute_expectile_properties(alpha, n, x, y, constant, coefficient):\n    properties = {}\n\n\n    properties[f'expectile_constant'] = stats.expectile(np.full(shape=n, fill_value=constant), alpha=alpha)\n\n    c = np.mean(x)\n    properties['expectile_x_plus_mean'] = stats.expectile(x + c, alpha=alpha)\n    properties['expectile_x_minus_mean'] = stats.expectile(x - c, alpha=alpha)\n    properties['expectile_mean_times_x'] = stats.expectile(c * x, alpha=alpha)\n\n\n    properties['expectile_x_y_sum'] = stats.expectile(np.r_[x + y], alpha=alpha)\n\n    properties['expectile_x_vs_y'] = (stats.expectile(x, alpha=alpha), stats.expectile(y, alpha=alpha))\n\n    interpolation_results = []\n    interpolation_results.append((stats.expectile((1 - coefficient) * x + coefficient * y, alpha=alpha),\n                                  (1 - coefficient) * stats.expectile(x, alpha=alpha) + coefficient * stats.expectile(y,\n                                                                                                      alpha=alpha)))\n    properties['interpolation'] = interpolation_results\n\n    properties['neg_expectile'] = stats.expectile(-x, alpha=alpha)\n    properties['neg_expectile_complement'] = -stats.expectile(x, alpha=1 - alpha)\n\n\n    return properties", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        alpha = np.random.uniform(0.1, 0.9)\n        n_value = np.random.randint(10, 100)\n\n        x = np.random.randn(n_value)\n        y = np.random.randn(n_value)\n\n        constant = np.random.uniform(-10, 10)\n        coefficient = np.random.uniform(0, 1)\n\n        test_cases.append((alpha, n_value, x, y, constant, coefficient))\n\n    return test_cases"}
{"problem_id": "scipy_61", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs independent t-tests between two datasets for different alternative hypotheses. The function should allow for the specification of the axis along which to perform the tests and the number of permutations to use for exact p-value calculations.\n\nFunction signature:\n```python\ndef compute_ttest_ind_exact_alternative(a, b, axis=1, permutations=1000):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1000`, which represents the default number of permutations for the t-test calculations.\n\nInput format:\n- The function accepts two input datasets `a` and `b`, which can be arrays or similar structures containing numerical data.\n- The function also accepts an optional integer `axis` and an optional integer `permutations`.\n\nOutput format:\n- The function returns a dictionary where each key corresponds to a specific alternative hypothesis and dataset combination (e.g., 'greater_ab', 'less_ab', 'two-sided_ab', etc.), and each value is the result of the t-test, which includes statistics such as the t-statistic and p-value.\n\nInput:\n```python\na = np.array([[1.2, 2.3], [3.1, 4.5], [2.2, 3.3]])\nb = np.array([[2.1, 1.5], [3.0, 2.8], [1.9, 2.2]])\naxis = 0\npermutations = 500\n```\n\nOutput:\n```python\n{\n    'greater_ab': TtestResult(statistic=array([-0.25854384,  1.62465726]), pvalue=array([0.55, 0.1 ]), df=nan), \n    'greater_ba': TtestResult(statistic=array([ 0.25854384, -1.62465726]), pvalue=array([0.5 , 0.95]), df=nan), \n    'less_ab': TtestResult(statistic=array([-0.25854384,  1.62465726]), pvalue=array([0.5 , 0.95]), df=nan), \n    'less_ba': TtestResult(statistic=array([ 0.25854384, -1.62465726]), pvalue=array([0.55, 0.1 ]), df=nan), \n    'two-sided_ab': TtestResult(statistic=array([-0.25854384,  1.62465726]), pvalue=array([1. , 0.2]), df=nan), \n    'two-sided_ba': TtestResult(statistic=array([ 0.25854384, -1.62465726]), pvalue=array([1. , 0.2]), df=nan)\n}\n\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef compute_ttest_ind_exact_alternative(a, b, axis=1, permutations=1000):\n    options_p = {'axis': axis, 'permutations': permutations}\n\n    results = {}\n    for alternative in ['greater', 'less', 'two-sided']:\n        options_p.update(alternative=alternative)\n        results[f\"{alternative}_ab\"] = stats.ttest_ind(a, b, **options_p)\n        results[f\"{alternative}_ba\"] = stats.ttest_ind(b, a, **options_p)\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_features = np.random.randint(1, 10)\n        num_samples_a = np.random.randint(5, 100)\n        num_samples_b = np.random.randint(5, 100)\n        a = np.random.randn(num_samples_a, num_features)\n        b = np.random.randn(num_samples_b, num_features)\n        axis = np.random.choice([0, 1]) if num_features > 1 else 0\n        if axis == 0:\n            b = np.random.randn(num_samples_b, num_features)\n        else:\n\n            min_samples = min(num_samples_a, num_samples_b)\n            a = a[:min_samples, :]\n            b = b[:min_samples, :]\n\n        permutations = np.random.randint(100, 1000)\n\n        test_cases.append((a, b, axis, permutations))\n\n    return test_cases"}
{"problem_id": "scipy_62", "library": "scipy", "code_problem": "```python\ndef tuning_s_estimator_mean(norm, breakdown, c_bounds):\n```\n\nIn this code, the function `tuning_s_estimator_mean` is designed to estimate tuning parameters for a statistical model based on a given breakdown point and a range of tuning parameter bounds. The function utilizes the `objective` function to evaluate the performance of different tuning parameters.\n\n### Constant Used:\n- The constant used in the main code is `bps`, which is derived from the `breakdown` parameter or defaults to a predefined list of values if `breakdown` is `None`.\n\n### Input and Output Format:\n- **Input Format**:\n  - `norm`: An object with specific methods for statistical calculations.\n  - `breakdown`: A float or list of floats representing breakdown points or `None`.\n  - `c_bounds`: A tuple of two floats representing the lower and upper bounds for the tuning parameter.\n\n- **Output Format**:\n  - Returns a NumPy array if multiple breakdown points are provided, or a single list if only one breakdown point is processed. Each entry contains the breakdown point, efficiency, tuning parameter, and expectation of rho.\n\n**Input:**\n```python\nclass NormMock:\n    def __init__(self, c):\n        self.c = c\n\n    def _set_tuning_param(self, c, inplace=True):\n        self.c = c\n\n    def psi(self, x):\n        return np.tanh(x)\n\n    def psi_deriv(self, x):\n        return 1 - np.tanh(x) ** 2\n\n    def rho(self, x):\n        return x ** 2 / 2\n\n    def max_rho(self):\n        return 1\n# NormMock instance with a tuning parameter c\nnorm = NormMock(3.5)\n\n# Breakdown values\nbreakdown = [0.3, 0.25, 0.2]\n\n# Bounds for tuning parameter c\nc_bounds = (1.0, 5.0)\n\n# Call the function\nresult = tuning_s_estimator_mean(norm, breakdown, c_bounds)\n```\n\n**Output:**\n```python\narray([[0.3       , 0.25      , 0.2       ],\n       [6.91283583, 6.91283583, 6.91283583],\n       [3.        , 3.        , 3.        ],\n       [0.5       , 0.5       , 0.5       ]])\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats, optimize\n\n\ndef objective(c, norm):\n    norm._set_tuning_param(c, inplace=True)\n    return stats.norm.expect(norm.rho) / norm.max_rho()\n\n# main code\ndef tuning_s_estimator_mean(norm, breakdown, c_bounds):\n    bps = np.atleast_1d(breakdown if breakdown is not None else\n                        [0.5, 0.45, 0.4, 0.35, 0.3, 0.25, 0.2, 0.15, 0.1, 0.05])\n\n    res = []\n    for bp in bps:\n        f_a, f_b = objective(c_bounds[0], norm) - bp, objective(c_bounds[1], norm) - bp\n        if f_a * f_b > 0:\n            c_bp = (c_bounds[0] + c_bounds[1]) / 2\n        else:\n            c_bp = optimize.brentq(lambda c0: objective(c0, norm) - bp, *c_bounds)\n\n        norm._set_tuning_param(c_bp, inplace=True)\n        eff = 1 / stats.norm.expect(lambda x: norm.psi(x) ** 2) / stats.norm.expect(norm.psi_deriv) ** 2\n        b = stats.norm.expect(norm.rho)\n        res.append([bp, eff, c_bp, b])\n\n    return np.asarray(res).T if bps.size > 1 else res[0]", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    class NormMock:\n        def __init__(self, c):\n            self.c = c\n\n        def _set_tuning_param(self, c, inplace=True):\n            self.c = c\n\n        def psi(self, x):\n            return np.tanh(x)\n\n        def psi_deriv(self, x):\n            return 1 - np.tanh(x) ** 2\n\n        def rho(self, x):\n            return x ** 2 / 2\n\n        def max_rho(self):\n            return 1\n\n    return [(NormMock(np.random.uniform(0.1, 10)),\n             np.random.uniform(0.05, 0.5, size=np.random.randint(1, 10)).tolist() if np.random.rand() > 0.5 else None,\n             tuple(sorted(np.random.uniform(0.1, 10, size=2))))\n            for _ in range(n)]"}
{"problem_id": "scipy_63", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates specific quantiles and confidence intervals for a given dataset. The function will take in a dataset and return the quantiles at specified levels along with a confidence interval for the median of the dataset.\n\nFunction signature:\n```python\ndef quantile_confidence_intervals(data, q_value, p_values, confidence_level):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `np.quantile`, which is a NumPy function that computes the quantile of a given dataset.\n\n\nInput format:\n- `data`: A list or array of numerical values.\n- `q_value`: A float representing the quantile level (between 0 and 1).\n- `p_values`: A list of floats representing additional quantile levels (each between 0 and 1).\n- `confidence_level`: A float representing the confidence level (between 0 and 1).\n\nOutput format:\n- A list containing:\n  - The quantile at `q_value`.\n  - The quantiles at each level specified in `p_values`.\n  - A tuple representing the confidence interval for the median of the dataset, with the lower and upper bounds.\n\nInput:\n```python\ndata = np.array([55.2, 48.3, 62.1, 49.5, 53.7, 60.4, 57.8, 54.6, 59.3, 52.9])\nq_value = 0.5\np_values = [0.25, 0.75]\nconfidence_level = 0.95\n```\n\nOutput:\n```python\nresults = [54.900000000000006, 53.1, 58.925, (51.6, 59.3)]\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as stats\n\n# main code\ndef quantile_confidence_intervals(data, q_value, p_values, confidence_level):\n    results = []\n\n    results.append(np.quantile(data, q_value))\n\n    for p in p_values:\n        results.append(np.quantile(data, p))\n\n    ci_result = stats.bootstrap((data,), np.median, confidence_level=confidence_level)\n    results.append((ci_result.confidence_interval.low, ci_result.confidence_interval.high))\n\n    return results", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = np.random.randn(np.random.randint(50, 1000)) * 10 + 50\n        q_value = np.random.uniform(0, 1)\n        p_values = np.random.uniform(0, 1, size=np.random.randint(1, 5)).tolist()\n        p_values.sort()\n\n        confidence_level = np.random.choice([0.9, 0.95, 0.99])\n\n        test_cases.append((data, q_value, p_values, confidence_level))\n\n    return test_cases"}
{"problem_id": "scipy_64", "library": "scipy", "code_problem": "```python\ndef test_shape(size):\n```\n\nIn this code, the function `test_shape` is designed to generate random samples based on a specific probability distribution. The function takes a single parameter, `size`, which determines the number of random samples to generate.\n\n### Input and Output Format:\n- **Input**: The function takes a single integer input `size`, which specifies the number of random samples to generate.\n- **Output**: The function returns an array of random samples generated from the specified distribution.\n\nInput: 10\nOutput: array([2.47961885,  1.16441608, -0.99318223,  0.60132675,  1.00020045,\n       -1.68648519, -0.18963872,  0.23446194,  0.3999933 ,  1.19815257])", "ground_truth_code": "import scipy.stats as stats\nfrom scipy.stats.sampling import RatioUniforms\nimport numpy as np\n\n# main code\ndef test_shape(size):\n    f = stats.norm.pdf\n    v_bound = np.sqrt(f(np.sqrt(2))) * np.sqrt(2)\n    umax, vmin, vmax = np.sqrt(f(0)), -v_bound, v_bound\n\n    ru = RatioUniforms(f, umax=umax, vmin=vmin, vmax=vmax)\n    r = ru.rvs(size=size)\n\n    return r", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    np.random.seed(42)\n\n    for _ in range(n):\n        shape_choice = np.random.choice([1, 2, 3])\n\n        if shape_choice == 1:\n            size = (np.random.randint(1, 100),)\n        elif shape_choice == 2:\n            size = (np.random.randint(1, 50), np.random.randint(1, 50))\n        else:\n            size = (np.random.randint(1, 20), np.random.randint(1, 20), np.random.randint(1, 10))\n\n        test_cases.append(size)\n\n    return test_cases\n"}
{"problem_id": "scipy_65", "library": "scipy", "code_problem": "You are tasked with implementing a function that identifies connected components in a sparse matrix representation of a graph. The function should label the connected components and return the number of components along with a matrix indicating the component labels for each node.\n\nFunction signature:\n```python\ndef label_foci(matrix: np.ndarray) -> Tuple[int, sp.coo_matrix]:\n```\n\nConstant used in the main code:\n- The constant `1` is used to create an array of ones for the adjacency matrix.\n\nInput format:\n- The input to the function is a 2D NumPy array `matrix` representing the adjacency matrix of a graph.\n\nOutput format:\n- The output of the function is a tuple consisting of:\n  - An integer representing the number of connected components.\n  - A COO sparse matrix where each entry corresponds to the component label of the respective node in the input matrix.\n\n**Input:**\n```python\nmatrix = np.array([[0, 1, 0, 0],\n                   [1, 1, 0, 0],\n                   [0, 0, 1, 1],\n                   [0, 0, 1, 0]])\n```\n\n**Output:**\n```python\n(2, <4x4 sparse matrix of type '<class 'numpy.int32'>'\n\twith 6 stored elements in COOrdinate format>)\n```", "ground_truth_code": "import scipy.sparse as sp\nimport numpy as np\n\n\n# main code\ndef label_foci(matrix):\n    matrix_sp = sp.coo_matrix(sp.csr_matrix(matrix))\n    nb_row, nb_col = matrix_sp.shape\n    nb_nodes = matrix_sp.nnz\n\n    dtype = [('row', int), ('col', int)]\n    coo = np.zeros(nb_nodes, dtype=dtype)\n    coo['row'] = matrix_sp.row\n    coo['col'] = matrix_sp.col\n\n    coo_rc = np.argsort(coo, order=['row', 'col'])\n    row_rc = coo['row'][coo_rc]\n    col_rc = coo['col'][coo_rc]\n\n    diff_row_rc = row_rc[1:] - row_rc[:-1]\n    diff_col_rc = col_rc[1:] - col_rc[:-1]\n    right_connected_p = (diff_row_rc == 0) & (diff_col_rc == 1)\n    right_connected_k = np.flatnonzero(right_connected_p)\n    right_node1 = right_connected_k\n    right_node2 = right_connected_k + 1\n\n    coo_cr = np.argsort(coo, order=['col', 'row'])\n    row_cr = coo['row'][coo_cr]\n    col_cr = coo['col'][coo_cr]\n\n    diff_row_cr = row_cr[1:] - row_cr[:-1]\n    diff_col_cr = col_cr[1:] - col_cr[:-1]\n    lower_connected_p = (diff_row_cr == 1) & (diff_col_cr == 0)\n    lower_connected_k = np.flatnonzero(lower_connected_p)\n\n    cr2rc = np.arange(len(coo_cr))[coo_cr]\n    lower_node1 = cr2rc[lower_connected_k]\n    lower_node2 = cr2rc[lower_connected_k + 1]\n\n    node1 = np.concatenate([right_node1, lower_node1])\n    node2 = np.concatenate([right_node2, lower_node2])\n    data = np.ones(len(node1), int)\n\n    adj_mat = sp.coo_matrix((data, (node1, node2)), shape=(nb_nodes, nb_nodes))\n    num_foci, foci = sp.csgraph.connected_components(adj_mat, directed=False)\n\n    foci_mat = sp.coo_matrix((foci + 1, (matrix_sp.row, matrix_sp.col)), shape=(nb_row, nb_col))\n\n    return num_foci, foci_mat", "test_script": "import scipy.sparse as sp\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        rows = np.random.randint(5, 50)\n        cols = np.random.randint(5, 50)\n        density = np.random.uniform(0.01, 0.5)\n        matrix = sp.random(rows, cols, density=density, format='csr', dtype=int)\n        matrix.data[:] = np.random.randint(1, 10, size=len(matrix.data))\n        dense_matrix = matrix.toarray()\n\n        test_cases.append(dense_matrix)\n\n    return test_cases"}
{"problem_id": "scipy_66", "library": "scipy", "code_problem": "You are tasked with implementing a function that fits a log-normal distribution to a given set of weights and computes various statistical properties of the fitted distribution. The function should also generate a probability density function (PDF) over a specified range of values.\n\nFunction Signature:\n```python\ndef linear_lognormal_fit(weights, num_points):\n```\n\n### Constants:\n- The constant used in the main code is `0.01`, which is the threshold for filtering out weights that are less than this value.\n\n\n### Input Format:\n- The function takes two parameters:\n  - `weights`: A list or array of numerical values representing the weights.\n  - `num_points`: An integer specifying the number of points to generate for the PDF.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `\"x_values\"`: An array of x values.\n  - `\"pdf_values\"`: An array of PDF values corresponding to the x values.\n  - `\"shape\"`: The shape parameter of the log-normal distribution.\n  - `\"scale\"`: The scale parameter of the log-normal distribution.\n  - `\"median\"`: The median of the log-normal distribution.\n  - `\"mode\"`: The mode of the log-normal distribution.\n  - `\"mean\"`: The mean of the log-normal distribution.\n\nInput:\n```python\nweights = [0.001, 0.002, 0.003, 0.004, 0.005, 0.006, 0.007, 0.008, 0.009, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6]\nnum_points = 50\n```\n\nOutput:\n```python\n{\n    'x_values': array([0.1       , 0.11020408, 0.12040816, 0.13061224, 0.14081633,\n       0.15102041, 0.16122449, 0.17142857, 0.18163265, 0.19183673,\n       0.20204082, 0.2122449 , 0.22244898, 0.23265306, 0.24285714,\n       0.25306122, 0.26326531, 0.27346939, 0.28367347, 0.29387755,\n       0.30408163, 0.31428571, 0.3244898 , 0.33469388, 0.34489796,\n       0.35510204, 0.36530612, 0.3755102 , 0.38571429, 0.39591837,\n       0.40612245, 0.41632653, 0.42653061, 0.43673469, 0.44693878,\n       0.45714286, 0.46734694, 0.47755102, 0.4877551 , 0.49795918,\n       0.50816327, 0.51836735, 0.52857143, 0.53877551, 0.54897959,\n       0.55918367, 0.56938776, 0.57959184, 0.58979592, 0.6       ]), \n    'pdf_values': array([1.27546321, 1.52870076, 1.76297958, 1.97210531, 2.15258174,\n       2.30303292, 2.42365174, 2.51572487, 2.58124893, 2.62263429,\n       2.64248541, 2.64344384, 2.62808062, 2.59882646, 2.55792994,\n       2.50743604, 2.44917899, 2.38478494, 2.31568093, 2.24310787,\n       2.16813558, 2.09167875, 2.01451293, 1.93729003, 1.86055286,\n       1.78474869, 1.71024157, 1.63732349, 1.56622436, 1.49712089,\n       1.43014443, 1.36538784, 1.30291157, 1.2427488 , 1.18491009,\n       1.12938728, 1.07615684, 1.02518284, 0.97641939, 0.92981279,\n       0.88530334, 0.84282682, 0.80231584, 0.76370087, 0.72691117,\n       0.69187552, 0.65852285, 0.62678272, 0.59658579, 0.56786404]), \n    'shape': 0.604907982189049, \n    'scale': 0.299379516552391, \n    'median': 0.299379516552391, \n    'mode': 0.20763845864860803, \n    'mean': 0.3594837189564099\n}\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\n# main code\ndef linear_lognormal_fit(weights, num_points):\n    weights = np.array(weights)\n    weights = weights[weights >= 0.01]\n\n    mu = np.mean(np.log(weights))\n    sigma = np.std(np.log(weights))\n\n    shape = sigma\n    scale = np.exp(mu)\n    median = np.exp(mu)\n    mode = np.exp(mu - sigma ** 2)\n    mean = np.exp(mu + sigma ** 2 / 2)\n\n    x = np.linspace(np.min(weights), np.max(weights), num=num_points)\n    pdf = stats.lognorm.pdf(x, shape, loc=0, scale=scale)\n\n    return {\n        \"x_values\": x,\n        \"pdf_values\": pdf,\n        \"shape\": shape,\n        \"scale\": scale,\n        \"median\": median,\n        \"mode\": mode,\n        \"mean\": mean\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_weights = np.random.randint(10, 1000)\n        weights = np.random.lognormal(mean=0, sigma=1, size=num_weights)\n        if np.random.rand() < 0.2:\n            weights[np.random.choice(num_weights, size=num_weights // 10, replace=False)] = np.random.uniform(0.001,\n                                                                                                              0.009,\n                                                                                                              num_weights // 10)\n\n        num_points = np.random.randint(10, 1000)\n\n        test_cases.append((weights.tolist(), num_points))\n\n    return test_cases"}
{"problem_id": "scipy_67", "library": "scipy", "code_problem": "You are tasked with implementing a function that uncovers hidden patterns in a dataset by calculating the mode of the data along a specified axis. The function should handle missing values and normalize the data before performing the mode calculation. \n\nFunction signature:\n```python\ndef uncover_hidden_patterns(data, axis=0, nan_policy='propagate'):\n```\n\n### Constants:\n- A constant threshold is defined as `0.1 * df.shape[axis]`, which is used to determine the significance of the modes based on their frequency.\n\n### Input Format:\n- The input `data` can be a list, NumPy array, or any structure that can be converted into a Pandas DataFrame.\n- The `axis` parameter is an integer (0 or 1) indicating the axis along which to compute the mode.\n- The `nan_policy` parameter is a string that specifies how to handle NaN values during mode calculation.\n\n### Output Format:\n- The output is a Pandas DataFrame containing two columns: 'Mode' and 'Frequency'. Each row corresponds to a significant mode and its count in the dataset. Rows with NaN values are excluded from the output.\n\nInput:\n```python\ndata = array([[ -3.22291848, -10.36820498,  17.61296428,   1.15423136],\n               [  1.0691904 ,   0.09673582,  -1.28078561,  15.05833354],\n               [  7.08595493, -15.78157617,  -5.06813478,   3.51727783],\n               [-13.66029989,   2.66152552,   6.4669738 ,   3.32955014],\n               [  3.49975039, -12.67588783,   0.91694049,  10.87824769],\n               [-14.10918826,  -8.73595287,  -9.21086264,   8.92988752],\n               [ -3.22291848,  -2.11983394,   0.07325392,  19.64168457]])\naxis = 1\nnan_policy = 'omit'\n```\n\nOutput:\n```python\n       Mode  Frequency\n0  0.000000        1.0\n1  0.295636        1.0\n2  0.000000        1.0\n3  0.021179        1.0\n4  0.168393        1.0\n5  0.000000        2.0\n6  0.346115        1.0\n\n```", "ground_truth_code": "import scipy.stats as stats\nimport numpy as np\nimport pandas as pd\n\n# main code\ndef uncover_hidden_patterns(data, axis=0, nan_policy='propagate'):\n\n    df = pd.DataFrame(data)\n    df.fillna(df.mean(), inplace=True)\n\n    df = (df - df.min()) / (df.max() - df.min())\n\n    mode_result = stats.mode(df.to_numpy(), axis=axis, nan_policy=nan_policy)\n    modes, counts = mode_result.mode, mode_result.count\n    threshold = 0.1 * df.shape[axis]\n    significant_modes = np.where(counts >= threshold, modes, np.nan)\n    mode_df = pd.DataFrame({'Mode': significant_modes.flatten(), 'Frequency': counts.flatten()})\n    mode_df.dropna(inplace=True)\n\n    return mode_df", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(5, 20)\n        cols = np.random.randint(3, 10)\n        data = np.random.randn(rows, cols) * 10\n        nan_mask = np.random.rand(rows, cols) < 0.1\n        data[nan_mask] = np.nan\n        axis = np.random.choice([0, 1])\n        nan_policy = np.random.choice(['propagate', 'omit', 'raise'])\n        test_cases.append((data, axis, nan_policy))\n\n    return test_cases\n"}
{"problem_id": "scipy_68", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the B-spline basis functions for a given set of input values. The function should be able to handle both periodic and non-periodic cases and should allow for a specified number of splines and spline order. The output should be in a sparse matrix format if required.\n\nFunction Signature:\n```python\ndef b_spline_basis(x, edge_knots, n_splines=20, spline_order=3, sparse=True, periodic=True):\n```\n\nConstants:\n- The constant used in the main code is `1e-09`, which is used to ensure numerical stability when handling periodic boundary conditions.\n\nInput Format:\n- The function takes in an array-like structure for `x` and `edge_knots`, along with optional integer and boolean parameters.\n\nOutput Format:\n- The function returns a sparse matrix or a dense array representing the computed B-spline basis functions.\n\nInput:\n```python\nx = np.array([0.5, 1.5, -0.2])\nedge_knots = np.array([-3.0, 0.0, 2.0, 4.0])\nn_splines = 10\nspline_order = 3\nsparse = True\nperiodic = False\n```\n\nOutput:\n```python\n<3x10 sparse matrix of type '<class 'numpy.float64'>'\n\twith 12 stored elements in Compressed Sparse Column format>\n  (2, 2)\t0.0013333333333333348\n  (0, 3)\t0.020833333333333308\n  (2, 3)\t0.2826666666666666\n  (0, 4)\t0.47916666666666646\n  (1, 4)\t0.020833333333333228\n  (2, 4)\t0.6306666666666665\n  (0, 5)\t0.47916666666666685\n  (1, 5)\t0.4791666666666662\n  (2, 5)\t0.0853333333333333\n  (0, 6)\t0.020833333333333363\n  (1, 6)\t0.479166666666667\n  (1, 7)\t0.020833333333333412\n``` \n", "ground_truth_code": "import numpy as np\nfrom copy import deepcopy\nimport scipy as sp\n\n# main code\ndef b_spline_basis(x, edge_knots, n_splines=20, spline_order=3, sparse=True, periodic=True):\n\n    n_splines += spline_order * periodic\n    edge_knots = np.sort(deepcopy(edge_knots))\n    offset = edge_knots[0]\n    scale = edge_knots[-1] - edge_knots[0]\n    scale = scale if scale != 0 else 1\n\n    boundary_knots = np.linspace(0, 1, 1 + n_splines - spline_order)\n    diff = np.diff(boundary_knots[:2])[0]\n    x = (np.ravel(deepcopy(x)) - offset) / scale\n    x = x % (1 + 1e-09) if periodic else x\n    x = np.r_[x, 0.0, 1.0]\n\n    x_extrapolte_l = x < 0\n    x_extrapolte_r = x > 1\n    x_interpolate = ~(x_extrapolte_r + x_extrapolte_l)\n    x = np.atleast_2d(x).T\n\n    aug = np.arange(1, spline_order + 1) * diff\n    aug_knots = np.r_[-aug[::-1], boundary_knots, 1 + aug]\n    aug_knots[-1] += 1e-09\n\n    bases = (x >= aug_knots[:-1]).astype(int) * (x < aug_knots[1:]).astype(int)\n    bases[-1] = bases[-2][::-1]\n\n    maxi = len(aug_knots) - 1\n    for m in range(2, spline_order + 2):\n        maxi -= 1\n        num = x - aug_knots[:maxi]\n        num *= bases[:, :maxi]\n        denom = aug_knots[m - 1:maxi + m - 1] - aug_knots[:maxi]\n        left = num / denom\n        num = (aug_knots[m:maxi + m] - x) * bases[:, 1:maxi + 1]\n        denom = aug_knots[m:maxi + m] - aug_knots[1:maxi + 1]\n        right = num / denom\n        prev_bases = bases[-2:]\n        bases = left + right\n\n    if periodic and spline_order > 0:\n        bases[:, :spline_order] = np.max([bases[:, :spline_order], bases[:, -spline_order:]], axis=0)\n        bases = bases[:, :-spline_order]\n\n    if (any(x_extrapolte_r) or any(x_extrapolte_l)) and spline_order > 0:\n        bases[~x_interpolate] = 0.0\n        denom = aug_knots[spline_order:-1] - aug_knots[:-spline_order - 1]\n        left = prev_bases[:, :-1] / denom\n        denom = aug_knots[spline_order + 1:] - aug_knots[1:-spline_order]\n        right = prev_bases[:, 1:] / denom\n        grads = spline_order * (left - right)\n        if any(x_extrapolte_l):\n            val = grads[0] * x[x_extrapolte_l] + bases[-2]\n            bases[x_extrapolte_l] = val\n        if any(x_extrapolte_r):\n            val = grads[1] * (x[x_extrapolte_r] - 1) + bases[-1]\n            bases[x_extrapolte_r] = val\n\n    bases = bases[:-2]\n\n    return sp.sparse.csc_matrix(bases) if sparse else bases", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        x = np.random.uniform(-1, 2, size=(np.random.randint(1, 20),))\n        num_knots = np.random.randint(2, 30)\n        edge_knots = np.sort(np.random.uniform(-5, 5, size=(num_knots,)))\n        n_splines = np.random.randint(2, 25)\n        spline_order = np.random.randint(1, min(n_splines, 5))\n        sparse = np.random.choice([True, False])\n        periodic = np.random.choice([True, False])\n        test_cases.append((x, edge_knots, n_splines, spline_order, sparse, periodic))\n\n    return test_cases"}
{"problem_id": "scipy_69", "library": "scipy", "code_problem": "You are tasked with implementing a function that converts a given sparse matrix into a symmetric sparse matrix. The function should ensure that the resulting matrix retains the same shape as the input matrix and normalizes the values of the matrix.\n\nFunction Signature:\n```python\ndef make_symmetric(m):\n```\n\nConstant Used:\n- The constant used in the main code is `1`, which is used as a fallback maximum value for normalization when there are no values in the matrix.\n\nInput Format:\n- The input to the function is a sparse matrix `m`, which can be represented in any format that can be converted to a COO sparse matrix.\n\nOutput Format:\n- The output of the function is a COO sparse matrix that is symmetric and has the same shape as the input matrix, with normalized values.\n\nInput:\n```python\nfrom scipy.sparse import coo_matrix\n\n# Sparse matrix with shape (3, 3)\nrows = [0, 1, 2]\ncols = [1, 0, 2]\nvalues = [1.0, 2.0, 3.0]\nsparse_matrix = coo_matrix((values, (rows, cols)), shape=(3, 3))\n```\n\nOutput:\n```python\n<3x3 sparse matrix of type '<class 'numpy.float64'>'\n\twith 3 stored elements in COOrdinate format>\n  (0, 1)\t0.3333333333333333\n  (2, 2)\t1.0\n  (1, 0)\t0.3333333333333333\n```", "ground_truth_code": "import numpy as np\nfrom scipy.sparse import coo_matrix\n\n# main code\ndef make_symmetric(m):\n    m = coo_matrix(m)\n    rows, cols, values = m.row, m.col, m.data\n    shape = m.shape\n    mask_upper = cols >= rows\n    rows, cols, values = rows[mask_upper], cols[mask_upper], values[mask_upper]\n    valid_mask = (cols < shape[0]) & (rows < shape[1])\n    rows, cols, values = rows[valid_mask], cols[valid_mask], values[valid_mask]\n\n    lower_rows = cols[cols > rows]\n    lower_cols = rows[cols > rows]\n    lower_values = values[cols > rows]\n\n    new_rows = np.concatenate([rows, lower_rows])\n    new_cols = np.concatenate([cols, lower_cols])\n    new_values = np.concatenate([values, lower_values])\n    max_value = np.max(np.abs(new_values)) if len(new_values) > 0 else 1\n    new_values = new_values / max_value\n    within_bounds = (new_rows < shape[0]) & (new_cols < shape[1])\n    new_rows, new_cols, new_values = new_rows[within_bounds], new_cols[within_bounds], new_values[within_bounds]\n    return coo_matrix((new_values, (new_rows, new_cols)), shape=shape, dtype=m.dtype)", "test_script": "import numpy as np\nfrom scipy.sparse import coo_matrix\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(2, 101, size=2)\n        num_nonzero = np.random.randint(1, max(2, int(0.2 * size[0] * size[1])))\n        rows = np.random.randint(0, size[0], size=num_nonzero)\n        cols = np.random.randint(0, size[1], size=num_nonzero)\n        values = np.random.randn(num_nonzero)\n        sparse_matrix = coo_matrix((values, (rows, cols)), shape=size)\n        test_cases.append(sparse_matrix)\n\n    return test_cases"}
{"problem_id": "scipy_70", "library": "scipy", "code_problem": "You are tasked with implementing a function that smooths a given dataset and normalizes the smoothed values. The function should handle both one-dimensional and multi-dimensional input data, applying a smoothing filter based on a specified parameter. The function will also ensure that any NaN values in the data are replaced with the mean of the dataset.\n\nFunction signature:\n```python\ndef the_legend_of_smooth(data, smoothie):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used in the smoothing artifact calculation.\n\n### Input and Output Format:\n- **Input**: \n  - `data`: A list or a NumPy array containing numerical values.\n  - `smoothie`: An integer representing the degree of smoothing to apply.\n\n- **Output**: \n  - A NumPy array containing the smoothed and normalized values derived from the input data.\n\nHere is a short test case input and output pair for the provided ground truth code:\n\n**Example Input & Output:**\n\nInput:\n```python\ndata = [1, 2, 3, 4, 5]\nsmoothie = 2\n```\n\nOutput:\n```python\narray([0. , 0. , 0. , 0.2, 0.5, 0.7, 1. , 1. , 1. ])\n```", "ground_truth_code": "import numpy as np\nfrom scipy import signal\n\n# main code\ndef the_legend_of_smooth(data, smoothie):\n    if isinstance(data, list):\n        data = np.array(data)\n    if data.ndim == 1:\n        data = data.reshape(-1)\n    elif data.ndim > 2:\n        data = data.reshape(data.shape[0], -1)\n\n    data = np.nan_to_num(data, nan=np.mean(data))\n\n    size_x = np.size(data)\n    length_x = len(data)\n\n    if smoothie > 0:\n        if 1 < length_x < size_x:\n            pad_x = np.vstack(([data[0, :]] * smoothie, data, [data[-1, :]] * smoothie))\n            smoothing_artifact = np.hstack((np.ones(smoothie) / (2 * smoothie), 0, np.ones(smoothie) / (2 * smoothie)))\n            refined_signal = signal.lfilter(smoothing_artifact, 1, pad_x.T).T\n            smoothed_data = refined_signal[2 * smoothie:]\n        else:\n            pad_x = np.hstack(([data[0]] * smoothie, data, [data[-1]] * smoothie))\n            smoothing_artifact = np.hstack((np.ones(smoothie) / (2 * smoothie), 0, np.ones(smoothie) / (2 * smoothie)))\n            smoothed_data = signal.lfilter(smoothing_artifact, 1, pad_x)\n            smoothed_data[:smoothie] = smoothed_data[smoothie]\n            smoothed_data[-smoothie:] = smoothed_data[-smoothie - 1]\n    else:\n        smoothed_data = data\n\n    min_val, max_val = np.min(smoothed_data), np.max(smoothed_data)\n    smoothed_data = (smoothed_data - min_val) / (max_val - min_val) if max_val != min_val else smoothed_data\n\n    return smoothed_data\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dim = np.random.choice([1, 2])\n\n        if dim == 1:\n            length = np.random.randint(5, 101)\n            data = np.random.uniform(-10, 10, size=length)\n        else:\n            rows = np.random.randint(5, 51)\n            cols = np.random.randint(5, 51)\n            data = np.random.uniform(-10, 10, size=(rows, cols))\n\n        smoothie = np.random.randint(0, 11)\n\n        test_cases.append((data, smoothie))\n\n    return test_cases"}
{"problem_id": "scipy_71", "library": "scipy", "code_problem": "```python\ndef construct_from_derivatives(xa, xb, ya, yb):\n```\n\nThe function `construct_from_derivatives` takes in four parameters: `xa`, `xb`, `ya`, and `yb`. The purpose of this function is to construct a polynomial from given derivatives at two points, `xa` and `xb`, represented by the arrays `ya` and `yb`, respectively.\n\n### Constants Used:\n- The constant used in the main code is `dt`, which is determined based on the data types of the input arrays `ya` and `yb`. It is set to `np.complex128` if either input contains complex numbers; otherwise, it defaults to `np.float64`.\n\n### Input and Output Format:\n- **Input**:\n  - `xa`: A scalar value representing the first point.\n  - `xb`: A scalar value representing the second point.\n  - `ya`: A NumPy array of derivatives at point `xa`.\n  - `yb`: A NumPy array of derivatives at point `xb`.\n\n- **Output**:\n  - Returns a NumPy array containing the coefficients of the polynomial constructed from the derivatives at the specified points.\n\n**Input:**\n```python\nxa = 2.5\nxb = 3.5\nya = np.array([[1.0], [2.0], [3.0]])\nyb = np.array([[4.0], [5.0]])\n```\n\n**Output:**\n```python\narray([[1.  ],\n       [1.5 ],\n       [2.25],\n       [2.75],\n       [4.  ]])\n```", "ground_truth_code": "import numpy as np\nimport scipy.special as spec\nfrom scipy.special import comb\n\n\ndef preprocess_data(ya, yb):\n    ya, yb = np.asarray(ya), np.asarray(yb)\n    dta, dtb = ya.dtype, yb.dtype\n    dt = np.complex128 if np.issubdtype(dta, np.complexfloating) or np.issubdtype(dtb,\n                                                                                  np.complexfloating) else np.float64\n    return ya, yb, dt\n\n# main code\ndef construct_from_derivatives(xa, xb, ya, yb):\n    ya, yb, dt = preprocess_data(ya, yb)\n    na, nb = len(ya), len(yb)\n    n = na + nb\n    c = np.empty((na + nb,) + ya.shape[1:], dtype=dt)\n    for q in range(na):\n        c[q] = ya[q] / spec.poch(n - q, q) * (xb - xa) ** q\n        for j in range(q):\n            c[q] -= (-1) ** (j + q) * comb(q, j) * c[j]\n\n    for q in range(nb):\n        c[-q - 1] = yb[q] / spec.poch(n - q, q) * (-1) ** q * (xb - xa) ** q\n        for j in range(q):\n            c[-q - 1] -= (-1) ** (j + 1) * comb(q, j + 1) * c[-q + j]\n\n    return c", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        na = np.random.randint(1, 10)\n        nb = np.random.randint(1, 10)\n        shape = tuple(np.random.randint(1, 5, size=np.random.randint(1, 3)))\n\n        xa = np.random.uniform(-10, 10)\n        xb = np.random.uniform(-10, 10)\n\n        dtype_choice = np.random.choice([np.float64, np.complex128])\n        ya = np.random.randn(na, *shape).astype(dtype_choice)\n        yb = np.random.randn(nb, *shape).astype(dtype_choice)\n\n        test_cases.append((xa, xb, ya, yb))\n    return test_cases"}
{"problem_id": "scipy_72", "library": "scipy", "code_problem": "You are tasked with implementing a function that finds the optimal transformation parameter for the Yeo-Johnson transformation, which is used to stabilize variance and make the data more normally distributed. The function should be able to handle both positive and negative values in the input data.\n\nFunction Signature:\n```python\ndef yeojohnson_normmax(x: Union[np.ndarray, List[float]]) -> float:\n```\n\nConstant used in the main code:\n- `tol_brent`: A tolerance value set to `1.48e-08`, which is used in the optimization process to determine the accuracy of the solution.\n\n\nInput Format:\n- The input `x` can be a NumPy array or a list of floating-point numbers.\n\nOutput Format:\n- The function returns a single floating-point number, which is the optimal transformation parameter for the Yeo-Johnson transformation.\n\n```python\n# Input\nnp.array([1.5, 2.3, 3.7, 0.0, -1.2, -3.4])\n\n# Output\n1.134112576442829\n```", "ground_truth_code": "import numpy as np\nfrom scipy import optimize\n\n\ndef _yeojohnson_transform(x, lmbda):\n    dtype = x.dtype if np.issubdtype(x.dtype, np.floating) else np.float64\n    out = np.zeros_like(x, dtype=dtype)\n    pos = x >= 0\n    if abs(lmbda) < np.spacing(1.0):\n        out[pos] = np.log1p(x[pos])\n    else:\n        out[pos] = np.expm1(lmbda * np.log1p(x[pos])) / lmbda\n    if abs(lmbda - 2) > np.spacing(1.0):\n        out[~pos] = -np.expm1((2 - lmbda) * np.log1p(-x[~pos])) / (2 - lmbda)\n    else:\n        out[~pos] = -np.log1p(-x[~pos])\n    return out\n\n\ndef yeojohnson_llf(lmb, data):\n    data = np.asarray(data)\n    n_samples = data.shape[0]\n    if n_samples == 0:\n        return np.nan\n    trans = _yeojohnson_transform(data, lmb)\n    trans_var = trans.var(axis=0)\n    loglike = np.empty_like(trans_var)\n    tiny_variance = trans_var < np.finfo(trans_var.dtype).tiny\n    loglike[tiny_variance] = np.inf\n    loglike[~tiny_variance] = -n_samples / 2 * np.log(trans_var[~tiny_variance])\n    loglike[~tiny_variance] += (lmb - 1) * (np.sign(data) * np.log1p(np.abs(data))).sum(axis=0)\n    return loglike\n\n# main code\ndef yeojohnson_normmax(x):\n    def _neg_llf(lmbda, data):\n        llf = yeojohnson_llf(lmbda, data)\n        llf[np.isinf(llf)] = -np.inf\n        return -llf\n\n    if np.all(x == 0):\n        return 1.0\n    x = np.asarray(x)\n    dtype = x.dtype if np.issubdtype(x.dtype, np.floating) else np.float64\n    log1p_max_x = np.log1p(20 * np.max(np.abs(x)))\n    log_eps = np.log(np.finfo(dtype).eps)\n    log_tiny_float = (np.log(np.finfo(dtype).tiny) - log_eps) / 2\n    log_max_float = (np.log(np.finfo(dtype).max) + log_eps) / 2\n    lb = log_tiny_float / log1p_max_x\n    ub = log_max_float / log1p_max_x\n    if np.all(x < 0):\n        lb, ub = 2 - ub, 2 - lb\n    elif np.any(x < 0):\n        lb, ub = max(2 - ub, lb), min(2 - lb, ub)\n    tol_brent = 1.48e-08\n    return optimize.fminbound(_neg_llf, lb, ub, args=(x,), xtol=tol_brent)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        shape = (np.random.randint(5, 50),)\n\n        data_type = np.random.choice(['positive', 'negative', 'mixed', 'zero'])\n\n        if data_type == 'positive':\n            x = np.random.uniform(0.1, 100, size=shape)\n        elif data_type == 'negative':\n            x = np.random.uniform(-100, -0.1, size=shape)\n        elif data_type == 'mixed':\n            x = np.random.uniform(-100, 100, size=shape)\n        else:\n            x = np.zeros(shape)\n\n        test_cases.append(x)\n\n    return test_cases"}
{"problem_id": "scipy_73", "library": "scipy", "code_problem": "You are tasked with implementing a statistical test known as the Doornik-Hansen test, which is used to assess the multivariate normality of a dataset. The test evaluates both skewness and kurtosis of the data and provides p-values to determine the significance of the results.\n\nFunction Signature:\n```python\ndef doornik_hansen(data):\n```\n\n### Constants Used:\n- A constant value of `1e-12` is used to filter eigenvalues during the computation.\n\n\n### Input Format:\n- The input to the function is a dataset in the form of a 2D array-like structure (e.g., list of lists, numpy array, or pandas DataFrame).\n\n### Output Format:\n- The function returns a tuple containing:\n  - `DH`: The Doornik-Hansen statistic for skewness and kurtosis.\n  - `AS`: The adjusted statistic for skewness and kurtosis.\n  - `PO`: The p-value associated with the Doornik-Hansen statistic.\n  - `PA`: The p-value associated with the adjusted statistic.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\ndata = pd.DataFrame({\n    '0': [-0.734572802386519, -1.2549131001809788, 1.3467004424844566, 0.6120202121326495, 0.452971161381763, 0.37009386154039714, -1.125103059621449, 0.3486078953993234, 2.5295324118059823, 0.25137138017690086],\n    '1': [0.48636088248138637, -0.8122309940727351, -0.21540185451112892, 0.7926750658706523, 1.7877380251096242, -1.4487527330127117, 0.8230360485508378, 1.4013033411338522, 0.04290203756338962, -0.45263293193825066]\n})\n```\n\n**Output:**\n```python\n(1.6427213487652819, 0.6754323270532528, 0.8010941250931828, 0.9543236978073787)\n```\n", "ground_truth_code": "import pandas as pd\nimport numpy as np\nfrom copy import deepcopy\nfrom numpy.linalg import eigh, matrix_rank\nfrom scipy.stats import chi2\n\n\ndef preprocess_data(data):\n    data = pd.DataFrame(data).fillna(method='ffill').fillna(method='bfill')\n    return (data - data.mean()) / data.std(ddof=0)\n\n# main code\ndef doornik_hansen(data):\n\n    data = preprocess_data(data)\n    data = deepcopy(data)\n    n, p = data.shape\n\n\n    R = np.corrcoef(data.T)\n    L, V = eigh(R)\n\n\n    L[L > 1e-12] = 1 / np.sqrt(L[L > 1e-12])\n    L[L <= 1e-12] = 0\n    L = np.diag(L)\n\n    if matrix_rank(R) < p:\n        V = pd.DataFrame(V)\n        G = V.loc[:, (L != 0).any(axis=0)]\n        data = data.dot(G)\n        p = data.shape[1]\n        R = np.corrcoef(data.T)\n        L, V = eigh(R)\n        L = np.diag(L)\n\n    Z = (data - data.mean()) / data.std(ddof=0)\n    Zp = Z.dot(V)\n    Zpp = Zp.dot(L)\n    st = Zpp.dot(V.T)\n\n    skew_vals = np.mean(st ** 3, axis=0)\n    kurt_vals = np.mean(st ** 4, axis=0)\n\n    n2 = n ** 2\n    b = 3 * (n2 + 27 * n - 70) * (n + 1) * (n + 3)\n    b /= (n - 2) * (n + 5) * (n + 7) * (n + 9)\n\n    w2 = -1 + np.sqrt(2 * (b - 1))\n    d = 1 / np.sqrt(np.log(np.sqrt(w2)))\n    y = skew_vals * np.sqrt((w2 - 1) * (n + 1) * (n + 3) / (12 * (n - 2)))\n    z1 = d * np.log(y + np.sqrt(y ** 2 + 1))\n\n    d = (n - 3) * (n + 1) * (n2 + 15 * n - 4)\n    a = (n - 2) * (n + 5) * (n + 7) * (n2 + 27 * n - 70) / (6 * d)\n    c = (n - 7) * (n + 5) * (n + 7) * (n2 + 2 * n - 5) / (6 * d)\n    k = (n + 5) * (n + 7) * (n * n2 + 37 * n2 + 11 * n - 313) / (12 * d)\n\n    al = a + skew_vals ** 2 * c\n    chi = (kurt_vals - 1 - skew_vals ** 2) * k * 2\n    z2 = ((chi / (2 * al)) ** (1 / 3) - 1 + 1 / (9 * al)) * np.sqrt(9 * al)\n\n    kurt_vals -= 3\n    DH = z1 @ z1.T + z2 @ z2.T\n    AS = (n / 6) * (skew_vals @ skew_vals.T) + (n / 24) * (kurt_vals @ kurt_vals.T)\n    v = 2 * p\n\n    PO = 1 - chi2.cdf(DH, v)\n    PA = 1 - chi2.cdf(AS, v)\n\n    return DH, AS, PO, PA", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 500)\n        num_features = np.random.randint(2, 20)\n        data = np.random.randn(num_samples, num_features)\n        df = pd.DataFrame(data)\n\n        test_cases.append(df)\n    return test_cases\n"}
{"problem_id": "scipy_74", "library": "scipy", "code_problem": "You are tasked with implementing a function that retrieves and formats a list of statistical distribution names from the `scipy.stats` library. The function should allow for filtering of the distribution names based on a keyword and should limit the number of results returned based on a specified maximum.\n\nFunction Signature:\n```python\ndef get_distributions(filter_keyword: str, max_results: int, format_output: bool) -> dict:\n```\n\n### Constants:\n- The constant used in the main code is `max_results`, which determines the maximum number of distribution names to return.\n\n### Input and Output Format:\n- **Input**: \n  - `filter_keyword`: A string that may be used to filter the distribution names.\n  - `max_results`: An integer specifying the maximum number of results to return.\n  - `format_output`: A boolean indicating whether to format the output names.\n\n- **Output**: \n  - A dictionary containing:\n    - `total_distributions_found`: An integer representing the total number of distributions found.\n    - `preview`: A list of strings representing the limited list of distribution names.\n    - `full_list`: A list of strings representing the full list of distribution names, potentially with an ellipsis if there are more than `max_results`.\n\nInput: `(\"norm\", 5, True)`\nOutput: `{'total_distributions_found': 12, 'preview': ['norm', 'exponnorm', 'foldnorm', 'halfnorm', 'norminvgauss'], 'full_list': ['norm', 'exponnorm', 'foldnorm', 'halfnorm', 'norminvgauss', '...']}`\n", "ground_truth_code": "import scipy.stats as stat\n\n\n# main code\ndef get_distributions(filter_keyword, max_results, format_output):\n    discovered_distributions = []\n    discovered_distributions.extend([dist for dist in stat._continuous_distns._distn_names])\n    discovered_distributions.extend([dist for dist in stat._discrete_distns._distn_names])\n\n    def preprocess(name):\n        formatted_name = name.strip()\n        if format_output:\n            formatted_name = formatted_name.lower().replace(\"_\", \"-\")\n        return formatted_name\n\n    cleaned_distributions = [preprocess(name) for name in discovered_distributions]\n\n    if filter_keyword:\n        filter_keyword = filter_keyword.lower()\n        cleaned_distributions = [name for name in cleaned_distributions if filter_keyword in name]\n\n    total_found = len(cleaned_distributions)\n    limited_results = cleaned_distributions[:max_results] if max_results > 0 else cleaned_distributions\n\n    summary = {\n        \"total_distributions_found\": total_found,\n        \"preview\": limited_results,\n        \"full_list\": limited_results if total_found <= max_results else limited_results + [\"...\"]\n    }\n    return summary", "test_script": "import random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        if random.random() < 0.3:\n            filter_keyword = None\n        else:\n            filter_keyword = ''.join(random.choices(string.ascii_lowercase, k=random.randint(1, 10)))\n\n        max_results = random.choice([-1] + [random.randint(1, 50)])\n        format_output = random.choice([True, False])\n\n        test_cases.append((filter_keyword, max_results, format_output))\n\n    return test_cases"}
{"problem_id": "scipy_75", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the Laplacian matrix for a one-dimensional grid of nodes. The Laplacian matrix is a key component in various numerical methods, particularly in finite element analysis and graph theory. The function should allow for customization of the matrix through parameters such as the number of nodes, a stiffness coefficient, optional weights, normalization, and a smoothing technique.\n\nFunction Signature:\n```python\ndef get_laplacian_1d(node, K, weight, normalize, smoother):\n```\n\n### Constants:\n- The constant `K` is set to `1` if it is provided as `None`.\n\n### Input Format:\n- `node`: An integer or a numpy array representing the nodes.\n- `K`: A float or `None`, representing the stiffness coefficient.\n- `weight`: A numpy array or `None`, representing weights for the diagonal.\n- `normalize`: A boolean indicating whether to normalize the matrix.\n- `smoother`: A string indicating the smoothing technique (e.g., 'jacobi').\n\n### Output Format:\n- The function returns a sparse matrix of type `csr_matrix`, representing the Laplacian matrix of the specified one-dimensional grid.\n\n**Input:**\n```python\nnode = np.linspace(0, 1, 10)\nK = 2.5\nweight = np.random.uniform(0.1, 1, size=(10,))\nnormalize = True\nsmoother = 'jacobi'\n```\n\n**Output:**\n```python\n<10x10 sparse matrix of type '<class 'numpy.float64'>'\n\twith 28 stored elements in Compressed Sparse Row format>\n```", "ground_truth_code": "from scipy.sparse import csr_matrix, diags\nimport numpy as np\nfrom numpy.core.numeric import identity\n\n# main code\ndef get_laplacian_1d(node, K, weight, normalize, smoother):\n\n    if isinstance(node, int):\n        node = np.linspace(0, 1, node)\n\n    N = node.shape[0]\n    h = node[1:] - node[:-1]\n    elem = np.c_[np.arange(N - 1), np.arange(1, N)]\n    Dphi = np.c_[-1 / h, 1 / h]\n\n    K = 1 if K is None else K\n    A = csr_matrix((N, N))\n\n    for i in range(2):\n        for j in range(2):\n            Aij = h * K * Dphi[:, i] * Dphi[:, j]\n            A += csr_matrix((Aij, (elem[:, i], elem[:, j])), shape=(N, N))\n\n    if weight is not None:\n        A += diags(weight)\n\n    if normalize:\n        D = diags(A.diagonal() ** (-0.5))\n        A = D.dot(A).dot(D)\n\n        if smoother == 'jacobi':\n            I = identity(N)\n            A = I - 2 / 3 * A\n            A = csr_matrix(A)\n\n    return A", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        if random.choice([True, False]):\n            node = random.randint(5, 100)\n        else:\n            node_count = random.randint(5, 100)\n            node = np.linspace(0, 1, node_count)\n\n        K = random.choice([None, random.uniform(0.1, 10)])\n        if random.choice([True, False]):\n            weight = np.random.uniform(0.1, 10, size=(node if isinstance(node, int) else node.shape[0]))\n        else:\n            weight = None\n\n        normalize = random.choice([True, False])\n\n        if normalize:\n            smoother = random.choice([None, 'jacobi'])\n        else:\n            smoother = None\n\n        test_cases.append((node, K, weight, normalize, smoother))\n\n    return test_cases"}
{"problem_id": "scipy_76", "library": "scipy", "code_problem": "You are tasked with analyzing traffic flow data to understand the relationships between density, flow, and other related metrics. The goal is to preprocess the data, fit curves to the fundamental diagram, and compute stability scores based on the fitted parameters.\n\nThe main function signature is as follows:\n```python\ndef reveal_the_truth(raw_data):\n```\n\n### Constants Used:\n- A small constant `1e-08` is used in the normalization function to prevent division by zero.\n\n### Input Format:\n- The input to the `reveal_the_truth` function is a tuple containing multiple arrays representing traffic metrics, specifically:\n  - density, flow, updates, densityrv, flowrv, densityav, flowav, clnum, avgclsize.\n\n### Output Format:\n- The output of the `reveal_the_truth` function is a tuple containing:\n  - FD_arr: A list of arrays representing the fitted fundamental diagram.\n  - FD_RV_arr: A list of arrays representing the fitted RV fundamental diagram.\n  - FD_AV_arr: A list of arrays representing the fitted AV fundamental diagram.\n  - params: A list of parameters for the fitted curves.\n  - analysis_results: A dictionary containing critical points and stability scores.\n\nInput:\n```python\nraw_data = (\n    np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]),\n    np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]),\n    np.array([10, 20, 30, 40, 50, 60, 70, 80, 90, 100]),\n    np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]),\n    np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]),\n    np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]),\n    np.array([1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]),\n    np.array([5, 10, 15, 20, 25, 30, 35, 40, 45, 50]),\n    np.array([1, 2, 3, 4, 5, 6, 7, 8, 9, 10])\n)\n```\n\nOutput:\n```python\n(\n    [array([0.00000000e+00, 3.33444481e-04, 6.66888963e-04, ...,\n       9.99333111e-01, 9.99666556e-01, 1.00000000e+00]), array([ 9.99999989e-01,  9.99666544e-01,  9.99333100e-01, ...,\n        6.66877852e-04,  3.33433370e-04, -1.11111110e-08])], \n    [array([0.00000000e+00, 3.33444481e-04, 6.66888963e-04, ...,\n       9.99333111e-01, 9.99666556e-01, 1.00000000e+00]), array([ 9.99999989e-01,  9.99666544e-01,  9.99333100e-01, ...,\n        6.66877852e-04,  3.33433370e-04, -1.11111110e-08])], \n    [array([0.00000000e+00, 3.33444481e-04, 6.66888963e-04, ...,\n       9.99333111e-01, 9.99666556e-01, 1.00000000e+00]), array([ 9.99999989e-01,  9.99666544e-01,  9.99333100e-01, ...,\n        6.66877852e-04,  3.33433370e-04, -1.11111110e-08])], \n    [array([ 0.50000001,  0.49999998, -1.        , -1.        ]), array([ 0.50000001,  0.49999998, -1.        , -1.        ]), array([ 0.50000001,  0.49999998, -1.        , -1.        ])], \n    {\n        'Critical Points': [(0.5000000109159451, 0.4999999779729439, -1.0, -1.0), (0.5000000109159451, 0.4999999779729439, -1.0, -1.0), (0.5000000109159451, 0.4999999779729439, -1.0, -1.0)], \n        'Stability': {\n            'Overall Stability': -0.0, \n            'RV Stability': -0.0, \n            'AV Stability': -0.0\n        }\n    }\n)\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import optimize\n\ndef remove_outliers(arr):\n    (q1, q3) = np.percentile(arr, [25, 75])\n    iqr = q3 - q1\n    (lower_bound, upper_bound) = (q1 - 1.5 * iqr, q3 + 1.5 * iqr)\n    return np.array([x if lower_bound <= x <= upper_bound else np.median(arr) for x in arr])\n\ndef normalize(arr):\n    return (arr - np.min(arr)) / (np.max(arr) - np.min(arr) + 1e-08)\n\ndef preprocess_data(data):\n    (density, flow, updates, densityrv, flowrv, densityav, flowav, clnum, avgclsize) = data\n    (density, flow, updates) = map(remove_outliers, [density, flow, updates])\n    (densityrv, flowrv) = map(remove_outliers, [densityrv, flowrv])\n    (densityav, flowav) = map(remove_outliers, [densityav, flowav])\n    (clnum, avgclsize) = map(remove_outliers, [clnum, avgclsize])\n    (density, flow, updates) = map(normalize, [density, flow, updates])\n    (densityrv, flowrv) = map(normalize, [densityrv, flowrv])\n    (densityav, flowav) = map(normalize, [densityav, flowav])\n    (clnum, avgclsize) = map(normalize, [clnum, avgclsize])\n    return (density, flow, updates, densityrv, flowrv, densityav, flowav, clnum, avgclsize)\n\ndef piecewise_linear(x, x0, y0, k1, k2):\n    return np.piecewise(x, [x < x0], [lambda x: k1 * x + y0 - k1 * x0, lambda x: k2 * x + y0 - k2 * x0])\n\ndef fit_curve(x, y, max_index):\n    p0 = [np.median(x), max(y), 0.5, -0.5]\n    y_weight = np.full(len(y), 1.0)\n    y_weight[0], y_weight[-1] = 0.1, 0.1\n    y_weight[max_index] = 0.5\n    (p, e) = optimize.curve_fit(piecewise_linear, x, y, p0, sigma=y_weight, absolute_sigma=True, maxfev=5000)\n    return (p, np.sqrt(np.diag(e)))\n\ndef analyze_fundamental_diagram(data):\n    (density, flow, updates, densityrv, flowrv, densityav, flowav, clnum, avgclsize) = data\n    (FD_arr, FD_RV_arr, FD_AV_arr, params) = ([], [], [], [])\n    flow_max_index = flow.tolist().index(max(flow))\n    flowrv_max_index = flowrv.tolist().index(max(flowrv))\n    flowav_max_index = flowav.tolist().index(max(flowav))\n    N = 3000\n    xd = np.linspace(0, 1, N)\n    xdrv = np.linspace(0, 1, N)\n    xdav = np.linspace(0, 1, N)\n    (p, _) = fit_curve(density, flow, flow_max_index)\n    FD_arr.extend([xd, piecewise_linear(xd, *p)])\n    (prv, _) = fit_curve(densityrv, flowrv, flowrv_max_index)\n    FD_RV_arr.extend([xdrv, piecewise_linear(xdrv, *prv)])\n    (pav, _) = fit_curve(densityav, flowav, flowav_max_index)\n    FD_AV_arr.extend([xdav, piecewise_linear(xdav, *pav)])\n    params.extend([p, prv, pav])\n    return (FD_arr, FD_RV_arr, FD_AV_arr, params)\n\ndef compute_stability(params):\n    def calculate_critical_points(params):\n        (x0, y0, k1, k2) = params\n        return (x0, y0, k1, k2)\n\n    overall_critical = calculate_critical_points(params[0])\n    rv_critical = calculate_critical_points(params[1])\n    av_critical = calculate_critical_points(params[2])\n\n    stability_scores = {\n        'Overall Stability': abs(params[0][2] - params[0][3]) / max(params[0][2], params[0][3]),\n        'RV Stability': abs(params[1][2] - params[1][3]) / max(params[1][2], params[1][3]),\n        'AV Stability': abs(params[2][2] - params[2][3]) / max(params[2][2], params[2][3])\n    }\n\n    return {'Critical Points': [overall_critical, rv_critical, av_critical], 'Stability': stability_scores}\n\n# main code\ndef reveal_the_truth(raw_data):\n    processed_data = preprocess_data(raw_data)\n    (FD_arr, FD_RV_arr, FD_AV_arr, params) = analyze_fundamental_diagram(processed_data)\n    analysis_results = compute_stability(params)\n    return (FD_arr, FD_RV_arr, FD_AV_arr, params, analysis_results)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = tuple(np.random.rand(100) for _ in range(9))\n        test_cases.append(data)\n    return test_cases\n\n"}
{"problem_id": "scipy_77", "library": "scipy", "code_problem": "You are tasked with implementing a function that solves a system of linear equations using the Conjugate Gradient method for sparse matrices. The function should handle cases where the number of features is greater than the number of samples and vice versa. The input to the function will be a sparse matrix \\( X \\), a target matrix \\( y \\), a regularization parameter \\( \\alpha \\), a maximum number of iterations \\( max\\_iter \\), and a tolerance level \\( tol \\).\n\nThe function signature of the main code is as follows:\n\n```python\ndef _solve_sparse_cg(X, y, alpha, max_iter, rtol):\n```\n\nIn the main code, the constant used is `curr_alpha`, which is derived from the `alpha` parameter passed to the function.\n\nInput format:\n- \\( X \\): A sparse matrix of shape (n_samples, n_features).\n- \\( y \\): A target matrix of shape (n_samples, n_outputs).\n- \\( \\alpha \\): A 1D array of regularization parameters of length n_outputs.\n- \\( max\\_iter \\): An integer representing the maximum number of iterations for the conjugate gradient solver.\n- \\( tol \\): A float representing the tolerance level for convergence.\n\nOutput format:\n- Returns a 2D array of shape (n_outputs, n_features) containing the computed coefficients for each output in \\( y \\).\n\n**Input:**\n```python\n(<10x3 sparse matrix of type '<class 'numpy.float32'>'\n\twith 3 stored elements in Compressed Sparse Row format>, \narray([[ 1.504705  , -1.0094401 ,  1.0015285 ],\n       [-0.45731205, -0.3521188 , -0.16311274],\n       [-1.2978926 , -0.62546766,  0.18847477],\n       [-1.0518662 ,  0.31046006, -0.76397455],\n       [-0.37278602,  0.77084655, -0.00929324],\n       [ 0.6308795 , -0.2926875 , -0.60900843],\n       [ 0.27699968, -1.0804272 ,  1.1442628 ],\n       [ 0.71879655,  0.4955261 ,  1.176533  ],\n       [ 1.321371  , -0.802135  , -1.7325853 ],\n       [-0.5165726 ,  0.01510037,  1.4024924 ]], dtype=float32), \narray([ 0.46674578, -0.04383035,  0.05576662]), \n119, \n0.0033900810705483875\n)\n\n```\n\n**Output:**\n```python\narray([[ 0.59968567,  0.58895731,  0.        ],\n       [70.62730408, -0.2128408 ,  0.        ],\n       [ 2.09546185, -1.52151966,  0.        ]])\n```", "ground_truth_code": "from scipy.sparse import linalg as sp_linalg\nimport numpy as np\n\ndef create_mv(curr_alpha, X1, n_features, n_samples):\n\n    def _mv(x):\n        if n_features > n_samples:\n            return X1.matvec(X1.rmatvec(x)) + curr_alpha * x\n        else:\n            return X1.rmatvec(X1.matvec(x)) + curr_alpha * x\n    return _mv\n\n# main code\ndef _solve_sparse_cg(X, y, alpha, max_iter, rtol):\n    (n_samples, n_features) = X.shape\n    X1 = sp_linalg.aslinearoperator(X)\n    coefs = np.empty((y.shape[1], n_features))\n    for i in range(y.shape[1]):\n        y_column = y[:, i]\n        mv = create_mv(alpha[i], X1, n_features, n_samples)\n        if n_features > n_samples:\n            C = sp_linalg.LinearOperator((n_samples, n_samples), matvec=mv, dtype=X.dtype)\n            (coef, info) = sp_linalg.cg(C, y_column, rtol=rtol)\n            coefs[i] = X1.rmatvec(coef)\n        else:\n            y_column = X1.rmatvec(y_column)\n            C = sp_linalg.LinearOperator((n_features, n_features), matvec=mv, dtype=X.dtype)\n            (coefs[i], info) = sp_linalg.cg(C, y_column, maxiter=max_iter, rtol=rtol)\n    return coefs", "test_script": "import numpy as np\nimport scipy\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        n_samples = np.random.randint(50, 100)\n        n_features = np.random.randint(50, 100)\n\n        X = scipy.sparse.random(n_samples, n_features, density=0.1, format='csr', dtype=np.float32)\n        alpha = np.random.uniform(-1, 1, size=n_features)\n        y = np.random.randn(n_samples, n_features).astype(np.float32)\n        max_iter = np.random.randint(50, 200)\n        tol = np.random.uniform(1e-6, 1e-2)\n        test_case = (X, y, alpha, max_iter, tol)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "scipy_78", "library": "scipy", "code_problem": "Implement a function that calculates the distance correlation between two datasets. The function should preprocess the input data, compute distance matrices, and then calculate the distance correlation, optionally providing statistical testing results.\n\nFunction Signature:\n```python\ndef distance_correlation(x: np.ndarray, y: np.ndarray, bias_corrected: bool = True, ttest: bool = True) -> dict:\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used in the calculation of the adjusted number of observations in the bias-corrected case.\n\n### Input Format:\n- `x`: A numpy array of shape (n_samples, n_features) or (n_samples,) representing the first dataset.\n- `y`: A numpy array of shape (n_samples, n_features) or (n_samples,) representing the second dataset.\n- `bias_corrected`: A boolean indicating whether to use bias correction in the distance correlation calculation (default is True).\n- `ttest`: A boolean indicating whether to perform a t-test for statistical significance (default is True).\n\n### Output Format:\n- The function returns a dictionary containing:\n  - `'dcorr'`: The distance correlation value (non-negative).\n  - If `bias_corrected` is True, it also includes:\n    - `'dcorr_squared'`: The squared distance correlation value.\n  - If `ttest` is True, it includes:\n    - `'t'`: The t-statistic value.\n    - `'p'`: The p-value from the t-test.\n    - `'df'`: The degrees of freedom used in the t-test.\n\nInput:\n```python\nx = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]])\ny = np.array([[0.2, 0.1], [0.4, 0.3], [0.6, 0.5]])\n```\n\nOutput:\n```python\n{\n    'dcorr': 0, \n    'dcorr_squared': nan, \n    't': nan, \n    'p': nan, \n    'df': 0.5\n}\n```", "ground_truth_code": "import numpy as np\nfrom scipy.spatial.distance import squareform, pdist\nfrom scipy.stats import t as t_dist\n\n\ndef preprocess_data(x, y):\n\n    if len(x.shape) == 1:\n        x = x[:, np.newaxis]\n    if len(y.shape) == 1:\n        y = y[:, np.newaxis]\n    return x, y\n\ndef compute_distance_matrix(x, y):\n\n    x_dist = squareform(pdist(x))\n    y_dist = squareform(pdist(y))\n    return x_dist, y_dist\n\ndef u_center(mat):\n    dim = mat.shape[0]\n    u_mu = mat.sum() / ((dim - 1) * (dim - 2))\n    sum_cols = mat.sum(axis=0, keepdims=True)\n    sum_rows = mat.sum(axis=1, keepdims=True)\n    u_mu_cols = np.ones((dim, 1)).dot(sum_cols / (dim - 2))\n    u_mu_rows = (sum_rows / (dim - 2)).dot(np.ones((1, dim)))\n    out = np.copy(mat)\n    out -= u_mu_rows\n    out -= u_mu_cols\n    out += u_mu\n    out[np.eye(dim, dtype=bool)] = 0\n    return out\n\ndef double_center(mat):\n    row_mean = mat.mean(axis=0, keepdims=True)\n    col_mean = mat.mean(axis=1, keepdims=True)\n    grand_mean = mat.mean()\n    return mat - row_mean - col_mean + grand_mean\n\ndef compute_distance_correlation(x_dist, y_dist, bias_corrected):\n    if bias_corrected:\n        x_dist_cent = u_center(x_dist)\n        y_dist_cent = u_center(y_dist)\n        adjusted_n = x_dist.shape[0] * (x_dist.shape[0] - 3)\n        xy = np.multiply(x_dist_cent, y_dist_cent).sum() / adjusted_n\n        xx = np.multiply(x_dist_cent, x_dist_cent).sum() / adjusted_n\n        yy = np.multiply(y_dist_cent, y_dist_cent).sum() / adjusted_n\n    else:\n        x_dist_cent = double_center(x_dist)\n        y_dist_cent = double_center(y_dist)\n        xy = np.multiply(x_dist_cent, y_dist_cent).mean()\n        xx = np.multiply(x_dist_cent, x_dist_cent).mean()\n        yy = np.multiply(y_dist_cent, y_dist_cent).mean()\n\n    denom = np.sqrt(xx * yy)\n    dcor = xy / denom\n    return dcor\n\n\ndef post_process_distance_correlation(dcor, bias_corrected, ttest, adjusted_n):\n    out = {'dcorr': max(0, np.sqrt(dcor))}\n\n    if bias_corrected:\n        out['dcorr_squared'] = dcor\n\n    if ttest:\n        dof = adjusted_n / 2 - 1\n        t_stat = np.sqrt(dof) * (dcor / np.sqrt(1 - dcor ** 2))\n        p_value = 1 - t_dist.cdf(t_stat, dof)\n        out.update({'t': t_stat, 'p': p_value, 'df': dof})\n\n    return out\n\n# main code\ndef distance_correlation(x, y, bias_corrected=True, ttest=True):\n    x, y = preprocess_data(x, y)\n    x_dist, y_dist = compute_distance_matrix(x, y)\n    dcor = compute_distance_correlation(x_dist, y_dist, bias_corrected)\n    out = post_process_distance_correlation(dcor, bias_corrected, ttest, x.shape[0])\n    return out", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(5, 50)\n        x = np.random.rand(num_samples, np.random.randint(1, 5))\n        y = np.random.rand(num_samples, np.random.randint(1, 5))\n\n        test_cases.append((x, y))\n\n    return test_cases"}
{"problem_id": "scipy_79", "library": "scipy", "code_problem": "You are tasked with implementing a function that applies the Savitzky-Golay filter to a 2D array (matrix) for smoothing or differentiating data. The Savitzky-Golay filter is a digital filter that can be applied to a set of data points to enhance the signal-to-noise ratio without greatly distorting the signal. Your implementation should allow for different orders of polynomial fitting and the option to compute derivatives.\n\nFunction signature:\n```python\ndef savitzky_golay2d(z: np.ndarray, window: int, order: int, deriv: Union[None, int, str]) -> Union[np.ndarray, Tuple[np.ndarray, np.ndarray]]:\n```\n\nConstants used in the main code:\n- `half_size`: This constant is calculated as half of the `window` size, which is used to create a padded version of the input array.\n\nInput format:\n- `z`: A 2D numpy array representing the data to be filtered.\n- `window`: An integer representing the size of the filter window (must be an odd integer).\n- `order`: An integer representing the order of the polynomial used for fitting.\n- `deriv`: Can be `None`, an integer (0, 1, 2, or 3), or a string ('both', 'col', 'row') indicating the type of derivative to compute.\n\nOutput format:\n- Returns a numpy array containing the filtered data. If `deriv` is set to compute derivatives, it returns a tuple of two numpy arrays: one for the row derivative and one for the column derivative.\n\n**Input:**\n```python\nz = np.array([[1, 2, 3], \n              [4, 5, 6], \n              [7, 8, 9]])\nwindow = 3\norder = 2\nderiv = None\n```\n\n**Output:**\n```python\narray([[1.        , 2.        , 3.33333333],\n       [4.        , 5.        , 6.        ],\n       [7.77777778, 8.        , 9.        ]])\n```\n", "ground_truth_code": "import numpy as np\nimport scipy.signal as sps\n\n\n# main code\ndef savitzky_golay2d(z, window, order, deriv):\n    half_size = window // 2\n    exps = [(k - n, n) for k in range(order + 1) for n in range(k + 1)]\n    ind = np.arange(-half_size, half_size + 1, dtype=np.float64)\n    dx = np.repeat(ind, window)\n    dy = np.tile(ind, [window, 1]).reshape(window ** 2)\n    A = np.empty((window ** 2, len(exps)))\n    for i, exp in enumerate(exps):\n        A[:, i] = dx ** exp[0] * dy ** exp[1]\n\n    new_shape = (z.shape[0] + 2 * half_size, z.shape[1] + 2 * half_size)\n    Z = np.zeros(new_shape)\n    Z[half_size:-half_size, half_size:-half_size] = z\n\n\n    Z[:half_size, half_size:-half_size] = z[0, :]\n    Z[-half_size:, half_size:-half_size] = z[-1, :]\n    Z[half_size:-half_size, :half_size] = z[:, 0].reshape(-1, 1)\n    Z[half_size:-half_size, -half_size:] = z[:, -1].reshape(-1, 1)\n\n    Z[:half_size, :half_size] = z[0, 0]\n    Z[-half_size:, -half_size:] = z[-1, -1]\n\n    if deriv is None or deriv == 0:\n        m = np.linalg.pinv(A)[0].reshape((window, -1))\n        return sps.convolve(Z, m, mode='valid')\n    elif deriv == 'both' or deriv == 1:\n        c = np.linalg.pinv(A)[1].reshape((window, -1))\n        r = np.linalg.pinv(A)[2].reshape((window, -1))\n        return (sps.convolve(Z, r, mode='valid'), sps.convolve(Z, c, mode='valid'))\n    elif deriv == 'col' or deriv == 2:\n        c = np.linalg.pinv(A)[1].reshape((window, -1))\n        return sps.convolve(Z, c, mode='valid')\n    elif deriv == 'row' or deriv == 3:\n        r = np.linalg.pinv(A)[2].reshape((window, -1))\n        return sps.convolve(Z, r, mode='valid')\n    return None\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        height = np.random.randint(5, 15)\n        width = np.random.randint(5, 15)\n        z = np.random.randn(height, width)\n        window = np.random.choice([3, 5, 7, 9, 11])\n        order = np.random.choice([2, 3])\n        deriv_choice = np.random.choice([None, 0, 'both', 1, 2, 3])\n        test_cases.append((z, window, order, deriv_choice))\n\n    return test_cases\n"}
{"problem_id": "scipy_80", "library": "scipy", "code_problem": "You are tasked with creating a function that estimates the parameters of various statistical distributions based on a given dataset. The function will take in a dataset and a specified distribution type, and it will return the estimated parameters for that distribution.\n\nFunction signature:\n```python\ndef estimate_distribution_parameters(cleaned_data, distribution):\n```\n\nIn the main code, the following constant is used:\n- `distribution`: A string that specifies the type of distribution for which the parameters are to be estimated. It can take values such as 'normal', 't', 'gamma', 'lognormal', or 'exponential'.\n\nInput format:\n- `cleaned_data`: A list or array-like structure containing numerical data points.\n- `distribution`: A string indicating the type of distribution to fit ('normal', 't', 'gamma', 'lognormal', or 'exponential').\n\nOutput format:\n- Returns a tuple containing the estimated parameters of the specified distribution, or `None` if the distribution type is invalid.\n\nInput:\n```python\ncleaned_data = np.array([1.2, 2.3, 2.1, 1.8, 2.5, 1.9, 2.0, 1.7, 2.4, 1.6])\ndistribution = 'normal'\n```\n\nOutput:\n```python\nparams = (1.9500000000000004, 0.3774917217635375)\n```", "ground_truth_code": "import scipy.stats as stats\n\n\n# main code\ndef estimate_distribution_parameters(cleaned_data, distribution):\n    if distribution == 'normal':\n        params = stats.norm.fit(cleaned_data)\n    elif distribution == 't':\n        params = stats.t.fit(cleaned_data)\n    elif distribution == 'gamma':\n        params = stats.gamma.fit(cleaned_data)\n    elif distribution == 'lognormal':\n        params = stats.lognorm.fit(cleaned_data)\n    elif distribution == 'exponential':\n        params = stats.expon.fit(cleaned_data)\n    else:\n        return None\n    return params", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def preprocess_data(data):\n        cleaned_data = np.array(data, dtype=np.float64)\n        cleaned_data = cleaned_data[~np.isnan(cleaned_data)]\n        cleaned_data = cleaned_data[np.isfinite(cleaned_data)]\n\n        q1, q3 = np.percentile(cleaned_data, [25, 75])\n        iqr = q3 - q1\n        lower_bound, upper_bound = q1 - 1.5 * iqr, q3 + 1.5 * iqr\n        cleaned_data = cleaned_data[(cleaned_data >= lower_bound) & (cleaned_data <= upper_bound)]\n        return cleaned_data\n\n    test_cases = []\n    distributions = ['normal', 't', 'gamma', 'lognormal', 'exponential']\n\n    for _ in range(n):\n\n        distribution = np.random.choice(distributions)\n\n        if distribution == 'normal':\n            data = np.random.normal(loc=np.random.uniform(-10, 10), scale=np.random.uniform(1, 5),\n                                    size=np.random.randint(50, 200))\n        elif distribution == 't':\n            data = np.random.standard_t(df=np.random.uniform(2, 30), size=np.random.randint(50, 200))\n        elif distribution == 'gamma':\n            shape = np.random.uniform(1, 5)\n            data = np.random.gamma(shape=shape, scale=np.random.uniform(1, 5), size=np.random.randint(50, 200))\n        elif distribution == 'lognormal':\n            mean = np.random.uniform(-1, 2)\n            sigma = np.random.uniform(0.1, 1.5)\n            data = np.random.lognormal(mean, sigma, size=np.random.randint(50, 200))\n        elif distribution == 'exponential':\n            scale = np.random.uniform(1, 5)\n            data = np.random.exponential(scale=scale, size=np.random.randint(50, 200))\n\n        if np.random.rand() < 0.3:\n            num_corrupt = np.random.randint(1, 5)\n            indices = np.random.choice(len(data), num_corrupt, replace=False)\n            data[indices] = np.nan if np.random.rand() < 0.5 else np.inf\n        cleaned_data = preprocess_data(data)\n\n        test_cases.append((cleaned_data, distribution))\n\n    return test_cases\n"}
{"problem_id": "scipy_81", "library": "scipy", "code_problem": "You are tasked with implementing a function that estimates parameters for the Asymmetric Generalized Gaussian Distribution (AGGD) based on a given block of numerical data. The function should analyze the data to compute the parameters alpha, beta_l, and beta_r, which characterize the distribution of the data.\n\nFunction signature:\n```python\ndef estimate_aggd_param(block):\n```\n\n### Constants Used:\n- `start`: 0.2\n- `end`: 10\n- `num_points`: 10000\n\n### Input Format:\n- The input to the function is a NumPy array `block` which can contain both positive and negative numerical values.\n\n### Output Format:\n- The function returns a tuple containing three values: `alpha`, `beta_l`, and `beta_r`, which are all floating-point numbers. If the input is invalid, it returns `(None, None, None)`.\n\nInput:\n```python\narray([[ 0.123, -0.456,  0.789],\n       [-0.234,  0.567, -0.890]])\n```\n\nOutput:\n```python\n(10.0, 1.0574104840152323, 1.0083260182369833)\n```", "ground_truth_code": "import numpy as np\nfrom scipy.special import gamma\n\n# main code\ndef estimate_aggd_param(block):\n    if block is None or block.size == 0:\n        return None, None, None\n\n    block = block.flatten()\n\n    start, end, num_points = 0.2, 10, 10000\n    gam = np.linspace(start, end, num=num_points)\n\n    gam_reciprocal = 1 / gam\n    r_gam = (gamma(gam_reciprocal * 2) ** 2) / (gamma(gam_reciprocal) * gamma(gam_reciprocal * 3))\n\n    left_vals, right_vals = block[block < 0], block[block > 0]\n\n    left_std = np.sqrt(np.mean(left_vals ** 2)) if left_vals.size > 0 else np.finfo(float).eps\n    right_std = np.sqrt(np.mean(right_vals ** 2)) if right_vals.size > 0 else np.finfo(float).eps\n\n    gammahat = left_std / right_std\n    rhat = (np.mean(np.abs(block)) ** 2) / np.mean(block ** 2)\n    rhatnorm = rhat * ((gammahat ** 3 + 1) * (gammahat + 1) / ((gammahat ** 2 + 1) ** 2))\n\n    array_position = np.argmin((r_gam - rhatnorm) ** 2)\n    alpha = gam[array_position]\n\n    beta_l = left_std * np.sqrt(gamma(1 / alpha) / gamma(3 / alpha))\n    beta_r = right_std * np.sqrt(gamma(1 / alpha) / gamma(3 / alpha))\n\n    return alpha, beta_l, beta_r", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 4)))\n        block = np.random.randn(*shape)\n\n        test_cases.append(block)\n    return test_cases"}
{"problem_id": "scipy_82", "library": "scipy", "code_problem": "```python\ndef f0_smooth(pitch_ts, f0s, wav_len, params, smooth=True):\n```\n\nIn this function, the goal is to smooth a given fundamental frequency (F0) time series based on specified parameters. The function takes in several inputs, including timestamps for pitch (`pitch_ts`), the corresponding F0 values (`f0s`), the length of the waveform (`wav_len`), a parameter object (`params`) that contains various smoothing options, and a boolean flag (`smooth`) that indicates whether smoothing should be applied.\n\n### Constants Used:\n- The function uses a constant `fs` which is derived from `params.pitch_fs`. This constant represents the sampling frequency of the pitch data.\n\n\n### Input and Output Format:\n- **Input**:\n  - `pitch_ts`: A 1D array of timestamps for pitch.\n  - `f0s`: A 1D array of fundamental frequency values corresponding to `pitch_ts`.\n  - `wav_len`: A scalar representing the length of the waveform.\n  - `params`: An object containing smoothing parameters.\n  - `smooth`: A boolean indicating whether to apply smoothing.\n\n- **Output**:\n  - A tuple containing:\n    - `f0s_smooth`: A 1D array of smoothed fundamental frequency values.\n    - `t`: A 1D array of time values.\n    - `f0s_t`: A 1D array of interpolated fundamental frequency values at the time vector.\n\n**Input:**\n```python\npitch_ts = np.array([0.1, 0.5, 1.0, 1.5, 2.0])\nf0s = np.array([100, 150, 200, 250, 300])\nwav_len = 2.5\nclass Params:\n    def __init__(self):\n        self.use_median = True\n        self.median_order = 3\n        self.use_lowpass = True\n        self.lowpass_fg = 0.1\n        self.lowpass_order = 20\n        self.pitch_fs = 200\n\nparams = Params()\nsmooth = True\n```\n\n**Output:**\n```python\n(\n    array([100.        , 149.72410845, 200.        , 250.        ,300.        ]),\n    array([0.   , 0.005, 0.01, ...,  2.485, 2.49 , 2.495]),\n    array([87.5,  88.125,  88.75, ...,  348.13822444, 348.57014413, 349.])\n)\n```\n\n**Expected Output Values:**\n- `f0s_smooth`: Smoothed fundamental frequency values at the original pitch timestamps.\n- `t`: Time array from 0 to `wav_len` with a sampling frequency of `params.pitch_fs`.\n- `f0s_t`: Interpolated fundamental frequency values at the time array `t`.\n\n(Note: The actual numerical values of `f0s_smooth`, `t`, and `f0s_t` will depend on the implementation and the random parameters used in the `Params` class.)", "ground_truth_code": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy import signal as sig\n\n# main code\ndef f0_smooth(pitch_ts, f0s, wav_len, params, smooth=True):\n    use_median = params.use_median\n    median_order = params.median_order\n    use_lowpass = params.use_lowpass\n    lowpass_fg = params.lowpass_fg\n    lowpass_order = params.lowpass_order\n    fs = params.pitch_fs\n\n    t = np.arange(0, wav_len, 1 / fs)\n    interfunc = interp1d(pitch_ts, f0s, kind='linear', bounds_error=False, fill_value='extrapolate')\n    f0s_t = interfunc(t)\n\n    if smooth:\n        if use_median:\n            f0s_t = sig.medfilt(f0s_t, kernel_size=median_order)\n        if use_lowpass:\n            b_fir = sig.firwin(lowpass_order, lowpass_fg, window='hamming', pass_zero=True)\n            f0s_t = sig.filtfilt(b_fir, [1], f0s_t)\n        interfunc_back = interp1d(t, f0s_t, kind='linear', bounds_error=False, fill_value='extrapolate')\n        f0s_smooth = interfunc_back(pitch_ts)\n    else:\n        f0s_smooth = np.copy(f0s)\n\n    return f0s_smooth, t, f0s_t", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    class Params:\n        def __init__(self):\n            self.use_median = np.random.choice([True, False])\n            self.median_order = np.random.choice([3, 5, 7])\n            self.use_lowpass = np.random.choice([True, False])\n            self.lowpass_fg = np.random.uniform(0.01, 0.5)\n            self.lowpass_order = np.random.choice([10, 20, 30])\n            self.pitch_fs = np.random.uniform(100, 400)\n\n    test_cases = []\n\n    for _ in range(n):\n        wav_len = np.random.uniform(0.5, 5.0)\n        pitch_fs = np.random.uniform(100, 400)\n        num_pitch_samples = np.random.randint(10, 100)\n\n        pitch_ts = np.sort(np.random.uniform(0, wav_len, num_pitch_samples))\n        f0s = np.abs(np.random.randn(num_pitch_samples)) * 100\n        params = Params()\n        params.pitch_fs = pitch_fs\n\n        test_cases.append((pitch_ts, f0s, wav_len, params, np.random.choice([True, False])))\n\n    return test_cases\n"}
{"problem_id": "scipy_83", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the cumulative distribution function (CDF) of averaged cospectra based on given coordinates and a parameter. The function will utilize mathematical concepts from statistics and special functions.\n\nFunction signature:\n```python\ndef averaged_cospectra_cdf(xcoord, n):\n```\n\nConstant used in the main code:\n- `power_factor` is set to `2.0 ** n`, which is a constant factor based on the input parameter `n`.\n\nInput format:\n- The function accepts two parameters:\n  - `xcoord`: A scalar or a one-dimensional array of float values.\n  - `n`: A positive integer.\n\nOutput format:\n- The function returns a float if `xcoord` is a single value, or a one-dimensional array of float values if `xcoord` is an array.\n\n```python\nInput: (array([-2.3, 0.5, 1.2]), 10)\nOutput: array([2.41419610e-05, 1.74946503e+02, 1.80361092e+02])\n```", "ground_truth_code": "import numpy as np\nfrom scipy.special import factorial, gamma, gammaincc\n\n# main code\ndef averaged_cospectra_cdf(xcoord, n):\n    xcoord = np.atleast_1d(xcoord)\n    cdf = np.zeros_like(xcoord, dtype=np.float64)\n\n    factorial_n_minus_1 = factorial(n - 1)\n    power_factor = 2.0 ** n\n\n    for i, x in enumerate(xcoord):\n        cdf_value = 0.0\n        for j in range(n):\n            prefac = (factorial(n - 1 + j) /\n                      (factorial_n_minus_1 * factorial(n - 1 - j) * factorial(j) * power_factor))\n\n            gf = n - j\n            gamma_gf = gamma(gf)\n\n            if x >= 0:\n                second_fac = gammaincc(gf, n * x) * gamma_gf\n                fac = 2.0 * gamma_gf - second_fac\n            else:\n                fac = gammaincc(gf, -n * x) * gamma_gf\n\n            cdf_value += prefac * fac\n\n        cdf[i] = cdf_value\n\n    return cdf[0] if cdf.size == 1 else cdf", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_val = np.random.randint(1, 20)\n        if np.random.rand() < 0.5:\n            xcoord = np.random.uniform(-5, 5)\n        else:\n            xcoord = np.random.uniform(-5, 5, size=np.random.randint(1, 10))\n\n        test_cases.append((xcoord, n_val))\n\n    return test_cases\n"}
{"problem_id": "scipy_84", "library": "scipy", "code_problem": "You are tasked with implementing a function that fits a specified probability distribution to a given dataset and checks the validity of the fitted parameters. The function should handle various distributions from the `scipy.stats` module and return the shape, location, and scale parameters if the fit is valid. If the fit is invalid or if the input data does not meet certain criteria, the function should return `None`.\n\nFunction signature:\n```python\ndef fit(spsdotwhat, x, fwords):\n```\n\n### Constants Used:\n- The constant `0` is used to check for non-positive values in the shape, location, and scale parameters.\n- The constant `1e10` is used as an upper limit for the parameters of the beta distribution.\n- The constant `0.5` is used as a threshold for the Kolmogorov-Smirnov statistic to determine the goodness of fit.\n\n### Input Format:\n- `spsdotwhat`: A distribution object from `scipy.stats` (e.g., `sps.norm`, `sps.gamma`, etc.).\n- `x`: A 1D array-like structure containing the data to fit.\n- `fwords`: A dictionary of additional fitting parameters (e.g., `{'floc': 0, 'fscale': 1}`).\n\n### Output Format:\n- Returns a tuple containing the shape, location, and scale parameters if the fit is valid.\n- Returns `None` if the fit is invalid or if the input data does not meet the criteria.\n\nInput:\n```python\nspsdotwhat = sps.gamma\nx = np.array([1.2, 2.3, 2.1, 3.5, 2.8, 1.9, 2.4, 3.1, 2.7, 3.0])\nfwords = {}\n```\n\nOutput:\n```python\n(295.4076490403005, -8.477604917677848, 0.03714642739301886)\n```", "ground_truth_code": "import numpy as np\nimport scipy.stats as sps\n\n\ndef check_shape_loc_scale(spsdotwhat, shape_loc_scale):\n    if np.any(np.isnan(shape_loc_scale)) or np.any(np.isinf(shape_loc_scale)):\n        return True\n    if spsdotwhat == sps.norm:\n        return shape_loc_scale[1] <= 0\n    if spsdotwhat in [sps.weibull_min, sps.gamma, sps.rice]:\n        return shape_loc_scale[0] <= 0 or shape_loc_scale[2] <= 0\n    if spsdotwhat == sps.beta:\n        return shape_loc_scale[0] <= 0 or shape_loc_scale[1] <= 0 or shape_loc_scale[0] > 1e10 or shape_loc_scale[\n            1] > 1e10\n    return True\n\n# main code\ndef fit(spsdotwhat, x, fwords):\n    if np.unique(x).size < 2:\n        return None\n    shape_loc_scale = spsdotwhat.fit(x, **fwords) if hasattr(spsdotwhat, 'fit') else (np.nan,)\n\n    if check_shape_loc_scale(spsdotwhat, shape_loc_scale):\n        if spsdotwhat == sps.gamma:\n            x_mean = np.mean(x) - fwords.get('floc', 0)\n            x_var = np.var(x)\n            scale = x_var / x_mean if x_mean != 0 else np.nan\n            shape = x_mean / scale if scale != 0 else np.nan\n            shape_loc_scale = (shape, fwords.get('floc', 0), scale)\n        elif spsdotwhat == sps.beta:\n            y = (x - fwords.get('floc', 0)) / fwords.get('fscale', 1)\n            y_mean = np.mean(y)\n            y_var = np.var(y)\n            p = (y_mean ** 2 * (1.0 - y_mean) / y_var - y_mean) if y_var != 0 else np.nan\n            q = (p * (1.0 - y_mean) / y_mean) if y_mean != 0 else np.nan\n            shape_loc_scale = (p, q, fwords.get('floc', 0), fwords.get('fscale', 1))\n        else:\n            return None\n\n    if check_shape_loc_scale(spsdotwhat, shape_loc_scale):\n        return None\n\n    ks_stat = sps.kstest(x, spsdotwhat.name, args=shape_loc_scale)[0]\n    if ks_stat > 0.5:\n        return None\n\n    return shape_loc_scale", "test_script": "import numpy as np\nimport scipy.stats as sps\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    distributions = [sps.norm, sps.weibull_min, sps.gamma, sps.rice, sps.beta]\n\n    for _ in range(n):\n        spsdotwhat = np.random.choice(distributions)\n        size = np.random.randint(10, 500)\n\n        if spsdotwhat == sps.norm:\n            loc = np.random.uniform(-10, 10)\n            scale = np.random.uniform(0.1, 5)\n            x = spsdotwhat.rvs(loc=loc, scale=scale, size=size)\n            fwords = {}\n        elif spsdotwhat in [sps.weibull_min, sps.gamma, sps.rice]:\n            shape = np.random.uniform(0.1, 5)\n            loc = np.random.uniform(-5, 5)\n            scale = np.random.uniform(0.1, 5)\n            x = spsdotwhat.rvs(shape, loc=loc, scale=scale, size=size)\n            fwords = {}\n        elif spsdotwhat == sps.beta:\n            a = np.random.uniform(0.1, 5)\n            b = np.random.uniform(0.1, 5)\n            loc = np.random.uniform(-5, 5)\n            scale = np.random.uniform(0.1, 5)\n            x = spsdotwhat.rvs(a, b, loc=loc, scale=scale, size=size)\n            fwords = {}\n        else:\n            continue\n\n        test_cases.append((spsdotwhat, x, fwords))\n\n    return test_cases\n"}
{"problem_id": "scipy_85", "library": "scipy", "code_problem": "You are tasked with implementing a function that performs a Quantile-Quantile (QQ) plot analysis to compare the distribution of a dataset against a specified theoretical distribution. The function should compute the theoretical and observed quantiles, fit the specified distribution to the data, and optionally calculate confidence intervals for the fitted line.\n\nFunction signature:\n```python\ndef qqplot(x, dist, sparams, confidence):\n```\n\n### Constants:\n- The constant used in the main code is `3 / 8`, which is used in the `_ppoints` function to determine the adjustment for the probability points when the sample size `n` is less than or equal to 10.\n\n### Input Format:\n- `x`: A list or array-like structure containing numerical data points.\n- `dist`: A string representing the name of the distribution (e.g., 'norm' for normal distribution).\n- `sparams`: A single shape parameter or a tuple/list of shape parameters for the distribution.\n- `confidence`: A boolean value indicating whether to calculate confidence intervals.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `\"theoretical_quantiles\"`: Array of theoretical quantiles.\n  - `\"observed_quantiles\"`: Array of observed quantiles.\n  - `\"slope\"`: The slope of the fitted line.\n  - `\"intercept\"`: The intercept of the fitted line.\n  - `\"r_squared\"`: The R-squared value of the regression.\n  - `\"confidence_upper\"`: Array of upper confidence interval bounds (or None if not calculated).\n  - `\"confidence_lower\"`: Array of lower confidence interval bounds (or None if not calculated).\n\n**Input:**\n```python\n(\n    [0.5, 1.2, 1.8, 2.5, 3.0, 3.5, 4.1, 4.8, 5.2, 6.0],  # Sample data\n    \"norm\",  # Distribution name\n    (1, 1),  # Parameters for the normal distribution (mean, std)\n    0.95  # Confidence level\n)\n```\n\n**Output:**\n```python\n{\n    'theoretical_quantiles': array([-0.49876728,  0.01505333,  0.35296197,  0.62890181,  0.87878591, 1.12121409,  1.37109819,  1.64703803,  1.98494667,  2.49876728]), \n    'observed_quantiles': array([-1.61949969, -1.20875701, -0.85669186, -0.44594919, -0.15256156, 0.14082606,  0.49289121,  0.90363388,  1.13834398,  1.60776418]), \n    'slope': 1.1447757263561225, \n    'intercept': -1.144775726356122, \n    'r_squared': 0.9927093478998735, \n    'confidence_upper': array([-1.23381081, -0.47787723,  0.08546114,  0.61143178,  1.16334458, 1.79809028,  2.60152553,  3.75428778,  5.78558959, 11.37197173]), \n    'confidence_lower': array([-2.19769399, -1.77720886, -1.56688799, -1.46108018, -1.44087047,  -1.52056439, -1.75187713, -2.27286092, -3.5305035 , -7.94046694])\n}\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy import stats\n\ndef _ppoints(n):\n    a = 3 / 8 if n <= 10 else 0.5\n    return (np.arange(n) + 1 - a) / (n + 1 - 2 * a)\n\n# Main function\ndef qqplot(x, dist, sparams, confidence):\n    if isinstance(dist, str):\n        dist = getattr(stats, dist)\n\n    x = np.asarray(x)\n    x = x[~np.isnan(x)]\n\n    if not isinstance(sparams, (tuple, list)):\n        sparams = (sparams,)\n\n    quantiles = stats.probplot(x, sparams=sparams, dist=dist, fit=False)\n    theor, observed = quantiles[0], quantiles[1]\n\n    fit_params = dist.fit(x)\n    loc = fit_params[-2]\n    scale = fit_params[-1]\n    shape = fit_params[:-2] if len(fit_params) > 2 else None\n\n    if loc != 0 and scale != 1:\n        observed = (np.sort(observed) - loc) / scale\n\n    slope, intercept, r, _, _ = stats.linregress(theor, observed)\n\n    if confidence:\n        n = x.size\n        P = _ppoints(n)\n        crit = stats.norm.ppf(1 - (1 - confidence) / 2)\n        pdf = dist.pdf(theor) if shape is None else dist.pdf(theor, *shape)\n        se = slope / pdf * np.sqrt(P * (1 - P) / n)\n        upper = slope * theor + intercept + crit * se\n        lower = slope * theor + intercept - crit * se\n    else:\n        upper = lower = None\n\n    return {\n        \"theoretical_quantiles\": theor,\n        \"observed_quantiles\": observed,\n        \"slope\": slope,\n        \"intercept\": intercept,\n        \"r_squared\": r ** 2,\n        \"confidence_upper\": upper,\n        \"confidence_lower\": lower\n    }", "test_script": "import numpy as np\nfrom scipy import stats\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    distributions = [\"norm\", \"expon\", \"lognorm\", \"gamma\", \"beta\", \"uniform\", \"chi2\"]\n\n    for _ in range(n):\n        dist_name = np.random.choice(distributions)\n        sample_size = np.random.randint(30, 500)\n        if dist_name == \"lognorm\":\n            s = np.random.uniform(0.5, 2.0)\n            data = stats.lognorm.rvs(s, size=sample_size)\n            sparams = (s,)\n        elif dist_name == \"gamma\":\n            shape = np.random.uniform(1.0, 5.0)\n            data = stats.gamma.rvs(shape, size=sample_size)\n            sparams = (shape,)\n        elif dist_name == \"beta\":\n            a, b = np.random.uniform(0.5, 3.0, size=2)\n            data = stats.beta.rvs(a, b, size=sample_size)\n            sparams = (a, b)\n        elif dist_name == \"chi2\":\n            df = np.random.randint(1, 10)\n            data = stats.chi2.rvs(df, size=sample_size)\n            sparams = (df,)\n        else:\n            data = getattr(stats, dist_name).rvs(size=sample_size)\n            sparams = ()\n\n        confidence = np.random.uniform(0.8, 0.99)\n\n        test_cases.append((data.tolist(), dist_name, sparams, confidence, ))\n\n    return test_cases"}
{"problem_id": "scipy_86", "library": "scipy", "code_problem": "You are tasked with implementing a function that processes a raw signal by normalizing it, applying a bandpass filter, and optionally enhancing the output using a Savitzky-Golay filter. The function should be able to handle various parameters that define the characteristics of the signal and the filtering process.\n\nFunction signature:\n```python\ndef signal_processing_journey(raw_signal, sampling_rate, filter_order, low_cutoff, high_cutoff, enhance_output):\n```\n\n### Constants:\n- The Nyquist frequency is calculated as half of the sampling rate.\n\n### Input Format:\n- `raw_signal`: A list or array of numerical values representing the raw signal data.\n- `sampling_rate`: A numerical value representing the sampling rate of the signal.\n- `filter_order`: An integer representing the order of the Butterworth filter.\n- `low_cutoff`: A numerical value representing the low cutoff frequency for the bandpass filter.\n- `high_cutoff`: A numerical value representing the high cutoff frequency for the bandpass filter.\n- `enhance_output`: A boolean value indicating whether to apply the Savitzky-Golay filter for output enhancement.\n\n### Output Format:\n- The function returns a NumPy array containing the processed signal after normalization, filtering, and optional enhancement.\n\nInput:\n```python\n(\n    [0.4, -0.2, 0.6, 1.4, -0.2, -0.2, 1.4, 0.7, -0.7, 0.5,\n    0.6, 0.1, 1.8, 1.9, 0.9, -0.3, 1.0, 1.2, -1.7, 1.9,\n    0.3, 0.9, 0.3, 1.5, -0.1, -0.2, 1.5, 0.3, 0.5, 1.0],\n    1000, \n    4, \n    10.0, \n    200.0, \n    True\n)\n```\n\nOutput:\n```python\narray([ 0.01255093,  0.09386076,  0.11027159,  0.03516319, -0.0200258 ,\n        0.03526734,  0.0908271 , -0.06201546, -0.39538789, -0.56220865,\n       -0.24971232,  0.43334303,  0.99882521,  1.03382602,  0.57734425,\n        0.00458716, -0.38227802, -0.52828137, -0.47999565, -0.28059832,\n       -0.0312981 ,  0.09870504,  0.00196657, -0.25689483, -0.49079992,\n       -0.56051478, -0.47888929, -0.3302538 , -0.15157774,  0.06696733])\n```", "ground_truth_code": "import scipy.signal as sig\nimport numpy as np\n\n# main code\ndef signal_processing_journey(raw_signal, sampling_rate, filter_order, low_cutoff, high_cutoff, enhance_output):\n    signal_array = np.array(raw_signal)\n    signal_mean = np.mean(signal_array)\n    signal_std = np.std(signal_array)\n    normalized_signal = (signal_array - signal_mean) / signal_std if signal_std != 0 else signal_array\n\n    nyquist_freq = 0.5 * sampling_rate\n    low_cutoff_norm = low_cutoff / nyquist_freq\n    high_cutoff_norm = high_cutoff / nyquist_freq\n\n    b, a = sig.butter(filter_order, [low_cutoff_norm, high_cutoff_norm], btype='bandpass')\n    filtered_signal = sig.filtfilt(b, a, normalized_signal)\n    if enhance_output:\n        filtered_signal = sig.savgol_filter(filtered_signal, window_length=5, polyorder=2)\n    return filtered_signal\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        signal_length = np.random.randint(100, 10000)\n        raw_signal = np.random.randn(signal_length)\n\n        sampling_rate = np.random.randint(100, 5000)\n\n        filter_order = np.random.randint(1, 10)\n\n        nyquist_freq = 0.5 * sampling_rate\n        low_cutoff = np.random.uniform(0.01 * nyquist_freq, 0.4 * nyquist_freq)\n        high_cutoff = np.random.uniform(low_cutoff + 0.01 * nyquist_freq, 0.49 * nyquist_freq)\n\n        enhance_output = np.random.choice([True, False])\n\n        test_cases.append((raw_signal.tolist(), sampling_rate, filter_order, low_cutoff, high_cutoff, enhance_output))\n\n    return test_cases"}
{"problem_id": "scipy_87", "library": "scipy", "code_problem": "You are tasked with implementing a signal filtering function that processes a given signal based on specified parameters. The function will preprocess the signal, apply a Butterworth filter, and then postprocess the filtered signal. The function signature is as follows:\n\n```python\ndef signal_filter(sg, freq, fr, order, mode, remove_mean):\n```\n\n### Constants:\n- The constant `step` is set to `10000`, which defines the chunk size for processing the signal in segments.\n\n### Input Format:\n- `sg`: A NumPy array representing the input signal.\n- `freq`: A single frequency or a list/tuple of two frequencies for bandpass/bandstop filtering.\n- `fr`: The sampling frequency of the signal.\n- `order`: The order of the Butterworth filter.\n- `mode`: A string indicating the type of filter (\"bandpass\" or \"bandstop\").\n- `remove_mean`: A boolean indicating whether to remove the mean from each chunk of the signal.\n\n### Output Format:\n- The function returns a NumPy array representing the filtered and processed signal, or `None` if any input validation fails.\n\n**Input:**\n```python\nsg = np.array([[0.5, -0.2], [0.1, 0.3], [-0.4, 0.6], [0.0, -0.1]], dtype=np.float32)\nfreq = 0.2\nfr = 1.0\norder = 3\nmode = \"lowpass\"\nremove_mean = True\n```\n\n**Output:**\n```python\narray([[ 0.4388506 , -0.4388505 ],\n       [-0.12538591,  0.12538591],\n       [-0.62692934,  0.62692934],\n       [ 0.06269296, -0.0626929 ]], dtype=float32)\n```", "ground_truth_code": "from scipy import signal\nimport numpy as np\n\ndef preprocess_signal(sg):\n    if sg is None or not isinstance(sg, np.ndarray):\n        return None\n    sg = np.nan_to_num(sg)\n    sg = (sg - np.min(sg)) / (np.max(sg) - np.min(sg))\n    return sg\n\n\ndef postprocess_signal(sg):\n    sg = np.clip(sg, -1, 1)\n    sg *= 1000\n    return sg\n\n# main code\ndef signal_filter(sg, freq, fr, order, mode, remove_mean):\n    sg = preprocess_signal(sg)\n    if sg is None or freq is None or fr is None:\n        return None\n\n    if mode in [\"bandpass\", \"bandstop\"]:\n        if isinstance(freq, (list, tuple)) and len(freq) == 2:\n            low, high = sorted(freq)\n            if low <= 0 or high >= fr:\n                return None\n            normFreq = [low / fr, high / fr]\n        else:\n\n            low = np.random.uniform(0.1, fr * 0.4)\n            high = np.random.uniform(low * 1.2, fr * 0.9)\n            normFreq = [low / fr, high / fr]\n    else:\n        if freq <= 0 or freq >= fr:\n            return None\n        normFreq = freq / fr\n\n    b, a = signal.butter(order, normFreq, mode)\n\n    step = 10000\n    for i in range(0, sg.shape[0], step):\n        temp_sig = sg[i:i + step]\n        if remove_mean:\n            temp_sig -= temp_sig.mean(axis=1)[:, None]\n        sg[i:i + step] = np.single(\n            signal.filtfilt(b, a, temp_sig, method='gust', padtype='odd', padlen=3 * (max(len(b), len(a)) - 1))\n        )\n\n    sg = postprocess_signal(sg)\n    return sg\n\n\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_samples = np.random.randint(1000, 2000)\n        num_channels = np.random.randint(1, 10)\n        sg = np.random.randn(num_samples, num_channels).astype(np.float32)\n        fr = np.random.uniform(100, 1000)\n        freq = np.random.uniform(0.1, fr / 2)\n\n        order = np.random.randint(1, 11)\n        mode = np.random.choice([\"lowpass\", \"highpass\", \"bandpass\", \"bandstop\"])\n\n        remove_mean = np.random.choice([True, False])\n\n        test_cases.append((sg, freq, fr, order, mode, remove_mean))\n\n    return test_cases"}
{"problem_id": "scipy_88", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the dot product of two matrices, which can be either sparse or dense. The function should handle different types of input matrices and return the appropriate result based on their types.\n\nFunction signature:\n```python\ndef dot(X, Y):\n```\n\nConstant used in the main code:\n- The function utilizes the `scipy.sparse` library to handle sparse matrix operations and the `numpy` library for dense matrix operations.\n\nInput format:\n- The function accepts two parameters, `X` and `Y`, which can be either sparse matrices (from `scipy.sparse`) or dense matrices (from `numpy`).\n\nOutput format:\n- The function returns the dot product of the two input matrices, which will be a sparse matrix if at least one of the inputs is sparse, or a dense matrix if both inputs are dense.\n\n**Input:**\n```python\nX = sp.csr_matrix([[1, 0, 0], [0, 0, 3], [4, 0, 0]])\nY = np.array([[0, 2], [1, 0], [0, 1]])\n```\n\n**Output:**\n```python\n<3x2 sparse matrix of type '<class 'numpy.int64'>'\n\twith 3 stored elements in Compressed Sparse Row format>\n```", "ground_truth_code": "import scipy.sparse as sp\nimport numpy as np\n\n# main code\ndef dot(X, Y):\n    if sp.isspmatrix(X) and sp.isspmatrix(Y):\n        return X * Y\n    elif sp.isspmatrix(X) or sp.isspmatrix(Y):\n        return sp.csr_matrix(X) * sp.csr_matrix(Y)\n    else:\n        return np.asmatrix(X) * np.asmatrix(Y)", "test_script": "import scipy.sparse as sp\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        choice = np.random.choice([\"sparse_sparse\", \"sparse_dense\", \"dense_sparse\", \"dense_dense\"])\n\n        # Generate compatible shapes\n        rows = np.random.randint(1, 10)\n        common_dim = np.random.randint(1, 10)\n        cols = np.random.randint(1, 10)\n\n        if choice == \"sparse_sparse\":\n            X = sp.random(rows, common_dim, density=np.random.uniform(0.1, 1.0), format='csr')\n            Y = sp.random(common_dim, cols, density=np.random.uniform(0.1, 1.0), format='csr')\n        elif choice == \"sparse_dense\":\n            X = sp.random(rows, common_dim, density=np.random.uniform(0.1, 1.0), format='csr')\n            Y = np.random.randn(common_dim, cols)\n        elif choice == \"dense_sparse\":\n            X = np.random.randn(rows, common_dim)\n            Y = sp.random(common_dim, cols, density=np.random.uniform(0.1, 1.0), format='csr')\n        else:  # dense_dense\n            X = np.random.randn(rows, common_dim)\n            Y = np.random.randn(common_dim, cols)\n\n        test_cases.append((X, Y))\n\n    return test_cases"}
{"problem_id": "scipy_89", "library": "scipy", "code_problem": "You are tasked with implementing a function that aligns two arrays by minimizing the squared differences between a reference array and a target array. The function should account for potential differences in the lengths of the two arrays by equalizing their sizes before performing the alignment. The alignment is achieved by shifting the target array and finding the optimal shift value that minimizes the differences within a specified region of interest (ROI).\n\nFunction signature:\n```python\ndef chisqr_align(reference: np.ndarray, target: np.ndarray, roi: list, order: int, init: float, bound: float) -> float:\n```\n\nConstants used in the main code:\n- The constant used in the main code is `1`, which is implicitly used in the calculation of the ROI slice and in the return statement.\n\nInput format:\n- `reference`: A NumPy array representing the reference data.\n- `target`: A NumPy array representing the target data to be aligned.\n- `roi`: A list containing two integers that define the region of interest within the arrays.\n- `order`: An integer specifying the order of the shift operation.\n- `init`: A float representing the initial guess for the shift value.\n- `bound`: A float representing the maximum allowable shift from the initial guess.\n\nOutput format:\n- The function returns a float representing the optimal shift value that aligns the target array with the reference array.\n\n**Input:**\n```python\nreference = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\ntarget = np.array([2.0, 3.0])\nroi = [0, 2]\norder = 1\ninit = 0.0\nbound = 0.5\n```\n\n**Output:**\n```python\nresult = 1.0\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy.ndimage import shift\n\n\ndef equalize_array_size(array1, array2):\n    len1, len2 = len(array1), len(array2)\n    dif_length = len1 - len2\n    if dif_length < 0:\n        offset = int(np.floor(-dif_length / 2))\n        array2 = array2[offset: len2 - int(np.ceil(-dif_length / 2))]\n    elif dif_length > 0:\n        offset = int(np.floor(dif_length / 2))\n        array1 = array1[offset: len1 - int(np.ceil(dif_length / 2))]\n    return array1, array2, dif_length\n\n# main code\ndef chisqr_align(reference, target, roi, order, init, bound):\n    reference, target, dif_length = equalize_array_size(reference, target)\n\n    if roi is None:\n        roi = [0, len(reference) - 1]\n\n    ROI = slice(int(roi[0]), int(roi[1]))\n    reference = reference / np.mean(reference[ROI])\n\n    def fcn2min(x):\n        shifted = shift(target, x, order=order)\n        shifted = shifted / np.mean(shifted[ROI])\n        return np.sum(((reference - shifted) ** 2)[ROI])\n\n    minb, maxb = sorted([init - bound, init + bound])\n    result = minimize(fcn2min, init, method='L-BFGS-B', bounds=[(minb, maxb)])\n\n    return result.x[0] + int(np.floor(dif_length / 2))", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        len1 = np.random.randint(50, 200)\n        len2 = np.random.randint(50, 200)\n\n        reference = np.random.rand(len1) * 10\n        target = np.random.rand(len2) * 10\n\n        min_len = min(len1, len2)\n        roi_start = np.random.randint(0, max(1, min_len - 10))\n        roi_end = np.random.randint(roi_start + 1, min_len)\n        roi = [roi_start, roi_end]\n        order = np.random.randint(0, 4)\n        init = np.random.uniform(-1, 1)\n        bound = np.random.uniform(0.1, 2.0)\n        test_cases.append((reference, target, roi, order, init, bound))\n\n    return test_cases"}
{"problem_id": "scipy_90", "library": "scipy", "code_problem": "The task is to implement a function that aligns a given density distribution (represented as a 3D numpy array) to a reference density distribution using principal axis alignment. The function should also handle the generation of enantiomers and compute overlap scores to determine the best alignment.\n\nFunction signature:\n```python\ndef principal_axis_alignment(refrho: np.ndarray, movrho: np.ndarray) -> np.ndarray:\n```\n\nConstant used in the main code:\n- `side`: A constant value set to `1.0`, which represents the side length of the cube in which the density distributions are defined.\n\n\nInput format:\n- `refrho`: A 3D numpy array representing the reference density distribution.\n- `movrho`: A 3D numpy array representing the moving density distribution to be aligned.\n\nOutput format:\n- Returns a 3D numpy array representing the aligned moving density distribution.\n\nInput:\n```python\nrefrho = np.array([[[ 0.1, -0.2, 0.3], \n                     [ 0.4,  0.5, -0.6], \n                     [-0.7,  0.8, 0.9]],\n\n                    [[ 0.1,  0.2, -0.3], \n                     [-0.4,  0.5, 0.6], \n                     [ 0.7, -0.8, 0.9]],\n\n                    [[-0.1,  0.2, 0.3], \n                     [ 0.4, -0.5, 0.6], \n                     [-0.7,  0.8, -0.9]]])\n\nmovrho = np.array([[[ 0.2, -0.1, 0.4], \n                     [ 0.3,  0.6, -0.5], \n                     [-0.8,  0.7, 0.1]],\n\n                    [[ 0.2,  0.1, -0.4], \n                     [-0.3,  0.6, 0.5], \n                     [ 0.8, -0.7, 0.1]],\n\n                    [[-0.2,  0.1, 0.4], \n                     [ 0.3, -0.6, 0.5], \n                     [-0.8,  0.7, -0.1]]])\n```\n\nOutput:\n```python\narray([[[ 0.02884153,  0.17888457,  0.02884153],\n        [-0.11614786,  0.3324647 , -0.11614786],\n        [ 0.02884153,  0.17888457,  0.02884153]],\n       [[ 0.00959595,  0.17696393,  0.00959595],\n        [ 0.18200198,  0.19707586,  0.18200198],\n        [ 0.00959595,  0.17696393,  0.00959595]],\n       [[ 0.02884153,  0.17888457,  0.02884153],\n        [-0.11614786,  0.3324647 , -0.11614786],\n        [ 0.02884153,  0.17888457,  0.02884153]]])\n```", "ground_truth_code": "import numpy as np\nfrom scipy import ndimage\n\n\ndef inertia_tensor(rho, side):\n\n    halfside = side / 2.0\n    n = rho.shape[0]\n    x_ = np.linspace(-halfside, halfside, n)\n    x, y, z = np.meshgrid(x_, x_, x_, indexing='ij')\n    Ixx = np.sum((y ** 2 + z ** 2) * rho)\n    Iyy = np.sum((x ** 2 + z ** 2) * rho)\n    Izz = np.sum((x ** 2 + y ** 2) * rho)\n    Ixy = -np.sum(x * y * rho)\n    Iyz = -np.sum(y * z * rho)\n    Ixz = -np.sum(x * z * rho)\n    I = np.array([[Ixx, Ixy, Ixz], [Ixy, Iyy, Iyz], [Ixz, Iyz, Izz]])\n    return I\n\n\ndef principal_axes(I):\n    w, v = np.linalg.eigh(I)\n    return w, v\n\n\ndef align2xyz(rho, return_transform=False):\n    side = 1.0\n    ne_rho = np.sum(rho)\n    rhocom = np.array(ndimage.center_of_mass(np.abs(rho)))\n    gridcenter = (np.array(rho.shape) - 1.0) / 2.0\n    shift = gridcenter - rhocom\n    rho = ndimage.shift(rho, shift, order=3, mode='wrap')\n\n    for _ in range(3):\n        I = inertia_tensor(rho, side)\n        w, v = np.linalg.eigh(I)\n        R = v.T\n        c_in = np.array(ndimage.center_of_mass(np.abs(rho)))\n        c_out = (np.array(rho.shape) - 1.0) / 2.0\n        offset = c_in - c_out.dot(R)\n        rho = ndimage.affine_transform(rho, R.T, order=3, offset=offset, mode='wrap')\n\n    for _ in range(3):\n        rhocom = np.array(ndimage.center_of_mass(np.abs(rho)))\n        shift = gridcenter - rhocom\n        rho = ndimage.shift(rho, shift, order=3, mode='wrap')\n\n    rho *= ne_rho / np.sum(rho)\n    return (rho, R, shift) if return_transform else rho\n\n\ndef generate_enantiomers(rho):\n    rho_zflip = rho[:, :, ::-1]\n    return np.array([rho, rho_zflip])\n\n\ndef rho_overlap_score(rho1, rho2, threshold=None):\n    if threshold is None:\n        n = np.sum(rho1 * rho2)\n        d = np.sqrt(np.sum(rho1 ** 2)) * np.sqrt(np.sum(rho2 ** 2))\n    else:\n        idx = np.where(np.abs(rho1) > threshold * np.abs(rho1).max())\n        n = np.sum(rho1[idx] * rho2[idx])\n        d = np.sqrt(np.sum(rho1[idx] ** 2)) * np.sqrt(np.sum(rho2[idx] ** 2))\n    return -n / d\n\n\n# main code\ndef principal_axis_alignment(refrho, movrho):\n    side = 1.0\n    ne_movrho = np.sum(movrho)\n    rhocom = np.array(ndimage.center_of_mass(np.abs(refrho)))\n    gridcenter = (np.array(refrho.shape) - 1.0) / 2.0\n    shift = gridcenter - rhocom\n    refrho = ndimage.shift(refrho, shift, order=3, mode='wrap')\n    refI = inertia_tensor(refrho, side)\n    refw, refv = principal_axes(refI)\n    refR = refv.T\n    refrho = align2xyz(refrho)\n    movrho = align2xyz(movrho)\n\n    enans = generate_enantiomers(movrho)\n    scores = np.array([-rho_overlap_score(refrho, enan) for enan in enans])\n    movrho = enans[np.argmax(scores)]\n\n    R = np.linalg.inv(refR)\n    c_in = np.array(ndimage.center_of_mass(np.abs(movrho)))\n    c_out = (np.array(movrho.shape) - 1.0) / 2.0\n    offset = c_in - c_out.dot(R)\n    movrho = ndimage.affine_transform(movrho, R.T, order=3, offset=offset, mode='wrap')\n    movrho = ndimage.shift(movrho, -shift, order=3, mode='wrap')\n    movrho *= ne_movrho / np.sum(movrho)\n\n    return movrho\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(10, 50, size=1)[0]\n        refrho = np.random.randn(shape, shape, shape)\n        movrho = np.random.randn(shape, shape, shape)\n\n        test_cases.append((refrho, movrho))\n\n    return test_cases"}
{"problem_id": "scipy_91", "library": "scipy", "code_problem": "You are tasked with implementing a signal transformation function that applies a series of specified operations to a given signal. The function should be able to perform scaling, vertical flipping, shifting, and bandpass filtering based on the operations provided in a list. The main function signature is as follows:\n\n```python\ndef transform(sig, operation_list):\n```\n\n### Constants Used:\n- The bandpass filter is configured with a low cutoff frequency of `0.05`, a high cutoff frequency of `46`, and a sampling frequency of `256`.\n\n### Input Format:\n- The input consists of:\n  - `sig`: A 2D numpy array of shape (n_samples, n_features) representing the signal.\n  - `operation_list`: A list of strings containing the operations to be applied.\n\n### Output Format:\n- The output is a PyTorch tensor of the transformed signal, with the same number of features as the input signal but potentially modified based on the operations applied.\n\nInput:\n```python\nsig = np.array([[ 0.49671415, -0.1382643 ],\n                [ 0.64768854,  1.52302986],\n                [-0.23415337, -0.23413696],\n                [ 1.57921282,  0.76743473],\n                [-0.46947439,  0.54256004]])\noperation_list = ['scaling', 'shift']\n```\n\nOutput:\n```python\ntensor([[ 0.3804,  0.5349, -0.3678,  1.4885, -0.6086],\n        [-0.3240,  1.4477, -0.4262,  0.6419,  0.4021]])\n```\n", "ground_truth_code": "from scipy.signal import butter, sosfilt\nimport numpy as np\nimport torch\n\ndef butter_bandpass(lowcut, highcut, fs, order=5):\n    nyq = 0.5 * fs\n    low = lowcut / nyq\n    high = highcut / nyq\n    return butter(order, [low, high], analog=False, btype='band', output='sos')\n\ndef scaling(X, sigma=0.05):\n    scaling_factor = np.random.normal(loc=1.0, scale=sigma, size=(1, X.shape[1]))\n    noise = np.matmul(np.ones((X.shape[0], 1)), scaling_factor)\n    return X * noise\n\ndef verflip(sig):\n    return sig[::-1, :]\n\ndef shift(sig, interval=20):\n    for col in range(sig.shape[1]):\n        offset = np.random.uniform(-interval / 100, interval / 100)\n        sig[:, col] += offset\n    return sig\n\ndef butter_bandpass_filter(data, lowcut, highcut, fs, order=5):\n    sos = butter_bandpass(lowcut, highcut, fs, order=order)\n    filtered_sig = np.zeros_like(data)\n    for i in range(data.shape[1]):\n        filtered_sig[:, i] = sosfilt(sos, data[:, i])\n    return filtered_sig\n\n# main code\ndef transform(sig, operation_list):\n\n    if 'scaling' in operation_list:\n        sig = scaling(sig)\n    if 'verflip' in operation_list:\n        sig = verflip(sig)\n    if 'shift' in operation_list:\n        sig = shift(sig)\n    if 'butter_bandpass_filter' in operation_list:\n        sig = butter_bandpass_filter(sig, 0.05, 46, 256)\n    sig = sig.T\n    return torch.tensor(sig.copy(), dtype=torch.float)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        rows = np.random.randint(50, 201)\n        cols = np.random.randint(1, 11)\n\n        sig = np.random.randn(rows, cols)\n\n        available_operations = ['scaling', 'verflip', 'shift', 'butter_bandpass_filter']\n        operation_list = random.sample(available_operations, k=np.random.randint(1, len(available_operations) + 1))\n\n        # Store test case\n        test_cases.append((sig, operation_list))\n\n    return test_cases"}
{"problem_id": "scipy_92", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the Fourier Shell Correlation (FSC) between two 3D density maps. The function will take two 3D numpy arrays representing the density maps and a scalar value representing the size of the grid. The FSC is a measure used in cryo-electron microscopy to assess the similarity between two reconstructions.\n\nFunction signature:\n```python\ndef calc_fsc(rho1: np.ndarray, rho2: np.ndarray, side: float) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant `df` is calculated as `1.0 / side`, which represents the frequency spacing based on the size of the grid.\n\nInput format:\n- `rho1`: A 3D numpy array representing the first density map.\n- `rho2`: A 3D numpy array representing the second density map.\n- `side`: A float representing the size of the grid.\n\nOutput format:\n- A 2D numpy array where the first column contains the radial frequency bins and the second column contains the corresponding FSC values.\n\nInput:\n```python\nrho1 = np.array([[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]])\nrho2 = np.array([[[0.2, 0.1], [0.4, 0.3]], [[0.6, 0.5], [0.8, 0.7]]])\nside = 20.0\n```\n\nOutput:\n```python\narray([], shape=(0, 2), dtype=float64)\n```", "ground_truth_code": "import numpy as np\nfrom scipy import ndimage\n\n# main code\ndef calc_fsc(rho1, rho2, side):\n    df = 1.0 / side\n    n = rho1.shape[0]\n    qx_ = np.fft.fftfreq(n) * n * df\n    (qx, qy, qz) = np.meshgrid(qx_, qx_, qx_, indexing='ij')\n    qx_max = qx.max()\n    qr = np.sqrt(qx ** 2 + qy ** 2 + qz ** 2)\n    qmax = np.max(qr)\n    qstep = np.min(qr[qr > 0])\n    nbins = int(qmax / qstep)\n    qbins = np.linspace(0, nbins * qstep, nbins + 1)\n    qbin_labels = np.searchsorted(qbins, qr, 'right')\n    qbin_labels -= 1\n    F1 = np.fft.fftn(rho1)\n    F2 = np.fft.fftn(rho2)\n    numerator = ndimage.sum(np.real(F1 * np.conj(F2)), labels=qbin_labels, index=np.arange(0, qbin_labels.max() + 1))\n    term1 = ndimage.sum(np.abs(F1) ** 2, labels=qbin_labels, index=np.arange(0, qbin_labels.max() + 1))\n    term2 = ndimage.sum(np.abs(F2) ** 2, labels=qbin_labels, index=np.arange(0, qbin_labels.max() + 1))\n    denominator = (term1 * term2) ** 0.5\n    FSC = numerator / denominator\n    qidx = np.where(qbins < qx_max)\n    return np.vstack((qbins[qidx], FSC[qidx])).T\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(8, 128)\n        shape = (size, size, size)\n        rho1 = np.random.rand(*shape)\n        rho2 = np.random.rand(*shape)\n        side = np.random.uniform(10, 100)\n\n        test_cases.append((rho1, rho2, side))\n\n    return test_cases"}
{"problem_id": "scipy_93", "library": "scipy", "code_problem": "```python\ndef frac_oct_smooth_fd(data_fd, frac):\n```\n\nIn this code, the function `frac_oct_smooth_fd` is designed to perform fractional octave smoothing on frequency domain data. The function takes two parameters: `data_fd`, which is a 2D array representing frequency domain data, and `frac`, which is a float representing the fractional octave bandwidth for smoothing.\n\n### Input and Output Format:\n- **Input**:\n  - `data_fd`: A 2D array of frequency domain data.\n  - `frac`: A float representing the fractional octave bandwidth.\n\n- **Output**:\n  - Returns a 1D array of the smoothed frequency domain data.\n\nInput:\n```python\ndata_fd = np.array([[0.5, 1.2, 0.3, 0.8, 1.0, 0.6, 0.9, 1.1, 0.4, 0.7]])\nfrac = 2.5\n```\n\nOutput:\n```python\narray([[112.88183268, 104.09495453,  97.12295429,  93.26902371,\n         90.82297543,  89.15018429,  87.88762235,  86.84783391,\n         86.07441437,  85.31514102]])\n\n```", "ground_truth_code": "from scipy.interpolate import interp1d\nimport numpy as np\nfrom scipy.signal import windows, filtfilt\n\ndef interp1(x, y, x_2interp, kind='linear'):\n    interpolator_function = interp1d(x, y, kind, fill_value='extrapolate' if x_2interp.max() > x.max() or x_2interp.min() < x.min() else None)\n    return interpolator_function(x_2interp)\n\n# main code\ndef frac_oct_smooth_fd(data_fd, frac):\n    data_fd = np.atleast_2d(data_fd).copy()\n    num_bins = data_fd.shape[-1]\n    (start_bin, stop_bin) = (1, num_bins)\n    N = stop_bin\n    spacing = 10 ** (np.log10(stop_bin - start_bin) / N)\n    N_oct = np.log10(2) / (frac * np.log10(spacing))\n    N_oct_even = max(4, round(N_oct / 2) * 2)\n    log_bins = np.logspace(np.log10(start_bin), np.log10(stop_bin - 1), N)\n    lin_bins = np.arange(0, num_bins)\n    if np.iscomplexobj(data_fd):\n        data_fd = np.abs(data_fd)\n    data_fd_ip = interp1(lin_bins, data_fd, log_bins, kind='cubic')\n    fd_win = windows.gaussian(N_oct_even * 2, N_oct_even / 2.5)\n\n    padding_size = max(10, fd_win.size)\n    fd_lead = np.full(np.append(data_fd.shape[:-1], padding_size), data_fd_ip[..., :1])\n    fd_lag = np.full(np.append(data_fd.shape[:-1], padding_size), data_fd_ip[..., -1:])\n\n    data_fd_ip_extrap = np.concatenate((fd_lead, data_fd_ip, fd_lag), axis=-1)\n    data_fd_temp = filtfilt(b=fd_win, a=[1, -0.9], x=data_fd_ip_extrap) / np.sum(fd_win) ** 2\n    data_fd_temp = data_fd_temp[..., fd_win.size:fd_win.size + num_bins]\n    data_fd_sm = interp1(log_bins, data_fd_temp, lin_bins, kind='linear')\n    return data_fd_sm", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_bins = np.random.randint(10, 1000)\n        is_complex = np.random.choice([True, False])\n        if is_complex:\n            data_fd = (np.random.randn(batch_size, num_bins) +\n                       1j * np.random.randn(batch_size, num_bins))\n        else:\n            data_fd = np.random.randn(batch_size, num_bins)\n        frac = np.random.uniform(1.0, 5.0)\n\n        test_cases.append((data_fd, frac))\n\n    return test_cases"}
{"problem_id": "scipy_94", "library": "scipy", "code_problem": "You are tasked with implementing a function that aligns multiple datasets based on a specified method. The datasets are provided as a list of strings, where each string represents a comma-separated list of numerical values. The function should compute the average of each dataset, determine the necessary shifts to align them, and return the aligned datasets along with the calculated shifts.\n\nThe function signature for the main code is as follows:\n```python\ndef align_nch_dataset(X, start, length, method='peak'):\n```\n\n### Constants Used:\n- The constant `max_ix` is used to store the index of the maximum value in the first dataset's average.\n\n### Input Format:\n- `X`: A list of datasets, where each dataset is represented as a string of comma-separated numerical values.\n- `start`: An integer indicating the starting index for alignment.\n- `length`: An integer specifying the length of the output arrays.\n- `method`: A string that determines the alignment method ('peak', 'phase', or 'chisq').\n\n### Output Format:\n- The function returns a tuple containing:\n  - A NumPy array of aligned datasets, where each dataset is an array of numerical values.\n  - A list of shifts applied to each dataset for alignment.\n\nInput:\n```python\nX = [\n    [[0.1, 0.2, 0.3, 0.4, 0.5], [0.2, 0.3, 0.4, 0.5, 0.6]],  # Sample 1\n    [[0.3, 0.4, 0.5, 0.6, 0.7], [0.4, 0.5, 0.6, 0.7, 0.8]]   # Sample 2\n]\nstart = 1\nlength = 3\nmethod = 'peak'\n```\n\nOutput:\n```python\naligned_data, shifts = align_nch_dataset(X, start, length, method)\n# aligned_data will be a 2D array with aligned samples based on the specified method\n# shifts will contain the calculated shifts for each sample\n```\n\nOutput Example:\n```python\naligned_data = array([[[0.1, 0.2, 0.3],\n                        [0.2, 0.3, 0.4]],\n                       [[0.3, 0.4, 0.5],\n                        [0.4, 0.5, 0.6]]])\nshifts = [0, 0]\n```", "ground_truth_code": "import numpy as np\nfrom scipy.interpolate import interp1d\nfrom scipy.optimize import minimize\nfrom scipy.ndimage import shift\n\n\ndef highres(y, kind='cubic', res=100):\n    x = np.arange(len(y))\n    f = interp1d(x, y, kind=kind)\n    xnew = np.linspace(0, len(y) - 1, len(y) * res)\n    return xnew, f(xnew)\n\n\ndef equalize_array_size(a1, a2):\n    dif = len(a1) - len(a2)\n    if dif < 0:\n        a2 = a2[-dif // 2: len(a2) + dif // 2]\n    elif dif > 0:\n        a1 = a1[dif // 2: len(a1) - dif // 2]\n    return a1, a2, dif\n\n\ndef phase_align(ref, target, roi, res=100):\n    r1, r2 = highres(ref[roi[0]:roi[1]], res=res)[1], highres(target[roi[0]:roi[1]], res=res)[1]\n    r1, r2 = r1 - np.mean(r1), r2 - np.mean(r2)\n    cc = np.correlate(r1, r2, mode='full') / len(r1)\n    return np.argmax(cc) * (1.0 / res) * (-1 if np.argmax(cc) == 0 else 1)\n\n\ndef chisqr_align(ref, target, roi=None, order=1, init=1, bound=0.1):\n    ref, target, dif = equalize_array_size(ref, target)\n    roi = roi or [0, len(ref) - 1]\n    ref /= np.mean(ref[roi[0]:roi[1]])\n\n    def cost(x):\n        shifted = shift(target, x, order=order if order is not None else 1)  # Default to 1 if None\n        return np.sum((ref - shifted / np.mean(shifted[roi[0]:roi[1]])) ** 2)\n\n    result = minimize(cost, init, method='L-BFGS-B', bounds=[(init - bound, init + bound)])\n    return result.x[0] + dif // 2\n\n\n# main code\ndef align_nch_dataset(X, start, length, method='peak'):\n    ch_avg = [np.mean([np.array(xx.split(',')).astype(float) if isinstance(xx, str) else xx for xx in x], axis=0) for x\n              in X]\n    max_ix = ch_avg[0].argmax()\n    shifts = [0]\n\n    for sample in ch_avg[1:]:\n        if method == 'phase':\n            s = phase_align(ch_avg[0], sample, [len(sample) // 4, len(sample) * 3 // 4])\n        elif method == 'chisq':\n            s = chisqr_align(ch_avg[0], sample, [len(sample) // 2, len(sample) * 3 // 4])\n        else:\n            s = max_ix - sample.argmax()\n        shifts.append(s)\n\n    return np.array([\n        np.array([\n            (np.array(xx.split(',')).astype(float) if isinstance(xx, str) else xx)[:length]\n            if start >= shifts[sidx] else [0] * length\n            for xx in sample\n        ]) for sidx, sample in enumerate(X)\n    ]), shifts", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(2, 10)\n        num_channels = np.random.randint(1, 5)\n        signal_length = np.random.randint(50, 200)\n        X = [\n            [np.random.rand(signal_length).tolist() for _ in range(num_channels)]\n            for _ in range(num_samples)\n        ]\n        start = np.random.randint(0, signal_length // 2)\n        length = np.random.randint(signal_length // 2, signal_length)\n        method = np.random.choice(['peak', 'phase', 'chisq'])\n\n        test_cases.append((X, start, length, method))\n\n    return test_cases"}
{"problem_id": "scipy_95", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the Kullback-Leibler divergence between two Dirichlet distributions given their parameters. The function signature is as follows:\n\n```python\ndef kl_dir(alphas, betas):\n```\n\nIn this function, `alphas` and `betas` are arrays representing the parameters of two Dirichlet distributions. The constant used in the main code is the sum of the parameters for each distribution, denoted as `alpha_0` for `alphas` and `beta_0` for `betas`.\n\n\nInput format:\n- The function takes two inputs: `alphas` and `betas`, which are both arrays of numerical values representing the parameters of the Dirichlet distributions.\n\nOutput format:\n- The function returns a single numerical value representing the Kullback-Leibler divergence between the two Dirichlet distributions defined by `alphas` and `betas`.\n\n```python\n# Input\nalphas = np.array([2.5, 1.2, 3.0])\nbetas = np.array([1.5, 2.0, 2.5])\n\n# Output\n0.6262276298675185\n```", "ground_truth_code": "from scipy.special import gammaln\nfrom scipy.special import digamma\n\n# main code\ndef kl_dir(alphas, betas):\n    alpha_0 = alphas.sum()\n    beta_0 = betas.sum()\n    a_part = gammaln(alpha_0) - gammaln(alphas).sum()\n    b_part = gammaln(beta_0) - gammaln(betas).sum()\n    ab_part = ((alphas - betas) * (digamma(alphas) - digamma(alpha_0))).sum()\n    return a_part - b_part + ab_part", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_dimensions = np.random.randint(2, 10)\n        alphas = np.random.gamma(shape=2.0, scale=1.0, size=(num_dimensions,))\n        betas = np.random.gamma(shape=2.0, scale=1.0, size=(num_dimensions,))\n\n        alphas = np.maximum(alphas, 1e-3)\n        betas = np.maximum(betas, 1e-3)\n\n        test_cases.append((alphas, betas))\n\n    return test_cases\n"}
{"problem_id": "scipy_96", "library": "scipy", "code_problem": "You are tasked with creating a function that calculates the probability density function (PDF) of a specified statistical distribution at a given value. The function should support several common distributions, including normal, t, gamma, lognormal, and exponential.\n\nFunction signature:\n```python\ndef fitPrior(value, distribution, dist_params):\n```\n\nConstant used in the main code:\n- A dictionary named `distributions` that maps string keys representing distribution names to their corresponding functions from the `scipy.stats` module.\n\nInput format:\n- The function takes three inputs:\n  - `value`: A float representing the point at which to evaluate the PDF.\n  - `distribution`: A string indicating the type of distribution to use.\n  - `dist_params`: A list or tuple of parameters required by the specified distribution.\n\nOutput format:\n- The function returns a float representing the value of the PDF at the specified `value` for the given distribution, or `None` if the distribution is not supported.\n\n**Input:**\n```python\nvalue = 1.5\ndistribution = 'normal'\ndist_params = (0, 1)  # mean = 0, std = 1\n```\n\n**Output:**\n```python\n0.12951759566589174\n```", "ground_truth_code": "import scipy.stats as stats\n\n# main code\ndef fitPrior(value, distribution, dist_params):\n    distributions = {\n        'normal': stats.norm,\n        't': stats.t,\n        'gamma': stats.gamma,\n        'lognormal': stats.lognorm,\n        'exponential': stats.expon\n    }\n\n    dist = distributions.get(distribution)\n    if dist:\n        return dist(*dist_params).pdf(value)\n\n    return None", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    distributions = ['normal', 't', 'gamma', 'lognormal', 'exponential']\n\n    for _ in range(n):\n        distribution = np.random.choice(distributions)\n\n        if distribution == 'normal':\n            mean = np.random.uniform(-10, 10)\n            std = np.random.uniform(0.1, 5)\n            value = np.random.normal(mean, std)\n            dist_params = (mean, std)\n\n        elif distribution == 't':\n            df = np.random.uniform(1, 30)\n            value = np.random.standard_t(df)\n            dist_params = (df,)\n\n        elif distribution == 'gamma':\n            shape = np.random.uniform(0.1, 5)\n            scale = np.random.uniform(0.1, 5)\n            value = np.random.gamma(shape, scale)\n            dist_params = (shape, scale)\n\n        elif distribution == 'lognormal':\n            sigma = np.random.uniform(0.1, 2)\n            scale = np.random.uniform(0.1, 5)\n            value = np.random.lognormal(mean=0, sigma=sigma)\n            dist_params = (sigma, 0, scale)\n\n        elif distribution == 'exponential':\n            scale = np.random.uniform(0.1, 5)\n            value = np.random.exponential(scale)\n            dist_params = (scale,)\n\n        test_cases.append((value, distribution, dist_params))\n\n    return test_cases"}
{"problem_id": "scipy_97", "library": "scipy", "code_problem": "You are tasked with simulating a multivariate time series model with added noise and connectivity structures. The main function, `simulate`, generates a time series based on autoregressive (AR) processes, applies noise to the generated data, and optionally mixes the data based on a specified length scale. \n\nFunction signature:\n```python\ndef simulate(time, snr_db, lmix, n, ntrials, popt, sparsity):\n```\n\n### Constants:\n- `scale_range`: A constant array generated using `np.linspace(0.1, 0.5, 41)` which defines the range of scales for the AR coefficients.\n\n### Input Format:\n- `time`: A 1D array of time points.\n- `snr_db`: A float representing the signal-to-noise ratio in decibels.\n- `lmix`: A float representing the length scale for mixing.\n- `n`: An integer representing the number of variables.\n- `ntrials`: An integer representing the number of trials.\n- `popt`: An integer representing the number of AR parameters.\n- `sparsity`: A float representing the sparsity level for connectivity.\n\n### Output Format:\n- Returns a tuple containing:\n  - `Y`: The generated time series with noise.\n  - `E`: The noise added to the time series.\n  - `AR`: The autoregressive coefficients.\n  - `LMx`: The mixing function.\n  - `DM`: The distance matrix.\n  - `SC`: The structural connectivity matrix.\n  - `FC`: The functional connectivity matrix.\n\n**Input:**\n```python\ntime = np.linspace(0, 1, 100)  # Time array with 100 samples\nsnr_db = 20.0  # Signal-to-noise ratio in dB\nlmix = 0.5  # Mixing length\nn = 10  # Number of nodes\nntrials = 50  # Number of trials\npopt = 3  # Autoregressive order\nsparsity = 0.3  # Sparsity value\n```\n\n**Output:**\n```python\nY.shape = (50, 10, 100)  # Output Y shape\nE.shape = (50, 10, 100)  # Output E shape\nAR.shape = (10, 10, 3, 100)  # Output AR shape\nLMx.shape = (10, 10)  # Output LMx shape\nDM.shape = (10, 10)  # Output DM shape\nSC.shape = (10, 10)  # Output SC shape\nFC.shape = (10, 10)  # Output FC shape\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy.stats import norm\nfrom scipy.spatial.distance import squareform, pdist\n\n\ndef add_noise(distribution, Y, snr_db):\n    noise = np.std(Y) / (10 ** (snr_db / 20)) * np.random.randn(*Y.shape) if distribution == 'w' else 0\n    return Y + noise\n\ndef initialize_AR(n, popt, nsamples, scale_range):\n    AR = np.zeros((n, n, popt, nsamples))\n    for i in range(n):\n        c1 = np.random.choice(scale_range, 1).item()\n        AR[i, i, 0, :] = np.full(nsamples, c1)\n\n        if popt > 1:\n            c2 = (np.max(scale_range) - c1) * 0.95\n            AR[i, i, 1, :] = np.full(nsamples, c2)\n\n    return AR\n\ndef generate_connectivity(n, sparsity, SC=None):\n    I = np.eye(n)\n    if SC is None:\n        SC = np.triu(np.random.rand(n, n) < 0.8) + I\n    FC = (np.random.rand(*SC.shape) < sparsity) * SC + I\n    return SC, FC\n\n# main code\ndef simulate(time, snr_db, lmix, n, ntrials, popt, sparsity):\n    nsamples = len(time)\n    scale_range = np.linspace(0.1, 0.5, 41)\n    SC, FC = generate_connectivity(n, sparsity)\n    AR = initialize_AR(n, popt, nsamples, scale_range)\n\n    X = np.zeros((ntrials, n, nsamples))\n    E = np.random.randn(ntrials, n, nsamples)\n\n    for k in range(popt, nsamples):\n        for l in range(popt):\n            X[:, :, k] += (AR[:, :, l, k] @ X[:, :, k - l].T).T\n        X[:, :, k] += E[:, :, k]\n\n    Y = add_noise('w', X, snr_db) if snr_db is not None else X\n\n    if lmix > 0:\n        DM = squareform(pdist(np.random.rand(n, 2)))\n        mixf = norm.pdf(np.arange(0, np.max(DM)), 0, lmix)\n        LMx = norm.pdf(DM, 0, lmix) / np.max(mixf)\n        Y = np.matmul(np.tile(LMx, [ntrials, 1, 1]), Y)\n    else:\n        LMx, DM = np.zeros((n, n)), np.full((n, n), np.nan)\n\n    return Y, E, AR, LMx, DM, SC, FC", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        time = np.linspace(0, 1, np.random.randint(50, 200))  # Random time array with variable length\n        snr_db = np.random.uniform(0, 30) if np.random.rand() > 0.2 else None  # Random SNR or None\n        lmix = np.random.uniform(0, 1) if np.random.rand() > 0.5 else 0  # Random lmix or 0\n        n = np.random.randint(5, 20)  # Random number of nodes (small to medium range)\n        ntrials = np.random.randint(10, 100)  # Random number of trials\n        popt = np.random.randint(1, 5)  # Random autoregressive order\n        sparsity = np.random.uniform(0.1, 0.9)  # Random sparsity value\n\n        test_cases.append((time, snr_db, lmix, n, ntrials, popt, sparsity))\n\n    return test_cases"}
{"problem_id": "scipy_98", "library": "scipy", "code_problem": "```python\ndef find_optimal_curve_std(df, lower, upper, sdev):\n```\n\nIn this function, the goal is to optimize the standard deviation of a log-normal distribution based on given bounds and an expected value. The function takes in a DataFrame `df` and three parameters: `lower`, `upper`, and `sdev`. The `lower` and `upper` parameters represent the column names in the DataFrame that contain the lower and upper bounds, respectively, while `sdev` is the initial standard deviation to be optimized.\n\n### Input and Output Format:\n- **Input**: The function takes a DataFrame `df` and three strings `lower`, `upper`, and `sdev`.\n- **Output**: The function returns an updated DataFrame with additional columns for the optimized standard deviation and the fitted limits.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'Lower': [2.5, 3.0, 4.0],\n    'Upper': [5.0, 6.0, 7.5],\n    'Expected Value': [3.75, 4.5, 5.75]\n}\ndf = pd.DataFrame(data)\ndf.index = ['Row_0', 'Row_1', 'Row_2']\nlower = 'Lower'\nupper = 'Upper'\nsdev = 0.5\n\nresult = find_optimal_curve_std(df, lower, upper, sdev)\nprint(result)\n```\n\n**Output:**\n```\n       Lower  Upper  ...  Fitted Lower Limit  Fitted Upper Limit\nRow_0    2.5    5.0  ...            2.741414            5.129652\nRow_1    3.0    6.0  ...            3.289950            6.155109\nRow_2    4.0    7.5  ...            4.308753            7.673334\n[3 rows x 6 columns]\n```", "ground_truth_code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy import stats\n\n# main code\ndef find_optimal_curve_std(df, lower, upper, sdev):\n    df = df.copy()\n\n    for i, val in enumerate(df.index):\n        lower_bound = df.iloc[i][lower]\n        upper_bound = df.iloc[i][upper]\n        expected_value = df.iloc[i]['Expected Value']\n\n        x = np.array([lower_bound, upper_bound, sdev, expected_value])\n\n        def objective_find_std(x: np.ndarray) -> float:\n            return (\n                np.square(stats.lognorm(x[2], scale=x[3]).ppf(0.1) - x[0]) +\n                np.square(stats.lognorm(x[2], scale=x[3]).ppf(0.9) - x[1])\n            )\n\n        bounds = (\n            (lower_bound, lower_bound),\n            (upper_bound, upper_bound),\n            (0, None),\n            (expected_value, expected_value)\n        )\n\n        solution = minimize(objective_find_std, x, method='SLSQP', bounds=bounds)\n        final_st_d = solution.x[2]\n\n        df.loc[val, 'Sigma'] = final_st_d\n        df.loc[val, f'Fitted {lower} Limit'] = stats.lognorm(final_st_d, scale=expected_value).ppf(0.1)\n        df.loc[val, f'Fitted {upper} Limit'] = stats.lognorm(final_st_d, scale=expected_value).ppf(0.9)\n\n    return df", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = np.random.randint(5, 20)\n        lower_bound_values = np.random.uniform(1, 10, size=num_rows)\n        upper_bound_values = lower_bound_values + np.random.uniform(0.1, 5,\n                                                                    size=num_rows)\n        expected_values = (lower_bound_values + upper_bound_values) / 2\n\n        df = pd.DataFrame({\n            'Lower': lower_bound_values,\n            'Upper': upper_bound_values,\n            'Expected Value': expected_values\n        })\n\n        df.index = [f'Row_{i}' for i in range(num_rows)]\n\n        lower = 'Lower'\n        upper = 'Upper'\n        sdev = np.random.uniform(0.1, 2.0)\n\n        test_cases.append((df, lower, upper, sdev))\n\n    return test_cases\n"}
{"problem_id": "scipy_99", "library": "scipy", "code_problem": "You are tasked with implementing a function that retrieves specific probability distribution objects from the `scipy.stats` module based on user input. The function should be able to handle different types of input to return a list of distribution objects.\n\nFunction Signature:\n```python\ndef get_distributions(distr, k_distribution):\n```\n\nConstant Used:\n- `popular_names`: A predefined list of popular distribution names.\n\nInput Format:\n- The function accepts two parameters:\n  - `distr`: Can be a list of strings, a string ('full' or 'popular'), or a single string representing a distribution name.\n  - `k_distribution`: A specific distribution object to include if 'k' is present in the list.\n\nOutput Format:\n- The function returns a list of distribution objects from `scipy.stats`. If no valid distributions are found, it returns an empty list.\n\n**Input:**\n```python\n('popular', <scipy.stats._distn_infrastructure.rv_frozen object at 0x7f8c1c1e3d90>)\n```\n\n**Output:**\n```python\n[<scipy.stats._distn_infrastructure.rv_frozen object at 0x7f8c1c1e3d90>, <scipy.stats._distn_infrastructure.rv_frozen object at 0x7f8c1c1e3e10>]\n```\n", "ground_truth_code": "import scipy.stats as st\n\n# main code\ndef get_distributions(distr, k_distribution):\n    out_distr = []\n\n    if isinstance(distr, list):\n        for getdistr in distr:\n            if getdistr == 'k':\n                out_distr.append(k_distribution)\n            else:\n                distribution = getattr(st, getdistr, None)\n                if distribution:\n                    out_distr.append(distribution)\n\n    elif distr == 'full':\n        out_distr = [getattr(st, name) for name in dir(st) if isinstance(getattr(st, name), st.rv_continuous)]\n\n    elif distr == 'popular':\n        popular_names = ['norm', 'expon', 'pareto', 'dweibull', 't', 'genextreme', 'gamma', 'lognorm', 'beta',\n                         'uniform', 'loggamma']\n        out_distr = [getattr(st, name) for name in popular_names if hasattr(st, name)]\n\n    else:\n        distribution = getattr(st, distr, None)\n        if distribution:\n            out_distr.append(distribution)\n\n    return out_distr if out_distr else []", "test_script": "import random\nimport scipy.stats as st\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    popular_names = ['norm', 'expon', 'pareto', 'dweibull', 't', 'genextreme', 'gamma', 'lognorm', 'beta', 'uniform',\n                     'loggamma']\n    all_distributions = [name for name in dir(st) if isinstance(getattr(st, name, None), st.rv_continuous)]\n\n    for _ in range(n):\n        case_type = random.choice(['list', 'full', 'popular', 'single'])\n\n        if case_type == 'list':\n            num_distributions = random.randint(1, 5)\n            distr = random.choices(popular_names + all_distributions + ['k'], k=num_distributions)\n        elif case_type == 'full':\n            distr = 'full'\n        elif case_type == 'popular':\n            distr = 'popular'\n        else:\n            distr = random.choice(popular_names + all_distributions)\n\n        k_distribution = getattr(st, random.choice(popular_names), None)\n\n        test_cases.append((distr, k_distribution))\n\n    return test_cases"}
{"problem_id": "scipy_100", "library": "scipy", "code_problem": "You are tasked with implementing a function that raises the degree of a polynomial represented by its coefficients. The polynomial is given as a NumPy array, and the function should return a new array representing the coefficients of the polynomial raised to a specified degree.\n\nFunction signature:\n```python\ndef _raise_degree(c: np.ndarray, d: int) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The constant `k` is defined as the degree of the input polynomial, which is calculated as the number of coefficients minus one (`k = c.shape[0] - 1`).\n\nInput format:\n- The input consists of a NumPy array `c` of shape `(n,)` where `n` is the number of coefficients, and an integer `d` representing the degree to which the polynomial should be raised.\n\nOutput format:\n- The output is a NumPy array of shape `(n + d,)` containing the coefficients of the polynomial raised to the specified degree.\n\nInput:\n```python\nc = np.array([[0.5, 1.0], [1.5, 2.0], [2.5, 3.0]])\nd = 2\n```\n\nOutput:\n```python\narray([[0.5, 1. ],\n       [1. , 1.5],\n       [1.5, 2. ],\n       [2. , 2.5],\n       [2.5, 3. ]])\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy.special import comb\n\n# main code\ndef _raise_degree(c, d):\n    k = c.shape[0] - 1\n    out = np.zeros((c.shape[0] + d,) + c.shape[1:], dtype=c.dtype)\n    for a in range(c.shape[0]):\n        f = c[a] * comb(k, a)\n        for j in range(d + 1):\n            out[a + j] += f * comb(d, j) / comb(k + d, a + j)\n    return out", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        k = np.random.randint(1, 10)\n        extra_dims = tuple(np.random.randint(1, 5, size=np.random.randint(0, 3)))\n        c_shape = (k + 1,) + extra_dims\n        c = np.random.randn(*c_shape)\n        d = np.random.randint(1, 10)\n\n        test_cases.append((c, d))\n\n    return test_cases\n"}
{"problem_id": "scipy_101", "library": "scipy", "code_problem": "You are tasked with implementing a function that optimizes parameters for a beta distribution based on input data representing different moisture conditions. The function will adjust the parameters to fit the observed data and return a modified DataFrame with the fitted values.\n\nFunction signature:\n```python\ndef find_optimal_curve_beta_dist_S(df, alpha, beta, Delta_CN):\n```\n\nConstants used in the main code:\n- The constant `10` is used in calculations to adjust the values derived from the input DataFrame.\n\nInput format:\n- The function expects a DataFrame `df` with specific columns: 'AMC I (Dry)', 'AMC II', and 'AMC III (Wet)', along with any other necessary columns.\n- The parameters `alpha` and `beta` are floats representing the shape parameters of the beta distribution.\n- The parameter `Delta_CN` is a float used to adjust the lower bound for the optimization.\n\nOutput format:\n- The function returns a modified DataFrame `df` that includes additional columns for the optimized parameters and fitted values. The new columns are 'alpha', 'beta', 'CN Lower Limit', 'Fitted AMC I (Dry)', 'Fitted AMC II', and 'Fitted AMC III (Wet)'.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Test case input\ndf = pd.DataFrame({\n    'AMC I (Dry)': [60, 70, 80],\n    'AMC II': [65, 75, 85],\n    'AMC III (Wet)': [70, 80, 90]\n})\n\nalpha = 2.5\nbeta = 3.0\nDelta_CN = 1.0\n\n```\n\n**Output:**\n```python\n# Expected output (example values, actual values will depend on the optimization)\noutput_df = pd.DataFrame({\n    'AMC I (Dry)': [60, 70, 80],\n    'AMC II': [65, 75, 85],\n    'AMC III (Wet)': [70, 80, 90],\n    'alpha': [9.633648916200118, 7.365214607875022, 4.141758311194802],\n    'beta': [2.9381431301639087, 2.719684776974031, 2.263035501271179],\n    'CN Lower Limit': [58.99999999999999, 69.0, 79.0],\n    'Fitted AMC I (Dry)': [61.413017972124635, 71.38450061692512, 81.26080099388018],\n    'Fitted AMC II': [63.79522828148565, 73.87090117398066, 84.06183686318185],\n    'Fitted AMC III (Wet)': [70.28929285904961, 80.2988485771117, 90.35032489653189]\n})\n```\n", "ground_truth_code": "import numpy as np\nfrom scipy.optimize import minimize\nfrom scipy import stats\n\n# main code\ndef find_optimal_curve_beta_dist_S(df, alpha, beta, Delta_CN):\n\n    for i, val in enumerate(df.index):\n        amc_i = df.iloc[i].get('AMC I (Dry)', np.nan)\n        amc_ii = df.iloc[i].get('AMC II', np.nan)\n        amc_iii = df.iloc[i].get('AMC III (Wet)', np.nan)\n\n        if np.isnan([amc_i, amc_ii, amc_iii]).any():\n            continue\n\n        x = np.array([\n            1000 / amc_i - 10,\n            1000 / amc_ii - 10,\n            1000 / amc_iii - 10,\n            alpha,\n            beta,\n            1000 / amc_i - 10\n        ])\n\n        def objective_find_std(x: np.ndarray) -> float:\n            return (\n                    np.square(x[5] * stats.beta(x[3], x[4]).ppf(0.9) - x[0]) +\n                    np.square(x[5] * (x[3] - 1) / (x[3] + x[4] - 2) - x[1]) +\n                    np.square(x[5] * stats.beta(x[3], x[4]).ppf(0.1) - x[2])\n            )\n\n        lower_bound_s = 1000 / max(amc_i - Delta_CN, 1) - 10\n        bounds = (\n            (x[0], x[0]),\n            (x[1], x[1]),\n            (x[2], x[2]),\n            (1.01, None),\n            (1.01, None),\n            (x[0], lower_bound_s)\n        )\n\n        solution = minimize(objective_find_std, x, method='SLSQP', bounds=bounds)\n\n        df.loc[val, 'alpha'] = solution.x[3]\n        df.loc[val, 'beta'] = solution.x[4]\n        df.loc[val, 'CN Lower Limit'] = 1000 / (solution.x[5] + 10)\n        df.loc[val, 'Fitted AMC I (Dry)'] = 1000 / (\n                    10 + solution.x[5] * stats.beta(solution.x[3], solution.x[4]).ppf(0.9))\n        df.loc[val, 'Fitted AMC II'] = 1000 / (\n                    10 + solution.x[5] * ((solution.x[3] - 1) / (solution.x[3] + solution.x[4] - 2)))\n        df.loc[val, 'Fitted AMC III (Wet)'] = 1000 / (\n                    10 + solution.x[5] * stats.beta(solution.x[3], solution.x[4]).ppf(0.1))\n\n    return df\n", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = np.random.randint(5, 10)\n        df = pd.DataFrame(\n            {\n                'AMC I (Dry)': np.random.uniform(50, 100, size=num_rows),\n                'AMC II': np.random.uniform(50, 100, size=num_rows),\n                'AMC III (Wet)': np.random.uniform(50, 100, size=num_rows)\n            }\n        )\n        alpha = np.random.uniform(1.1, 10)\n        beta_val = np.random.uniform(1.1, 10)\n        Delta_CN = np.random.uniform(0.1, 5)\n\n        test_cases.append((df, alpha, beta_val, Delta_CN))\n\n    return test_cases\n"}
{"problem_id": "scipy_102", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes statistical properties from a given probability density function (PDF). The function will analyze the PDF to determine key statistics such as the most probable value, mean, standard deviation, and confidence limits.\n\nFunction Signature:\n```python\ndef get_stats(pdf_x: np.ndarray, pdf_y_smooth: np.ndarray) -> dict:\n```\n\n### Constants Used:\n- The function uses the following constant values for confidence levels:\n  - 0.158 for the lower limit at 1 sigma\n  - 0.022 for the lower limit at 2 sigma\n  - 0.341 for the upper limit at 1 sigma\n  - 0.477 for the upper limit at 2 sigma\n\n### Input Format:\n- `pdf_x`: A 1D numpy array representing the x-values of the probability density function.\n- `pdf_y_smooth`: A 1D numpy array representing the smoothed y-values of the probability density function.\n\n### Output Format:\n- The function returns a dictionary containing the following keys and their corresponding values:\n  - 'most_probable': The most probable value from the PDF.\n  - 'mean': The mean of the distribution.\n  - 'std': The standard deviation of the distribution.\n  - 'lower_limit_1sigma': The lower limit at 1 sigma confidence.\n  - 'lower_limit_2sigma': The lower limit at 2 sigma confidence.\n  - 'upper_limit_1sigma': The upper limit at 1 sigma confidence.\n  - 'upper_limit_2sigma': The upper limit at 2 sigma confidence.\n\nInput:\n```python\npdf_x = np.array([-9.5, -7.2, -5.1, -3.0, -1.0, 1.0, 3.0, 5.2, 7.4, 9.8])\npdf_y_smooth = np.array([0.01, 0.05, 0.1, 0.2, 0.25, 0.15, 0.1, 0.05, 0.03, 0.01])\n```\n\nOutput:\n```python\n{\n    'most_probable': -1.0, \n    'mean': -1.6606281432335783, \n    'std': 5.2090766507870265, \n    'lower_limit_1sigma': -4.4458799100857735, \n    'lower_limit_2sigma': -8.03016302047389, \n    'upper_limit_1sigma': 2.9667532919254684, \n    'upper_limit_2sigma': 7.660291367861893\n}\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy.integrate import simpson\nfrom scipy.interpolate import griddata\n\n# main code\ndef get_stats(pdf_x, pdf_y_smooth):\n    stats = {}\n\n    stats['most_probable'] = np.mean(np.array(pdf_x)[pdf_y_smooth == max(pdf_y_smooth)])\n    stats['mean'] = simpson(pdf_y_smooth * pdf_x, pdf_x)\n    stats['std'] = np.sqrt(simpson(pdf_y_smooth * (pdf_x - stats['mean']) ** 2, pdf_x))\n\n    k_left = pdf_x <= stats['most_probable']\n    pdf_y_left = 0.5 * pdf_y_smooth[k_left] / simpson(pdf_y_smooth[k_left], pdf_x[k_left])\n    pdf_x_left = pdf_x[k_left]\n    areas_left = np.array([simpson(pdf_y_left[pdf_x_left <= x], pdf_x_left[pdf_x_left <= x]) for x in pdf_x_left])\n\n    if np.mean(areas_left) == 0:\n        return {key: None for key in ['most_probable', 'lower_limit_1sigma', 'lower_limit_2sigma', 'upper_limit_1sigma',\n                                      'upper_limit_2sigma']}\n\n    k_right = pdf_x >= stats['most_probable']\n    pdf_y_right = 0.5 * pdf_y_smooth[k_right] / simpson(pdf_y_smooth[k_right], pdf_x[k_right])\n    pdf_x_right = pdf_x[k_right]\n    areas_right = np.array([simpson(pdf_y_right[pdf_x_right <= x], pdf_x_right[pdf_x_right <= x]) for x in pdf_x_right])\n\n    stats['lower_limit_1sigma'] = np.mean(griddata(areas_left, pdf_x_left, 0.158, method='linear', fill_value=np.nan))\n    stats['lower_limit_2sigma'] = np.mean(griddata(areas_left, pdf_x_left, 0.022, method='linear', fill_value=np.nan))\n    stats['upper_limit_1sigma'] = np.mean(griddata(areas_right, pdf_x_right, 0.341, method='linear', fill_value=np.nan))\n    stats['upper_limit_2sigma'] = np.mean(griddata(areas_right, pdf_x_right, 0.477, method='linear', fill_value=np.nan))\n\n    return stats", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_points = np.random.randint(10, 100)\n        pdf_x = np.sort(np.random.uniform(-10, 10, num_points))\n        pdf_y_smooth = np.abs(np.random.randn(num_points))\n        pdf_y_smooth /= np.sum(pdf_y_smooth)\n\n        test_cases.append((pdf_x, pdf_y_smooth))\n\n    return test_cases"}
{"problem_id": "scipy_103", "library": "scipy", "code_problem": "You are tasked with implementing a function that solves a system of linear equations using the Conjugate Gradient (CG) method. The function should be able to handle both sparse and dense matrices, depending on the dimensions of the input data. The function will utilize the `scipy` library for efficient computation.\n\nFunction signature:\n```python\ndef solve_sparse_cg(X, y, alpha, max_iter, tol):\n```\n\n### Constants:\n- `curr_alpha`: This variable represents the current alpha value used in the matrix-vector multiplication and is derived from the `alpha` parameter passed to the function.\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A 2D numpy array of shape `(n_samples, n_features)`.\n  - `y`: A 2D numpy array of shape `(n_samples, m)`.\n  - `alpha`: A 1D numpy array of length `m`.\n  - `max_iter`: An integer.\n  - `tol`: A float.\n\n- **Output**:\n  - A 2D numpy array of shape `(m, n_features)` containing the coefficients for each target variable.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]])\ny = np.array([[1.0], [2.0], [3.0]])\nalpha = np.array([0.5])\nmax_iter = 100\ntol = 1e-5\n```\n\nOutput:\n```python\ncoefs = np.array([[1.5549901 , 1.99604184]])\n```", "ground_truth_code": "from scipy.sparse import linalg as sp_linalg\nimport numpy as np\n\n\ndef create_mv(curr_alpha, X1, is_sparse=True):\n    def _mv(x):\n        if is_sparse:\n            return X1.matvec(X1.rmatvec(x)) + curr_alpha * x\n        else:\n            return X1.rmatvec(X1.matvec(x)) + curr_alpha * x\n\n    return _mv\n\n\n# main code\ndef solve_sparse_cg(X, y, alpha, max_iter, tol):\n\n    (n_samples, n_features) = X.shape\n    X1 = sp_linalg.aslinearoperator(X)\n    coefs = np.empty((y.shape[1], n_features), dtype=X.dtype)\n\n    def choose_mv_function(curr_alpha):\n        if n_features > n_samples:\n            return create_mv(curr_alpha, X1, is_sparse=True)\n        else:\n            return create_mv(curr_alpha, X1, is_sparse=False)\n\n    for i in range(y.shape[1]):\n        y_column = y[:, i]\n        mv = choose_mv_function(alpha[i])\n\n        if n_features > n_samples:\n            C = sp_linalg.LinearOperator((n_samples, n_samples), matvec=mv, dtype=X.dtype)\n            coef, info = sp_linalg.cg(C, y_column, rtol=tol)\n            coefs[i] = X1.rmatvec(coef)\n        else:\n\n            y_column = X1.rmatvec(y_column)\n            C = sp_linalg.LinearOperator((n_features, n_features), matvec=mv, dtype=X.dtype)\n            coefs[i], info = sp_linalg.cg(C, y_column, maxiter=max_iter, rtol=tol)\n\n    return coefs\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(10, 100)\n        n_features = np.random.randint(10, 100)\n        n_output = np.random.randint(1, 5)\n        X = np.random.rand(n_samples, n_features)\n        y = np.random.rand(n_samples, n_output)\n        alpha = np.random.rand(n_output)\n        max_iter = np.random.randint(50, 500)\n        tol = np.random.uniform(1e-5, 1e-2)\n\n        test_cases.append((X, y, alpha, max_iter, tol))\n    return test_cases"}
{"problem_id": "scipy_104", "library": "scipy", "code_problem": "You are tasked with creating a function that increases the resolution of a given one-dimensional dataset using cubic interpolation. The function should take in a list or array of numerical values and a resolution factor, and return a new set of x-coordinates and their corresponding interpolated y-values.\n\nFunction signature:\n```python\ndef highres(y, res):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the interpolation method, which is set to 'cubic'.\n\nInput format:\n- The function takes two parameters: \n  - `y`: a list or array of numerical values representing the original dataset.\n  - `res`: a float representing the resolution factor by which to increase the number of points in the output.\n\nOutput format:\n- The function returns a tuple containing:\n  - `xnew`: a NumPy array of new x-coordinates.\n  - `ynew`: a NumPy array of interpolated y-values corresponding to `xnew`.\n\n```python\n# Input\ny = [0.1, 0.4, 0.3, 0.8, 0.6]\nres = 3.5\n\n# Output\narray([0.  , 0.25, 0.5 , 0.75, 1.  , 1.25, 1.5 , 1.75, 2.  , 2.25, 2.5 ,\n       2.75, 3.  , 3.25, 3.5 , 3.75, 4.  ]), \narray([0.1       , 0.29863281, 0.3984375 , 0.42402344, 0.4       ,\n       0.35097656, 0.3015625 , 0.27636719, 0.3       , 0.38808594,\n       0.5203125 , 0.66738281, 0.8       , 0.88886719, 0.9046875 ,\n       0.81816406, 0.6       ])\n```", "ground_truth_code": "import numpy as np\nfrom scipy.interpolate import interp1d\n\n# main code\ndef highres(y, res):\n    y = np.array(y)\n    x = np.arange(0, y.shape[0])\n    f = interp1d(x, y, kind='cubic')\n    xnew = np.linspace(0, x.shape[0] - 1, int(x.shape[0] * res))\n\n    ynew = f(xnew)\n    return (xnew, ynew)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        y_len = np.random.randint(5, 21)\n        y = np.random.random(y_len)\n        res = np.random.uniform(1, 5)\n        test_cases.append((y, res))\n\n    return test_cases"}
{"problem_id": "scipy_105", "library": "scipy", "code_problem": "```python\ndef _solve_sparse_cg(X, y, alpha, max_iter=None, tol=0.001, verbose=0):\n```\n\nIn this code, the function `_solve_sparse_cg` is designed to solve a system of linear equations using the Conjugate Gradient method, specifically tailored for sparse matrices. The function takes in several parameters: \n\n- `X`: A sparse matrix representing the features of the dataset.\n- `y`: A matrix or array representing the target values.\n- `alpha`: A list or array of regularization parameters for each target variable.\n- `max_iter`: An optional parameter specifying the maximum number of iterations for the solver.\n- `tol`: A tolerance level for convergence, defaulting to 0.001.\n- `verbose`: A flag for verbosity, defaulting to 0 (silent mode).\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A sparse matrix of shape (n_samples, n_features).\n  - `y`: A matrix or array of shape (n_samples, n_targets).\n  - `alpha`: A list or array of regularization parameters of length n_targets.\n  - `max_iter`: An optional integer specifying the maximum number of iterations.\n  - `tol`: A float specifying the tolerance for convergence.\n  - `verbose`: An integer flag for verbosity.\n\n- **Output**:\n  - Returns a 2D array of shape (n_targets, n_features) containing the coefficients for each target variable, or `None` if no coefficients are computed.\n\nInput:\n```python\nX = coo_matrix([[0, 0, 1, 0, 0],\n                 [1, 0, 0, 0, 0],\n                 [0, 0, 0, 1, 0],\n                 [0, 1, 0, 0, 0]])\ny = np.array([[0.5],\n              [0.2],\n              [0.8],\n              [0.1]])\nalpha = np.array([0.1])\n```\n\nOutput:\n```python\ncoefs = array([[-0.66390613, -0.9958592 ,  0.33195307,  1.32781226,  0.        ]])\n```", "ground_truth_code": "from scipy.sparse import linalg as sp_linalg\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom scipy.sparse import coo_matrix\n\ndef preprocess_data(X, y):\n    X = coo_matrix(X)\n    y = StandardScaler().fit_transform(y)\n    return X, y\n\ndef create_mv(curr_alpha, X1, X):\n    if X.shape[1] > X.shape[0]:\n        def _mv(x):\n            return X1.matvec(X1.rmatvec(x)) + curr_alpha * x\n    else:\n        def _mv(x):\n            return X1.rmatvec(X1.matvec(x)) + curr_alpha * x\n    return _mv\n\n# main code\ndef _solve_sparse_cg(X, y, alpha, max_iter=None, tol=0.001, verbose=0):\n    X, y = preprocess_data(X, y)\n    n_samples, n_features = X.shape\n    X1 = sp_linalg.aslinearoperator(X)\n    coefs = np.empty((y.shape[1], n_features))\n\n    for i in range(y.shape[1]):\n        y_column = y[:, i]\n        mv = create_mv(alpha[i], X1, X)\n\n        if n_features > n_samples:\n            C = sp_linalg.LinearOperator((n_samples, n_samples), matvec=mv, dtype=X.dtype)\n            coef, info = sp_linalg.cg(C, y_column, rtol=tol)\n            coefs[i] = X1.rmatvec(coef)\n        else:\n            y_column = X1.rmatvec(y_column)\n            C = sp_linalg.LinearOperator((n_features, n_features), matvec=mv, dtype=X.dtype)\n            coefs[i], info = sp_linalg.cg(C, y_column, maxiter=max_iter, rtol=tol)\n\n        if max_iter is None and info > 0 and verbose:\n            pass\n\n    return coefs if coefs.size > 0 else None", "test_script": "import numpy as np\nfrom scipy.sparse import random as sparse_random\nfrom sklearn.preprocessing import StandardScaler\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(50, 200)\n        n_features = np.random.randint(10, 50)\n        n_target_features = np.random.randint(1, 5)\n        X = sparse_random(n_samples, n_features, density=0.2, format='coo', random_state=42)\n        y = np.random.rand(n_samples, n_target_features)\n        y = StandardScaler().fit_transform(y)\n        alpha = np.random.rand(n_target_features)\n        test_cases.append((X, y, alpha))\n\n    return test_cases"}
{"problem_id": "scipy_106", "library": "scipy", "code_problem": "You are tasked with implementing a function that calculates the percentile rank of a given score within a dataset, while handling potential NaN values according to specified policies. The function should be able to accommodate different types of percentile calculations based on the provided kind parameter.\n\nFunction Signature:\n```python\ndef percentileofscore(a, score, kind, nan_policy):\n```\n\n### Constants:\n- The constant used in the main code is `50.0`, which is used in the calculation of percentiles.\n\n### Input Format:\n- `a`: A list or array-like structure containing numerical values.\n- `score`: A single numerical value or an array-like structure containing scores to evaluate.\n- `kind`: A string indicating the type of percentile calculation ('rank', 'strict', 'weak', 'mean').\n- `nan_policy`: A string indicating how to handle NaN values ('propagate' or 'omit').\n\n### Output Format:\n- Returns a float or an array of floats representing the percentile rank(s) of the given score(s) within the dataset `a`. If there are no valid entries, it returns NaN.\n\nInput:\n```python\na = np.array([0.1, 0.4, 0.5, 0.7, 0.9])\nscore = np.array([0.3, 0.6])\nkind = 'rank'\nnan_policy = 'omit'\n```\n\nOutput:\n```python\narray([20., 60.])\n```", "ground_truth_code": "import numpy as np\nfrom numpy import ma\n\n\ndef _contains_nan(a, nan_policy, use_summation='propagate'):\n    policies = ['propagate', 'omit']\n    if nan_policy not in policies:\n        nan_policy = 'propagate'\n\n    try:\n        if use_summation:\n            contains_nan = np.isnan(np.sum(a))\n        else:\n            contains_nan = np.isnan(a).any()\n    except TypeError:\n        contains_nan = False\n        nan_policy = 'omit'\n\n    return (contains_nan, nan_policy)\n\n\ndef count(x):\n    return np.count_nonzero(x, -1)\n\n\n# main code\ndef percentileofscore(a, score, kind, nan_policy):\n    a = np.asarray(a)\n    n = len(a)\n    score = np.asarray(score)\n    (cna, npa) = _contains_nan(a, nan_policy, use_summation=False)\n    (cns, nps) = _contains_nan(score, nan_policy, use_summation=False)\n\n    if cna or cns:\n        if nan_policy == 'omit':\n            if cna:\n                a = ma.masked_where(np.isnan(a), a)\n                n = a.count()\n            if cns:\n                score = ma.masked_where(np.isnan(score), score)\n        elif nan_policy == 'propagate':\n            n = 0\n\n    if n == 0:\n        perct = np.full_like(score, np.nan, dtype=np.float64)\n    else:\n        score = score[..., None]\n\n        if kind == 'rank':\n            left = count(a < score)\n            right = count(a <= score)\n            plus1 = left < right\n            perct = (left + right + plus1) * (50.0 / n)\n        elif kind == 'strict':\n            perct = count(a < score) * (100.0 / n)\n        elif kind == 'weak':\n            perct = count(a <= score) * (100.0 / n)\n        elif kind == 'mean':\n            left = count(a < score)\n            right = count(a <= score)\n            perct = (left + right) * (50.0 / n)\n        else:\n            perct = np.nan\n\n    perct = ma.filled(perct, np.nan)\n    if perct.ndim == 0:\n        return perct[()]\n    return perct", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape_a = np.random.randint(5, 20)\n        shape_score = np.random.randint(1, 10)\n        a = np.random.random(shape_a)\n        score = np.random.random(shape_score)\n        nan_policy = np.random.choice(['propagate', 'omit'])\n        kind = np.random.choice(['rank', 'strict', 'weak', 'mean'])\n        test_cases.append((a, score, kind, nan_policy))\n\n    return test_cases"}
{"problem_id": "scipy_107", "library": "scipy", "code_problem": "```python\ndef _construct_from_derivatives(xa, xb, ya, yb):\n```\n\nIn this code, the function `_construct_from_derivatives` constructs a polynomial from given derivatives at two points, `xa` and `xb`. The function takes four parameters: `xa`, `xb`, `ya`, and `yb`. Here, `ya` and `yb` are arrays representing the values of the derivatives at the points `xa` and `xb`, respectively.\n\n### Input and Output Format:\n- **Input**: The function takes four parameters:\n  - `xa`: A float or complex number representing the first point.\n  - `xb`: A float or complex number representing the second point.\n  - `ya`: A 1D array-like structure containing the derivative values at `xa`.\n  - `yb`: A 1D array-like structure containing the derivative values at `xb`.\n\n- **Output**: The function returns a NumPy array containing the coefficients of the polynomial constructed from the derivatives, with the shape determined by the input derivative arrays.\n\nInput:\n```python\nxa = 2.5\nxb = 3.5\nya = np.array([[1.0], [2.0]])\nyb = np.array([[3.0], [4.0]])\n```\n\nOutput:\n```python\narray([[1.        ],\n       [1.66666667],\n       [1.66666667],\n       [3.        ]])\n```", "ground_truth_code": "import numpy as np\nimport scipy.special as spec\nfrom scipy.special import comb\n\n# main code\ndef _construct_from_derivatives(xa, xb, ya, yb):\n    (ya, yb) = (np.asarray(ya), np.asarray(yb))\n    (dta, dtb) = (ya.dtype, yb.dtype)\n    dt = np.complex_ if np.issubdtype(dta, np.complexfloating) or np.issubdtype(dtb, np.complexfloating) else np.float_\n    (na, nb) = (len(ya), len(yb))\n    n = na + nb\n    c = np.empty((na + nb,) + ya.shape[1:], dtype=dt)\n\n    for q in range(na):\n        c[q] = ya[q] / spec.poch(n - q, q) * (xb - xa) ** q\n        for j in range(q):\n            c[q] -= (-1) ** (j + q) * comb(q, j) * c[j]\n\n    for q in range(nb):\n        c[-q - 1] = yb[q] / spec.poch(n - q, q) * (-1) ** q * (xb - xa) ** q\n        for j in range(q):\n            c[-q - 1] -= (-1) ** (j + 1) * comb(q, j + 1) * c[-q + j]\n\n    return c", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200, max_len=10, max_cols=5):\n    test_cases = []\n\n    for _ in range(n):\n        xa = np.random.uniform(-10, 10)\n        xb = np.random.uniform(-10, 10)\n\n        len_ya = np.random.randint(1, max_len)\n        len_yb = np.random.randint(1, max_len)\n        cols = np.random.randint(1, max_cols)\n        ya = np.random.uniform(-10, 10, size=(len_ya, cols))\n        yb = np.random.uniform(-10, 10, size=(len_yb, cols))\n\n        test_cases.append((xa, xb, ya, yb))\n\n    return test_cases\n"}
{"problem_id": "scipy_108", "library": "scipy", "code_problem": "You are tasked with implementing a function that aligns a 3D density distribution to the principal axes of its inertia tensor. The function should take a 3D numpy array representing the density distribution and a scalar value representing the side length of the cube that contains the density. The function should also have a boolean parameter that determines whether to return the transformation matrix and the initial shift used during the alignment process.\n\nFunction signature:\n```python\ndef align2xyz(rho: np.ndarray, side: float, return_transform: bool) -> np.ndarray:\n```\n\n### Constants:\n- The constant used in the main code is `3`, which indicates the number of iterations for aligning the density distribution to the principal axes.\n\n### Input and Output Format:\n- **Input**: \n  - `rho`: A 3D numpy array representing the density distribution.\n  - `side`: A float representing the side length of the cube containing the density.\n  - `return_transform`: A boolean indicating whether to return the transformation matrix and initial shift.\n\n- **Output**: \n  - If `return_transform` is `True`, return a tuple containing:\n    - The aligned 3D numpy array of the density distribution.\n    - The transformation matrix used for alignment.\n    - The initial shift applied to the density distribution.\n  - If `return_transform` is `False`, return only the aligned 3D numpy array of the density distribution.\n\n**Input:**\n```python\nrho = np.array([[[0.1, 0.2], [0.3, 0.4]], \n                 [[0.5, 0.6], [0.7, 0.8]]])\nside = 2\nreturn_transform = False\n```\n\n**Output:**\n```python\narray([[[0.45, 0.45],\n        [0.45, 0.45]],\n       [[0.45, 0.45],\n        [0.45, 0.45]]])\n\n```", "ground_truth_code": "import numpy as np\nfrom scipy import ndimage\n\n\ndef inertia_tensor(rho, side):\n    halfside = side / 2.0\n    n = rho.shape[0]\n    x_ = np.linspace(-halfside, halfside, n)\n    x, y, z = np.meshgrid(x_, x_, x_, indexing='ij')\n    Ixx = np.sum((y ** 2 + z ** 2) * rho)\n    Iyy = np.sum((x ** 2 + z ** 2) * rho)\n    Izz = np.sum((x ** 2 + y ** 2) * rho)\n    Ixy = -np.sum(x * y * rho)\n    Iyz = -np.sum(y * z * rho)\n    Ixz = -np.sum(x * z * rho)\n    I = np.array([[Ixx, Ixy, Ixz], [Ixy, Iyy, Iyz], [Ixz, Iyz, Izz]])\n    return I\n\n\ndef principal_axes(I):\n    w, v = np.linalg.eigh(I)\n    return w, v\n\n\n# main code\ndef align2xyz(rho, side, return_transform):\n    ne_rho = np.sum(rho)\n    rhocom = np.array(ndimage.measurements.center_of_mass(np.abs(rho)))\n    gridcenter = (np.array(rho.shape) - 1.0) / 2.0\n    shift = gridcenter - rhocom\n    rho = ndimage.interpolation.shift(rho, shift, order=3, mode='wrap')\n\n    I = inertia_tensor(rho, side)\n    w, v = principal_axes(I)\n    R = v.T\n    refR = np.copy(R)\n    refshift = np.copy(shift)\n\n    for _ in range(3):\n        I = inertia_tensor(rho, side)\n        w, v = np.linalg.eigh(I)\n        R = v.T\n        c_in = np.array(ndimage.measurements.center_of_mass(np.abs(rho)))\n        c_out = (np.array(rho.shape) - 1.0) / 2.0\n        offset = c_in - c_out.dot(R)\n        rho = ndimage.interpolation.affine_transform(rho, R.T, order=3, offset=offset, mode='wrap')\n\n    for _ in range(3):\n        rhocom = np.array(ndimage.measurements.center_of_mass(np.abs(rho)))\n        shift = gridcenter - rhocom\n        rho = ndimage.interpolation.shift(rho, shift, order=3, mode='wrap')\n\n    rho *= ne_rho / np.sum(rho)\n\n    if return_transform:\n        return rho, refR, refshift\n    return rho", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        side = np.random.randint(10, 50)\n        n = side\n        rho = np.random.rand(n, n, n)\n        return_transform = np.random.choice([True, False])\n\n        test_cases.append((rho, side, return_transform))\n\n    return test_cases"}
{"problem_id": "scipy_109", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the logarithm of the beta function using parameters related to a Bayesian inference context. The function signature is as follows:\n\n```python\ndef _e_log_beta(c0: float, d0: float, c: float, d: float) -> float:\n```\n\nIn this function, the following constant is used:\n- `log_C`: This constant represents the logarithm of the normalization constant for the beta distribution, calculated using the gamma function.\n\n\nInput format:\n- The function takes four floating-point numbers as input: `c0`, `d0`, `c`, and `d`.\n\nOutput format:\n- The function returns a single floating-point number, which is the computed logarithm of the beta function based on the provided parameters.\n\n```python\nInput: (array([3.5, 2.1]), array([4.2, 1.8]), array([2.3, 3.7]), array([1.5, 2.9]))\nOutput: -0.28772341349696595\n```", "ground_truth_code": "import numpy as np\nfrom scipy.special import psi, gammaln\n\n\n# main code\ndef _e_log_beta(c0, d0, c, d):\n    log_C = gammaln(c0 + d0) - gammaln(c0) - gammaln(d0)\n    psi_cd = psi(c + d)\n    log_mu = (c0 - 1) * (psi(c) - psi_cd)\n    log_i_mu = (d0 - 1) * (psi(d) - psi_cd)\n    return np.sum(log_C + log_mu + log_i_mu)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(1, 5)\n        c0 = np.random.rand(size) * 10\n        d0 = np.random.rand(size) * 10\n        c = np.random.rand(size) * 10\n        d = np.random.rand(size) * 10\n        test_cases.append((c0, d0, c, d))\n\n    return test_cases"}
{"problem_id": "scipy_110", "library": "scipy", "code_problem": "You are tasked with implementing a function that computes the Singular Value Decomposition (SVD) of a given matrix using sparse matrix operations. The function should handle both dense and sparse input matrices and return the left singular vectors, singular values, and right singular vectors of the input matrix.\n\nFunction signature:\n```python\ndef _svd_right(X):\n```\n\nConstant used in the main code:\n- `1e-07`: This constant is used as a threshold to filter out small singular values during the computation.\n\nInput format:\n- The input to the function is a matrix `X`, which can be either a dense NumPy array or a sparse matrix from the `scipy.sparse` module.\n\nOutput format:\n- The function returns a tuple `(U, S, V)`, where:\n  - `U` is a sparse matrix containing the left singular vectors.\n  - `S` is a sparse diagonal matrix containing the singular values.\n  - `V` is a sparse matrix containing the right singular vectors.\n\nInput:\n```python\nX = np.array([[1, 2, 3], \n              [4, 5, 6], \n              [7, 8, 9]])\n```\n\nOutput:\n```python\n(U, S, V) = _svd_right(X)\n# U: \n<3x2 sparse matrix of type '<class 'numpy.float64'>'\n\twith 6 stored elements in Compressed Sparse Row format>\n  (0, 0)\t-0.21483723836839624\n  (0, 1)\t0.8872306883463725\n  (1, 0)\t-0.520587389464737\n  (1, 1)\t0.2496439529882937\n  (2, 0)\t-0.8263375405610779\n  (2, 1)\t-0.3879427823697725\n# S: \n<2x2 sparse matrix of type '<class 'numpy.float64'>'\n\twith 2 stored elements in Compressed Sparse Row format>\n  (0, 0)\t16.84810335261421\n  (1, 1)\t1.0683695145547083\n# V: \n[[-0.47967118 -0.57236779 -0.66506441]\n [-0.77669099 -0.07568647  0.62531805]]\n```", "ground_truth_code": "import scipy.sparse as sp\nimport numpy as np\nimport scipy.sparse.linalg as sla\n\ndef dot(X, Y):\n    if sp.isspmatrix(X) and sp.isspmatrix(Y):\n        return X * Y\n    elif sp.isspmatrix(X) or sp.isspmatrix(Y):\n        return sp.csr_matrix(X) * sp.csr_matrix(Y)\n    else:\n        return np.asmatrix(X) * np.asmatrix(Y)\n\n# main code\ndef _svd_right(X):\n    XXt = dot(X, X.T)\n    u_vec, val, _ = sla.svds(XXt, k=X.shape[0] - 1, solver='arpack')\n    keep = np.where(val > 1e-07)[0]\n    u_vec = u_vec[:, keep]\n    val = val[keep]\n    idx = np.argsort(val)[::-1]\n    val = val[idx]\n    U = sp.csr_matrix(u_vec[:, idx])\n    tmp_val = np.sqrt(val)\n    tmp_l = len(idx)\n    S = sp.spdiags(tmp_val, 0, m=tmp_l, n=tmp_l, format='csr')\n    inv_S = sp.spdiags(1.0 / tmp_val, 0, m=tmp_l, n=tmp_l, format='csr')\n    V = U.T @ X\n    V = inv_S @ V\n    return (U, S, V)\n\nX = np.array([[1, 2, 3],\n              [4, 5, 6],\n              [7, 8, 9]])\n\na = _svd_right(X)", "test_script": "import numpy as np\nimport scipy.sparse as sp\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(3, 20)\n        cols = np.random.randint(3, 20)\n        density = np.random.uniform(0.05, 0.5)\n        use_sparse = np.random.choice([True, False])\n\n        if use_sparse:\n            X = sp.random(rows, cols, density=density, format='csr', dtype=np.float64)\n        else:\n            X = np.random.randn(rows, cols)\n\n        test_cases.append(X)\n\n    return test_cases"}
{"problem_id": "scipy_111", "library": "scipy", "code_problem": "You are tasked with implementing a function that applies a bandpass filter to a given signal using Chebyshev Type I filters. The function will take in a signal and filter it to allow frequencies within a specified range to pass through while attenuating frequencies outside this range.\n\nFunction signature:\n```python\ndef blackbox(x, samplerate, low_cutoff, high_cutoff, order_1, order_2, axis):\n```\n\nConstants used in the main code:\n- The constant `0.1` is used as the ripple factor for the Chebyshev filter design.\n\nInput format:\n- `x`: A 1D or 2D array-like structure representing the input signal.\n- `samplerate`: A float representing the sampling rate of the signal.\n- `low_cutoff`: A float representing the lower cutoff frequency for the bandpass filter.\n- `high_cutoff`: A float representing the upper cutoff frequency for the bandpass filter.\n- `order_1`: An integer representing the order of the low-pass filter.\n- `order_2`: An integer representing the order of the high-pass filter.\n- `axis`: An integer specifying the axis along which to filter the signal.\n\nOutput format:\n- The function returns a filtered signal, which is a 1D or 2D array-like structure containing the frequencies within the specified band.\n\nInput:\n```python\nx = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nsamplerate = 1000\nlow_cutoff = 10.0\nhigh_cutoff = 100.0\norder_1 = 2\norder_2 = 3\naxis = 0\n```\n\nOutput:\n```python\narray([[0.00018003, 0.00036005, 0.00054008],\n       [0.00123296, 0.00192585, 0.00261873],\n       [0.00384379, 0.00506885, 0.00629391]])\n``` \n", "ground_truth_code": "from scipy import signal\n\n# main code\ndef blackbox(x, samplerate, low_cutoff, high_cutoff, order_1, order_2, axis):\n    low_cutoff_freq = low_cutoff * 2 / samplerate\n    high_cutoff_freq = high_cutoff * 2 / samplerate\n    b, a = signal.cheby1(order_1, 0.1, low_cutoff_freq)\n    x_filtered = signal.lfilter(b, a, x, axis)\n    b, a = signal.cheby1(order_2, 0.1, high_cutoff_freq, 'high')\n    x_filtered = signal.lfilter(b, a, x_filtered, axis)\n    return x_filtered", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        x = np.random.randn(100, 10)\n        samplerate = np.random.randint(1000, 5000)\n        low_cutoff = np.random.uniform(0, 50)\n        high_cutoff = np.random.uniform(50, 200)\n        order_1 = np.random.randint(1, 6)\n        order_2 = np.random.randint(1, 6)\n        axis = np.random.randint(0, 2)\n\n        test_cases.append((x, samplerate, low_cutoff, high_cutoff, order_1, order_2, axis))\n\n    return test_cases\n"}
{"problem_id": "sklearn_0", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of various regression models on a given dataset. The function will take training and testing datasets as input, fit multiple regression models to the training data, and compute performance metrics for each model. The performance metrics to be calculated are Mean Absolute Error (MAE) and Root Mean Squared Error (RMSE). Additionally, a baseline model will be evaluated using the median of the training target values.\n\nFunction Signature:\n```python\ndef evaluate(X_train: pd.DataFrame, X_test: pd.DataFrame, y_train: pd.Series, y_test: pd.Series) -> pd.DataFrame:\n```\n\nConstant Used:\n- The constant used in the main code is the list of model names: `model_name_list`.\n\nInput Format:\n- `X_train`: A pandas DataFrame containing the training features.\n- `X_test`: A pandas DataFrame containing the testing features.\n- `y_train`: A pandas Series containing the training target values.\n- `y_test`: A pandas Series containing the testing target values.\n\nOutput Format:\n- The function returns a pandas DataFrame with the performance metrics (MAE and RMSE) for each regression model and the baseline model. The DataFrame is indexed by model names and contains two columns: 'mae' and 'rmse'.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample data generation\nX_train = pd.DataFrame({\n    'feature_0': [0.5, 1.5, -1.0, 2.0, 0.0],\n    'feature_1': [1.0, 2.0, 0.0, -1.0, 1.0],\n    'feature_2': [0.0, -1.5, 1.0, 0.5, 2.0],\n    'feature_3': [1.5, 0.5, -0.5, 1.0, 1.0]\n})\ny_train = pd.Series([1.0, 2.0, 0.0, 1.5, 1.0])\n\nX_test = pd.DataFrame({\n    'feature_0': [0.0, 1.0],\n    'feature_1': [1.5, -1.0],\n    'feature_2': [0.5, 1.0],\n    'feature_3': [1.0, 0.0]\n})\ny_test = pd.Series([1.0, 0.5])\n```\n\n**Output:**\n```python\n                            mae      rmse\nLinear Regression      0.207648  0.286376\nElasticNet Regression  0.341463  0.449734\nRandom Forest            0.2275  0.282511\nExtra Trees               0.345  0.453927\nSVM                    0.355472  0.468442\nGradient Boosted       0.250515  0.353918\nBaseline                   0.25  0.353553\n```\n", "ground_truth_code": "from sklearn.linear_model import LinearRegression\nfrom sklearn.linear_model import ElasticNet\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.ensemble import ExtraTreesRegressor\nfrom sklearn.svm import SVR\nfrom sklearn.ensemble import GradientBoostingRegressor\nimport pandas as pd\nimport numpy as np\n\n\n# main code\ndef evaluate(X_train, X_test, y_train, y_test):\n    model_name_list = ['Linear Regression', 'ElasticNet Regression', 'Random Forest', 'Extra Trees', 'SVM',\n                       'Gradient Boosted', 'Baseline']\n    X_train = X_train.drop(X_train.columns[-1], axis='columns')\n    X_test = X_test.drop(X_test.columns[-1], axis='columns')\n\n    models = [\n        LinearRegression(),\n        ElasticNet(alpha=1.0, l1_ratio=0.5),\n        RandomForestRegressor(n_estimators=100),\n        ExtraTreesRegressor(n_estimators=100),\n        SVR(kernel='rbf', degree=3, C=1.0, gamma='auto'),\n        GradientBoostingRegressor(n_estimators=50)\n    ]\n    results = pd.DataFrame(columns=['mae', 'rmse'], index=model_name_list)\n\n    for i, model in enumerate(models):\n        model.fit(X_train, y_train)\n        predictions = model.predict(X_test)\n        mae = np.mean(abs(predictions - y_test))\n        rmse = np.sqrt(np.mean((predictions - y_test) ** 2))\n        results.loc[model_name_list[i], :] = [mae, rmse]\n\n    baseline = np.median(y_train)\n    baseline_mae = np.mean(abs(baseline - y_test))\n    baseline_rmse = np.sqrt(np.mean((baseline - y_test) ** 2))\n    results.loc['Baseline', :] = [baseline_mae, baseline_rmse]\n\n    return results if not results.empty else pd.DataFrame()", "test_script": "import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n        X = pd.DataFrame(np.random.randn(num_samples, num_features),\n                         columns=[f'feature_{i}' for i in range(num_features)])\n        y = pd.Series(np.random.randn(num_samples))\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=np.random.randint(1000))\n        if X_train.shape[1] > 1 and X_test.shape[1] > 1:\n            test_cases.append((X_train, X_test, y_train, y_test))\n\n    return test_cases"}
{"problem_id": "sklearn_1", "library": "sklearn", "code_problem": "The task is to implement a data preprocessing function for machine learning datasets, specifically designed to handle training and testing datasets. The function will perform several preprocessing steps to clean and transform the data, making it suitable for further analysis or modeling.\n\nFunction Signature:\n```python\ndef expert_preprocessing(X_train, X_test):\n```\n\nConstant Used:\n- The constant value `117310.979` is used to identify and replace specific outlier values in the dataset.\n\nInput Format:\n- `X_train`: A pandas DataFrame representing the training dataset.\n- `X_test`: A pandas DataFrame representing the testing dataset.\n\nOutput Format:\n- Returns a tuple containing two pandas DataFrames: the processed training dataset and the processed testing dataset.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample training data\nX_train = pd.DataFrame({\n    'var0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'var1': [1, 2, 3, 4, 5],\n    'var2': [5, 4, 3, 2, 1],\n    'var3': [0, 0, -999999, 0, 0],\n    'var38': [117310.9795, 117310.979, 117310.979, 117310.979, 117310.979],\n    'ID': [0, 1, 2, 3, 4],\n    'TARGET': [0, 1, 0, 1, 0]\n})\n\n# Sample testing data\nX_test = pd.DataFrame({\n    'var0': [0.2, 0.3, 0.4],\n    'var1': [2, 3, 4],\n    'var2': [4, 3, 2],\n    'var3': [0, -999999, 0],\n    'var38': [117310.9795, 117310.979, 117310.979],\n    'ID': [0, 1, 2],\n    'TARGET': [1, 0, 1]\n})\n\n# Call the expert preprocessing function\nX_train_processed, X_test_processed = expert_preprocessing(X_train, X_test)\n```\n\n**Output:**\n```python\n# Processed training data\nX_train_processed\n        var0      var1  ...  kmeans_cluster9  kmeans_cluster10\n0   0.083333  0.083333  ...                8                 7\n1   0.166667  0.166667  ...                0                 5\n2   0.250000  0.250000  ...                7                 8\n3   0.333333  0.333333  ...                0                 5\n4   0.416667  0.416667  ...                3                 2\n5   0.500000  0.500000  ...                4                 1\n6   0.583333  0.583333  ...                1                 0\n7   0.666667  0.666667  ...                2                 9\n8   0.750000  0.750000  ...                6                 6\n9   0.833333  0.833333  ...                2                 3\n10  0.916667  0.916667  ...                5                 4\n11  1.000000  1.000000  ...                2                 3\n[12 rows x 18 columns]\n# Processed testing data\nX_test_processed\n       var0      var1  ...  kmeans_cluster9  kmeans_cluster10\n0  0.166667  0.166667  ...                3                 2\n1  0.250000  0.250000  ...                7                 8\n2  0.333333  0.333333  ...                3                 2\n3  0.416667  0.416667  ...                4                 9\n4  0.500000  0.500000  ...                1                 0\n5  0.583333  0.583333  ...                2                 9\n[6 rows x 18 columns]\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.decomposition import PCA\nfrom sklearn.preprocessing import normalize\nfrom sklearn.cluster import KMeans\n\n\n# main code\ndef expert_preprocessing(X_train, X_test):\n\n    def process_base(train, test):\n        train.loc[(train['var38'] > 117310.979) & (train['var38'] < 117310.98), 'var38'] = -999.0\n        test.loc[(test['var38'] > 117310.979) & (test['var38'] < 117310.98), 'var38'] = -999.0\n        train.loc[train['var3'] == -999999, 'var3'] = -999.0\n        test.loc[test['var3'] == -999999, 'var3'] = -999.0\n        return train, test\n\n    def drop_sparse(train, test):\n        flist = [col for col in train.columns if col not in ['ID', 'TARGET']]\n        for col in flist:\n            if len(np.unique(train[col])) < 2:\n                train.drop(col, axis=1, inplace=True)\n                test.drop(col, axis=1, inplace=True)\n        return train, test\n\n    def drop_duplicated(train, test):\n        flist = [col for col in train.columns if col not in ['ID', 'TARGET']]\n        train.drop([col for col in flist if 'var6' in col], axis=1, inplace=True)\n        test.drop([col for col in flist if 'var6' in col], axis=1, inplace=True)\n        return train, test\n\n    def normalize_features(train, test):\n        flist = [col for col in train.columns if col not in ['ID', 'TARGET']]\n        for col in flist:\n            fmax = train[col].max()\n            if fmax > 0:\n                train[col] = train[col] / fmax\n                test[col] = test[col] / fmax\n        return train, test\n\n    def pca_features(train, test):\n        flist = [col for col in train.columns if col not in ['ID', 'TARGET']]\n        pca = PCA(n_components=2)\n        x_train_projected = pca.fit_transform(normalize(train[flist], axis=0))\n        x_test_projected = pca.transform(normalize(test[flist], axis=0))\n        train['PCAOne'] = x_train_projected[:, 0]\n        train['PCATwo'] = x_train_projected[:, 1]\n        test['PCAOne'] = x_test_projected[:, 0]\n        test['PCATwo'] = x_test_projected[:, 1]\n        return train, test\n\n    def kmeans_features(train, test):\n        flist = [col for col in train.columns if col not in ['ID', 'TARGET']]\n        for ncl in range(2, 11):\n            cls = KMeans(n_clusters=ncl)\n            cls.fit(train[flist].values)\n            train[f'kmeans_cluster{ncl}'] = cls.predict(train[flist].values)\n            test[f'kmeans_cluster{ncl}'] = cls.predict(test[flist].values)\n        return train, test\n\n    X_train, X_test = process_base(X_train.copy(), X_test.copy())\n    X_train, X_test = drop_sparse(X_train, X_test)\n    X_train, X_test = drop_duplicated(X_train, X_test)\n    X_train, X_test = normalize_features(X_train, X_test)\n    X_train, X_test = pca_features(X_train, X_test)\n    X_train, X_test = kmeans_features(X_train, X_test)\n\n    return X_train, X_test", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples_train = np.random.randint(50, 200)\n        num_samples_test = np.random.randint(20, 100)\n        num_features = np.random.randint(10, 50)\n        X_train_data, y_train = make_classification(n_samples=num_samples_train, n_features=num_features,\n                                                    random_state=None)\n        X_test_data, y_test = make_classification(n_samples=num_samples_test, n_features=num_features,\n                                                  random_state=None)\n        feature_names = [f'var{i}' for i in range(num_features)]\n        X_train = pd.DataFrame(X_train_data, columns=feature_names)\n        X_test = pd.DataFrame(X_test_data, columns=feature_names)\n        X_train['ID'] = np.arange(len(X_train))\n        X_test['ID'] = np.arange(len(X_test))\n        X_train['TARGET'] = y_train\n        X_test['TARGET'] = y_test\n        X_train.loc[\n            np.random.choice(X_train.index, size=len(X_train) // 10), 'var38'] = 117310.9795\n        X_test.loc[np.random.choice(X_test.index, size=len(X_test) // 10), 'var38'] = 117310.9795\n        X_train.loc[np.random.choice(X_train.index, size=len(X_train) // 20), 'var3'] = -999999\n        X_test.loc[np.random.choice(X_test.index, size=len(X_test) // 20), 'var3'] = -999999\n        X_train.fillna(0, inplace=True)\n        X_test.fillna(0, inplace=True)\n\n        test_cases.append((X_train, X_test))\n\n    return test_cases"}
{"problem_id": "sklearn_2", "library": "sklearn", "code_problem": "You are tasked with implementing a function that fits a machine learning model to a given dataset and makes predictions on a test dataset. The function should utilize a support vector classifier (SVC) with the option to scale the input features. Additionally, it should support both binary and multi-class classification tasks, applying model calibration for improved probability estimates.\n\nFunction signature:\n```python\ndef fit(X, y, X_test, param_grid, label_binarizer, models, scaler):\n```\n\n### Constants:\n- The constant `random_state` is set to `42` for reproducibility in the SVC model.\n\n### Input Format:\n- `X`: A 2D array-like structure representing the training features.\n- `y`: A 1D array-like structure representing the target labels.\n- `X_test`: A 2D array-like structure representing the test features.\n- `param_grid`: A dictionary specifying the hyperparameters to be tuned during model fitting.\n- `label_binarizer`: An instance of a label binarizer for transforming the target labels.\n- `models`: A list or dictionary to store the fitted models.\n- `scaler`: An optional scaler object for feature scaling.\n\n### Output Format:\n- The function returns a 2D NumPy array containing the predicted labels for the test dataset. Each row corresponds to a sample in `X_test`, and each column corresponds to a class label.\n\nInput:\n```python\nX = np.array([\n    [0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6],\n    [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 1.0], [1.0, 1.1]\n])\ny = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 1])  # now 5 samples per class\nX_test = np.array([[0.15, 0.25], [0.85, 0.95]])\nparam_grid = {'svc__C': [0.1, 1.0, 10.0]}\nlabel_binarizer = LabelBinarizer()\nmodels = [None, None]\nscaler = StandardScaler()\n```\n\nOutput:\n```python\npredictions = np.array([0, 1])\n```", "ground_truth_code": "from sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.calibration import CalibratedClassifierCV\nfrom sklearn.svm import LinearSVC\nimport numpy as np\n\n# main code\ndef fit(X, y, X_test, param_grid, label_binarizer, models, scaler):\n\n    label_binarizer.fit(y)\n    y_bin = label_binarizer.transform(y)\n    y_bin = y_bin[:, np.newaxis] if y_bin.ndim == 1 else y_bin\n    classes = label_binarizer.classes_\n    steps = [('svc', LinearSVC(dual=False, penalty='l2', loss='squared_hinge', random_state=42))]\n    if scaler:\n        scaler = scaler.fit(X)\n        steps.insert(0, ('scaler', scaler))\n\n    pipeline = Pipeline(steps)\n\n    predictions = []\n    if len(classes) == 2 and y_bin.shape[1] == 1:\n        grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring='accuracy')\n        grid_search.fit(X, y_bin.ravel())\n        best_pipeline = grid_search.best_estimator_\n        calibrated_svc = CalibratedClassifierCV(best_pipeline.named_steps['svc'], cv='prefit', method='sigmoid')\n        transform_X = best_pipeline.named_steps['scaler'].transform(X) if scaler else X\n        calibrated_svc.fit(transform_X, y_bin.ravel())\n        models[0] = (best_pipeline.named_steps.get('scaler'), calibrated_svc)\n        models[1] = (best_pipeline.named_steps.get('scaler'), calibrated_svc)\n        transform_X_test = best_pipeline.named_steps['scaler'].transform(X_test) if scaler else X_test\n        predictions = calibrated_svc.predict(transform_X_test)\n    else:\n        for (i, class_label) in enumerate(classes):\n            grid_search = GridSearchCV(pipeline, param_grid, cv=5, scoring='balanced_accuracy')\n            grid_search.fit(X, y_bin[:, i])\n            best_pipeline = grid_search.best_estimator_\n            calibrated_svc = CalibratedClassifierCV(best_pipeline.named_steps['svc'], cv='prefit', method='sigmoid')\n            transform_X = best_pipeline.named_steps['scaler'].transform(X) if scaler else X\n            calibrated_svc.fit(transform_X, y_bin[:, i])\n            models[class_label] = (best_pipeline.named_steps.get('scaler'), calibrated_svc)\n\n            transform_X_test = best_pipeline.named_steps['scaler'].transform(X_test) if scaler else X_test\n            class_predictions = calibrated_svc.predict(transform_X_test)\n            predictions.append(class_predictions)\n\n        predictions = np.array(predictions).T if len(classes) > 2 else predictions\n\n    return predictions\n", "test_script": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler, LabelBinarizer\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(50, 500)\n        n_features = np.random.randint(5, 50)\n        X = np.random.randn(n_samples, n_features)\n        X_test = np.random.randn(np.random.randint(10, 100), n_features)\n        n_classes = np.random.choice([2, 3, 4, 5])\n        y = np.random.choice(range(n_classes), n_samples)\n        param_grid = {\n            'svc__C': np.random.uniform(0.1, 10, size=5).tolist(),\n        }\n        label_binarizer = LabelBinarizer()\n        models = {} if n_classes > 2 else [None, None]\n        scaler = StandardScaler() if np.random.rand() > 0.5 else None\n        test_cases.append((X, y, X_test, param_grid, label_binarizer, models, scaler))\n\n    return test_cases"}
{"problem_id": "sklearn_3", "library": "sklearn", "code_problem": "You are tasked with implementing a function that computes various metrics for evaluating the performance of a logistic regression model using cross-validation. The function will calculate the average Pearson and Spearman correlation coefficients, the area under the ROC curve (AUC), and the area under the precision-recall curve (PRC) for a given dataset. Additionally, it will provide confidence intervals for the correlation coefficients.\n\nFunction Signature:\n```python\ndef compute_roc_metrics(df, cv_column, outcome, predictor, model, model_input, n_bootstraps, alternate_train):\n```\n\nConstants used in the main code:\n- The significance level for the confidence interval is set to 0.05.\n\nInput format:\n- `df`: A pandas DataFrame containing the dataset.\n- `cv_column`: A string representing the name of the column used for cross-validation.\n- `outcome`: A string representing the name of the outcome variable.\n- `predictor`: A string representing the name of the column where predicted probabilities will be stored.\n- `model`: A boolean indicating whether to train a logistic regression model.\n- `model_input`: A list of strings representing the names of the input features for the model.\n- `n_bootstraps`: An integer representing the number of bootstrap samples to use for estimating AUC and PRC.\n- `alternate_train`: A boolean indicating whether to use the current fold for training or not.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `\"pearson_corr\"`: A tuple containing the average Pearson correlation coefficient and its lower and upper confidence interval bounds.\n  - `\"spearman_corr\"`: A tuple containing the average Spearman correlation coefficient and its lower and upper confidence interval bounds.\n  - `\"auc\"`: A float representing the mean AUC value.\n  - `\"prc\"`: A float representing the mean PRC value.\n  - `\"outcome_mean\"`: A float representing the mean of the outcome variable in the dataset.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    \"feature_0\": [0.5, -0.2, 0.1, 0.4, -0.3, 0.6, -0.1, 0.2, 0.3, -0.4],\n    \"feature_1\": [1.0, 0.8, 0.6, 0.9, 0.5, 1.1, 0.7, 0.4, 0.3, 0.2],\n    \"outcome\": [1, 0, 1, 1, 0, 1, 0, 0, 1, 0],\n    \"cv_column\": [1, 1, 1, 2, 2, 2, 3, 3, 3, 3]\n}\ndf = pd.DataFrame(data)\n\n# Parameters for the function\ncv_column = \"cv_column\"\noutcome = \"outcome\"\npredictor = \"feature_0\"  # Using one of the features directly\nmodel = False  # Not using logistic regression\nmodel_input = [\"feature_0\", \"feature_1\"]  # Features to consider\nn_bootstraps = 10  # Number of bootstraps\nalternate_train = True  # Alternate training\n\n# Call the function\nresult = compute_roc_metrics(df, cv_column, outcome, predictor, model, model_input, n_bootstraps, alternate_train)\n```\n\n**Output:**\n```python\n{\n    'pearson_corr': (0.8106020078036348, 0.36962206569133566, 0.9535559230771932), \n    'spearman_corr': (0.835549158936787, 0.4345131613540143, 0.9600885158646587), \n    'auc': 1.0, \n    'prc': 1.0, \n    'outcome_mean': 0.5\n}\n```", "ground_truth_code": "import math\nimport numpy as np\nfrom scipy import stats\nfrom scipy.stats import pearsonr, spearmanr\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.metrics import roc_curve, precision_recall_curve, auc\nimport numpy.random as rng\n\n\ndef r_to_z(r):\n    return math.log((1 + r) / (1 - r)) / 2.0\n\n\ndef z_to_r(z):\n    e = math.exp(2 * z)\n    return (e - 1) / (e + 1)\n\n\ndef r_confidence_interval(r, alpha, n):\n    z = r_to_z(r)\n    se = 1.0 / math.sqrt(n - 3)\n    z_crit = stats.norm.ppf(1 - alpha / 2)\n    lo = z - z_crit * se\n    hi = z + z_crit * se\n    return (z_to_r(lo), z_to_r(hi))\n\n\ndef predict_logistic_regression(clf, input_cols):\n    return clf.predict_proba(input_cols)[:, 1]\n\n\n# main code\ndef compute_roc_metrics(df, cv_column, outcome, predictor, model, model_input, n_bootstraps, alternate_train):\n    tprs = []\n    base_fpr = np.linspace(0, 1, 101)\n    aucs = []\n    prcs = []\n    rs = []\n    ps = []\n\n    for i in [1, 2, 3]:\n        df_temp = df[df[cv_column] == float(i)].copy()\n\n        if model:\n            df_train = df[df[cv_column] != float(i)].copy() if alternate_train else df_temp\n            clf = LogisticRegression().fit(df_train[model_input], df_train[outcome])\n            df_temp[predictor] = predict_logistic_regression(clf, df_temp[model_input])  # Overwrite predictor\n        r, p = pearsonr(df_temp[predictor], df_temp[outcome]), spearmanr(df_temp[predictor], df_temp[outcome])\n        rs.append(r[0])\n        ps.append(p[0])\n\n        aucs_sub = []\n        if n_bootstraps:\n            X, Y = df_temp[predictor].to_numpy(), df_temp[outcome].to_numpy()\n            for _ in range(n_bootstraps):\n                indices = rng.randint(0, len(Y), len(Y))\n                if len(np.unique(Y[indices])) < 2:\n                    continue\n                fpr, tpr, _ = roc_curve(Y[indices], X[indices])\n                aucs.append(auc(fpr, tpr))\n                aucs_sub.append(auc(fpr, tpr))\n                precision, recall, _ = precision_recall_curve(Y[indices], X[indices])\n                prcs.append(auc(recall, precision))\n                tprs.append(np.interp(base_fpr, fpr, tpr))\n        else:\n            fpr, tpr, _ = roc_curve(df_temp[outcome], df_temp[predictor])\n            aucs.append(auc(fpr, tpr))\n            precision, recall, _ = precision_recall_curve(df_temp[outcome], df_temp[predictor])\n            prcs.append(auc(recall, precision))\n            tprs.append(np.interp(base_fpr, fpr, tpr))\n\n    aucs = np.mean(aucs)\n    prcs = np.mean(prcs)\n    avg_r, avg_p = np.mean(rs), np.mean(ps)\n    r_lb, r_ub = r_confidence_interval(avg_r, 0.05, len(df.index))\n    p_lb, p_ub = r_confidence_interval(avg_p, 0.05, len(df.index))\n\n    return {\n        \"pearson_corr\": (avg_r, r_lb, r_ub),\n        \"spearman_corr\": (avg_p, p_lb, p_ub),\n        \"auc\": aucs,\n        \"prc\": prcs,\n        \"outcome_mean\": df[outcome].mean()\n    }", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(50, 500)\n        num_features = random.randint(2, 10)\n        feature_columns = [f\"feature_{i}\" for i in range(num_features)]\n        df = pd.DataFrame(\n            np.random.randn(num_samples, num_features + 2),\n            columns=feature_columns + [\"outcome\", \"cv_column\"]\n        )\n        df[\"cv_column\"] = [random.choice([1, 2, 3]) for _ in range(num_samples)]\n        df[\"outcome\"] = [random.choice([0, 1]) for _ in range(num_samples)]\n        model = random.choice([True, False])\n        num_selected_features = random.randint(1, num_features)\n        model_input = random.sample(feature_columns, num_selected_features)\n        predictor = \"comb\" if model else random.choice(model_input)\n        n_bootstraps = random.randint(0, 50)\n        alternate_train = random.choice([True, False])\n        test_cases.append((df, \"cv_column\", \"outcome\", predictor, model, model_input, n_bootstraps, alternate_train))\n\n    return test_cases"}
{"problem_id": "sklearn_4", "library": "sklearn", "code_problem": "You are tasked with implementing a function that utilizes ensemble learning models to identify the most important features from a given dataset. The function should allow for the selection of a specified number of top features based on their importance scores derived from multiple regression models.\n\nFunction Signature:\n```python\ndef ensemble_model_feature(X, Y, top_n_features, models=None):\n```\n\n### Constants Used:\n- The constant `n_estimators` is set to `100` for the ensemble models, which indicates the number of trees in the ensemble.\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A pandas DataFrame with shape (n_samples, n_features).\n  - `Y`: A pandas Series or DataFrame with shape (n_samples,).\n  - `top_n_features`: An integer.\n  - `models`: (Optional) A dictionary of models.\n\n- **Output**:\n  - A list of strings representing the names of the top features based on their importance scores.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\nfrom sklearn import ensemble\n\n# Sample Data\nnp.random.seed(42)  # For reproducibility\nnum_samples = 60\nnum_features = 10\n\nfeature_names = [f\"feature_{i}\" for i in range(num_features)]\nX = pd.DataFrame(np.random.rand(num_samples, num_features), columns=feature_names)\nY = np.random.rand(num_samples)\n\ntop_n_features = 3\nmodels = {\n    \"RandomForest\": ensemble.RandomForestRegressor(n_estimators=100, n_jobs=-1),\n    \"AdaBoost\": ensemble.AdaBoostRegressor(n_estimators=100),\n    \"ExtraTrees\": ensemble.ExtraTreesRegressor(n_estimators=100, n_jobs=-1)\n}\n```\n\n**Output:**\n```python\n['feature_2', 'feature_8', 'feature_6']\n```", "ground_truth_code": "import pandas as pd\nfrom sklearn import ensemble\n\ndef get_top_k_features(features, model, top_n_features):\n\n    feature_importances = model.feature_importances_\n    feature_imp_sorted = pd.DataFrame({'feature': features, 'importance': feature_importances})\n    return feature_imp_sorted.nlargest(top_n_features, 'importance')['feature'].tolist()\n\n# main code\ndef ensemble_model_feature(X, Y, top_n_features, models=None):\n    if models is None:\n        models = {\n            \"RandomForest\": ensemble.RandomForestRegressor(n_estimators=100, n_jobs=-1),\n            \"AdaBoost\": ensemble.AdaBoostRegressor(n_estimators=100),\n            \"ExtraTrees\": ensemble.ExtraTreesRegressor(n_estimators=100, n_jobs=-1)\n        }\n\n    features = X.columns.to_list()\n    selected_features = set()\n\n    for model_name, model in models.items():\n        model.fit(X, Y)\n        top_features = get_top_k_features(features, model, top_n_features)\n        selected_features.update(top_features)\n\n    return list(selected_features)", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn import ensemble\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 20)\n\n        feature_names = [f\"feature_{i}\" for i in range(num_features)]\n        X = pd.DataFrame(np.random.rand(num_samples, num_features), columns=feature_names)\n        Y = np.random.rand(num_samples)\n\n        top_n_features = np.random.randint(1, min(num_features, 10))\n        models = None if np.random.rand() < 0.5 else {\n            \"RandomForest\": ensemble.RandomForestRegressor(n_estimators=100, n_jobs=-1),\n            \"AdaBoost\": ensemble.AdaBoostRegressor(n_estimators=100),\n            \"ExtraTrees\": ensemble.ExtraTreesRegressor(n_estimators=100, n_jobs=-1)\n        }\n\n        test_cases.append((X, Y, top_n_features, models))\n\n    return test_cases"}
{"problem_id": "sklearn_5", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a classification model by calculating its accuracy under different thresholds. The function should identify the rarest class in the dataset and compute the balanced accuracy score for predictions made at two different thresholds: a default threshold of 0.5 and a user-defined threshold for the rare class.\n\nThe function signature of the main code is:\n```python\ndef classification_model_stats(y_true, predicted, m_thresh=0.5):\n```\n\nIn this function, the constant used is:\n- `0.5`: This is the default threshold for classification predictions.\n\n\nInput format:\n- `y_true`: A list or array of true class labels.\n- `predicted`: A 2D array of predicted probabilities for each class.\n- `m_thresh`: A float representing the threshold for the rare class (default is 0.5).\n\nOutput format:\n- The function returns a float representing the maximum balanced accuracy score calculated from the predictions at the specified thresholds.\n\nInput:\n```python\ny_true = np.array([0, 1, 0, 1, 0, 2, 1, 0, 2, 1])\npredicted = np.array([[0.1, 0.7, 0.2],\n                      [0.2, 0.5, 0.3],\n                      [0.6, 0.3, 0.1],\n                      [0.1, 0.8, 0.1],\n                      [0.9, 0.05, 0.05],\n                      [0.2, 0.1, 0.7],\n                      [0.3, 0.4, 0.3],\n                      [0.4, 0.4, 0.2],\n                      [0.05, 0.1, 0.85],\n                      [0.3, 0.6, 0.1]])\nm_thresh = 0.6\n```\n\nOutput:\n```python\n0.9166666666666666\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import confusion_matrix\n\n\ndef find_rare_class(classes):\n    unique_classes, counts = np.unique(classes, return_counts=True)\n    class_counts = dict(zip(unique_classes, counts))\n    return min(class_counts, key=class_counts.get)\n\n\ndef balanced_accuracy_score(y_true, y_pred, sample_weight=None, adjusted=False):\n    confu = confusion_matrix(y_true, y_pred, sample_weight=sample_weight)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        per_class = np.diag(confu) / confu.sum(axis=1)\n    per_class = per_class[~np.isnan(per_class)]\n    score = np.mean(per_class) if len(per_class) > 0 else 0\n\n    if adjusted and len(per_class) > 0:\n        n_classes = len(per_class)\n        chance = 1 / n_classes\n        score = (score - chance) / (1 - chance)\n\n    return score\n\n# main code\ndef classification_model_stats(y_true, predicted, m_thresh=0.5):\n    rare_class = find_rare_class(y_true)\n    reg_acc = [0, 0]\n    for i, threshold in enumerate([0.5, m_thresh]):\n        y_pred = predicted.argmax(axis=1) if threshold == 0.5 else (predicted[:, rare_class] >= threshold).astype(int)\n        acc = balanced_accuracy_score(y_true, y_pred)\n        reg_acc[i] = acc\n\n    return max(reg_acc)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_classes = np.random.randint(2, 10)\n        y_true = np.random.randint(0, num_classes, size=num_samples)\n        predicted = np.random.rand(num_samples, num_classes)\n        predicted /= predicted.sum(axis=1, keepdims=True)\n        m_thresh = np.random.uniform(0, 1)\n        test_cases.append((y_true, predicted, m_thresh))\n\n    return test_cases"}
{"problem_id": "sklearn_6", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates a machine learning model's performance on a given dataset. The function will train the model using training data, make predictions on test data, and compute various performance metrics, including accuracy, recall, and a classification report. Additionally, it will calculate the Receiver Operating Characteristic (ROC) curve and the Area Under the Curve (AUC) for the model's predictions.\n\nFunction Signature:\n```python\ndef model(algorithm, dtrain_X, dtrain_Y, dtest_X, dtest_Y, cols=None):\n```\n\nConstant Used:\n- The constant used in the main code is `None`, which is used to check if the `cols` parameter is provided.\n\nInput Format:\n- `algorithm`: A machine learning algorithm object that implements the `fit`, `predict`, and `predict_proba` methods.\n- `dtrain_X`: A 2D array-like structure (e.g., NumPy array or pandas DataFrame) containing the training features.\n- `dtrain_Y`: A 1D array-like structure containing the training labels.\n- `dtest_X`: A 2D array-like structure containing the test features.\n- `dtest_Y`: A 1D array-like structure containing the test labels.\n- `cols`: An optional parameter that specifies which columns of the feature set to use for training and testing.\n\nOutput Format:\n- The function returns a dictionary containing:\n  - \"model\": A string representation of the algorithm.\n  - \"accuracy_score\": A float representing the accuracy of the model.\n  - \"recall_score\": A float representing the recall of the model.\n  - \"classification_report\": A dictionary containing precision, recall, f1-score, and support for each class.\n  - \"roc_curve\": A dictionary containing:\n    - \"fpr\": A list of false positive rates.\n    - \"tpr\": A list of true positive rates.\n    - \"auc\": A float representing the area under the ROC curve.\n\n```python\n# Input\nalgorithm = RandomForestClassifier(n_estimators=10)\ndtrain_X = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.1, 0.4], [0.5, 0.3, 0.2]])\ndtrain_Y = np.array([0, 1, 1, 0, 1])\ndtest_X = np.array([[0.3, 0.4, 0.5], [0.6, 0.7, 0.8], [0.1, 0.2, 0.1]])\ndtest_Y = np.array([0, 1, 0])\ncols = [0, 1, 2]\n\n# Output\n{\n    'model': 'RandomForestClassifier(n_estimators=10)', \n    'accuracy_score': 0.6666666666666666, \n    'recall_score': 1.0, \n    'classification_report': {\n        '0': {\n            'precision': 1.0, \n            'recall': 0.5, \n            'f1-score': 0.6666666666666666, \n            'support': 2.0\n        }, \n        '1': {\n            'precision': 0.5, \n            'recall': 1.0, \n            'f1-score': 0.6666666666666666, \n            'support': 1.0\n        }, \n        'accuracy': 0.6666666666666666, \n        'macro avg': {\n            'precision': 0.75, \n            'recall': 0.75, \n            'f1-score': 0.6666666666666666, \n            'support': 3.0\n        }, \n        'weighted avg': {\n            'precision': 0.8333333333333334, \n            'recall': 0.6666666666666666, \n            'f1-score': 0.6666666666666666, \n            'support': 3.0\n        }\n    }, \n    'roc_curve': {\n        'fpr': [0.0, 0.0, 1.0], \n        'tpr': [0.0, 1.0, 1.0], \n        'auc': 1.0\n    }\n}\n\n```", "ground_truth_code": "from sklearn.metrics import roc_curve, accuracy_score, recall_score, classification_report, auc\n\n\n# main code\ndef model(algorithm, dtrain_X, dtrain_Y, dtest_X, dtest_Y, cols=None):\n    if cols is None:\n        cols = list(range(dtrain_X.shape[1]))\n\n    algorithm.fit(dtrain_X[:, cols], dtrain_Y)\n    predictions = algorithm.predict(dtest_X[:, cols])\n    prediction_probabilities = algorithm.predict_proba(dtest_X[:, cols])[:, 1]\n\n    metrics = {\n        \"model\": str(algorithm),\n        \"accuracy_score\": accuracy_score(dtest_Y, predictions),\n        \"recall_score\": recall_score(dtest_Y, predictions),\n        \"classification_report\": classification_report(dtest_Y, predictions, output_dict=True)\n    }\n\n    fpr, tpr, _ = roc_curve(dtest_Y, prediction_probabilities)\n    metrics[\"roc_curve\"] = {\"fpr\": fpr.tolist(), \"tpr\": tpr.tolist(), \"auc\": auc(fpr, tpr)}\n\n    return metrics\n", "test_script": "import numpy as np\nimport random\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.ensemble import RandomForestClassifier, GradientBoostingClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.svm import SVC\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    classifiers = [\n        RandomForestClassifier(n_estimators=10),\n        GradientBoostingClassifier(n_estimators=10),\n        LogisticRegression(),\n        SVC(probability=True)\n    ]\n    for _ in range(n):\n        num_features = random.randint(5, 20)\n        num_train_samples = random.randint(50, 500)\n        num_test_samples = random.randint(20, 200)\n        algorithm = random.choice(classifiers)\n        X = np.random.rand(num_train_samples + num_test_samples, num_features)\n        Y = np.random.randint(0, 2, num_train_samples + num_test_samples)\n        dtrain_X, dtest_X, dtrain_Y, dtest_Y = train_test_split(\n            X, Y, test_size=num_test_samples / (num_train_samples + num_test_samples))\n        cols = list(range(num_features))\n        test_cases.append((algorithm, dtrain_X, dtrain_Y, dtest_X, dtest_Y, cols))\n\n    return test_cases\n"}
{"problem_id": "sklearn_7", "library": "sklearn", "code_problem": "You are tasked with implementing a feature selection function that filters out irrelevant features from a given dataset based on their relationship with specified target variables. The function should utilize machine learning models to identify important features and optionally refine the selection based on mutual information with additional batch variables.\n\nFunction Signature:\n```python\ndef filter_relevant_features(data, variable_types, target_dict, batch_dict=None, mi_threshold=0.1):\n```\n\nConstants:\n- `mi_threshold`: A float value set to 0.1, which serves as the threshold for mutual information to determine the relevance of features in relation to batch variables.\n\nInput Format:\n- `data`: A pandas DataFrame containing the dataset with features.\n- `variable_types`: A dictionary mapping feature names to their types ('categorical' or 'continuous').\n- `target_dict`: A dictionary where keys are target variable names and values are pandas Series representing the target variables.\n- `batch_dict`: (Optional) A dictionary where keys are batch variable names and values are pandas Series representing additional variables for filtering.\n- `mi_threshold`: A float value representing the threshold for mutual information.\n\nOutput Format:\n- A pandas DataFrame containing the filtered dataset with only the relevant features based on the specified criteria. If no features are deemed important, the original dataset is returned.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample data\ndata = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [1.0, 1.1, 1.2, 1.3, 1.4],\n    'feature_2': [0.5, 0.6, 0.7, 0.8, 0.9]\n})\n\nvariable_types = {\n    'target_0': 'categorical',\n    'target_1': 'continuous'\n}\n\ntarget_dict = {\n    'target_0': pd.Series([0, 1, 0, 1, 0]),\n    'target_1': pd.Series([0.1, 0.2, 0.3, 0.4, 0.5])\n}\n\nbatch_dict = {\n    'target_0': pd.Series([1, 0, 1, 0, 1])\n}\n\nmi_threshold = 0.1\n```\n\n**Output:**\n```python\n# Expected output (filtered relevant features)\n   feature_1  feature_2\n0        1.0        0.5\n1        1.1        0.6\n2        1.2        0.7\n3        1.3        0.8\n4        1.4        0.9\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.feature_selection import SelectFromModel\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.feature_selection import mutual_info_classif, mutual_info_regression\n\n# main code\ndef filter_relevant_features(data, variable_types, target_dict, batch_dict=None, mi_threshold=0.1):\n    target_dict_np = {k: v.to_numpy() for k, v in target_dict.items()}\n    important_features = set()\n\n    for var_name, target in target_dict_np.items():\n        if np.isnan(target).all():\n            continue\n\n        not_missing = ~np.isnan(target)\n        data_sub = data.loc[not_missing]\n        target_sub = target[not_missing]\n\n        clf = RandomForestClassifier() if variable_types[var_name] == 'categorical' else RandomForestRegressor()\n        clf.fit(data_sub, target_sub)\n\n        model = SelectFromModel(clf, prefit=True)\n        important_features.update(data.columns[model.get_support()])\n\n    if batch_dict:\n        batch_dict_np = {k: v.to_numpy() for k, v in batch_dict.items()}\n        for var_name, batch in batch_dict_np.items():\n            if np.isnan(batch).all():\n                continue\n\n            not_missing = ~np.isnan(batch)\n            data_sub = data.loc[not_missing]\n            batch_sub = batch[not_missing]\n\n            mi = mutual_info_classif(data_sub, batch_sub) if variable_types[\n                                                                 var_name] == 'categorical' else mutual_info_regression(\n                data_sub, batch_sub)\n            important_features -= set(data.columns[mi > mi_threshold])\n\n    return data.loc[:, list(important_features)] if important_features else data", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 20)\n        feature_names = [f'feature_{i}' for i in range(num_features)]\n        data = pd.DataFrame(np.random.rand(num_samples, num_features), columns=feature_names)\n        variable_types = {f'target_{i}': np.random.choice(['categorical', 'continuous']) for i in range(3)}\n        target_dict = {}\n        for var_name, var_type in variable_types.items():\n            if var_type == 'categorical':\n                target_dict[var_name] = pd.Series(np.random.randint(0, 3, size=num_samples))\n            else:\n                target_dict[var_name] = pd.Series(np.random.rand(num_samples))\n        batch_dict = None\n        if np.random.rand() > 0.5:\n            batch_dict = {}\n            for var_name in variable_types.keys():\n                batch_dict[var_name] = pd.Series(np.random.randint(0, 3, size=num_samples))\n        mi_threshold = np.random.uniform(0.05, 0.3)\n        test_cases.append((data, variable_types, target_dict, batch_dict, mi_threshold))\n    return test_cases\n"}
{"problem_id": "sklearn_8", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a regression model by calculating various metrics based on the true values and predicted values for both training and testing datasets. The function will compute the Mean Squared Error (MSE) and R-squared (R2) score for both the training and testing sets.\n\nThe function signature is as follows:\n```python\ndef metric_display(y_train, y_test, train_pred, test_pred):\n```\n\nIn this function, the following constant is used:\n- The constant `np.float64` is used to ensure that the input arrays are converted to a 64-bit floating-point format for accurate numerical computations.\n\nInput format:\n- The function accepts four parameters:\n  - `y_train`: A list or array of true values for the training dataset.\n  - `y_test`: A list or array of true values for the testing dataset.\n  - `train_pred`: A list or array of predicted values for the training dataset.\n  - `test_pred`: A list or array of predicted values for the testing dataset.\n\nOutput format:\n- The function returns a dictionary containing the following keys and their corresponding values:\n  - `\"MSE_train\"`: The Mean Squared Error for the training set.\n  - `\"MSE_test\"`: The Mean Squared Error for the testing set.\n  - `\"R2_train\"`: The R-squared score for the training set.\n  - `\"R2_test\"`: The R-squared score for the testing set.\n\nInput:\n```python\ny_train = [12.5, 15.0, 14.2, 13.8, 16.1]\ny_test = [14.0, 15.5, 13.5]\ntrain_pred = [12.0, 15.5, 14.0, 13.0, 16.5]\ntest_pred = [14.5, 15.0, 13.0]\n```\n\nOutput:\n```python\n{\n    'MSE_train': 0.2679999999999999, \n    'MSE_test': 0.25, \n    'R2_train': 0.8146098505810737, \n    'R2_test': 0.653846153846154\n}\n``` \n", "ground_truth_code": "from sklearn.metrics import mean_squared_error, r2_score\nimport numpy as np\n\n# main code\ndef metric_display(y_train, y_test, train_pred, test_pred):\n    y_train = np.array(y_train, dtype=np.float64)\n    y_test = np.array(y_test, dtype=np.float64)\n\n    train_pred = np.array(train_pred, dtype=np.float64)\n    test_pred = np.array(test_pred, dtype=np.float64)\n\n    metrics = {\n        \"MSE_train\": mean_squared_error(y_train, train_pred),\n        \"MSE_test\": mean_squared_error(y_test, test_pred),\n        \"R2_train\": r2_score(y_train, train_pred),\n        \"R2_test\": r2_score(y_test, test_pred),\n    }\n\n    return metrics", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        train_size = np.random.randint(10, 100)\n        test_size = np.random.randint(10, 100)\n\n        y_train = np.random.uniform(-100, 100, train_size).tolist()\n        train_pred = np.random.uniform(-100, 100, train_size).tolist()\n        y_test = np.random.uniform(-100, 100, test_size).tolist()\n        test_pred = np.random.uniform(-100, 100, test_size).tolist()\n\n        test_cases.append((y_train, y_test, train_pred, test_pred))\n\n    return test_cases"}
{"problem_id": "sklearn_9", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various performance metrics for a classification model. The function will take two lists as input: the true labels and the predicted labels from the model. It will compute the accuracy, precision, recall, and F1 score of the predictions using the `sklearn` library.\n\nFunction signature:\n```python\ndef print_statistics(y, y_pred):\n```\n\nIn this function, the following constant is used:\n- `average='weighted'`: This constant is used in the precision, recall, and F1 score calculations to account for label imbalance by computing metrics for each label and finding their average, weighted by the number of true instances for each label.\n\nInput format:\n- The function takes two lists as input:\n  - `y`: A list of true labels (ground truth).\n  - `y_pred`: A list of predicted labels from the classification model.\n\nOutput format:\n- The function returns a tuple containing four floating-point numbers:\n  - The first element is the accuracy.\n  - The second element is the precision.\n  - The third element is the recall.\n  - The fourth element is the F1 score.\n\n```python\n# Input\ny = np.array([0, 1, 1, 0, 1, 2, 2, 0, 1, 2])\ny_pred = np.array([0, 1, 0, 0, 1, 2, 2, 1, 1, 2])\n\n# Output\n(0.8, 0.8, 0.8, 0.8)\n```", "ground_truth_code": "from sklearn import metrics\n\n# main code\ndef print_statistics(y, y_pred):\n    accuracy = metrics.accuracy_score(y, y_pred)\n    precision = metrics.precision_score(y, y_pred, average='weighted')\n    recall = metrics.recall_score(y, y_pred, average='weighted')\n    f_score = metrics.f1_score(y, y_pred, average='weighted')\n    return (accuracy, precision, recall, f_score)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_classes = np.random.randint(2, 10)\n        min_samples, max_samples = np.random.randint(10, 51), np.random.randint(51, 101)\n        num_samples = np.random.randint(min_samples, max_samples + 1)\n        y = np.random.randint(0, num_classes, size=num_samples)\n        y_pred = np.random.randint(0, num_classes, size=num_samples)\n        test_cases.append((y, y_pred))\n    return test_cases"}
{"problem_id": "sklearn_10", "library": "sklearn", "code_problem": "You are tasked with implementing a function that computes various performance metrics for a logistic regression model based on a given dataset. The function will evaluate the model's predictive capabilities using Receiver Operating Characteristic (ROC) analysis and Precision-Recall (PR) analysis. The function will also provide confidence intervals for correlation coefficients derived from the model's predictions.\n\nFunction Signature:\n```python\ndef compute_roc(df1, outcome: str, clin_predictor: str, avg_coefs: bool) -> dict:\n```\n\n### Constants Used:\n- The constant `n_bootstraps` is set to `200` when the `avg_coefs` parameter is `True`.\n\n### Input Format:\n- The function expects a DataFrame `df1`, a string `outcome`, a string `clin_predictor`, and a boolean `avg_coefs`.\n\n### Output Format:\n- The function returns a dictionary containing the computed metrics, which may include correlation coefficients, AUC values, and other relevant statistics based on the input parameters.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndf = pd.DataFrame({\n    'cv_linear': [1, 1, 2, 2, 3, 3],\n    'percent_tiles_positive0': [0.1, 0.4, 0.6, 0.8, 0.3, 0.5],\n    'ten_score': [0.2, 0.5, 0.7, 0.9, 0.4, 0.6],\n    'outcome': [0, 1, 1, 0, 1, 0]\n})\n\noutcome = 'outcome'\nclin_predictor = 'percent_tiles_positive0'\navg_coefs = True\n\n# Call the function\nresults = compute_roc(df, outcome, clin_predictor, avg_coefs)\n```\n\n**Output:**\n```python\n{\n    'percent_tiles_positive0': {\n        'correlation_r': '-0.333 (-0.901 - 0.656)', \n        'correlation_p': '-0.333 (-0.901 - 0.656)', \n        'auc': '0.349 (0.000 - 1.000)', \n        'prc': '0.512 (0.250 - 1.000)', \n        'mean_outcome': '0.500'\n    }, \n    'comb': {\n        'correlation_r': '1.000 (nan - nan)', \n        'correlation_p': '1.000 (1.000 - 1.000)', \n        'auc': '1.000 (1.000 - 1.000)', \n        'prc': '1.000 (1.000 - 1.000)', \n        'mean_outcome': '0.500'\n    }\n}\n\n```", "ground_truth_code": "import math\nfrom sklearn.linear_model import LogisticRegression\nfrom scipy import stats\nimport numpy as np\nfrom scipy.stats import pearsonr, spearmanr\nfrom sklearn.metrics import roc_curve, precision_recall_curve, auc\nimport numpy.random as rng\n\n\ndef r_to_z(r):\n    return math.log((1 + r) / (1 - r)) / 2.0\n\n\ndef z_to_r(z):\n    e = math.exp(2 * z)\n    return (e - 1) / (e + 1)\n\n\ndef r_confidence_interval(r, alpha, n):\n    z = r_to_z(r)\n    se = 1.0 / math.sqrt(n - 3)\n    z_crit = stats.norm.ppf(1 - alpha / 2)\n    lo = z - z_crit * se\n    hi = z + z_crit * se\n    return z_to_r(lo), z_to_r(hi)\n\n\ndef predict_logistic_regression(clf, input_cols):\n    return clf.predict_proba(input_cols)[:, 1]\n\n\n\ndef compute_roc_metrics(df, cv_column, outcome, predictor, model=False, model_input=None, n_bootstraps=0):\n    base_fpr = np.linspace(0, 1, 101)\n    aucs, prcs, rs, ps = [], [], [], []\n    tprs = []\n\n    for i in [1, 2, 3]:\n        df_temp = df[df[cv_column] == float(i)].copy()\n\n        if model:\n            clf = LogisticRegression().fit(df_temp[model_input], df_temp[outcome])\n            df_temp['comb'] = predict_logistic_regression(clf, df_temp[model_input])\n            predictor = 'comb'\n\n        r, _ = pearsonr(df_temp[predictor], df_temp[outcome])\n        p, _ = spearmanr(df_temp[predictor], df_temp[outcome])\n        rs.append(r)\n        ps.append(p)\n\n        aucs_sub = []\n\n        if n_bootstraps:\n            X = df_temp[predictor].to_numpy()\n            Y = df_temp[outcome].to_numpy()\n\n            for _ in range(n_bootstraps):\n                indices = rng.randint(0, len(Y), len(Y))\n                if len(np.unique(Y[indices])) < 2:\n                    continue\n                fpr, tpr, _ = roc_curve(Y[indices], X[indices])\n                aucs.append(auc(fpr, tpr))\n                aucs_sub.append(auc(fpr, tpr))\n                precision, recall, _ = precision_recall_curve(Y[indices], X[indices])\n                prcs.append(auc(recall, precision))\n                tpr = np.interp(base_fpr, fpr, tpr)\n                tpr[0] = 0.0\n                tprs.append(tpr)\n        else:\n            fpr, tpr, _ = roc_curve(df[outcome], df[predictor])\n            aucs.append(auc(fpr, tpr))\n            precision, recall, _ = precision_recall_curve(df[outcome], df[predictor])\n            prcs.append(auc(recall, precision))\n            tpr = np.interp(base_fpr, fpr, tpr)\n            tpr[0] = 0.0\n            tprs.append(tpr)\n\n    avg_r, avg_p = sum(rs) / len(rs), sum(ps) / len(ps)\n    lb, ub = np.percentile(aucs, 2.5), np.percentile(aucs, 97.5)\n    lb_prc, ub_prc = np.percentile(prcs, 2.5), np.percentile(prcs, 97.5)\n    r_lb, r_ub = r_confidence_interval(avg_r, 0.05, len(df.index))\n    p_lb, p_ub = r_confidence_interval(avg_p, 0.05, len(df.index))\n\n    return {\n        \"correlation_r\": f\"{avg_r:.3f} ({r_lb:.3f} - {r_ub:.3f})\",\n        \"correlation_p\": f\"{avg_p:.3f} ({p_lb:.3f} - {p_ub:.3f})\",\n        \"auc\": f\"{np.mean(aucs):.3f} ({lb:.3f} - {ub:.3f})\",\n        \"prc\": f\"{np.mean(prcs):.3f} ({lb_prc:.3f} - {ub_prc:.3f})\",\n        \"mean_outcome\": f\"{df[outcome].mean():.3f}\"\n    }\n\n# main code\ndef compute_roc(df1, outcome, clin_predictor, avg_coefs):\n    df = df1.copy()\n    results = {}\n\n    if avg_coefs:\n        results['percent_tiles_positive0'] = compute_roc_metrics(df, 'cv_linear', outcome, 'percent_tiles_positive0',\n                                                                 model=False, model_input=None, n_bootstraps=200)\n        results[clin_predictor] = compute_roc_metrics(df, 'cv_linear', outcome, clin_predictor, model=False,\n                                                      model_input=None, n_bootstraps=200)\n        results['comb'] = compute_roc_metrics(df, 'cv_linear', outcome, predictor=None, model=True,\n                                              model_input=['percent_tiles_positive0', clin_predictor],\n                                              n_bootstraps=200)\n    else:\n        fpr, tpr, _ = roc_curve(df[outcome], df['percent_tiles_positive0'])\n        results['auc_DL'] = auc(fpr, tpr)\n\n        fpr, tpr, _ = roc_curve(df[outcome], df['ten_score'])\n        results['auc_ten_score'] = auc(fpr, tpr)\n\n        fpr, tpr, _ = roc_curve(df[outcome], df['comb'])\n        results['auc_comb'] = auc(fpr, tpr)\n\n    return results", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(50, 100)\n\n        df = pd.DataFrame({\n            'cv_linear': np.random.choice([1, 2, 3], size=num_samples),\n            'percent_tiles_positive0': np.random.rand(num_samples),\n            'ten_score': np.random.rand(num_samples),\n            'comb': np.random.rand(num_samples),\n            'outcome': np.random.choice([0, 1], size=num_samples)\n        })\n        clin_predictor = random.choice(['percent_tiles_positive0', 'ten_score'])\n        avg_coefs = random.choice([True, False])\n        test_cases.append((df, 'outcome', clin_predictor, avg_coefs))\n    return test_cases\n\n"}
{"problem_id": "sklearn_11", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the baseline performance of machine learning models on a given dataset. The function will take in training and testing datasets, a variable name to predict, the method of modeling (either 'RandomForest' or 'SVC/SVR'), and will perform k-fold cross-validation to assess the model's performance. The function will return a DataFrame containing various performance metrics based on the type of variable being predicted (categorical or continuous).\n\nFunction signature:\n```python\ndef evaluate_baseline_performance(train_dataset, test_dataset, variable_name, method, n_folds=5, n_jobs=4):\n```\n\nConstant used in the main code:\n- `n_folds`: This constant is set to 5 by default, indicating the number of folds for cross-validation.\n\nInput format:\n- `train_dataset`: An object containing training data with features and annotations.\n- `test_dataset`: An object containing testing data with features and annotations.\n- `variable_name`: A string representing the name of the variable to predict.\n- `method`: A string indicating the modeling method ('RandomForest' or 'SVC/SVR').\n- `n_folds`: An integer specifying the number of folds for cross-validation (default is 5).\n- `n_jobs`: An integer specifying the number of jobs to run in parallel (default is 4).\n\nOutput format:\n- The function returns a Pandas DataFrame containing the evaluation metrics, including method, variable name, variable type, metric names, and their corresponding values.\n\n**Input:**\n```python\ntrain_dataset = MockDataObject(num_samples=80, num_features=5, categorical=True)\ntest_dataset = MockDataObject(num_samples=40, num_features=5, categorical=True)\nvariable_name = \"variable_name\"\nmethod = \"RandomForest\"\nn_folds = 3\nn_jobs = 2\n```\n\n**Output:**\n```python\n                   method            var variable_type        metric     value\n0  RandomForestClassifier  variable_name   categorical  balanced_acc  0.522556\n1  RandomForestClassifier  variable_name   categorical      f1_score  0.522313\n2  RandomForestClassifier  variable_name   categorical         kappa  0.045226\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import balanced_accuracy_score, f1_score, cohen_kappa_score, mean_squared_error\nfrom scipy.stats import linregress\nfrom sklearn.model_selection import KFold, GridSearchCV\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.svm import SVC, SVR\nimport pandas as pd\n\n\ndef prepare_data(data_object, duration_col, event_col):\n    X = np.concatenate(list(data_object.dat.values()), axis=1)\n    durations = np.array(data_object.ann[duration_col])\n    events = np.array(data_object.ann[event_col])\n    valid_indices = ~np.isnan(durations) & ~np.isnan(events)\n    X = X[valid_indices]\n    y = np.array(\n        [(event, duration) for event, duration in zip(events, durations)],\n        dtype=[('Event', '?'), ('Time', '<f8')]\n    )\n    return X, y[valid_indices]\n\n\ndef evaluate_classifier(y_true, y_pred):\n    return {\n        'balanced_acc': balanced_accuracy_score(y_true, y_pred),\n        'f1_score': f1_score(y_true, y_pred, average='macro', zero_division=0),\n        'kappa': cohen_kappa_score(y_true, y_pred)\n    }\n\n\ndef evaluate_regressor(y_true, y_pred):\n    mse = mean_squared_error(y_true, y_pred)\n    slope, intercept, r_value, _, _ = linregress(y_true, y_pred)\n    return {'mse': mse, 'r2': r_value ** 2, 'pearson_corr': r_value}\n\n\n# main code\ndef evaluate_baseline_performance(train_dataset, test_dataset, variable_name, method, n_folds=5, n_jobs=4):\n    def prepare_data(data_object):\n        X = np.concatenate(list(data_object.dat.values()), axis=1)\n        y = np.array(data_object.ann[variable_name])\n        valid_indices = ~np.isnan(y)\n        return X[valid_indices], y[valid_indices]\n\n    variable_type = train_dataset.variable_types[variable_name]\n    kf = KFold(n_splits=n_folds, shuffle=True)\n    X_train, y_train = prepare_data(train_dataset)\n    X_test, y_test = prepare_data(test_dataset)\n    metrics_list = []\n\n    if variable_type == 'categorical':\n        model = RandomForestClassifier(n_estimators=50, max_depth=10, n_jobs=n_jobs) if method == 'RandomForest' else SVC(kernel='linear')\n        params = {'n_estimators': [50, 100], 'max_depth': [5, 10]} if method == 'RandomForest' else {'C': [0.1, 1]}\n    else:\n        model = RandomForestRegressor(n_estimators=50, max_depth=10, n_jobs=n_jobs) if method == 'RandomForest' else SVR(kernel='linear')\n        params = {'n_estimators': [50, 100], 'max_depth': [5, 10]} if method == 'RandomForest' else {'C': [0.1, 1]}\n\n    grid_search = GridSearchCV(model, params, cv=kf, n_jobs=n_jobs)\n    grid_search.fit(X_train, y_train)\n    best_model = grid_search.best_estimator_\n    y_pred = best_model.predict(X_test)\n    metrics = evaluate_classifier(y_test, y_pred) if variable_type == 'categorical' else evaluate_regressor(y_test, y_pred)\n\n    metrics_list.extend(\n        {'method': method + ('Classifier' if variable_type == 'categorical' else 'Regressor'),\n         'var': variable_name, 'variable_type': variable_type, 'metric': metric, 'value': value}\n        for metric, value in metrics.items()\n    )\n\n    return pd.DataFrame(metrics_list)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    class MockDataObject:\n        def __init__(self, num_samples, num_features, categorical=True):\n            self.dat = {f\"feature_{i}\": np.random.rand(num_samples, 1) for i in range(num_features)}\n            self.ann = {\n                \"variable_name\": np.random.choice([0, 1] if categorical else np.random.rand(num_samples), num_samples)\n            }\n            self.variable_types = {\"variable_name\": \"categorical\" if categorical else \"continuous\"}\n\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(3, 10)\n        categorical = np.random.choice([True, False])\n\n        train_dataset = MockDataObject(num_samples, num_features, categorical)\n        test_dataset = MockDataObject(num_samples // 2, num_features, categorical)\n        variable_name = \"variable_name\"\n        method = np.random.choice([\"RandomForest\", \"SVM\"])\n        n_folds = 3\n        n_jobs = 2\n\n        test_cases.append((train_dataset, test_dataset, variable_name, method, n_folds, n_jobs))\n\n    return test_cases"}
{"problem_id": "sklearn_12", "library": "sklearn", "code_problem": "You are tasked with implementing a function that enhances a given dataset by adding polynomial features based on specified parameters. The function will also allow for the selection of different types of regression or classification models, apply scaling to the data, and optionally fit the model to the data.\n\nFunction Signature:\n```python\ndef add_poly_vars_select(data: pd.DataFrame, numvars: list, targetvar: str, modeltype: str, poly_degree: int, Add_Poly: int, md: PolynomialFeatures, scaling: str, fit_flag: bool) -> pd.DataFrame:\n```\n\nConstants Used:\n- The constant `alpha` for the Lasso regression model is set to `0.001`.\n- The constant `C` for the Logistic regression model is set to `0.01`.\n- The maximum iterations for the Lasso model is set to `2000`, and for the Logistic regression model, it is set to `2000` for binary classification and `10000` for multi-class classification.\n\nInput Format:\n- `data`: A pandas DataFrame containing the dataset.\n- `numvars`: A list of strings representing the names of numerical variables in the dataset.\n- `targetvar`: A string representing the name of the target variable.\n- `modeltype`: A string that can be 'Regression', 'Binary_Classification', or 'Multi_Class_Classification'.\n- `poly_degree`: An integer representing the degree of polynomial features to be generated.\n- `Add_Poly`: An integer indicating whether to include interaction terms (1 for yes, 0 for no).\n- `md`: A PolynomialFeatures object for transforming the features.\n- `scaling`: A string indicating the scaling method ('Standard', 'MinMax', 'Centering', or 'None').\n- `fit_flag`: A boolean indicating whether to fit the model.\n\nOutput Format:\n- The function returns a pandas DataFrame containing the newly created polynomial features based on the specified parameters.\n\n**Input:**\n```python\ndata = pd.DataFrame({\n    'var_0': [0.5, 1.5, 2.5, 3.5, 4.5],\n    'var_1': [1.0, 2.0, 3.0, 4.0, 5.0],\n    'var_2': [2.0, 3.0, 4.0, 5.0, 6.0],\n    'var_3': [3.0, 4.0, 5.0, 6.0, 7.0],\n    'var_4': [4.0, 5.0, 6.0, 7.0, 8.0]\n})\nnumvars = ['var_0', 'var_1', 'var_2', 'var_3']\ntargetvar = 'var_4'\nmodeltype = 'Regression'\npoly_degree = 2\nAdd_Poly = 1\nscaling = 'Standard'\nmd = PolynomialFeatures(degree=poly_degree, include_bias=False, interaction_only=True)\nfit_flag = True\n```\n\n**Output:**\n```python\n    x0   x1   x2   x3  x0 x1  x0 x2  x0 x3  x1 x2  x1 x3  x2 x3\n0  0.5  1.0  2.0  3.0    0.5    1.0    1.5    2.0    3.0    6.0\n1  1.5  2.0  3.0  4.0    3.0    4.5    6.0    6.0    8.0   12.0\n2  2.5  3.0  4.0  5.0    7.5   10.0   12.5   12.0   15.0   20.0\n3  3.5  4.0  5.0  6.0   14.0   17.5   21.0   20.0   24.0   30.0\n4  4.5  5.0  6.0  7.0   22.5   27.0   31.5   30.0   35.0   42.0\n```", "ground_truth_code": "from sklearn.model_selection import KFold, cross_val_score, StratifiedKFold\nimport numpy as np\nimport copy\nimport pandas as pd\nfrom sklearn.linear_model import Lasso, LogisticRegression\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler, PolynomialFeatures\n\ndef compute_model_metrics(modeltype, reg, X, y, fit_flag=False):\n    n_splits = 5\n    if modeltype == 'Regression':\n        scv = KFold(n_splits=n_splits, shuffle=True, random_state=42)\n        cv_scores = cross_val_score(reg, X, y.values.ravel(), cv=scv, scoring='neg_mean_squared_error')\n        cv_scores = np.sqrt(np.abs(cv_scores))\n        return (reg.fit(X, y), cv_scores.mean()) if fit_flag else cv_scores.mean()\n\n    elif modeltype in ['Binary_Classification', 'Multi_Class_Classification']:\n        if len(np.unique(y)) == 1:\n            return 0.0\n\n        if np.issubdtype(y.dtype, np.number) and (not np.issubdtype(y.dtype, np.integer)):\n            y = (y > y.median()).astype(int)\n\n        scv = StratifiedKFold(n_splits=n_splits, shuffle=True, random_state=42)\n        cv_scores = cross_val_score(reg, X, y.values.ravel(), cv=scv, scoring='f1_weighted')\n        return (reg.fit(X, y), cv_scores.mean()) if fit_flag else cv_scores.mean()\n\n    else:\n        return 0.0\n\n\n# main code\ndef add_poly_vars_select(data, numvars, targetvar, modeltype, poly_degree, Add_Poly, md, scaling, fit_flag):\n    data = copy.deepcopy(data)\n    numvars = copy.deepcopy(numvars)\n    orig_data_index = data.index\n\n    lm = Lasso(alpha=0.001, max_iter=2000, fit_intercept=True) if modeltype == 'Regression' \\\n        else LogisticRegression(C=0.01, fit_intercept=True, max_iter=2000, solver='liblinear', n_jobs=-1, penalty='l2', dual=False, random_state=0) \\\n        if modeltype == 'Binary_Classification' else LogisticRegression(multi_class='ovr', max_iter=10000)\n\n    predictors = copy.deepcopy(numvars)\n    X_data = data[predictors]\n    XS = StandardScaler().fit_transform(X_data) if scaling == 'Standard' else \\\n         MinMaxScaler().fit_transform(X_data) if scaling == 'MinMax' else \\\n         X_data - X_data.mean() if scaling == 'Centering' else copy.deepcopy(X_data)\n\n    X = copy.deepcopy(XS)\n    if fit_flag:\n        Y = data[targetvar]\n        if modeltype in ['Binary_Classification', 'Multi_Class_Classification']:\n            if np.issubdtype(Y.dtype, np.floating):\n                num_classes = 2 if modeltype == 'Binary_Classification' else min(10, len(np.unique(Y)))\n                Y = pd.qcut(Y, q=num_classes, labels=False, duplicates='drop')\n        compute_model_metrics(modeltype, lm, X, Y, False)\n\n    poly = PolynomialFeatures(degree=poly_degree, include_bias=False, interaction_only=Add_Poly in [1, 3])\n    if fit_flag:\n        md = poly.fit(X)\n\n    xnames = md.get_feature_names_out().tolist()\n    final_df = pd.DataFrame(md.transform(data[predictors]), index=orig_data_index, columns=xnames)\n\n    return final_df", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import PolynomialFeatures\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(2, 11)\n        num_samples = np.random.randint(50, 201)\n        data = pd.DataFrame(np.random.randn(num_samples, num_features),\n                            columns=[f'var_{i}' for i in range(num_features)])\n        targetvar = f'var_{np.random.randint(0, num_features)}'\n        numvars = [col for col in data.columns if col != targetvar]\n        modeltype = np.random.choice(['Regression', 'Binary_Classification', 'Multi_Class_Classification'])\n        poly_degree = np.random.randint(2, 5)\n        Add_Poly = np.random.choice([1, 2, 3])\n        scaling = np.random.choice([None, 'Standard', 'MinMax', 'Centering'])\n        poly = PolynomialFeatures(degree=poly_degree, include_bias=False, interaction_only=Add_Poly in [1, 3])\n        md = poly.fit(data[numvars])\n        fit_flag = np.random.choice([True, False])\n        test_cases.append((data, numvars, targetvar, modeltype, poly_degree, Add_Poly, md, scaling, fit_flag))\n\n    return test_cases"}
{"problem_id": "sklearn_13", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model using various metrics. The function will take in the true labels and the predicted labels from the model and return a dictionary containing the calculated metrics.\n\nFunction Signature:\n```python\ndef evaluate(x, y, predict):\n```\n\nConstant used in the main code:\n- The constant `average=\"macro\"` is used in the calculation of F1 score, precision, and recall metrics to indicate that the metrics should be calculated for each class and then averaged.\n\nInput Format:\n- The function takes three parameters:\n  - `x`: A dataset for which predictions are to be made.\n  - `y`: The true labels corresponding to the dataset `x`.\n  - `predict`: A function that takes `x` as input and returns predicted labels.\n\nOutput Format:\n- The function returns a dictionary where the keys are metric names (\"accuracy\", \"f1\", \"precision\", \"recall\") and the values are the corresponding calculated metric scores rounded to two decimal places.\n\nInput:\n```python\nx = np.array([[0.1, 0.2, 0.3], \n              [0.4, 0.5, 0.6], \n              [0.7, 0.8, 0.9], \n              [0.1, 0.1, 0.1], \n              [0.2, 0.2, 0.2]])\ny = np.array([0, 1, 1, 0, 0])\nmodel = DummyClassifier(strategy=\"most_frequent\")\nmodel.fit(x, y)\npredict = lambda x_: model.predict(x_)\nmetrics = evaluate(x, y, predict)\n```\n\nOutput:\n```python\n{'accuracy': 0.6, 'f1': 0.38, 'precision': 0.3, 'recall': 0.5}\n```", "ground_truth_code": "from sklearn.metrics import accuracy_score, f1_score, precision_score, recall_score\n\n\ndef predict(x, model):\n    return model.predict(x)\n\n# main code\ndef evaluate(x, y, predict):\n    y_pred = predict(x)\n\n    metric_functions = {\n        \"accuracy\": accuracy_score,\n        \"f1\": lambda y_true, y_pred: f1_score(y_true, y_pred, average=\"macro\", zero_division=0.0),\n        \"precision\": lambda y_true, y_pred: precision_score(y_true, y_pred, average=\"macro\", zero_division=0.0),\n        \"recall\": lambda y_true, y_pred: recall_score(y_true, y_pred, average=\"macro\", zero_division=0.0),\n    }\n\n    metrics = {key: round(func(y, y_pred), 2) for key, func in metric_functions.items()}\n\n    return metrics", "test_script": "import numpy as np\nfrom sklearn.dummy import DummyClassifier\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(10, 100)\n        feature_dim = np.random.randint(5, 50)\n        num_classes = np.random.randint(2, 10)\n        x = np.random.rand(batch_size, feature_dim)\n        y = np.random.randint(0, num_classes, batch_size)\n        model = DummyClassifier(strategy=\"most_frequent\")\n        model.fit(x, y)\n        test_cases.append((x, y, lambda x_: model.predict(x_)))\n\n    return test_cases"}
{"problem_id": "sklearn_14", "library": "sklearn", "code_problem": "You are tasked with developing a machine learning model that can handle different types of prediction tasks based on the nature of the target variable. The model should be able to classify the problem as either regression, binary classification, or multi-class classification, and then train an appropriate model using the LightGBM library.\n\nThe function signature of the main code is:\n```python\ndef simple_model(X_train, y_train, X_test):\n```\n\nIn the main code, the following constant is used:\n- `seed`: This constant is set to `42` to ensure reproducibility of the model training process.\n\nInput format:\n- `X_train`: A Pandas DataFrame containing the training features.\n- `y_train`: A Pandas Series or a NumPy array containing the target variable.\n- `X_test`: A Pandas DataFrame containing the test features.\n\nOutput format:\n- A tuple where the first element is an array of predictions and the second element is an array of scaled probabilities (if applicable), or `None` if the task is regression.\n\n**Input:**\n```python\nX_train = pd.DataFrame({\n    'feat_0': [0.5, -1.2, 0.3, 1.5, -0.7],\n    'feat_1': [1.0, 0.0, -0.5, 0.5, 1.2],\n    'feat_2': [0.1, 0.4, -0.3, 0.8, 0.2]\n})\ny_train = pd.Series([0, 1, 0, 1, 0])  # Binary Classification\nX_test = pd.DataFrame({\n    'feat_0': [0.2, -0.1],\n    'feat_1': [0.3, 0.1],\n    'feat_2': [0.0, 0.5]\n})\n```\n\n**Output:**\n```python\n(array([0, 0]), array([[0., 0.],\n       [0., 0.]]))\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import MinMaxScaler\nimport lightgbm as lgbm\n\ndef analyze_problem_type(y_train):\n    unique_vals = len(np.unique(y_train))\n    if y_train.dtype in ['int64', 'int32', 'int16']:\n        return 'Binary_Classification' if unique_vals == 2 else 'Multi_Classification' if unique_vals <= 10 else 'Regression'\n    elif y_train.dtype in ['float16', 'float32', 'float64']:\n        return 'Regression' if unique_vals > 10 else 'Binary_Classification'\n    else:\n        return 'Multi_Classification'\n\n# main code\ndef simple_model(X_train, y_train, X_test):\n    y_train = pd.Series(y_train, index=X_train.index) if isinstance(y_train, np.ndarray) else y_train\n    model_type = analyze_problem_type(y_train)\n    model_params = {'Regression': {'objective': 'regression', 'metric': 'rmse'}, 'Binary_Classification': {'objective': 'binary', 'metric': 'auc'}, 'Multi_Classification': {'objective': 'multiclass', 'metric': 'multi_logloss'}}\n    params = model_params[model_type]\n    params.update({'boosting_type': 'gbdt', 'verbose': -1, 'seed': 42, 'feature_fraction': 0.7, 'bagging_fraction': 0.7, 'max_depth': 4, 'n_estimators': 50, 'num_leaves': 15, 'min_data_in_leaf': 20, 'subsample_freq': 1})\n    if model_type != 'Regression':\n        params['num_class'] = y_train.nunique() if model_type == 'Multi_Classification' else 1\n        params['is_unbalance'] = True\n    model = lgbm.LGBMClassifier(**params) if model_type != 'Regression' else lgbm.LGBMRegressor(**params)\n    model.fit(X_train, y_train)\n    preds = model.predict(X_test)\n    probas = model.predict_proba(X_test) if model_type != 'Regression' else None\n    if probas is not None:\n        probas = MinMaxScaler().fit_transform(probas)\n    return (preds, probas)\n", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(3, 10)\n        X = np.random.randn(num_samples, num_features)\n        X_train, X_test = train_test_split(X, test_size=0.2, random_state=42)\n        problem_type = np.random.choice(['Binary_Classification', 'Multi_Classification', 'Regression'])\n\n        if problem_type == 'Binary_Classification':\n            y_train = np.random.choice([0, 1], size=len(X_train))\n        elif problem_type == 'Multi_Classification':\n            num_classes = np.random.randint(3, 10)\n            y_train = np.random.choice(range(num_classes), size=len(X_train))\n        else:\n            y_train = np.random.randn(len(X_train))\n        X_train_df = pd.DataFrame(X_train, columns=[f'feat_{i}' for i in range(num_features)])\n        X_test_df = pd.DataFrame(X_test, columns=[f'feat_{i}' for i in range(num_features)])\n        y_train_series = pd.Series(y_train)\n\n        test_cases.append((X_train_df, y_train_series, X_test_df))\n\n    return test_cases"}
{"problem_id": "sklearn_15", "library": "sklearn", "code_problem": "You are tasked with implementing a function that computes the Area Under the Receiver Operating Characteristic Curve (AUROC) for a given dataset. The function should also provide confidence intervals for the AUROC estimate, and optionally perform bootstrapping to assess the variability of the AUROC.\n\nFunction Signature:\n```python\ndef compute_auroc(df, outcome, predictor, n_bootstraps=None):\n```\n\n### Constants Used:\n- The constant `0.025` and `0.975` are used to calculate the 95% confidence interval for the AUROC using the normal distribution.\n\n### Input Format:\n- `df`: A pandas DataFrame containing the data.\n- `outcome`: A string representing the name of the column with binary outcome labels (0 or 1).\n- `predictor`: A string representing the name of the column with predicted scores (continuous values).\n- `n_bootstraps`: An optional integer specifying the number of bootstrap samples to generate.\n\n### Output Format:\n- A dictionary with the following keys:\n  - `\"AUROC_Mean\"`: The mean AUROC value (float).\n  - `\"AUROC_CI_Lower\"`: The lower bound of the AUROC confidence interval (float).\n  - `\"AUROC_CI_Upper\"`: The upper bound of the AUROC confidence interval (float).\n  - `\"Outcome_Mean\"`: The mean of the outcome variable (float).\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    \"predictor\": [0.1, 0.4, 0.35, 0.8, 0.6, 0.2, 0.9, 0.3, 0.7, 0.5],\n    \"outcome\": [0, 1, 1, 1, 0, 0, 1, 0, 1, 0]\n}\ndf = pd.DataFrame(data)\n\n# Parameters\noutcome = \"outcome\"\npredictor = \"predictor\"\nn_bootstraps = None\n```\n\nOutput:\n```python\n{'AUROC_Mean': 0.84, 'AUROC_CI_Lower': 0.5684194238217186, 'AUROC_CI_Upper': 1.0, 'Outcome_Mean': 0.5}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import roc_curve, auc\nfrom scipy import stats\n\n\ndef compute_midrank(x):\n    sorted_idx = np.argsort(x)\n    sorted_x = x[sorted_idx]\n    ranks = np.zeros_like(x, dtype=float)\n    i = 0\n    while i < len(x):\n        j = i\n        while j < len(x) and sorted_x[j] == sorted_x[i]:\n            j += 1\n        ranks[i:j] = 0.5 * (i + j - 1)\n        i = j\n    return ranks[sorted_idx.argsort()] + 1\n\n\ndef fastDeLong_no_weights(predictions, label_1_count):\n    m = label_1_count\n    n = predictions.shape[1] - m\n    tx = np.array([compute_midrank(pred[:m]) for pred in predictions])\n    ty = np.array([compute_midrank(pred[m:]) for pred in predictions])\n    tz = np.array([compute_midrank(pred) for pred in predictions])\n    aucs = tz[:, :m].sum(axis=1) / m / n - (m + 1.0) / (2.0 * n)\n    v01, v10 = (tz[:, :m] - tx) / n, 1.0 - (tz[:, m:] - ty) / m\n    return aucs, np.cov(v01) / m + np.cov(v10) / n\n\n\ndef delong_roc_variance(ground_truth, predictions):\n    order = (-ground_truth).argsort()\n    label_1_count = int(ground_truth.sum())\n    predictions_sorted = predictions[np.newaxis, order]\n    return fastDeLong_no_weights(predictions_sorted, label_1_count)\n\n\n# main code\ndef compute_auroc(df, outcome, predictor, n_bootstraps=None):\n    aucs = []\n    X, Y = df[predictor].to_numpy(), df[outcome].to_numpy()\n\n    if n_bootstraps:\n        for _ in range(n_bootstraps):\n            indices = np.random.randint(0, len(Y), len(Y))\n            if np.sum(Y[indices]) == 0 or np.sum(Y[indices]) == len(Y[indices]):\n                continue\n\n            fpr, tpr, _ = roc_curve(Y[indices], X[indices])\n            aucs.append(auc(fpr, tpr))\n    else:\n        fpr, tpr, _ = roc_curve(Y, X)\n        aucs.append(auc(fpr, tpr))\n\n\n    if len(aucs) == 0:\n        aucs.append(auc(*roc_curve(Y, X)[:2]))\n\n\n    auc_delong, auc_cov_delong = delong_roc_variance(Y, X)\n    auc_std_delong = np.sqrt(auc_cov_delong)\n    ci = stats.norm.ppf([0.025, 0.975], loc=auc_delong, scale=auc_std_delong)\n    ci = np.clip(ci, 0, 1)\n\n    lb, ub = (np.percentile(aucs, 2.5), np.percentile(aucs, 97.5)) if n_bootstraps else ci\n\n    return {\n        \"AUROC_Mean\": np.mean(aucs) if aucs else float('nan'),\n        \"AUROC_CI_Lower\": lb if aucs else float('nan'),\n        \"AUROC_CI_Upper\": ub if aucs else float('nan'),\n        \"Outcome_Mean\": df[outcome].mean()\n    }", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sample_size = np.random.randint(50, 100)\n        predictor = np.random.rand(sample_size)\n        outcome = np.random.choice([0, 1], size=sample_size, p=[0.5, 0.5])\n        df = pd.DataFrame({\n            \"predictor\": predictor,\n            \"outcome\": outcome\n        })\n        n_bootstraps = np.random.choice([None, np.random.randint(10, 100)])\n        test_cases.append((df, \"outcome\", \"predictor\", n_bootstraps))\n\n    return test_cases"}
{"problem_id": "sklearn_16", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs linear regression analysis on a dataset containing multiple features. The function will evaluate the relationship between each feature and a target variable, and return various metrics for each regression model.\n\nFunction Signature:\n```python\ndef perform_regression(three_edge):\n```\n\nConstant Used:\n- The constant `120` is used to limit the number of data points considered for regression analysis.\n\nInput Format:\n- The input to the function is a DataFrame `three_edge` with multiple columns, where the first column is the target variable 'SPAD' and the remaining columns are features.\n\nOutput Format:\n- The output of the function is a dictionary where each key is a feature name and the value is another dictionary containing:\n  - \"model\": the regression model equation\n  - \"r2\": the R-squared value of the model\n  - \"rmse\": the Root Mean Squared Error of the model\n  - \"RE\": the Relative Error of the model\n  - \"adjusted_model\": the adjusted regression model equation\n  - \"adjusted_r2\": the adjusted R-squared value\n  - \"adjusted_rmse\": the adjusted Root Mean Squared Error\n  - \"adjusted_RE\": the adjusted Relative Error\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame for testing\ndata = {\n    'SPAD': np.array([20.5, 30.2, 25.1, 40.3, 35.0, 50.1, 45.2, 60.3, 55.0, 70.1, \n                      65.2, 80.3, 75.0, 90.1, 85.2, 100.3, 95.0, 110.1, 105.2, 120.3]),\n    'Feature_1': np.array([1.0, 2.0, 1.5, 3.0, 2.5, 4.0, 3.5, 5.0, 4.5, 6.0, \n                           5.5, 7.0, 6.5, 8.0, 7.5, 9.0, 8.5, 10.0, 9.5, 11.0]),\n    'Feature_2': np.array([10.0, 20.0, 15.0, 30.0, 25.0, 40.0, 35.0, 50.0, 45.0, 60.0, \n                           55.0, 70.0, 65.0, 80.0, 75.0, 90.0, 85.0, 100.0, 95.0, 110.0])\n}\n\nthree_edge = pd.DataFrame(data)\n\n# Call the perform_regression function\nresults = perform_regression(three_edge)\n```\n\n**Output:**\n```python\n{\n    'Feature_1': {\n        'model': 'Y=10.0041x+10.129', \n        'r2': 0.99996, \n        'rmse': 0.20019, \n        'RE': 0.00527, \n        'adjusted_model': 'y=1.0018x+-0.2016', \n        'adjusted_r2': 0.99999, \n        'adjusted_rmse': 0.10919, \n        'adjusted_RE': 0.00285\n    }, \n    'Feature_2': {\n        'model': 'Y=1.0012x+10.0647', \n        'r2': 0.99995, \n        'rmse': 0.21526, \n        'RE': 0.00591, \n        'adjusted_model': 'y=1.0032x+-0.3312', \n        'adjusted_r2': 0.99996, \n        'adjusted_rmse': 0.19018, \n        'adjusted_RE': 0.00545\n    }\n}\n\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import r2_score, mean_squared_error\n\n\ndef reg(X, y):\n    reg = LinearRegression().fit(X, y)\n    coef = round(reg.coef_[0][0], 4)\n    intercept = round(reg.intercept_[0], 4)\n    model = f'y={coef}x+{intercept}'\n    y_predict = reg.predict(X)\n    return model, coef, intercept, y_predict\n\n# main code\ndef perform_regression(three_edge):\n    y = np.array(three_edge['SPAD']).reshape(-1, 1)[:120]\n    col = three_edge.columns[1:]\n    LR = LinearRegression()\n    results = {}\n\n    for i in col:\n        X = np.array(three_edge[i]).reshape(-1, 1)[:120]\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)\n\n        reg_LR = LR.fit(X_train, y_train)\n        coef = round(reg_LR.coef_[0][0], 4)\n        intercept = round(reg_LR.intercept_[0], 4)\n        model = f'Y={coef}x+{intercept}'\n        y_pre = reg_LR.predict(X_test)\n\n        rmse = round(np.sqrt(mean_squared_error(y_test, y_pre)), 5)\n        r_2 = round(r2_score(y_test, y_pre), 5)\n        RE = round(np.mean(abs(y_pre - y_test) / y_test), 5)\n\n        model_reg, coef1, intercept1, y_pre_adj = reg(y_test, y_pre)\n        rmse_adj = round(np.sqrt(mean_squared_error(y_test, y_pre_adj)), 5)\n        r_2_adj = round(r2_score(y_test, y_pre_adj), 5)\n        RE_adj = round(np.mean(abs(y_pre_adj - y_test) / y_test), 5)\n\n        results[i] = {\n            \"model\": model,\n            \"r2\": r_2,\n            \"rmse\": rmse,\n            \"RE\": RE,\n            \"adjusted_model\": model_reg,\n            \"adjusted_r2\": r_2_adj,\n            \"adjusted_rmse\": rmse_adj,\n            \"adjusted_RE\": RE_adj,\n        }\n\n    return results", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = 150\n        num_features = np.random.randint(2, 6)\n        spad_values = np.random.uniform(10, 100, size=num_samples)\n        feature_data = {\n            f'Feature_{i}': np.random.uniform(0, 50, size=num_samples)\n            for i in range(1, num_features + 1)\n        }\n        three_edge = pd.DataFrame({'SPAD': spad_values, **feature_data})\n\n        test_cases.append(three_edge)\n\n    return test_cases"}
{"problem_id": "sklearn_17", "library": "sklearn", "code_problem": "You are tasked with implementing a function that fits a machine learning model to a dataset and evaluates its performance. The function will take in a specific parameter name from the dataset, the dataset itself, and a machine learning model class. It will return a dictionary containing various performance metrics of the model.\n\nFunction signature:\n```python\ndef fit_and_evaluate(name, data, model):\n```\n\nConstant used in the main code:\n- The constant `test_size=0.25` is used in the `train_test_split` function to specify that 25% of the data should be used for testing.\n\nInput format:\n- `name`: A string representing the name of the feature column in the dataset.\n- `data`: A pandas DataFrame containing the dataset with at least two columns: one for the feature specified by `name` and one for the target variable `SPAD`.\n- `model`: A machine learning model class from scikit-learn that can be instantiated and fitted to the data.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `'parameter'`: The input feature name.\n  - `'R2_train'`: The R-squared score for the training set.\n  - `'r2_test'`: The R-squared score for the testing set.\n  - `'RMSE'`: The Root Mean Squared Error for the testing set.\n  - `'RE%'`: The Relative Error percentage for the testing set.\n\n**Input:**\n```python\nname = \"feature_42\"\ndata = pd.DataFrame({\n    \"feature_42\": [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    \"SPAD\": [35.1, 70.5, 105.2, 140.3, 175.0, 210.1, 245.5, 280.2, 315.0, 350.5]\n})\nmodel = LinearRegression\n```\n\n**Output:**\n```python\n{'parameter': 'feature_42', 'R2_train': 1.0, 'r2_test': 1.0, 'RMSE': 0.259, 'RE%': 0.1}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import mean_squared_error, r2_score\n\n# main code\ndef fit_and_evaluate(name, data, model):\n\n    y = np.array(data['SPAD']).reshape(-1, 1)\n    X = np.array(data[name]).reshape(-1, 1)\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.25)\n\n    Model = model().fit(X_train, y_train)\n    y_train_pred = Model.predict(X_train).reshape(-1, 1)\n    y_pred = Model.predict(X_test).reshape(-1, 1)\n\n    R2_train = round(r2_score(y_train, y_train_pred), 3)\n    r2_test = round(r2_score(y_test, y_pred), 3)\n    rmse = round(np.sqrt(mean_squared_error(y_test, y_pred)), 3)\n    RE = round(np.mean(abs(y_pred - y_test) / y_test), 3)\n\n    res = {\n        'parameter': name,\n        'R2_train': R2_train,\n        'r2_test': r2_test,\n        'RMSE': rmse,\n        'RE%': RE * 100\n    }\n    return res", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.linear_model import LinearRegression\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        feature_name = f\"feature_{np.random.randint(1, 100)}\"\n        X = np.random.uniform(0, 100, size=(num_samples, 1))\n        y = 3.5 * X + np.random.normal(0, 10, size=(num_samples, 1))\n        data = pd.DataFrame({feature_name: X.flatten(), 'SPAD': y.flatten()})\n        test_cases.append((feature_name, data, LinearRegression))\n\n    return test_cases"}
{"problem_id": "sklearn_18", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for the KMeans clustering algorithm using grid search. The function will evaluate different numbers of clusters and return the best parameters based on various scoring metrics.\n\nFunction signature:\n```python\ndef test_unsupervised_grid_search(X, y):\n```\n\nIn this function, the following constant is used:\n- `random_state=0`: This constant ensures reproducibility of the results by setting a fixed seed for the random number generator.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature set for clustering.\n- `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the true labels for the data points.\n\nOutput format:\n- The function returns a dictionary where the keys are the scoring criteria and the values are the best number of clusters determined by the grid search for each criterion.\n\nInput:\n```python\nX = np.array([[ 1.0, 2.0], [ 1.5, 1.8], [ 5.0, 8.0], [ 8.0, 8.0], [ 1.0, 0.6], [ 9.0, 11.0]])\ny = np.array([0, 0, 1, 1, 0, 1])\n```\n\nOutput:\n```python\n{'adjusted_rand_score': 2, 'fowlkes_mallows_score': 2, 'fowlkes_mallows_score_no_refit': 2, 'no_scoring': 4}\n```", "ground_truth_code": "from sklearn.cluster import KMeans\nfrom sklearn.model_selection import GridSearchCV\n\n# main code\ndef test_unsupervised_grid_search(X, y):\n    km = KMeans(random_state=0, init='random', n_init=1)\n    scoring = ['adjusted_rand_score', 'fowlkes_mallows_score']\n    refit_criteria = ['adjusted_rand_score', 'fowlkes_mallows_score']\n    param_grid = dict(n_clusters=[2, 3, 4])\n\n    best_params = {}\n\n    for refit in refit_criteria:\n        grid_search = GridSearchCV(km, param_grid=param_grid, scoring=scoring, refit=refit)\n        grid_search.fit(X, y)\n        best_params[refit] = grid_search.best_params_['n_clusters']\n\n    grid_search = GridSearchCV(km, param_grid=param_grid, scoring='fowlkes_mallows_score')\n    grid_search.fit(X, y)\n    best_params['fowlkes_mallows_score_no_refit'] = grid_search.best_params_['n_clusters']\n\n    grid_search = GridSearchCV(km, param_grid=param_grid)\n    grid_search.fit(X)\n    best_params['no_scoring'] = grid_search.best_params_['n_clusters']\n\n    return best_params", "test_script": "import numpy as np\nfrom sklearn.datasets import make_blobs\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_clusters = np.random.choice([2, 3, 4])\n        num_samples = np.random.randint(100, 500)\n        num_features = np.random.randint(2, 10)\n        X, y = make_blobs(n_samples=num_samples, n_features=num_features, centers=num_clusters,\n                          random_state=np.random.randint(1000))\n\n        test_cases.append((X, y))\n\n    return test_cases"}
{"problem_id": "sklearn_19", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a classification model based on its predictions and the true labels. The function should handle different types of classification tasks, including binary, multiclass, and multilabel classifications. The evaluation metrics to be computed include accuracy, AUC (Area Under the Curve), and average precision (AUPRC) as appropriate for the classification mode.\n\nFunction signature:\n```python\ndef evaluate(data_dict, mode=None, clf=None):\n```\n\n### Constants:\n- The constant used in the main code is `0.5`, which is used as the threshold for binary classification to determine the predicted labels from the predicted scores.\n\n### Input and Output Format:\n- **Input**: \n  - `data_dict`: A dictionary containing 'logits' and 'labels'.\n  - `mode`: A string indicating the classification mode (optional).\n  - `clf`: A classifier object (optional).\n\n- **Output**: \n  - A dictionary containing:\n    - 'pred': The predicted labels.\n    - 'labels': The true labels.\n    - 'acc': The accuracy of the predictions.\n    - 'auc': The AUC score (for binary and multilabel).\n    - 'auprc': The average precision score (for multilabel).\n    - Additional metrics from the classification report (for binary and multiclass).\n\nInput:\n```python\ndata_dict = {\n    'labels': torch.tensor([1, 0, 1, 1, 0]),\n    'logits': torch.tensor([[0.8], [0.2], [0.6], [0.9], [0.1]])\n}\nmode = 'binary'\n```\n\nOutput:\n```python\n{\n    'pred': array([0, 0, 0, 0, 0]), \n    'labels': array([1, 0, 1, 1, 0]), \n    'auc': 0.5, \n    'acc': 0.6, \n    'precision': 0.3, \n    'recall': 0.5, \n    'f1-score': 0.375\n}\n```", "ground_truth_code": "import torch\nimport numpy as np\nfrom sklearn.metrics import roc_auc_score, classification_report, average_precision_score\n\n# main code\ndef evaluate(data_dict, mode=None, clf=None):\n    if clf:\n        clf.eval()\n\n    pred_list = []\n    label_list = []\n\n    with torch.no_grad():\n        if clf:\n            outputs = clf(**data_dict)\n        else:\n            outputs = {'logits': torch.zeros_like(data_dict['labels'])}\n        pred_list.append(outputs['logits'])\n    label_list.append(data_dict['labels'])\n\n    pred_list = torch.cat(pred_list, 0)\n    labels = torch.cat(label_list, 0).numpy()\n    pred = pred_list.numpy()\n\n    outputs = {'pred': pred, 'labels': labels}\n\n    if mode is None:\n        mode = 'binary' if len(labels.shape) == 1 and len(np.unique(labels)) == 2 else 'multiclass' if len(\n            labels.shape) == 1 else 'multilabel'\n\n    if mode == 'binary':\n        if pred.ndim == 1 or pred.shape[1] == 1:\n            pred_score = torch.tensor(pred).sigmoid().numpy().flatten()\n            outputs['auc'] = roc_auc_score(labels, pred_score)\n            pred_label = (pred_score >= 0.5).astype(int)\n        else:\n            pred_score = torch.tensor(pred).sigmoid().numpy()\n            pred_label = np.argmax(pred_score, axis=1)\n        outputs['acc'] = (pred_label == labels).mean()\n        res = classification_report(labels, pred_label, output_dict=True)['macro avg']\n        res.pop('support', None)\n        outputs.update(res)\n\n    elif mode == 'multiclass':\n        pred_label = pred.argmax(axis=1) if pred.ndim > 1 else pred\n        outputs['acc'] = (pred_label == labels).mean()\n        res = classification_report(labels, pred_label, output_dict=True)['macro avg']\n        res.pop('support', None)\n        outputs.update(res)\n\n    elif mode == 'multilabel':\n        pred_score = torch.tensor(pred).sigmoid().numpy()\n        auroc_list = [roc_auc_score(labels[:, i], pred_score[:, i]) for i in range(pred_score.shape[1])]\n        auprc_list = [average_precision_score(labels[:, i], pred_score[:, i]) for i in range(pred_score.shape[1])]\n        outputs['auc'] = np.mean(auroc_list)\n        outputs['auprc'] = np.mean(auprc_list)\n\n    return outputs", "test_script": "import torch\nfrom random import choice, randint\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        mode = choice(['binary', 'multiclass', 'multilabel'])\n        batch_size = randint(10, 100)\n\n        if mode == 'binary':\n            labels = torch.randint(0, 2, (batch_size,))\n            logits = torch.randn(batch_size, 1)\n        elif mode == 'multiclass':\n            num_classes = randint(2, 10)\n            labels = torch.randint(0, num_classes, (batch_size,))\n            logits = torch.randn(batch_size, num_classes)\n        elif mode == 'multilabel':\n            num_labels = randint(2, 10)\n            labels = torch.randint(0, 2, (batch_size, num_labels))\n            logits = torch.randn(batch_size, num_labels)\n\n        data_dict = {'labels': labels, 'logits': logits}\n        test_cases.append((data_dict, mode))\n\n    return test_cases"}
{"problem_id": "sklearn_20", "library": "sklearn", "code_problem": "You are tasked with creating a neural network model using PyTorch. The model should be initialized based on the provided parameters, including the dimensions of the input context, the number of output actions, the sizes of hidden layers, and the type of activation function to be used.\n\nFunction signature:\n```python\ndef initialize_nn_model(dim_context, n_actions, hidden_layer_size, activation):\n```\n\nConstant used in the main code:\n- The default activation function used if the provided activation type is not recognized is `nn.ReLU`.\n\nInput format:\n- The function accepts four parameters: an integer for `dim_context`, an integer for `n_actions`, a list of integers for `hidden_layer_size`, and a string for `activation`.\n\nOutput format:\n- The function returns a PyTorch `nn.Sequential` object representing the initialized neural network model.\n\n```python\nInput: (32, 5, [64, 128], 'relu')\nOutput: Sequential(\n  (0): Linear(in_features=32, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=128, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=128, out_features=5, bias=True)\n)\n```", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef initialize_nn_model(dim_context, n_actions, hidden_layer_size, activation):\n    activation_mapping = {\n        'identity': nn.Identity,\n        'logistic': nn.Sigmoid,\n        'tanh': nn.Tanh,\n        'relu': nn.ReLU,\n        'elu': nn.ELU\n    }\n    activation_layer = activation_mapping.get(activation, nn.ReLU)\n\n    layers = []\n    input_size = dim_context\n    for i, h in enumerate(hidden_layer_size):\n        layers.append(nn.Linear(input_size, h))\n        layers.append(activation_layer())\n        input_size = h\n\n    layers.append(nn.Linear(input_size, n_actions))\n    return nn.Sequential(*layers)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    activation_options = ['identity', 'logistic', 'tanh', 'relu', 'elu']\n\n    for _ in range(n):\n        dim_context = random.randint(1, 100)\n        n_actions = random.randint(1, 20)\n        hidden_layer_size = [random.randint(1, 100) for _ in range(random.randint(1, 5))]\n        activation = random.choice(activation_options)\n        test_cases.append((dim_context, n_actions, hidden_layer_size, activation))\n\n    return test_cases"}
{"problem_id": "sklearn_21", "library": "sklearn", "code_problem": "You are tasked with implementing a machine learning model that predicts binary labels based on input features. The model should be trained using logistic regression with cross-validation, and it should account for class imbalance in the dataset. The function signature for the main code is as follows:\n\n```python\ndef learn_model(labels, X):\n```\n\n### Constants Used:\n- `pos_class_boost`: A constant value set to `1.5`, which is used to boost the weight of the positive class in the class weights calculation.\n\n\n### Input Format:\n- `labels`: A 1D array-like structure containing binary labels (0s and 1s).\n- `X`: A 2D array-like structure containing the feature set for training the model.\n\n### Output Format:\n- The function returns a 1D array of predicted labels (0s and 1s) corresponding to the input feature set `X`.\n\nInput:\n```python\nlabels = np.array([0, 1, 0, 1, 1, 0, 0, 1, 0, 0])\nX = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n              [0.5, 0.6, 0.7, 0.8, 0.9],\n              [0.2, 0.1, 0.4, 0.3, 0.6],\n              [0.9, 0.8, 0.7, 0.6, 0.5],\n              [0.4, 0.5, 0.6, 0.7, 0.8],\n              [0.3, 0.2, 0.1, 0.0, -0.1],\n              [0.6, 0.7, 0.8, 0.9, 1.0],\n              [0.0, 0.1, 0.2, 0.3, 0.4],\n              [0.8, 0.9, 1.0, 1.1, 1.2],\n              [0.7, 0.6, 0.5, 0.4, 0.3]])\n```\n\nOutput:\n```python\narray([1, 0, 1, 1, 1, 1, 1, 1, 1, 1])\n``` \n", "ground_truth_code": "import numpy as np\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\nfrom sklearn import utils, metrics\nfrom sklearn.linear_model import LogisticRegressionCV\n\n# main code\ndef learn_model(labels, X):\n    num_pos_labels = np.count_nonzero(labels)\n    num_labels = labels.shape[0]\n    num_neg_labels = num_labels - num_pos_labels\n\n    pos_class_weight = num_labels / num_pos_labels\n    neg_class_weight = num_labels / num_neg_labels\n    total_weight = pos_class_weight + neg_class_weight\n    pos_class_weight /= total_weight\n    neg_class_weight /= total_weight\n\n    pos_class_boost = 1.5\n    class_weights = {1: pos_class_weight * pos_class_boost, 0: neg_class_weight}\n\n    label_encoder = LabelEncoder()\n    labels = label_encoder.fit_transform(labels)\n\n    scaler = StandardScaler()\n    X = scaler.fit_transform(X)\n    X, labels = utils.shuffle(X, labels, random_state=999)\n\n    p_scorer = metrics.make_scorer(metrics.fbeta_score, pos_label=1, beta=0.5)\n    logreg_cv = LogisticRegressionCV(Cs=[1000], class_weight=class_weights, cv=3,\n                                     solver='sag', n_jobs=6, scoring=p_scorer, random_state=999)\n    logreg_cv.fit(X, labels)\n\n    pred = logreg_cv.predict(X)\n\n    return pred", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 50)\n\n        labels = np.random.choice([0, 1], size=num_samples, p=[0.5, 0.5])\n        X = np.random.randn(num_samples, num_features)\n\n        test_cases.append((labels, X))\n\n    return test_cases"}
{"problem_id": "sklearn_22", "library": "sklearn", "code_problem": "You are tasked with implementing a function that utilizes machine learning models to classify data into different classes. The function will use Support Vector Classification (SVC) and Ridge regression to predict labels based on input data. The function should also handle cases where the input data or labels are not provided, using default values instead.\n\nFunction Signature:\n```python\ndef quest_for_mysterious_classes(data, labels, svc_params=None, ridge_params=None):\n```\n\nConstants Used:\n- `sacred_parameters_svc`: Default parameters for the SVC model, set to `{'C': [0.1, 1, 10]}` if not provided.\n- `sacred_parameters_ridge`: Default parameters for the Ridge regression model, set to `{'alpha': [1.0, 2.0]}` if not provided.\n\nInput Format:\n- `data`: A 2D numpy array of shape (n_samples, n_features) or `None`.\n- `labels`: A 1D numpy array of shape (n_samples,) or `None`.\n- `svc_params`: A dictionary of parameters for the SVC model or `None`.\n- `ridge_params`: A dictionary of parameters for the Ridge regression model or `None`.\n\nOutput Format:\n- A dictionary containing the predictions from the three model configurations, with keys:\n  - `'Sir_LinearSVC_with_refit'`\n  - `'Lady_Ridge_with_refit'`\n  - `'Sir_LinearSVC_with_refit_False'` (which may be `None` if the model was not fitted).\n\nInput:\n```python\ndata = np.array([[0.1, 0.2, 0.3], \n                 [0.4, 0.5, 0.6], \n                 [0.7, 0.8, 0.9], \n                 [0.1, 0.4, 0.7], \n                 [0.2, 0.5, 0.8], \n                 [0.3, 0.6, 0.9]])\nlabels = np.array([0, 0, 1, 1, 0, 1])\nsvc_params = {'C': [0.1, 1, 10]}\nridge_params = {'alpha': [1.0, 2.0]}\n```\n\nOutput:\n```python\n{\n    'Sir_LinearSVC_with_refit': array([0, 1, 1, 1, 1, 1]), \n    'Lady_Ridge_with_refit': array([0.31339286, 0.48214286, 0.65089286, 0.46160714, 0.51785714, 0.57410714]), \n    'Sir_LinearSVC_without_fit': None, \n    'Sir_LinearSVC_with_refit_False': array([0, 1, 1, 1, 1, 1])\n}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.svm import LinearSVC\nfrom sklearn.linear_model import Ridge\n\n\n# main code\ndef quest_for_mysterious_classes(data, labels, svc_params=None, ridge_params=None):\n    oracle_data = data if data is not None else np.arange(100).reshape(10, 10)\n    oracle_labels = labels if labels is not None else np.array(\n        [0] * (len(oracle_data) // 2) + [1] * (len(oracle_data) // 2))\n    sacred_parameters_svc = svc_params if svc_params is not None else {'C': [0.1, 1, 10]}\n    sacred_parameters_ridge = ridge_params if ridge_params is not None else {'alpha': [1.0, 2.0]}\n    chronicles_of_classes = {}\n    min_class_size = min(np.bincount(oracle_labels))\n    cv_folds = min(5, min_class_size) if min_class_size > 1 else 2\n\n    sage_svc = GridSearchCV(LinearSVC(), sacred_parameters_svc, cv=cv_folds)\n    sage_svc.fit(oracle_data, oracle_labels)\n    chronicles_of_classes['Sir_LinearSVC_with_refit'] = sage_svc.predict(oracle_data)\n\n    sage_ridge = GridSearchCV(Ridge(), sacred_parameters_ridge, cv=cv_folds)\n    sage_ridge.fit(oracle_data, oracle_labels)\n    chronicles_of_classes['Lady_Ridge_with_refit'] = sage_ridge.predict(oracle_data)\n\n    chronicles_of_classes['Sir_LinearSVC_without_fit'] = None\n\n    sage_svc_no_refit = GridSearchCV(LinearSVC(), sacred_parameters_svc, refit=False, cv=cv_folds)\n    sage_svc_no_refit.fit(oracle_data, oracle_labels)\n    best_idx = np.argmax(sage_svc_no_refit.cv_results_['mean_test_score'])\n    best_svc_model = LinearSVC(C=sage_svc_no_refit.param_grid['C'][best_idx])\n    best_svc_model.fit(oracle_data, oracle_labels)\n    chronicles_of_classes['Sir_LinearSVC_with_refit_False'] = best_svc_model.predict(oracle_data)\n\n    return chronicles_of_classes\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(5, 50)\n        d = np.random.randint(5, 20)\n        data = np.random.rand(m, d)\n        labels = np.random.choice([0, 1], size=m)\n        svc_params = {'C': np.random.choice([0.1, 1, 10, 100], size=np.random.randint(1, 4), replace=False).tolist()}\n        ridge_params = {\n            'alpha': np.random.choice([0.5, 1.0, 2.0, 5.0], size=np.random.randint(1, 3), replace=False).tolist()}\n        test_cases.append((data, labels, svc_params, ridge_params))\n\n    return test_cases\n"}
{"problem_id": "sklearn_23", "library": "sklearn", "code_problem": "You are tasked with evaluating the performance of a classification model using various metrics and analyzing its fairness across different demographic groups. The evaluation will be based on a DataFrame containing true labels and predicted labels for multiple tasks, such as gender, age, country, and ethnicity.\n\nThe main function signature is as follows:\n```python\ndef eval(df):\n```\n\nIn this function, a constant list `tasks` is defined, which includes the following demographic categories: `['gender', 'age', 'country', 'ethnicity']`. \n\nThe logic of the `eval` function is detailed step by step as follows:\n\nThe input format for the function is expected to be a DataFrame with at least the following columns: `label`, `pred`, `pred_prob`, and any of the demographic task columns specified in the `tasks` list. The output format is a dictionary containing the calculated metrics for accuracy, F1 scores, AUC, and fairness metrics for each task.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'label': [0, 1, 0, 1, 0, 1, 1, 0, 1, 0],\n    'pred': [0, 1, 0, 0, 1, 1, 1, 0, 0, 1],\n    'pred_prob': [0.1, 0.9, 0.2, 0.4, 0.8, 0.95, 0.85, 0.3, 0.6, 0.7],\n    'gender': ['male', 'female', 'male', 'female', 'male', 'female', 'female', 'male', 'female', 'male'],\n    'age': [20, 30, 20, 30, 20, 30, 30, 20, 30, 20]\n}\n\ndf = pd.DataFrame(data)\n```\n\n**Output:**\n```python\n{\n    'accuracy': 0.6, \n    'f1-macro': 0.6, \n    'f1-weight': 0.6, \n    'auc': 0.84, \n    'gender': {'fned': nan, 'fped': nan, 'tped': nan, 'tned': nan}, \n    'age': {'fned': nan, 'fped': nan, 'tped': nan, 'tned': nan}\n}\n``` \n", "ground_truth_code": "from sklearn import metrics\n\n\ndef cal_fnr(fn, tp):\n    return fn / (fn + tp)\n\n\ndef cal_fpr(fp, tn):\n    return fp / (fp + tn)\n\n\ndef cal_tpr(tp, fn):\n    return tp / (tp + fn)\n\n\ndef cal_tnr(tn, fp):\n    return tn / (tn + fp)\n\n# main code\ndef eval(df):\n    tasks = ['gender', 'age', 'country', 'ethnicity']\n    scores = {\n        'accuracy': metrics.accuracy_score(y_true=df.label, y_pred=df.pred),\n        'f1-macro': metrics.f1_score(y_true=df.label, y_pred=df.pred, average='macro'),\n        'f1-weight': metrics.f1_score(y_true=df.label, y_pred=df.pred, average='weighted'),\n        'auc': metrics.auc(*metrics.roc_curve(y_true=df.label, y_score=df.pred_prob)[:2])\n    }\n\n    for task in tasks:\n        if task not in df.columns or df[task].isnull().all():\n            continue\n\n        scores[task] = {'fned': 0.0, 'fped': 0.0, 'tped': 0.0, 'tned': 0.0}\n        task_df = df[df[task].notnull()]\n        tn, fp, fn, tp = metrics.confusion_matrix(y_true=task_df.label, y_pred=task_df.pred).ravel()\n\n        for group in task_df[task].unique():\n            group_df = task_df[task_df[task] == group]\n            g_tn, g_fp, g_fn, g_tp = metrics.confusion_matrix(y_true=group_df.label, y_pred=group_df.pred).ravel()\n\n            scores[task]['fned'] += abs(cal_fnr(fn, tp) - cal_fnr(g_fn, g_tp))\n            scores[task]['fped'] += abs(cal_fpr(fp, tn) - cal_fpr(g_fp, g_tn))\n            scores[task]['tped'] += abs(cal_tpr(tp, fn) - cal_tpr(g_tp, g_fn))\n            scores[task]['tned'] += abs(cal_tnr(tn, fp) - cal_tnr(g_tn, g_fp))\n\n    return scores", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n\n        df = pd.DataFrame({\n            'label': np.random.randint(0, 2, num_samples),\n            'pred': np.random.randint(0, 2, num_samples),\n            'pred_prob': np.random.rand(num_samples)\n        })\n\n        for task in ['gender', 'age', 'country', 'ethnicity']:\n            if np.random.rand() > 0.2:\n                num_groups = np.random.randint(2, 5)\n                df[task] = np.random.choice(range(num_groups), num_samples)\n                df.loc[np.random.choice(df.index, num_samples // 5, replace=False), task] = np.nan\n\n        test_cases.append(df)\n\n    return test_cases"}
{"problem_id": "sklearn_24", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various performance metrics for binary classification models. The function will take the true labels and predicted probabilities as inputs and return several evaluation metrics that are commonly used to assess the performance of classification models.\n\nFunction Signature:\n```python\ndef get_metrics_bin(y_true: np.ndarray, y_pred: np.ndarray, t: Optional[float] = None) -> Tuple[float, float, float, float, float, float, float, float]:\n```\n\nConstant Used:\n- The constant used in the main code is `0.5`, which is the default threshold for converting predicted probabilities into binary predictions when no threshold `t` is provided.\n\nInput Format:\n- `y_true`: A numpy array of true binary labels (0 or 1).\n- `y_pred`: A numpy array of predicted probabilities (float values between 0 and 1).\n- `t`: An optional float value representing the threshold for binary classification (default is None).\n\nOutput Format:\n- A tuple containing the following metrics in order: precision (float), recall (float), false positive rate (float), specificity (float), accuracy (float), F1 score (float), KSS score (float), and EDI (float).\n\nInput:\n```python\ny_true = np.array([1, 0, 1, 1, 0])\ny_pred = np.array([0.8, 0.4, 0.6, 0.9, 0.2])\nt = None\n```\n\nOutput:\n```python\n(1.0, 1.0, 0.0, 1.0, 1.0, 1.0, 1.0, 0.0)\n```", "ground_truth_code": "from sklearn import metrics\nimport numpy as np\n\n# main code\ndef get_metrics_bin(y_true, y_pred, t=None):\n    if t is not None:\n        t = 100 * t if t < 1 else t\n        y_pred_b = np.array(y_pred > np.percentile(y_pred, t), dtype=int)\n    else:\n        y_pred_b = np.array(y_pred >= 0.5, dtype=int)\n\n    if np.sum(y_true) != 0 or np.sum(y_pred_b) != 0:\n        prec = metrics.precision_score(y_true, y_pred_b)\n        recall = metrics.recall_score(y_true, y_pred_b)\n    else:\n        prec = recall = 0.0\n\n    tn, fp, fn, tp = metrics.confusion_matrix(y_true, y_pred_b).ravel()\n\n    fpr = fp / (fp + tn) if fp + tn != 0 else 0.0\n    SP = tn / (tn + fp) if tn + fp != 0 else 1.0\n    Acc = metrics.accuracy_score(y_true, y_pred_b)\n\n    f1 = metrics.f1_score(y_true, y_pred_b) if (tp + fp != 0 and tp + fn != 0) else 0.0\n\n    KSS_score = recall - fpr\n\n    if fpr not in {0.0, 1.0} and recall not in {0.0, 1.0}:\n        EDI = (np.log(fpr) - np.log(recall)) / (np.log(fpr) + np.log(recall))\n    else:\n        EDI = 0.0\n\n    return prec, recall, fpr, SP, Acc, f1, KSS_score, EDI", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(10, 200)\n        y_true = np.random.randint(0, 2, size=length)\n        y_pred = np.random.rand(length)\n        t = np.random.rand() if np.random.rand() > 0.5 else None\n\n        test_cases.append((y_true, y_pred, t))\n\n    return test_cases"}
{"problem_id": "sklearn_25", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a Support Vector Classifier (SVC) using both Grid Search and Randomized Search methods. The function will evaluate the performance of these methods based on cross-validation results and return the mean test scores and their corresponding ranks.\n\nFunction Signature:\n```python\ndef test_search_cv_results_rank_tie_breaking(X, y, param_grid):\n```\n\nConstant Used:\n- The constant `cv=3` is used in both Grid Search and Randomized Search to specify the number of cross-validation folds.\n\nInput Format:\n- `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature set.\n- `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the target variable.\n- `param_grid`: A dictionary where keys are hyperparameter names and values are lists of settings to be tested.\n\nOutput Format:\n- The function returns a dictionary where:\n  - Each key is the name of the search method ('GridSearchCV' or 'RandomizedSearchCV').\n  - Each value is another dictionary containing:\n    - 'mean_test_scores': An array of mean test scores for each parameter setting.\n    - 'rank_test_scores': An array of ranks corresponding to the mean test scores.\n\nInput:\n```python\n(X, y, param_grid) = (\n    array([[ 0.12345678, -0.98765432,  0.45678901,  0.23456789, -0.12345678],\n           [ 0.23456789,  0.87654321, -0.56789012, -0.34567890,  0.23456789],\n           [-0.34567890,  0.12345678,  0.67890123,  0.45678901, -0.34567890],\n           [ 0.45678901, -0.23456789, -0.78901234,  0.56789012,  0.45678901],\n           [ 0.56789012,  0.34567890,  0.89012345, -0.67890123, -0.56789012]]),\n    array([0, 1, 0, 1, 0]),\n    {\n        'C': [0.1, 10.0],\n        'gamma': [0.01, 1.0],\n        'kernel': ['linear']\n    }\n)\n```\n\nOutput:\n```python\n{\n    'GridSearchCV': {\n        'mean_test_scores': array([0.66666667, 0.66666667, 1.        , 1.        ]), \n        'rank_test_scores': array([3, 3, 1, 1], dtype=int32)}, \n    'RandomizedSearchCV': {\n        'mean_test_scores': array([1.        , 0.66666667]), \n        'rank_test_scores': array([1, 2], dtype=int32)\n    }\n}\n\n```", "ground_truth_code": "from sklearn.model_selection import GridSearchCV, RandomizedSearchCV\nfrom sklearn.svm import SVC\n\n# main code\ndef test_search_cv_results_rank_tie_breaking(X, y, param_grid):\n    grid_search = GridSearchCV(SVC(), param_grid=param_grid, return_train_score=False, cv=3)\n    random_search = RandomizedSearchCV(SVC(), n_iter=2, param_distributions=param_grid, return_train_score=False, cv=3)\n\n    results = {}\n\n    for search in (grid_search, random_search):\n        search.fit(X, y)\n        cv_results = search.cv_results_\n\n        results[search.__class__.__name__] = {\n            'mean_test_scores': cv_results['mean_test_score'],\n            'rank_test_scores': cv_results['rank_test_score']\n        }\n\n    return results", "test_script": "import numpy as np\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X, y = make_classification(n_samples=np.random.randint(20, 100),\n                                   n_features=np.random.randint(5, 10),\n                                   n_classes=2,\n                                   random_state=np.random.randint(0, 1000))\n\n        param_grid = {\n            'C': np.logspace(-2, 2, num=np.random.randint(2, 3)).tolist(),\n            'gamma': np.logspace(-2, 2, num=np.random.randint(2, 3)).tolist(),\n            'kernel': np.random.choice(['linear', 'rbf'], size=1, replace=False).tolist()\n        }\n\n        test_cases.append((X, y, param_grid))\n\n    return test_cases\n"}
{"problem_id": "sklearn_26", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model based on its predictions. The function will compute different types of loss metrics and the area under the curve (AUC) based on the specified loss type. The function will take in a dataset, a TensorFlow session, the type of loss to compute, and the model's predictions.\n\nFunction signature:\n```python\ndef evaluate(data, sess, loss_type, train_labels, out, train_features):\n```\n\n### Constants:\n- The constant used in the main code is `0.0001` and `0.9999`, which are used to clip the predicted probabilities in the case of log loss.\n\n### Input and Output Format:\n- **Input Format**:\n  - `data`: A dictionary with keys 'X' (features) and 'Y' (true labels).\n  - `sess`: A TensorFlow session.\n  - `loss_type`: A string ('square_loss' or 'log_loss').\n  - `train_labels`: A TensorFlow placeholder for true labels.\n  - `out`: A list of TensorFlow tensors for model predictions.\n  - `train_features`: A TensorFlow placeholder for input features.\n\n- **Output Format**:\n  - A tuple containing three values: \n    - `loss`: A float representing the computed loss.\n    - `auc`: A float representing the area under the curve.\n    - `loss_low`: A float representing the computed loss for the lower-bound predictions.\n\n**Input:**\n```python\ndata = {\n    'X': np.array([[0.5, -1.2, 0.3], [1.0, 0.0, -0.5], [-0.3, 0.8, 1.5]], dtype=np.float32),\n    'Y': np.array([0, 1, 0], dtype=np.float32)\n}\nsess = MockSession()\nloss_type = 'log_loss'\ntrain_labels = \"train_labels_placeholder\"\nout = [None, None]\ntrain_features = \"train_features_placeholder\"\n```\n\n**Output:**\n```python\n(3.1320713989091793, 0.25, 0.717411845108275)\n```", "ground_truth_code": "import numpy as np\nimport math\nfrom sklearn.metrics import mean_squared_error, log_loss, roc_auc_score\n\n\n# main code\ndef evaluate(data, sess, loss_type, train_labels, out, train_features):\n    num_example = data['Y'].shape[0]\n    feed_dict = {train_features: data['X'], train_labels: data['Y']}\n    predictions, predictions_low = sess.run((out[-1], out[0]), feed_dict=feed_dict)\n\n    y_pred = predictions.reshape(num_example)\n    y_pred_low = predictions_low.reshape(num_example)\n    y_true = data['Y'].reshape(num_example)\n\n    if loss_type == 'square_loss':\n        y_min, y_max = y_true.min(), y_true.max()\n        predictions_dependent = np.clip(y_pred, y_min, y_max)\n        predictions_dependent_low = np.clip(y_pred_low, y_min, y_max)\n        loss = math.sqrt(mean_squared_error(y_true, predictions_dependent))\n        auc = 0\n        loss_low = math.sqrt(mean_squared_error(y_true, predictions_dependent_low))\n\n    elif loss_type == 'log_loss':\n        y_pred = np.clip(y_pred, 0.0001, 0.9999)\n        y_pred_low = np.clip(y_pred_low, 0.0001, 0.9999)\n        loss = log_loss(y_true, y_pred)\n        auc = roc_auc_score(y_true, y_pred)\n        loss_low = log_loss(y_true, y_pred_low)\n\n    else:\n        loss, auc, loss_low = 0, 0, 0\n\n    return loss, auc, loss_low", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    class MockSession:\n        def run(self, fetches, feed_dict):\n            num_examples = feed_dict[\"train_labels_placeholder\"].shape[0]\n            return (\n                np.random.randn(num_examples).astype(np.float32),\n                np.random.randn(num_examples).astype(np.float32)\n            )\n\n    for _ in range(n):\n        num_examples = random.randint(10, 100)\n        num_features = random.randint(5, 50)\n        X = np.random.randn(num_examples, num_features).astype(np.float32)\n        Y = np.random.randint(0, 2, size=(num_examples,)).astype(np.float32)\n        loss_type = random.choice(['square_loss', 'log_loss'])\n\n        sess = MockSession()\n        train_features = \"train_features_placeholder\"\n        train_labels = \"train_labels_placeholder\"\n        out = [None, None]\n        data = {'X': X, 'Y': Y}\n        test_case = (data, sess, loss_type, train_labels, out, train_features)\n\n        test_cases.append(test_case)\n\n    return test_cases\n"}
{"problem_id": "sklearn_27", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a predictive model based on its true labels and predicted labels. The function should preprocess the input data according to the specified mode (binary or multi-class) and then calculate the accuracy, precision, and recall of the predictions.\n\nThe function signature of the main code is:\n```python\ndef reveal_truth(y_true, y_pred, train_config=None):\n```\n\nIn the main code, a constant is used to determine the mode of prediction:\n- If the `train_config` parameter is provided and its `data` attribute equals 'ur_funny', the prediction mode is set to 'multi-class'.\n- Otherwise, the prediction mode defaults to 'binary'.\n\nInput format:\n- `y_true`: A numpy array of true labels.\n- `y_pred`: A numpy array of predicted labels.\n- `train_config`: An optional parameter that may contain configuration settings, including a `data` attribute.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - \"accuracy\": The accuracy of the predictions.\n  - \"precision\": The precision of the predictions.\n  - \"recall\": The recall of the predictions.\n\nInput:\n```python\ny_true = np.array([1, 0, 1, 1, 0])\ny_pred = np.array([-0.5, 0.3, 0.8, -0.1, 0.2])\ntrain_config = None\n```\n\nOutput:\n```python\n{'accuracy': 0.6, 'precision': 1.0, 'recall': 0.6}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score\n\n\ndef preprocess_data(raw_truth, raw_preds, prophecy_mode='binary'):\n    if prophecy_mode == 'binary':\n        return (raw_truth >= 0).astype(int), (raw_preds >= 0).astype(int)\n    elif prophecy_mode == 'multi-class':\n        return raw_truth, np.argmax(raw_preds, axis=1)\n    else:\n        return raw_truth, raw_preds\n\n\ndef interpret_fate(y_true, y_pred):\n    acc = accuracy_score(y_true, y_pred)\n    precision = precision_score(y_true, y_pred, average='weighted', zero_division=1)\n    recall = recall_score(y_true, y_pred, average='weighted', zero_division=1)\n    return {\"accuracy\": acc, \"precision\": precision, \"recall\": recall}\n\n# main code\ndef reveal_truth(y_true, y_pred, train_config=None):\n    if train_config and getattr(train_config, 'data', None) == 'ur_funny':\n        prophecy_mode = 'multi-class'\n    else:\n        prophecy_mode = 'binary'\n\n    y_true, y_pred = preprocess_data(y_true, y_pred, prophecy_mode)\n    results = interpret_fate(y_true, y_pred)\n\n    return results", "test_script": "import numpy as np\nfrom collections import namedtuple\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    TrainConfig = namedtuple(\"TrainConfig\", [\"data\"])\n    for _ in range(n):\n        is_multiclass = np.random.choice([True, False])\n        train_config = TrainConfig(data='ur_funny') if is_multiclass else None\n\n        if is_multiclass:\n            num_samples = np.random.randint(10, 100)\n            num_classes = np.random.randint(2, 10)\n            y_true = np.random.randint(0, num_classes, size=(num_samples,))\n            y_pred = np.random.randn(num_samples, num_classes)\n        else:\n            num_samples = np.random.randint(10, 100)\n            y_true = np.random.choice([0, 1], size=(num_samples,))\n            y_pred = np.random.randn(num_samples)\n\n        test_cases.append((y_true, y_pred, train_config))\n\n    return test_cases"}
{"problem_id": "sklearn_28", "library": "sklearn", "code_problem": "You are tasked with creating a function that evaluates the performance of a classification model using various metrics. The function will take two lists as input: the true labels and the predicted labels from the model. It will compute several evaluation metrics and return them in a structured format.\n\nFunction Signature:\n```python\ndef get_evaluation_metrics(y_true, y_pred):\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput Format:\n- The function takes two lists as input:\n  - `y_true`: A list of true labels (ground truth).\n  - `y_pred`: A list of predicted labels from the classification model.\n\nOutput Format:\n- The function returns a tuple containing:\n  - A float representing accuracy.\n  - A float representing F1 score.\n  - A float representing precision.\n  - A float representing recall.\n  - A string representing the classification report.\n  - A 2D array (or list of lists) representing the confusion matrix.\n\nInput:\n```python\ny_true = np.array([1, 0, 1, 1, 0, 0, 1, 0, 1, 0])\ny_pred = np.array([1, 0, 0, 1, 0, 1, 1, 0, 1, 0])\n```\n\nOutput:\n```python\n(0.8, 0.8, 0.8, 0.8, '              precision    recall  f1-score   support\\n\\n           0       0.80      0.80      0.80         5\\n           1       0.80      0.80      0.80         5\\n\\n    accuracy                           0.80        10\\n   macro avg       0.80      0.80      0.80        10\\nweighted avg       0.80      0.80      0.80        10\\n', array([[4, 1],[1, 4]]))\n```", "ground_truth_code": "from sklearn import metrics\n\n# main code\ndef get_evaluation_metrics(y_true, y_pred):\n    accuracy = metrics.accuracy_score(y_true, y_pred)\n    f1_score = metrics.f1_score(y_true, y_pred)\n    precision = metrics.precision_score(y_true, y_pred)\n    recall = metrics.recall_score(y_true, y_pred)\n    report = metrics.classification_report(y_true, y_pred)\n    confusion_matrix = metrics.confusion_matrix(y_true, y_pred)\n    return (accuracy, f1_score, precision, recall, report, confusion_matrix)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 1001)\n\n        y_true = np.random.randint(0, 2, size=num_samples)\n        y_pred = np.random.randint(0, 2, size=num_samples)\n\n        test_cases.append((y_true, y_pred))\n    return test_cases"}
{"problem_id": "sklearn_29", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a linear support vector classifier using grid search. The function will evaluate the model's performance on both dense and sparse representations of the input data, as well as using a custom scoring function based on the F1 score.\n\nFunction Signature:\n```python\ndef perform_grid_search(X, y, param_grid):\n```\n\n### Constants Used:\n- The constant used in the main code is `{'C': [0.1, 1.0]}`, which represents the hyperparameter grid for the regularization parameter `C` of the `LinearSVC` model.\n\n### Input Format:\n- `X`: A 2D array-like structure representing the feature set.\n- `y`: A 1D array-like structure representing the labels corresponding to the feature set.\n- `param_grid`: A dictionary specifying the hyperparameters to be tuned (optional).\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `\"y_pred_dense\"`: Predictions made on the dense test set.\n  - `\"y_pred_sparse\"`: Predictions made on the sparse test set.\n  - `\"y_pred_custom\"`: Predictions made using the custom scoring function on the sparse test set.\n  - `\"best_C_dense\"`: The best `C` value found using the dense data.\n  - `\"best_C_sparse\"`: The best `C` value found using the sparse data.\n  - `\"best_C_custom\"`: The best `C` value found using the custom scoring function.\n\n**Input:**\n```python\nX = np.array([[-0.49290501,  0.66396092,  0.77576257, ..., -0.07371404,\n         1.61828713,  0.14494593],\n       [ 0.78605295,  0.22421045,  1.20327687, ...,  2.04068113,\n        -0.27542641,  0.57373909],\n       [-1.23282114, -0.27460576,  0.2565794 , ...,  0.05425216,\n        -0.40777379, -0.35961529],\n       ...,\n       [ 1.0192856 ,  0.00531284,  1.21871859, ...,  1.24769075,\n        -1.43502715,  1.19648113],\n       [-0.52868016, -1.24970377, -0.12744667, ...,  0.47100256,\n         2.40519233, -0.00723512],\n       [ 0.36406975,  1.02582375,  2.03205723, ..., -0.6997692 ,\n         0.36079638,  0.6168379 ]])\ny = np.array([1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 1,\n       0, 0, 0, 1, 1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 0, 1, 0, 0,\n       1, 1, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 1, 1, 1, 1, 0, 1,\n       0, 0, 0, 1, 0, 0, 0, 0, 0, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0,\n       1, 0, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 1, 1, 1, 0, 0, 1, 1, 0, 0, 1,\n       1, 0, 1, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 0, 0,\n       1, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 1,\n       1, 0, 0, 1, 0, 0, 0, 0, 1, 0, 0, 1, 0, 0, 1, 1, 0, 1, 1, 1, 1, 0,\n       0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 0, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1,\n       0, 1])\nparam_grid = {'C': [3.5461060222503202, 2.4583509398966945, 9.87150449542872, 6.292540527946352]}\n```\n\n**Output:**\n```python\n{\n    'y_pred_dense': array([1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0]), \n    'y_pred_sparse': array([1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0]), \n    'y_pred_custom': array([1, 0, 0, 1, 1, 1, 0, 0, 0, 1, 0, 1, 0, 1, 0, 0, 0, 1, 0, 0]), \n    'best_C_dense': 3.5461060222503202, \n    'best_C_sparse': 3.5461060222503202, \n    'best_C_custom': 3.5461060222503202\n}\n\n```", "ground_truth_code": "from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\nimport scipy.sparse as sp\nfrom sklearn.metrics import make_scorer, f1_score\n\n# main code\ndef perform_grid_search(X, y, param_grid):\n    if param_grid is None:\n        param_grid = {'C': [0.1, 1.0]}\n\n    clf = LinearSVC()\n    cv = GridSearchCV(clf, param_grid, scoring='f1')\n    cv.fit(X[:180], y[:180])\n    y_pred_dense = cv.predict(X[180:])\n    best_C_dense = cv.best_estimator_.C\n\n    X_sparse = sp.csr_matrix(X)\n    cv.fit(X_sparse[:180], y[:180])\n    y_pred_sparse = cv.predict(X_sparse[180:])\n    best_C_sparse = cv.best_estimator_.C\n\n    def f1_loss(y_true, y_pred):\n        return -f1_score(y_true, y_pred)\n\n    F1Loss = make_scorer(f1_loss, greater_is_better=False)\n    cv = GridSearchCV(clf, param_grid, scoring=F1Loss)\n    cv.fit(X_sparse[:180], y[:180])\n    y_pred_custom = cv.predict(X_sparse[180:])\n    best_C_custom = cv.best_estimator_.C\n\n    return {\n        \"y_pred_dense\": y_pred_dense,\n        \"y_pred_sparse\": y_pred_sparse,\n        \"y_pred_custom\": y_pred_custom,\n        \"best_C_dense\": best_C_dense,\n        \"best_C_sparse\": best_C_sparse,\n        \"best_C_custom\": best_C_custom,\n    }", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        d = np.random.randint(5, 51)\n        X = np.random.randn(200, d)\n        y = np.random.randint(0, 2, size=200)\n        param_grid = {'C': np.random.uniform(0.01, 10, size=np.random.randint(2, 5)).tolist()}\n        test_cases.append((X, y, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_30", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for machine learning models using both grid search and randomized search techniques. The function should be able to handle both classification and regression tasks based on the nature of the target variable. \n\nFunction Signature:\n```python\ndef grid_search_with_multioutput_data(X, y):\n```\n\n### Constants Used:\n- `est_parameters`: A dictionary containing the hyperparameter grid for tuning, specifically `{'max_depth': list(range(1, 5))}`.\n\n### Input Format:\n- `X`: A 2D array-like structure (e.g., list of lists, NumPy array) representing the features.\n- `y`: A 1D or 2D array-like structure (e.g., list, NumPy array) representing the target variable(s).\n\n### Output Format:\n- The function returns a dictionary where:\n  - Keys are strings indicating the search method and estimator type (e.g., `GridSearch_DecisionTreeClassifier`).\n  - Values are dictionaries containing scores for each candidate parameter set, where keys are candidate identifiers (e.g., `candidate_0`) and values are lists of scores from the cross-validation folds.\n\n```python\n# Input\nX = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.1, 0.4, 0.7], [0.2, 0.5, 0.8]])\ny = np.array([[0, 1], [1, 0], [0, 1], [1, 0], [0, 1]])\n\n# Output\n{\n    'GridSearch_DecisionTreeClassifier': {\n        'candidate_0': [0.0, 0.0, 0.0, 0.0, 0.0], \n        'candidate_1': [0.0, 0.0, 0.0, 1.0, 0.0], \n        'candidate_2': [0.0, 1.0, 1.0, 0.0, 0.0], \n        'candidate_3': [0.0, 1.0, 0.0, 0.0, 0.0]}, \n    'RandomSearch_DecisionTreeClassifier': {\n        'candidate_0': [0.0, 0.0, 1.0, 0.0, 0.0], \n        'candidate_1': [0.0, 0.0, 1.0, 0.0, 0.0], \n        'candidate_2': [0.0, 0.0, 0.0, 0.0, 0.0]\n    }\n}\n\n```", "ground_truth_code": "from sklearn.model_selection import KFold\nfrom sklearn.tree import DecisionTreeRegressor, DecisionTreeClassifier\nfrom sklearn.model_selection import GridSearchCV, RandomizedSearchCV\n\n# main code\ndef grid_search_with_multioutput_data(X, y):\n    est_parameters = {'max_depth': list(range(1, 5))}\n    cv = KFold()\n    results = {}\n    is_classification = len(set(y.flatten())) < 10\n    if is_classification:\n        if y.ndim > 1:\n            y = y.argmax(axis=1)\n        estimators = [DecisionTreeClassifier()]\n    else:\n        estimators = [DecisionTreeRegressor()]\n\n    for est in estimators:\n        grid_search = GridSearchCV(est, est_parameters, cv=cv)\n        grid_search.fit(X, y)\n        res_params = grid_search.cv_results_['params']\n        scores = {}\n\n        for cand_i, params in enumerate(res_params):\n            est.set_params(**params)\n            fold_scores = []\n\n            for i, (train, test) in enumerate(cv.split(X, y)):\n                est.fit(X[train], y[train])\n                fold_scores.append(est.score(X[test], y[test]))\n\n            scores[f'candidate_{cand_i}'] = fold_scores\n\n        results[f'GridSearch_{est.__class__.__name__}'] = scores\n\n    for est in estimators:\n        random_search = RandomizedSearchCV(est, est_parameters, cv=cv, n_iter=3)\n        random_search.fit(X, y)\n        res_params = random_search.cv_results_['params']\n        scores = {}\n\n        for cand_i, params in enumerate(res_params):\n            est.set_params(**params)\n            fold_scores = []\n\n            for i, (train, test) in enumerate(cv.split(X, y)):\n                est.fit(X[train], y[train])\n                fold_scores.append(est.score(X[test], y[test]))\n\n            scores[f'candidate_{cand_i}'] = fold_scores\n\n        results[f'RandomSearch_{est.__class__.__name__}'] = scores\n\n    return results", "test_script": "import numpy as np\nfrom sklearn.datasets import make_regression, make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        is_regression = np.random.rand() > 0.5\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n\n        if is_regression:\n            num_targets = np.random.randint(1, 5)\n            X, y = make_regression(n_samples=num_samples, n_features=num_features,\n                                   n_targets=num_targets, noise=np.random.uniform(0, 1))\n        else:\n            num_classes = np.random.randint(2, 5)\n            num_informative = max(2, min(num_features - 1, int(np.log2(num_classes) + 1)))\n            num_redundant = max(0, (num_features - num_informative) // 2)\n            num_repeated = max(0, num_features - num_informative - num_redundant)\n            X, y = make_classification(n_samples=num_samples, n_features=num_features,\n                                       n_classes=num_classes, n_informative=num_informative,\n                                       n_redundant=num_redundant, n_repeated=num_repeated,\n                                       n_clusters_per_class=1)\n            if num_classes > 2:\n                y = np.eye(num_classes)[y]\n\n        test_cases.append((X, y))\n\n    return test_cases"}
{"problem_id": "sklearn_31", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a decision tree model using cross-validation. The function will take in a dataset and a parameter grid, and it will return the best hyperparameters, the best score from cross-validation, and the predictions on a test set.\n\nFunction signature:\n```python\ndef search_cv_results(X, y, param_grid):\n```\n\n### Constants:\n- The constant used in the main code is `random_state=42`, which ensures reproducibility of the results by controlling the randomness in data splitting and K-Fold cross-validation.\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A 2D array-like structure (e.g., a NumPy array or a Pandas DataFrame) representing the features of the dataset.\n  - `y`: A 1D array-like structure (e.g., a NumPy array or a Pandas Series) representing the target variable.\n  - `param_grid`: A dictionary containing the hyperparameters to be tuned and their respective values.\n\n- **Output**:\n  - A dictionary containing:\n    - `\"best_params\"`: The best hyperparameters found.\n    - `\"best_score\"`: The best score from cross-validation.\n    - `\"predictions\"`: The predictions made on the test set.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6], \n              [0.6, 0.7], [0.7, 0.8], [0.8, 0.9], [0.9, 1.0], [1.0, 1.1]])\ny = np.array([0, 0, 1, 1, 0, 1, 0, 1, 1, 0])\nparam_grid = {\n    'max_depth': [None, 5, 10, 20],\n    'min_samples_split': [2, 5, 10],\n    'min_samples_leaf': [1, 2, 4]\n}\n```\n\nOutput:\n```python\n{\n    'best_params': {\n        'max_depth': None, \n        'min_samples_leaf': 1, \n        'min_samples_split': 5\n    }, \n    'best_score': 0.6, \n    'predictions': array([0, 1])\n}\n```", "ground_truth_code": "from sklearn.model_selection import KFold, GridSearchCV, train_test_split\nfrom sklearn.tree import DecisionTreeRegressor, DecisionTreeClassifier\nimport numpy as np\n\n\n# main code\ndef search_cv_results(X, y, param_grid):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n    cv = KFold(n_splits=5, shuffle=True, random_state=42)\n\n    if np.issubdtype(y.dtype, np.floating):\n        estimator = DecisionTreeRegressor()\n    else:\n        estimator = DecisionTreeClassifier()\n\n    grid_search = GridSearchCV(estimator, param_grid, cv=cv, scoring=\"accuracy\" if isinstance(estimator,\n                                                                                              DecisionTreeClassifier) else \"neg_mean_squared_error\")\n    grid_search.fit(X_train, y_train)\n\n    best_model = grid_search.best_estimator_\n    predictions = best_model.predict(X_test)\n\n    results = {\n        \"best_params\": grid_search.best_params_,\n        \"best_score\": grid_search.best_score_,\n        \"predictions\": predictions\n    }\n\n    return results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 500)\n        num_features = np.random.randint(1, 50)\n        X = np.random.randn(num_samples, num_features)\n        is_regression = np.random.choice([True, False])\n\n        if is_regression:\n            y = np.random.randn(num_samples).astype(np.float64)\n        else:\n            num_classes = np.random.randint(2, 10)\n            y = np.random.randint(0, num_classes, num_samples)\n        param_grid = {\n            'max_depth': [None, 5, 10, 20],\n            'min_samples_split': [2, 5, 10],\n            'min_samples_leaf': [1, 2, 4]\n        }\n\n        test_cases.append((X, y, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_32", "library": "sklearn", "code_problem": "You are tasked with implementing a function that applies various normalization transformations to a given single feature dataset for both training and testing. The function should utilize different transformation techniques based on the characteristics of the input data.\n\nFunction signature:\n```python\ndef normal_transformations(single_feature_train_data, single_feature_test_data):\n```\n\nConstant used in the main code:\n- The constant `nmin` is defined as `np.nanmin`, which is used to compute the minimum value of the input data while ignoring NaN values.\n\nInput format:\n- The function accepts two inputs:\n  - `single_feature_train_data`: A 1D or 2D array-like structure containing the training data for a single feature.\n  - `single_feature_test_data`: A 1D or 2D array-like structure containing the testing data for the same single feature.\n\nOutput format:\n- The function returns a list of transformed datasets, where each element corresponds to the transformed version of the `single_feature_test_data` using the different normalization techniques applied. Each transformed dataset is in the same format as the input datasets.\n\n**Input:**\n```python\nsingle_feature_train_data = np.array([[ 5.1], [ 6.2], [ 7.3], [ 8.4], [ 9.5], [ 10.6], [ 11.7], [ 12.8], [ 13.9], [ 14.0]])\nsingle_feature_test_data = np.array([[ 5.5], [ 6.6], [ 7.7], [ 8.8], [ 9.9]])\n```\n\n**Output:**\n```python\n[array([[-1.74601652],\n       [-1.02995676],\n       [-0.63526971],\n       [-0.32197089],\n       [-0.03798835]]), \n array([[-1.48117221],\n       [-1.1116905 ],\n       [-0.74384055],\n       [-0.37740895],\n       [-0.01223118]]), \n array([[-1.48658133],\n       [-1.11166665],\n       [-0.74047428],\n       [-0.37243899],\n       [-0.00714185]])\n ]\n\n```\n", "ground_truth_code": "from sklearn.preprocessing import QuantileTransformer, PowerTransformer\nfrom sklearn.pipeline import make_pipeline\nfrom sklearn.impute import SimpleImputer\nimport numpy as np\n\n# main code\ndef normal_transformations(single_feature_train_data, single_feature_test_data):\n    normal_transformers = [QuantileTransformer(output_distribution='normal'), PowerTransformer(method='yeo-johnson')]\n    nmin = np.nanmin\n    if nmin(single_feature_train_data) > 0 and nmin(single_feature_test_data) > 0:\n        normal_transformers.append(PowerTransformer(method='box-cox'))\n    output = []\n    for transformer in normal_transformers:\n        pipe = make_pipeline(SimpleImputer(strategy='median'), transformer)\n        pipe.fit(single_feature_train_data)\n        output.append(pipe.transform(single_feature_test_data))\n    return output\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        train_size = np.random.randint(10, 1000)\n        test_size = np.random.randint(10, 500)\n\n        include_nans = np.random.choice([True, False], p=[0.2, 0.8])\n\n        if np.random.rand() < 0.5:\n            single_feature_train_data = np.abs(np.random.randn(train_size, 1) * 10 + 5)\n            single_feature_test_data = np.abs(np.random.randn(test_size, 1) * 10 + 5)\n        else:\n            single_feature_train_data = np.random.randn(train_size, 1) * 10\n            single_feature_test_data = np.random.randn(test_size, 1) * 10\n\n        if include_nans:\n            nan_indices_train = np.random.choice(train_size, size=train_size // 10, replace=False)\n            nan_indices_test = np.random.choice(test_size, size=test_size // 10, replace=False)\n            single_feature_train_data[nan_indices_train] = np.nan\n            single_feature_test_data[nan_indices_test] = np.nan\n\n        test_cases.append((single_feature_train_data, single_feature_test_data))\n\n    return test_cases"}
{"problem_id": "sklearn_33", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a Support Vector Classifier (SVC) using grid search. The function will take in training and testing datasets along with a dictionary of hyperparameters to search over. The goal is to find the best model based on the provided hyperparameters and use it to make predictions on the test dataset.\n\nFunction signature:\n```python\ndef test_grid_search_one_grid_point(X_train, y_train, X_test, param_dict):\n```\n\nConstant used in the main code:\n- `gamma='auto'`: This constant is used to set the gamma parameter of the SVC to 'auto', which means that the value of gamma will be set to 1/n_features.\n\nInput format:\n- `X_train`: A 2D array-like structure containing the training feature data.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `X_test`: A 2D array-like structure containing the test feature data.\n- `param_dict`: A dictionary where keys are hyperparameter names and values are lists of settings to be tested.\n\nOutput format:\n- The function returns a 1D array-like structure containing the predicted labels for the test dataset.\n\nInput:\n```python\nX_train = np.array([\n    [0.5, -1.2],\n    [1.5, 2.3],\n    [-0.3, 0.8],\n    [1.0, -0.5],\n    [0.2, 1.5],\n    [1.1, 0.9],\n    [1.3, 1.2],\n    [0.9, -0.3],\n    [1.0, 1.0],\n    [0.8, 0.2]\n])\ny_train = np.array([0, 1, 0, 1, 0, 1, 1, 0, 1, 0])\nX_test = np.array([[0.1, -0.5], [1.2, 1.0]])\nparam_dict = {\"C\": [2.5], \"kernel\": [\"rbf\"], \"degree\": [3]}\n```\n\nOutput:\n```python\npredictions = np.array([0, 1])\n```", "ground_truth_code": "from sklearn.svm import SVC\nfrom sklearn.model_selection import GridSearchCV\n\n# main code\ndef test_grid_search_one_grid_point(X_train, y_train, X_test, param_dict):\n    clf = SVC(gamma='auto')\n    cv = GridSearchCV(clf, param_dict)\n    cv.fit(X_train, y_train)\n    best_model = cv.best_estimator_\n    predictions = best_model.predict(X_test)\n\n    return predictions", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_train_samples = np.random.randint(10, 100)\n        num_test_samples = np.random.randint(5, 50)\n        num_features = np.random.randint(2, 20)\n\n        X_train = np.random.randn(num_train_samples, num_features)\n        y_train = np.random.randint(0, 2, size=num_train_samples)\n        X_test = np.random.randn(num_test_samples, num_features)\n\n        param_dict = {\"C\": [np.random.uniform(0.1, 10)], \"kernel\": [np.random.choice([\"linear\", \"rbf\", \"poly\"])],\n                      \"degree\": [np.random.randint(2, 5)]}\n\n        test_cases.append((X_train, y_train, X_test, param_dict))\n\n    return test_cases"}
{"problem_id": "sklearn_34", "library": "sklearn", "code_problem": "You are tasked with implementing a function that utilizes a machine learning model to classify data based on provided training and testing datasets. The function will employ a grid search to optimize the hyperparameters of a linear support vector classifier (SVC) and return the most frequent prediction from the test set.\n\nFunction signature:\n```python\ndef test_refit_callable(X_train, y_train, X_test, param_grid):\n```\n\nIn this function, the following constant is used:\n- `class_weight='balanced'`: This constant is used in the `LinearSVC` to automatically adjust weights inversely proportional to class frequencies in the input data.\n\nInput format:\n- `X_train`: A 2D array-like structure containing the training features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `X_test`: A 2D array-like structure containing the test features.\n- `param_grid`: A dictionary or list of dictionaries containing the hyperparameters to be tested in the grid search.\n\nOutput format:\n- The function returns a single value representing the most frequent predicted class from the test dataset.\n\n", "ground_truth_code": "from sklearn.model_selection import GridSearchCV\nfrom sklearn.svm import LinearSVC\nimport numpy as np\nfrom scipy.stats import mode\n\n# main code\ndef test_refit_callable(X_train, y_train, X_test, param_grid):\n    def refit_callable(cv_results):\n        return np.argmax(cv_results['mean_test_score'])  # Select best model\n\n    clf = GridSearchCV(\n        LinearSVC(class_weight='balanced'),\n        param_grid,\n        scoring='precision',\n        refit=refit_callable\n    )\n\n    clf.fit(X_train, y_train)\n    predictions = clf.predict(X_test)\n    mode_prediction = mode(predictions, keepdims=False).mode\n\n    return mode_prediction\n", "test_script": "import numpy as np\nfrom sklearn.datasets import make_classification\nfrom sklearn.model_selection import train_test_split\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X, y = make_classification(n_samples=100, n_features=20, random_state=np.random.randint(1000))\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n        param_grid = {'C': np.logspace(-3, 3, num=5)}\n\n        test_cases.append((X_train, y_train, X_test, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_35", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various classification metrics based on the true labels, predicted labels, and predicted probabilities of a binary classification model. The function will return a DataFrame containing these metrics for further analysis.\n\nFunction Signature:\n```python\ndef classification_scores(y_test, y_predict, y_prob):\n```\n\nConstant Used:\n- The function utilizes constants from the `sklearn.metrics` library to compute various metrics.\n\nInput Format:\n- The function accepts three parameters: `y_test`, `y_predict`, and `y_prob`, which should be lists or arrays of the same length.\n\nOutput Format:\n- The function returns a pandas DataFrame with two columns: the index containing the names of the metrics and a single column labeled 'Metrics' containing the corresponding values.\n\nInput:\n```python\ny_test = np.array([1, 0, 1, 1, 0, 0, 1, 0, 0, 1])\ny_predict = np.array([1, 0, 1, 0, 0, 1, 1, 0, 0, 0])\ny_prob = np.array([0.9, 0.1, 0.8, 0.4, 0.2, 0.7, 0.6, 0.3, 0.1, 0.5])\n```\n\nOutput:\n```\n                                         Metrics\nLog Loss                                0.444328\nBrier Score                             0.146000\nAccuracy                                0.700000\nROC AUC Score                           0.880000\nAverage Precision Score                 0.876667\nPrecision (Positive Predictive Value)   0.750000\nFalse Positive Rate                     0.200000\nNegative Predictive Value               0.666667\nFalse Negative Rate                     0.400000\nFalse Discovery Rate                    0.250000\nTotal Samples                          10.000000\nPositive Class Samples                  5.000000\nNegative Class Samples                  5.000000\nPredicted Positive Cases                4.000000\nCorrectly Predicted Positives (TP)      3.000000\nIncorrectly Predicted Positives (FP)    1.000000\nPredicted Negative Cases                6.000000\nCorrectly Predicted Negatives (TN)      4.000000\nIncorrectly Predicted Negatives (FN)    2.000000\n```", "ground_truth_code": "from sklearn.metrics import (\n    confusion_matrix, log_loss, brier_score_loss, accuracy_score,\n    roc_auc_score, average_precision_score\n)\nimport pandas as pd\n\n# main code\ndef classification_scores(y_test, y_predict, y_prob):\n    confusion_mat = confusion_matrix(y_test, y_predict)\n    TN, FP = confusion_mat[0]\n    FN, TP = confusion_mat[1]\n\n    total = TN + FP + FN + TP\n    precision = TP / (TP + FP) if (TP + FP) else 0\n    negative_predictive_value = TN / (TN + FN) if (TN + FN) else 0\n    false_positive_rate = FP / (FP + TN) if (FP + TN) else 0\n    false_negative_rate = FN / (TP + FN) if (TP + FN) else 0\n    false_discovery_rate = FP / (TP + FP) if (TP + FP) else 0\n\n    metrics = {\n        'Log Loss': log_loss(y_test, y_prob),\n        'Brier Score': brier_score_loss(y_test, y_prob),\n        'Accuracy': accuracy_score(y_test, y_predict),\n        'ROC AUC Score': roc_auc_score(y_test, y_prob),\n        'Average Precision Score': average_precision_score(y_test, y_prob),\n        'Precision (Positive Predictive Value)': precision,\n        'False Positive Rate': false_positive_rate,\n        'Negative Predictive Value': negative_predictive_value,\n        'False Negative Rate': false_negative_rate,\n        'False Discovery Rate': false_discovery_rate,\n        'Total Samples': total,\n        'Positive Class Samples': TP + FN,\n        'Negative Class Samples': TN + FP,\n        'Predicted Positive Cases': TP + FP,\n        'Correctly Predicted Positives (TP)': TP,\n        'Incorrectly Predicted Positives (FP)': FP,\n        'Predicted Negative Cases': TN + FN,\n        'Correctly Predicted Negatives (TN)': TN,\n        'Incorrectly Predicted Negatives (FN)': FN\n    }\n\n    df_exec = pd.DataFrame.from_dict(metrics, orient='index', columns=['Metrics'])\n    return df_exec", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 1000)\n        y_test = np.random.randint(0, 2, size=num_samples)\n        y_predict = np.random.randint(0, 2, size=num_samples)\n        y_prob = np.random.rand(num_samples)\n\n        test_cases.append((y_test, y_predict, y_prob))\n\n    return test_cases"}
{"problem_id": "sklearn_36", "library": "sklearn", "code_problem": "You are tasked with implementing a function that computes various performance metrics for a binary classification model. The function will take two lists as input: the true labels and the predicted labels from the model. It will return a dictionary containing the accuracy, precision, recall, F1 score, confusion matrix, and ROC AUC score.\n\nFunction signature:\n```python\ndef compute_metrics(y_true, y_pred):\n```\n\nIn the main code, the following constant is used:\n- No specific constant is defined in the code.\n\nInput format:\n- The function takes two lists as input:\n  - `y_true`: A list of true binary labels (0s and 1s).\n  - `y_pred`: A list of predicted binary labels (0s and 1s).\n\nOutput format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - 'accuracy': A float representing the accuracy of the predictions.\n  - 'precision': A float representing the precision of the predictions.\n  - 'recall': A float representing the recall of the predictions.\n  - 'f1_score': A float representing the F1 score of the predictions.\n  - 'confusion_matrix': A 2x2 array representing the confusion matrix.\n  - 'roc_auc_score': A float representing the ROC AUC score of the predictions.\n\nInput:\n```python\ny_true = [1, 0, 1, 1, 0, 1, 0, 0, 1, 0]\ny_pred = [1, 0, 0, 1, 0, 1, 1, 0, 1, 0]\n```\n\nOutput:\n```python\n{\n    'accuracy': 0.8, \n    'precision': 0.8, \n    'recall': 0.8, \n    'f1_score': 0.8, \n    'confusion_matrix': array([[4, 1], [1, 4]]), \n    'roc_auc_score': 0.8\n}\n```", "ground_truth_code": "from sklearn.metrics import (\n    accuracy_score, precision_score, recall_score,\n    f1_score, confusion_matrix, roc_auc_score\n)\n\n# main code\ndef compute_metrics(y_true, y_pred):\n    metrics = {\n        'accuracy': accuracy_score(y_true, y_pred),\n        'precision': precision_score(y_true, y_pred),\n        'recall': recall_score(y_true, y_pred),\n        'f1_score': f1_score(y_true, y_pred),\n        'confusion_matrix': confusion_matrix(y_true, y_pred),\n        'roc_auc_score': roc_auc_score(y_true, y_pred)\n    }\n    return metrics", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 1001)\n        y_true = np.random.randint(0, 2, size=num_samples)\n        y_pred = np.random.randint(0, 2, size=num_samples)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n"}
{"problem_id": "sklearn_37", "library": "sklearn", "code_problem": "You are tasked with implementing a function that fits a Support Vector Machine (SVM) model to a given dataset and evaluates its performance using cross-validation and permutation testing. The function should also allow for optional normalization of the input features and dimensionality reduction using Principal Component Analysis (PCA) if the number of features exceeds a specified threshold.\n\nFunction signature:\n```python\ndef fit_svm(X, y, use_x_normalization, kernel, n_splits, n_permutations):\n```\n\nConstants used in the main code:\n- The constant used for PCA is `20`, which indicates the maximum number of components to keep if the number of features exceeds this value.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., list of lists, NumPy array) where each row represents a sample and each column represents a feature.\n- `y`: A 1D array-like structure (e.g., list, NumPy array) where each element corresponds to the label of the respective sample in `X`.\n- `use_x_normalization`: A boolean value (True or False).\n- `kernel`: A string representing the SVM kernel type.\n- `n_splits`: An integer for the number of cross-validation splits.\n- `n_permutations`: An integer for the number of permutations in the permutation test.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `\"train_accuracy\"`: A float representing the mean training accuracy.\n  - `\"validation_accuracy\"`: A float representing the mean validation accuracy.\n  - `\"permutation_test_score\"`: A float representing the score from the permutation test.\n  - `\"p_value\"`: A float representing the p-value from the permutation test.\n\nInput:\n```python\nX = np.array([\n    [0.1, 0.2, 0.3],\n    [0.15, 0.25, 0.35],\n    [0.4, 0.5, 0.6],\n    [0.45, 0.55, 0.65],\n    [0.7, 0.8, 0.9],\n    [0.75, 0.85, 0.95],\n    [1.0, 1.1, 1.2],\n    [1.05, 1.15, 1.25],\n    [1.3, 1.4, 1.5],\n    [1.35, 1.45, 1.55]\n])\ny = np.array([0, 0, 0, 0, 1, 1, 1, 1, 1, 1]) \n\nuse_x_normalization = True\nkernel = \"linear\"\nn_splits = 2\nn_permutations = 20\n```\n\nOutput:\n```python\n{'train_accuracy': 100.0, 'validation_accuracy': 80.0, 'permutation_test_score': 1.0, 'p_value': 0.09090909090909091}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import StratifiedKFold, permutation_test_score\nfrom sklearn.svm import SVC\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.decomposition import PCA\n\n# main code\ndef fit_svm(X, y, use_x_normalization, kernel, n_splits, n_permutations):\n    if use_x_normalization:\n        scaler = StandardScaler()\n        X = scaler.fit_transform(X)\n\n        if X.shape[1] > 20:\n            pca = PCA(n_components=20)\n            X = pca.fit_transform(X)\n\n    train_scores = []\n    val_scores = []\n    skf = StratifiedKFold(n_splits=n_splits, shuffle=True)\n\n    for train_index, val_index in skf.split(X, y):\n        X_train, X_val = X[train_index], X[val_index]\n        y_train, y_val = y[train_index], y[val_index]\n\n        clf = SVC(kernel=kernel if kernel else \"rbf\", cache_size=100)\n        clf.fit(X_train, y_train)\n\n        adjusted_n_permutations = min(n_permutations, max(10, len(y_train) // 10))\n\n        score, permutation_scores, pvalue = permutation_test_score(\n            clf, X_train, y_train, scoring=\"accuracy\", cv=skf,\n            n_permutations=adjusted_n_permutations, n_jobs=-1\n        )\n\n        train_scores.append(clf.score(X_train, y_train) * 100)\n        val_scores.append(clf.score(X_val, y_val) * 100)\n\n    return {\n        \"train_accuracy\": np.mean(train_scores),\n        \"validation_accuracy\": np.mean(val_scores),\n        \"permutation_test_score\": score,\n        \"p_value\": pvalue\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    kernels = [\"linear\", \"poly\", \"rbf\", \"sigmoid\"]\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 300)\n        num_features = np.random.randint(5, 20)\n\n        X = np.random.randn(num_samples, num_features)\n        y = np.random.randint(0, 2, size=num_samples)\n        use_x_normalization = np.random.choice([True, False])\n        kernel = np.random.choice(kernels)\n        n_splits = np.random.randint(2, min(5, num_samples))\n        n_permutations = np.random.randint(10, 100)\n\n        test_cases.append((X, y, use_x_normalization, kernel, n_splits, n_permutations))\n\n    return test_cases"}
{"problem_id": "sklearn_38", "library": "sklearn", "code_problem": "You are tasked with implementing a function that trains a Support Vector Machine (SVM) classifier on a given dataset and evaluates its performance. The function should handle cases where the dataset may not be suitable for splitting into training and testing sets. \n\nFunction signature:\n```python\ndef train_model(X, y):\n```\n\n### Constants:\n- The constant used in the main code is `test_size=0.2`, which indicates that 20% of the dataset will be used for testing if the dataset is suitable for splitting.\n\n### Input and Output Format:\n- **Input Format**: \n  - `X`: A 2D array-like structure of shape (n_samples, n_features).\n  - `y`: A 1D array-like structure of shape (n_samples,).\n\n- **Output Format**: \n  - A tuple containing:\n    - `y_pred`: A 1D array of predicted labels or `None`.\n    - `accuracy`: A float representing the accuracy score or `None`.\n    - `confusion_mtx`: A 2D array representing the confusion matrix or `None`.\n\nInput:\n```python\nX = np.array([[ 0.5, -1.2,  0.3],\n              [ 1.5,  0.4, -0.8],\n              [-0.3,  0.1,  1.2],\n              [ 0.7, -0.5,  0.9],\n              [ 1.0,  1.1, -1.0],\n              [-1.5,  0.3,  0.4],\n              [ 0.2, -0.2,  0.5],\n              [ 0.9,  0.8, -0.6],\n              [ 1.1,  0.2, -0.4],\n              [ 0.3, -1.0,  0.6]])\ny = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1])\n```\n\nOutput:\n```python\n(y_pred, accuracy, confusion_mtx) = (array([1, 0]), 0.0, array([[0, 1], [1, 0]]))\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.svm import SVC\nfrom sklearn.metrics import accuracy_score, confusion_matrix\n\n# main code\ndef train_model(X, y):\n    class_counts = np.bincount(y)\n    if np.min(class_counts) < 2 or len(y) * 0.2 < len(np.unique(y)):\n        (X_train, y_train) = (X, y)\n        (X_test, y_test) = (None, None)\n    else:\n        (X_train, X_test, y_train, y_test) = train_test_split(X, y, test_size=0.2, stratify=y)\n    scaler = StandardScaler()\n    X_train_scaled = scaler.fit_transform(X_train)\n    svm_classifier = SVC(kernel='linear')\n    svm_classifier.fit(X_train_scaled, y_train)\n    if X_test is not None:\n        X_test_scaled = scaler.transform(X_test)\n        y_pred = svm_classifier.predict(X_test_scaled)\n        accuracy = accuracy_score(y_test, y_pred)\n        confusion_mtx = confusion_matrix(y_test, y_pred)\n        return (y_pred, accuracy, confusion_mtx)\n    return (None, None, None)\n", "test_script": "import numpy as np\nfrom sklearn.utils import shuffle\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        m = np.random.randint(5, 100)\n        d = np.random.randint(2, 50)\n        X = np.random.randn(m, d)\n        num_classes = np.random.randint(2, min(5, m // 2) + 1)\n        y = np.random.randint(0, num_classes, size=m)\n        X, y = shuffle(X, y)\n        test_cases.append((X, y))\n    return test_cases"}
{"problem_id": "sklearn_39", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a predictive model using various metrics. The function will take in a dataset, the true labels for that dataset, a function to predict probabilities, and a threshold for classification. The goal is to compute several performance metrics based on the predictions made by the model.\n\nFunction Signature:\n```python\ndef predict_and_metric(data, label, predict_proba, threshold):\n```\n\nConstant Used:\n- The constant used in the main code is `threshold`, which is a value that determines the cutoff for classifying predicted probabilities into binary outcomes.\n\nInput Format:\n- `data`: A dataset for which predictions are to be made.\n- `label`: The true labels corresponding to the dataset.\n- `predict_proba`: A function that takes `data` as input and returns predicted probabilities.\n- `threshold`: A float value representing the threshold for classifying predicted probabilities.\n\nOutput Format:\n- The function returns a dictionary containing the following keys and their corresponding values:\n  - 'threshold': The threshold used for classification.\n  - 'AUC': The computed Area Under the ROC Curve.\n  - 'ACC': The computed accuracy score.\n  - 'Recall': The computed recall score.\n  - 'Precision': The computed precision score.\n  - 'F1-score': The computed F1-score.\n\n**Input:**\n```python\nimport numpy as np\ndata = np.array([[0.1, 0.2, 0.3],\n                 [0.4, 0.5, 0.6],\n                 [0.7, 0.8, 0.9]])\nlabel = np.array([0, 1, 1])\nthreshold = 0.5\n\n# Mock model for predict_proba\nclass MockModel:\n    def predict_proba(self, data):\n        return np.array([[0.3, 0.7],\n                         [0.2, 0.8],\n                         [0.1, 0.9]])\n\nmodel = MockModel()\n\n# Wrap predict_proba so it becomes a callable with only one argument: data\npredict_proba = lambda data: predict_proba(data, model, data_process)\n```\n\n**Output:**\n```python\n{'threshold': 0.5, 'AUC': 0.5, 'ACC': 0.6666666666666666, 'Recall': 1.0, 'Precision': 0.6666666666666666, 'F1-score': 0.8}\n```", "ground_truth_code": "from sklearn import metrics\n\n\ndef data_process(data):\n    return data\n\n\ndef predict_proba(data, _model, data_process):\n    if _model is not None:\n        data = data_process(data)\n        return _model.predict_proba(data)\n    return None\n\n\n# main code\ndef predict_and_metric(data, label, predict_proba, threshold):\n    y_pred = predict_proba(data)[:, 1] if predict_proba is not None else []\n    y_pred_binary = (y_pred >= threshold).astype(int)\n    metrics_result = {\n        'threshold': threshold,\n        'AUC': metrics.roc_auc_score(label, y_pred_binary),\n        'ACC': metrics.accuracy_score(label, y_pred_binary),\n        'Recall': metrics.recall_score(label, y_pred_binary),\n        'Precision': metrics.precision_score(label, y_pred_binary),\n        'F1-score': metrics.f1_score(label, y_pred_binary),\n    }\n\n\n    return metrics_result", "test_script": "import numpy as np\nfrom sklearn.linear_model import LogisticRegression\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(10, 100)\n        data = np.random.rand(num_samples, num_features)\n        label = np.random.randint(0, 2, size=(num_samples,))\n\n        model = LogisticRegression()\n        model.fit(data, label)\n\n        expected_features = num_features\n\n        def mock_predict_proba(new_data):\n            current_features = new_data.shape[1]\n            if current_features > expected_features:\n                new_data = new_data[:, :expected_features]\n            elif current_features < expected_features:\n                pad_width = expected_features - current_features\n                new_data = np.hstack((new_data, np.zeros((new_data.shape[0], pad_width))))\n\n            return model.predict_proba(new_data)\n        threshold = round(np.random.uniform(0, 1), 1)\n\n        test_cases.append((data, label, mock_predict_proba, threshold))\n\n    return test_cases"}
{"problem_id": "sklearn_40", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various F1 scores based on predictions made for a set of documents. The function will utilize multi-label binarization to handle the classification of documents into multiple categories. The function signature is as follows:\n\n```python\ndef calc_f1(predictions, document_ids, class_labels, data_mappings):\n```\n\n### Constants Used:\n- The constant used in the main code is the string values 'micro', 'macro', and 'samples' which are used as averaging methods in the F1 score calculation.\n\n### Input and Output Format:\n- **Input Format**:\n  - `predictions`: List of lists of integers.\n  - `document_ids`: List of integers.\n  - `class_labels`: List of strings.\n  - `data_mappings`: Dictionary containing various mappings and data structures.\n\n- **Output Format**:\n  - Returns a tuple of three tuples, each containing three float values representing the F1 scores (micro, macro, samples).\n\n**Input:**\n```python\npredictions = [[0, 1], [1, 2], [2], [0, 2]]\ndocument_ids = ['doc_0', 'doc_1', 'doc_2', 'doc_3']\nclass_labels = [0, 1, 2]\ndata_mappings = {\n    \"document_data\": {\n        'doc_0': {\"class_idx\": [0, 1]},\n        'doc_1': {\"class_idx\": [1]},\n        'doc_2': {\"class_idx\": [2]},\n        'doc_3': {\"class_idx\": [0, 2]}\n    },\n    \"ancestor_data\": {\n        'doc_0': {\"class_idx\": [0]},\n        'doc_1': {\"class_idx\": [1]},\n        'doc_2': {\"class_idx\": [2]},\n        'doc_3': {\"class_idx\": [0, 1]}\n    },\n    \"category_to_aliases\": {\n        0: [1],\n        1: [0, 2],\n        2: [1]\n    },\n    \"id_to_name\": {0: 'class_0', 1: 'class_1', 2: 'class_2'},\n    \"name_to_id\": {'class_0': 0, 'class_1': 1, 'class_2': 2},\n    \"index_to_id\": {0: 0, 1: 1, 2: 2},\n    \"id_to_index\": {0: 0, 1: 1, 2: 2}\n}\n```\n\n**Output:**\n```python\nf1_base = (0.9230769230769231, 0.9333333333333332, 0.9166666666666666)\nf1_ancestor = (0.6666666666666666, 0.6666666666666666, 0.7083333333333333)\nf1_expanded = (0.6666666666666666, 0.6666666666666666, 0.7083333333333333)\n```\n", "ground_truth_code": "from sklearn.preprocessing import MultiLabelBinarizer\nfrom scipy import sparse\nfrom sklearn.metrics import f1_score\n\n# main code\ndef calc_f1(predictions, document_ids, class_labels, data_mappings):\n    label_binarizer = MultiLabelBinarizer(classes=class_labels)\n\n    ancestor_data = data_mappings.get(\"ancestor_data\")\n    document_data = data_mappings[\"document_data\"]\n    category_to_aliases = data_mappings[\"category_to_aliases\"]\n    id_to_name = data_mappings[\"id_to_name\"]\n    name_to_id = data_mappings[\"name_to_id\"]\n    index_to_id = data_mappings[\"index_to_id\"]\n    id_to_index = data_mappings[\"id_to_index\"]\n\n    true_labels = [document_data[doc]['class_idx'] for doc in document_ids]\n    ancestor_labels = [ancestor_data[doc]['class_idx'] for doc in document_ids] if ancestor_data else true_labels\n\n    expanded_predictions = [\n        pred + [id_to_index[name_to_id[term]] for term in\n                category_to_aliases.get(id_to_name.get(index_to_id.get(id, \"\"), \"\"), [])]\n        for pred in predictions\n    ]\n\n    def compute_f1(true, pred):\n        true_matrix = sparse.csr_matrix(label_binarizer.fit_transform(true))\n        pred_matrix = sparse.csr_matrix(label_binarizer.transform(pred))\n        return (\n            f1_score(true_matrix, pred_matrix, average='micro'),\n            f1_score(true_matrix, pred_matrix, average='macro'),\n            f1_score(true_matrix, pred_matrix, average='samples')\n        )\n\n    f1_base = compute_f1(true_labels, predictions)\n    f1_ancestor = compute_f1(ancestor_labels, predictions)\n    f1_expanded = compute_f1(ancestor_labels, expanded_predictions)\n\n    return f1_base, f1_ancestor, f1_expanded", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_classes = random.randint(5, 20)\n        num_documents = random.randint(10, 50)\n        class_labels = list(range(num_classes))\n        document_ids = [f'doc_{i}' for i in range(num_documents)]\n        document_data = {\n            doc_id: {\"class_idx\": random.sample(class_labels, random.randint(1, min(3, num_classes)))}\n            for doc_id in document_ids\n        }\n        ancestor_data = {\n            doc_id: {\"class_idx\": random.sample(class_labels, random.randint(1, min(3, num_classes)))}\n            for doc_id in document_ids\n        } if random.random() > 0.5 else None\n        category_to_aliases = {\n            i: random.sample(range(num_classes), random.randint(0, 3)) for i in class_labels\n        }\n        id_to_name = {i: f'class_{i}' for i in class_labels}\n        name_to_id = {v: k for k, v in id_to_name.items()}\n        index_to_id = {i: i for i in class_labels}\n        id_to_index = {i: i for i in class_labels}\n        predictions = [random.sample(class_labels, random.randint(1, min(3, num_classes))) for _ in range(\n                num_documents)]\n        data_mappings = {\n            \"document_data\": document_data,\n            \"ancestor_data\": ancestor_data,\n            \"category_to_aliases\": category_to_aliases,\n            \"id_to_name\": id_to_name,\n            \"name_to_id\": name_to_id,\n            \"index_to_id\": index_to_id,\n            \"id_to_index\": id_to_index,\n        }\n        test_cases.append((predictions, document_ids, class_labels, data_mappings))\n    return test_cases\n"}
{"problem_id": "sklearn_41", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of different regression models on a given dataset. The function will take training and testing datasets as input, apply three different regression models, and return the root mean squared error (RMSE) for each model.\n\nFunction Signature:\n```python\ndef machine_regression(X_train, y_train, X_test, y_test):\n```\n\nConstant used in the main code:\n- The constant `C=0.8` is used in the Support Vector Machine (SVM) model.\n\nInput Format:\n- `X_train`: A 2D array-like structure containing the training features.\n- `y_train`: A 1D or 2D array-like structure containing the training target values.\n- `X_test`: A 2D array-like structure containing the testing features.\n- `y_test`: A 1D or 2D array-like structure containing the testing target values.\n\nOutput Format:\n- A Pandas DataFrame with two columns: \"Model\" (the name of the regression model) and \"RMSE\" (the root mean squared error for that model). If no models were evaluated, an empty DataFrame is returned.\n\nInput:\n```python\nX_train = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.3, 0.4], [0.5, 0.6, 0.7]])\ny_train = np.array([[1], [2], [3], [2], [3]])\nX_test = np.array([[0.15, 0.25, 0.35], [0.45, 0.55, 0.65]])\ny_test = np.array([[1.5], [2.5]])\n```\n\nOutput:\n```python\n     Model      RMSE\n0   GCN+rf  0.155724\n1  GCN+svm  0.185124\n2  GCN+knn  0.538516\n```", "ground_truth_code": "from sklearn.ensemble import RandomForestRegressor\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn import svm\nfrom sklearn.neighbors import KNeighborsRegressor\nimport pandas as pd\nimport numpy as np\n\n# main code\ndef machine_regression(X_train, y_train, X_test, y_test):\n    scores = []\n\n    if len(y_train.shape) == 3:\n        y_train, y_test = y_train.squeeze(-1), y_test.squeeze(-1)\n\n    if y_test.shape[-1] == 1:\n        models = {\n            'GCN+rf': RandomForestRegressor(),\n            'GCN+svm': svm.SVR(C=0.8, cache_size=200, kernel='rbf', degree=3, epsilon=0.2),\n            'GCN+knn': KNeighborsRegressor(n_neighbors=5)\n        }\n\n        for model_name, model in models.items():\n            model.fit(X_train, y_train.ravel())\n            y_pred = model.predict(X_test)\n            rmse = mean_squared_error(y_test.astype(float), y_pred) ** 0.5\n            scores.append([model_name, rmse])\n\n        return pd.DataFrame(scores, columns=[\"Model\", \"RMSE\"])\n\n    results = {\"GCN+rf\": [], \"GCN+svm\": [], \"GCN+knn\": []}\n\n    for i in range(y_test.shape[1]):\n        if any(float(max(y[i])) == 0 for y in (y_train, y_test)):\n            continue\n\n        models = {\n            'GCN+rf': RandomForestRegressor(),\n            'GCN+svm': svm.SVR(C=0.8, cache_size=200, kernel='rbf', degree=3, epsilon=0.2),\n            'GCN+knn': KNeighborsRegressor(n_neighbors=5)\n        }\n\n        for model_name, model in models.items():\n            model.fit(X_train, y_train[:, i])\n            y_pred = model.predict(X_test)\n            rmse = mean_squared_error(y_test[:, i], y_pred) ** 0.5\n            results[model_name].append(rmse)\n\n    for model_name, rmse_values in results.items():\n        if rmse_values:\n            scores.append([model_name, np.mean(rmse_values)])\n\n    return pd.DataFrame(scores, columns=[\"Model\", \"RMSE\"]) if scores else pd.DataFrame([])\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_train_samples = np.random.randint(50, 200)\n        num_test_samples = np.random.randint(10, 50)\n        num_features = np.random.randint(5, 50)\n        num_targets = np.random.randint(1, 5)\n\n        X_train = np.random.rand(num_train_samples, num_features)\n        X_test = np.random.rand(num_test_samples, num_features)\n        if np.random.rand() > 0.5:\n            y_train = np.random.rand(num_train_samples, 1)\n            y_test = np.random.rand(num_test_samples, 1)\n        else:\n            y_train = np.random.rand(num_train_samples, num_targets, 1)\n            y_test = np.random.rand(num_test_samples, num_targets, 1)\n\n        test_cases.append((X_train, y_train, X_test, y_test))\n\n    return test_cases"}
{"problem_id": "sklearn_42", "library": "sklearn", "code_problem": "You are tasked with creating a machine learning model that can handle both numerical and categorical features for classification tasks. The model should preprocess the data appropriately and utilize a Random Forest Classifier for predictions. \n\nThe main function signature is as follows:\n```python\ndef get_model(params, numerical_features, categorical_features):\n```\n\nIn this function, the following constant is used:\n- `random_state=0`: This constant is used to ensure reproducibility of the results by setting a seed for the random number generator in the Random Forest Classifier.\n\nInput format:\n- `params`: A dictionary of hyperparameters for the Random Forest Classifier.\n- `numerical_features`: A list of strings representing the names of numerical features.\n- `categorical_features`: A list of strings representing the names of categorical features.\n\nOutput format:\n- The function returns a scikit-learn `Pipeline` object that includes the preprocessing steps and the Random Forest Classifier, configured with the specified parameters if provided.\n\n**Input:**\n```python\nparams = {\n    'n_estimators': 150,\n    'max_depth': 10,\n    'min_samples_split': 5,\n    'min_samples_leaf': 2,\n    'max_features': 'sqrt',\n}\nnumerical_features = ['num_0', 'num_1', 'num_2']\ncategorical_features = ['cat_0', 'cat_1']\n```\n\n**Output:**\n```python\nPipeline(steps=[('preprocessor',\n                 ColumnTransformer(transformers=[('num', StandardScaler(),\n                                                  ['num_0', 'num_1', 'num_2']),\n                                                 ('cat',\n                                                  OneHotEncoder(handle_unknown='ignore'),\n                                                  ['cat_0', 'cat_1'])])),\n                ('classifier',\n                 RandomForestClassifier(max_depth=10, min_samples_leaf=2,\n                                        min_samples_split=5, n_estimators=150,\n                                        random_state=0))])\n```", "ground_truth_code": "from sklearn.preprocessing import StandardScaler, OneHotEncoder\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.ensemble import RandomForestClassifier\n\n# main code\ndef get_model(params, numerical_features, categorical_features):\n\n    numeric_preprocessor = StandardScaler()\n    categorical_preprocessor = OneHotEncoder(handle_unknown='ignore')\n\n    preprocessor = ColumnTransformer(\n        transformers=[\n            ('num', numeric_preprocessor, numerical_features),\n            ('cat', categorical_preprocessor, categorical_features)\n        ]\n    )\n\n    model = Pipeline(steps=[\n        ('preprocessor', preprocessor),\n        ('classifier', RandomForestClassifier(random_state=0))\n    ])\n\n    return model.set_params(**{f\"classifier__{key}\": value for key, value in params.items()}) if params else model\n", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        params = {\n            'n_estimators': random.randint(10, 200),\n            'max_depth': random.choice([None, random.randint(3, 20)]),\n            'min_samples_split': random.randint(2, 10),\n            'min_samples_leaf': random.randint(1, 10),\n            'max_features': random.choice(['sqrt', 'log2', None]),\n        }\n\n        num_numerical = random.randint(1, 10)\n        num_categorical = random.randint(1, 10)\n\n        numerical_features = [f'num_{i}' for i in range(num_numerical)]\n        categorical_features = [f'cat_{i}' for i in range(num_categorical)]\n\n        test_cases.append((params, numerical_features, categorical_features))\n\n    return test_cases\n"}
{"problem_id": "sklearn_43", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of clustering algorithms by comparing the predicted clusters against the ground truth clusters. The function should compute several clustering validation metrics, including the adjusted Rand index, homogeneity score, purity score, adjusted mutual information score, and Fowlkes-Mallows score.\n\nFunction Signature:\n```python\ndef externalValidation(truthClusters, predictedClusters):\n```\n\nConstant Used:\n- The function utilizes the `numpy` library for numerical operations and the `sklearn` library for various clustering metrics.\n\nInput Format:\n- The function takes two inputs:\n  - `truthClusters`: A list or array-like structure containing the true cluster labels for each sample.\n  - `predictedClusters`: A list or array-like structure containing the predicted cluster labels for each sample.\n\nOutput Format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - `'rand_index'`: A float representing the adjusted Rand index.\n  - `'homogeneity_score'`: A float representing the homogeneity score.\n  - `'purity_score'`: A float representing the purity score.\n  - `'adjusted_mutual_info_score'`: A float representing the adjusted mutual information score.\n  - `'fowlkes_mallows_score'`: A float representing the Fowlkes-Mallows score.\n\nInput:\n```python\ntruthClusters = np.array([0, 0, 1, 1, 2, 2, 2, 1, 0, 0])\npredictedClusters = np.array([0, 1, 1, 1, 2, 2, 0, 0, 0, 1])\n```\n\nOutput:\n```python\n{\n    'rand_index': 0.05904059040590406, \n    'homogeneity_score': 0.36344274382025715, \n    'purity_score': 0.6, \n    'adjusted_mutual_info_score': 0.13751883986923835, \n    'fowlkes_mallows_score': 0.32025630761017426\n}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn import metrics\nfrom sklearn.metrics.cluster import adjusted_rand_score\n\n# main code\ndef externalValidation(truthClusters, predictedClusters):\n    def purity_score(y_true, y_pred):\n        contingency_matrix = metrics.cluster.contingency_matrix(y_true, y_pred)\n        return np.sum(np.amax(contingency_matrix, axis=0)) / np.sum(contingency_matrix)\n\n    return {\n        'rand_index': adjusted_rand_score(truthClusters, predictedClusters),\n        'homogeneity_score': metrics.homogeneity_score(truthClusters, predictedClusters),\n        'purity_score': purity_score(truthClusters, predictedClusters),\n        'adjusted_mutual_info_score': metrics.adjusted_mutual_info_score(truthClusters, predictedClusters),\n        'fowlkes_mallows_score': metrics.fowlkes_mallows_score(truthClusters, predictedClusters)\n    }", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_clusters = np.random.randint(2, 20)\n\n        truthClusters = np.random.randint(0, num_clusters, size=num_samples)\n        predictedClusters = np.random.randint(0, num_clusters, size=num_samples)\n\n        test_cases.append((truthClusters, predictedClusters))\n    return test_cases\n"}
{"problem_id": "sklearn_44", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a linear support vector classifier (SVC) using both dense and sparse representations of the input data. The function will utilize grid search to find the best regularization parameter (C) for the model and compare the predictions made on the test set using both representations.\n\nFunction signature:\n```python\ndef test_grid_search_sparse(X_, y_, param_grid, train_size):\n```\n\n### Constants:\n- The constant used in the main code is `C`, which represents the best regularization parameter found during the grid search for the dense representation, and `C2`, which represents the best regularization parameter for the sparse representation.\n\n### Input and Output Format:\n- **Input Format**:\n  - `X_`: A 2D array-like structure (e.g., list of lists, NumPy array) representing the feature matrix.\n  - `y_`: A 1D array-like structure (e.g., list, NumPy array) representing the target labels.\n  - `param_grid`: A dictionary where keys are parameter names and values are lists of parameter settings to try.\n  - `train_size`: An integer specifying the number of samples to use for training.\n\n- **Output Format**:\n  - A dictionary containing:\n    - `\"y_pred_dense\"`: Array of predictions for the dense representation.\n    - `\"y_pred_sparse\"`: Array of predictions for the sparse representation.\n    - `\"best_C_dense\"`: Float value of the best regularization parameter for the dense representation.\n    - `\"best_C_sparse\"`: Float value of the best regularization parameter for the sparse representation.\n    - `\"accuracy\"`: Float value representing the accuracy of the predictions.\n\nInput:\n```python\n{\n    \"X_\": array([[ 2.02064166e-01,  4.58807059e-01, -3.21742910e+00,\n                -1.20574106e+00, -1.80913026e+00],\n                 ...,\n               [ 1.44418114e+00, -1.29934110e-01, -8.88020146e-01,\n                -8.24748618e-01, -8.46506594e-01]]),\n    \"y_\": array([0, 0, 1, 0, 0, 0, 0, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1, 1,\n       1, 0, 1, 1, 1, 0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1,\n       0, 0, 0, 1, 0, 0]),\n    \"param_grid\": {'C': array([1.e-03, 1.e+03])}\n    \"train_size\": 35\n}\n```\n\nOutput:\n```python\n{'y_pred_dense': array([1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0]), 'y_pred_sparse': array([1, 0, 0, 1, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 0]), 'best_C_dense': 0.001, 'best_C_sparse': 0.001, 'accuracy': 1.0}\n```", "ground_truth_code": "from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\nimport scipy.sparse as sp\nimport numpy as np\n\n# main code\ndef test_grid_search_sparse(X_, y_, param_grid, train_size):\n\n    clf = LinearSVC()\n    cv = GridSearchCV(clf, param_grid)\n    cv.fit(X_[:train_size], y_[:train_size])\n    y_pred = cv.predict(X_[train_size:])\n    C = cv.best_estimator_.C\n\n    X_ = sp.csr_matrix(X_)\n    clf = LinearSVC()\n    cv = GridSearchCV(clf, param_grid)\n    cv.fit(X_[:train_size].tocoo(), y_[:train_size])\n    y_pred2 = cv.predict(X_[train_size:])\n    C2 = cv.best_estimator_.C\n\n    return {\n        \"y_pred_dense\": y_pred,\n        \"y_pred_sparse\": y_pred2,\n        \"best_C_dense\": C,\n        \"best_C_sparse\": C2,\n        \"accuracy\": np.mean(y_pred == y_pred2)\n    }", "test_script": "from sklearn.datasets import make_classification\nimport numpy as np\nimport scipy.sparse as sp\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n        train_size = int(0.7 * num_samples)\n\n        X, y = make_classification(n_samples=num_samples, n_features=num_features,\n                                   random_state=np.random.randint(10000))\n        param_grid = {'C': np.logspace(-3, 3, num=np.random.randint(2, 10))}\n        if np.random.rand() > 0.5:\n            X = sp.csr_matrix(X)\n\n        test_cases.append((X, y, param_grid, train_size))\n\n    return test_cases"}
{"problem_id": "sklearn_45", "library": "sklearn", "code_problem": "You are tasked with implementing a machine learning model using Support Vector Classification (SVC) from the scikit-learn library. The goal is to optimize the model's hyperparameters using grid search and evaluate its performance based on recall and accuracy metrics.\n\nThe function signature of the main code is:\n```python\ndef model(X, y, param_grid):\n```\n\nIn this function, the following constant is used:\n- `est`: This constant is an instance of the `LinearSVC` class, which is the estimator used for classification.\n\nInput and output format:\n- Input: The function takes three parameters:\n  - `X`: A 2D array-like structure containing the feature set for classification.\n  - `y`: A 1D array-like structure containing the target variable.\n  - `param_grid`: A dictionary or list of dictionaries specifying the hyperparameters to be tuned during the grid search.\n\n- Output: The function returns a 1D array-like structure containing the predicted class labels for the input feature set `X`.\n\nInput:\n```python\nX = np.array([[ 7.86849355e-01, -5.39163052e-01,  2.07494909e+00,\n                     1.33430635e+00, -4.01524442e-01],\n                   ...,\n                   [ 8.42239258e-01,  1.77303320e-01, -1.21549971e+00,\n                    -1.51516370e+00, -5.02957359e-01]])\ny = np.array([1, 0, 0, 0, 0, 1, 1, 0, 1, 1, 1, 0, 0, 1, 0, 0, 0, 1, 0, 0, 0, 1,\n       0, 1, 1, 1, 0, 0, 1, 1, 1, 0, 1, 1, 1, 0, 0, 0, 0, 0, 1, 1, 1, 1,\n       0, 1, 1, 1, 1, 1])\nparam_grid = {'C': [4.440279266184252, 4.844997786166895, 8.034141205725835], 'max_iter': [100, 200, 500]}\n```\n\nOutput:\n```python\narray([0, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1,\n       1, 1, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 1, 0, 1, 1, 0, 1, 0, 0, 1,\n       1, 1, 1, 1, 1, 1])\n```", "ground_truth_code": "from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import recall_score, accuracy_score\n\n# main code\ndef model(X, y, param_grid):\n    def custom_scorer(est, X, y):\n        y_pred = est.predict(X)\n        return {'recall': recall_score(y, y_pred), 'accuracy': accuracy_score(y, y_pred)}\n\n    est = LinearSVC()\n\n    search_callable = GridSearchCV(est, param_grid, scoring=custom_scorer, refit='recall')\n    search_str = GridSearchCV(est, param_grid, scoring=['recall', 'accuracy'], refit='recall')\n\n    search_callable.fit(X, y)\n    search_str.fit(X, y)\n\n    predictions = search_callable.predict(X)\n\n    return predictions", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 50)\n        X = np.random.randn(num_samples, num_features)\n        y = np.random.choice([0, 1], size=(num_samples,))\n        param_grid = {\n            'C': np.random.uniform(0.01, 10, size=np.random.randint(2, 5)).tolist(),\n            'max_iter': [100, 200, 500],\n        }\n\n        test_cases.append((X, y, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_46", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of various classifiers on clustered data. The function will take in features and labels, along with cluster labels, and a specified classifier type. It will train the classifier on each cluster of data, compute various performance metrics, and return these metrics along with the total log loss.\n\nFunction signature:\n```python\ndef evaluate_cac(X: np.ndarray, y: np.ndarray, cluster_labels: np.ndarray, classifier: str) -> tuple:\n```\n\nConstant used in the main code:\n- The constant `5` is used to determine the minimum number of samples required in a cluster for the classifier to be trained.\n\nInput format:\n- `X`: A 2D numpy array of shape (n_samples, n_features) representing the feature set.\n- `y`: A 1D numpy array of shape (n_samples,) representing the true labels.\n- `cluster_labels`: A 1D numpy array of shape (n_samples,) representing the cluster assignments for each sample.\n- `classifier`: A string indicating the type of classifier to use ('LR', 'RF', 'SVM', 'DT', 'KNN').\n\nOutput format:\n- A tuple containing:\n  - A list of five metrics: [accuracy, F1 score, AUC, specificity, sensitivity].\n  - A float representing the total log loss.\n  - A list of trained models for each cluster.\n\n**Input:**\n```python\nX = np.array([[ 1.74964153e+00,  9.35716540e-01,  1.75181995e+00,\n                 1.12319763e+00,  1.29249212e+00],\n                ...,\n               [-8.36434367e-01, -2.85875168e-01, -3.18969323e-01,\n                -9.44015546e-01, -7.87808565e-01]])\ny = np.array([1, 1, 0, 0, 1, 1, 0, 0, 1, 0, 1, 0, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0,\n       0, 1, 1, 0, 1, 0, 0, 1, 0, 0, 1, 1, 1, 1, 1, 0, 1, 0, 0, 1, 0, 1,\n       1, 1, 0, 1, 0, 0])\ncluster_labels = np.array([8, 3, 1, 2, 0, 4, 0, 5, 4, 5, 4, 1, 4, 4, 2, 6, 0, 2, 2, 2, 2, 2,\n       2, 5, 0, 1, 6, 5, 2, 6, 5, 1, 6, 0, 3, 0, 8, 5, 6, 5, 5, 4, 2, 0,\n       6, 4, 7, 4, 2, 5], dtype=int32)\nclassifier = 'DT'\n```\n\n**Output:**\n```python\n([1.0, 1.0, 1.0, array([1.]), array([1.])], 4.440892098500627e-16)\n```", "ground_truth_code": "from sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.svm import LinearSVC\nimport numpy as np\nfrom sklearn.tree import DecisionTreeClassifier\nfrom sklearn.neighbors import KNeighborsClassifier\nfrom sklearn import metrics\nfrom sklearn.metrics import f1_score, roc_auc_score, log_loss, confusion_matrix\n\ndef get_base_model(classifier, cluster_size=None):\n    models = {\n        'LR': LogisticRegression(class_weight='balanced', max_iter=1000),\n        'RF': RandomForestClassifier(n_estimators=10),\n        'SVM': LinearSVC(max_iter=1000),\n        'DT': DecisionTreeClassifier(),\n        'KNN': KNeighborsClassifier(n_neighbors=min(5, max(1, cluster_size or 5)))  # Dynamic adjustment\n    }\n    model = models.get(classifier, LogisticRegression(class_weight='balanced', max_iter=1000))\n    if classifier == 'SVM':\n        model.predict_proba = lambda X: np.array([model.decision_function(X), model.decision_function(X)]).transpose()\n    return model\n\ndef specificity(params):\n    return params[0] / (params[0] + params[1]) if params[0] + params[1] != 0 else 0\n\ndef sensitivity(params):\n    return params[3] / (params[3] + params[2]) if params[3] + params[2] != 0 else 0\n\n# main code\ndef evaluate_cac(X, y, cluster_labels, classifier):\n    (y_pred, y_true, y_proba, models, loss) = ([], [], [], [], [])\n    for j in np.unique(cluster_labels):\n        pts_index = np.where(cluster_labels == j)[0]\n        if len(pts_index) < 5:\n            continue\n        (x_cluster, y_cluster) = (X[pts_index], y[pts_index])\n        model = get_base_model(classifier, len(y_cluster))\n        if len(np.unique(y_cluster)) < 2:\n            continue\n        clf = model.fit(x_cluster, y_cluster)\n        pred = clf.predict(x_cluster)\n        y_predict_proba = clf.predict_proba(x_cluster)\n        y_pred.extend(pred)\n        y_true.extend(y_cluster)\n        y_proba.extend(y_predict_proba[:, 1])\n        models.append(clf)\n        loss.append(log_loss(y_cluster, y_predict_proba))\n    if len(y_pred) == 0:\n        return ([0, 0, 0, 0, 0], float('inf'), models)\n    acc = metrics.accuracy_score(y_true, y_pred)\n    f1 = f1_score(y_true, y_pred)\n    auc = roc_auc_score(y_true, y_proba)\n    params = confusion_matrix(y_true, y_pred).reshape(4, 1)\n    spe = specificity(params)\n    sen = sensitivity(params)\n    return ([acc, f1, auc, spe, sen], sum(loss))\n\n", "test_script": "import numpy as np\nfrom sklearn.datasets import make_classification\nfrom sklearn.cluster import KMeans\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    classifiers = [\"LR\", \"RF\", \"SVM\", \"DT\", \"KNN\"]\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_features = np.random.randint(5, 20)\n        X, y = make_classification(n_samples=num_samples, n_features=num_features, n_classes=2, random_state=None)\n        num_clusters = np.random.randint(2, min(10, num_samples // 5))\n        cluster_labels = KMeans(n_clusters=num_clusters, n_init=10, random_state=None).fit_predict(X)\n        classifier = np.random.choice(classifiers)\n\n        test_cases.append((X, y, cluster_labels, classifier))\n\n    return test_cases"}
{"problem_id": "sklearn_47", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of machine learning models using both grid search and randomized search for hyperparameter tuning. The function should handle both regression and classification tasks based on the type of target variable provided.\n\nFunction signature:\n```python\ndef test_grid_search_with_multioutput_data(X, y, est_parameters):\n```\n\n### Constants:\n- The constant used in the main code is `n_splits=5`, which defines the number of folds for cross-validation.\n\n### Input and Output Format:\n- **Input Format**:\n  - `X`: 2D array-like structure (features).\n  - `y`: 1D array-like structure (target variable).\n  - `est_parameters`: Dictionary of hyperparameters for tuning.\n\n- **Output Format**:\n  - A dictionary containing two keys: `\"grid_search\"` and `\"random_search\"`, each mapping to another dictionary where the keys are the names of the estimators and the values are lists of scores from the respective search methods.\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n              [0.2, 0.3, 0.4, 0.5, 0.6],\n              [0.3, 0.4, 0.5, 0.6, 0.7],\n              [0.4, 0.5, 0.6, 0.7, 0.8],\n              [0.5, 0.6, 0.7, 0.8, 0.9]])\ny = np.array([0, 1, 0, 1, 0])\nest_parameters = {\n    \"max_depth\": [None, 5],\n    \"min_samples_split\": [2, 5],\n    \"min_samples_leaf\": [1, 2]\n}\n```\n\nOutput:\n```python\n{\n    'grid_search': {\n        'DecisionTreeClassifier': [[0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0], [0.0, 0.0, 0.0, 0.0, 0.0], [1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0]]}, \n    'random_search': {\n        'DecisionTreeClassifier': [[1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0], [1.0, 0.0, 1.0, 0.0, 1.0]]\n    }\n}\n\n```", "ground_truth_code": "from sklearn.model_selection import KFold\nfrom sklearn.tree import DecisionTreeRegressor, DecisionTreeClassifier\nfrom sklearn.model_selection import GridSearchCV, RandomizedSearchCV\nfrom sklearn.utils.multiclass import type_of_target\n\n# main code\ndef test_grid_search_with_multioutput_data(X, y, est_parameters):\n    cv = KFold(n_splits=5)\n    y_type = type_of_target(y)\n    if \"continuous\" in y_type:\n        estimators = [DecisionTreeRegressor()]\n    else:\n        estimators = [DecisionTreeClassifier()]\n\n    results = {\"grid_search\": {}, \"random_search\": {}}\n\n    for est in estimators:\n        grid_search = GridSearchCV(est, est_parameters, cv=cv)\n        grid_search.fit(X, y)\n        res_params = grid_search.cv_results_['params']\n        grid_scores = []\n\n        for cand_i, params in enumerate(res_params):\n            est.set_params(**params)\n            scores = []\n            for train_idx, test_idx in cv.split(X, y):\n                est.fit(X[train_idx], y[train_idx])\n                scores.append(est.score(X[test_idx], y[test_idx]))\n            grid_scores.append(scores)\n\n        results[\"grid_search\"][type(est).__name__] = grid_scores\n\n    for est in estimators:\n        random_search = RandomizedSearchCV(est, est_parameters, cv=cv, n_iter=3)\n        random_search.fit(X, y)\n        res_params = random_search.cv_results_['params']\n        random_scores = []\n\n        for cand_i, params in enumerate(res_params):\n            est.set_params(**params)\n            scores = []\n            for train_idx, test_idx in cv.split(X, y):\n                est.fit(X[train_idx], y[train_idx])\n                scores.append(est.score(X[test_idx], y[test_idx]))\n            random_scores.append(scores)\n\n        results[\"random_search\"][type(est).__name__] = random_scores\n\n    return results\n\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_features = np.random.randint(5, 21)\n\n        problem_type = np.random.choice([\"classification\", \"regression\"])\n\n        if problem_type == \"classification\":\n            num_classes = np.random.randint(2, 6)\n            y = np.random.randint(0, num_classes, size=(num_samples,))\n        else:\n            num_outputs = np.random.randint(1, 6)\n            y = np.random.rand(num_samples, num_outputs)\n\n        X = np.random.rand(num_samples, num_features)\n\n        est_parameters = {\n            \"max_depth\": [None, 5, 10, 20],\n            \"min_samples_split\": [2, 5, 10],\n            \"min_samples_leaf\": [1, 2, 4]\n        }\n\n        test_cases.append((X, y, est_parameters))\n\n    return test_cases"}
{"problem_id": "sklearn_48", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a linear support vector classifier using grid search and evaluates its performance using a custom confusion matrix scoring method. The function should return both the confusion matrix and the score of the best model found during the grid search.\n\nFunction signature:\n```python\ndef callable_multimetric_confusion_matrix(X, y, param_grid):\n```\n\n### Constants:\n- The constant used in the main code is `random_state=42`, which ensures reproducibility of the results by controlling the randomness in the model training process.\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A 2D array-like structure representing the feature set.\n  - `y`: A 1D array-like structure representing the labels corresponding to the feature set.\n  - `param_grid`: A dictionary specifying the hyperparameters and their respective values to be tested during the grid search.\n\n- **Output**:\n  - A dictionary containing:\n    - `'confusion_matrix'`: A 2D array representing the confusion matrix.\n    - `'score'`: A float representing the score of the best model on the input data.\n\nInput:\n```python\nX = np.array([[-1.49687609,  1.42383666, -0.96138373, ...,  1.84801671,\n        -0.59283363,  0.66197261],\n       ...,\n       [-0.78176627,  0.89347592, -0.60030612, ..., -1.00089066,\n         0.12493982, -1.57936337]])\ny = np.array([0, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 1, 0, 1, 0, 0, 0,\n       0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 1, 1, 0, 1, 1, 0, 0, 0, 0, 0,\n       0, 0, 0, 0, 1, 0, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 1, 0, 0, 1,\n       0, 1, 1, 0, 0])\nparam_grid = {'C': array([1.e-03, 1.e-02, 1.e-01, 1.e+00, 1.e+01, 1.e+02, 1.e+03])}\n```\n\nOutput:\n```python\n{'confusion_matrix': array([[35,  8],\n       [11, 17]]), 'score': 8}\n```", "ground_truth_code": "from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import confusion_matrix\n\n# main code\ndef callable_multimetric_confusion_matrix(X, y, param_grid):\n\n    def custom_scorer(clf, X, y):\n        y_pred = clf.predict(X)\n        cm = confusion_matrix(y, y_pred)\n        return {'tn': cm[0, 0], 'fp': cm[0, 1], 'fn': cm[1, 0], 'tp': cm[1, 1]}\n    est = LinearSVC(random_state=42)\n    search = GridSearchCV(est, param_grid, scoring=custom_scorer, refit='fp')\n    search.fit(X, y)\n    y_pred = search.predict(X)\n    cm = confusion_matrix(y, y_pred)\n    return {'confusion_matrix': cm, 'score': search.score(X, y)}", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n\n        X = np.random.randn(num_samples, num_features)\n        y = np.random.choice([0, 1], size=num_samples)\n        param_grid = {'C': np.logspace(-3, 3, num=7)}\n\n        test_cases.append((X, y, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_49", "library": "sklearn", "code_problem": "You are tasked with implementing a data preprocessing function for a machine learning pipeline. The function will handle both numerical and categorical features in a dataset, ensuring that missing values are appropriately imputed and that the data is scaled for model training. The function signature is as follows:\n\n```python\ndef preprocess_fitting_data(x, y):\n```\n\n### Constants Used:\n- The constant used in the main code is `np.nan`, which represents missing values in the dataset.\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A 2D array-like structure containing the feature data, which may include both numerical and categorical values.\n  - `y`: A 1D array-like structure containing the target labels corresponding to the feature data.\n\n- **Output**: \n  - A tuple containing two elements:\n    - A PyTorch tensor of the processed feature data.\n    - A PyTorch tensor of the target labels.\n\n**Input:**\n```python\n(\n    [\n        [1.0, 2.0, np.nan, 'A'],\n        [3.0, np.nan, 5.0, 'B'],\n        [np.nan, 4.0, 6.0, 'C'],\n        [7.0, 8.0, 9.0, np.nan],\n        [10.0, 11.0, 12.0, 'A']\n    ],\n    [0, 1, 0, 1, 0]\n)\n```\n\n**Output:**\n```python\n(tensor([[ 1.2247, -0.5000, -0.5000, -0.5000,  1.2247, -0.5000, -0.5000, -0.5000,\n          1.2247, -0.5000, -0.5000, -0.5000,  0.8165, -0.5000, -0.5000],\n        [-0.8165,  2.0000, -0.5000, -0.5000,  1.2247, -0.5000, -0.5000, -0.5000,\n          1.2247, -0.5000, -0.5000, -0.5000, -1.2247,  2.0000, -0.5000],\n        [ 1.2247, -0.5000, -0.5000, -0.5000, -0.8165,  2.0000, -0.5000, -0.5000,\n         -0.8165,  2.0000, -0.5000, -0.5000, -1.2247, -0.5000,  2.0000],\n        [-0.8165, -0.5000,  2.0000, -0.5000, -0.8165, -0.5000,  2.0000, -0.5000,\n         -0.8165, -0.5000,  2.0000, -0.5000,  0.8165, -0.5000, -0.5000],\n        [-0.8165, -0.5000, -0.5000,  2.0000, -0.8165, -0.5000, -0.5000,  2.0000,\n         -0.8165, -0.5000, -0.5000,  2.0000,  0.8165, -0.5000, -0.5000]]),\n tensor([0, 1, 0, 1, 0]))\n```\n", "ground_truth_code": "from sklearn.impute import SimpleImputer\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler, OneHotEncoder\nimport pandas as pd\nfrom sklearn.compose import ColumnTransformer\nimport torch\n\n# main code\ndef preprocess_fitting_data(x, y):\n    x = np.array(x, dtype=object)\n    y = np.array(y, dtype=np.int64).copy()\n\n    num_imputer = SimpleImputer(missing_values=np.nan, strategy='mean')\n\n    all_feature_idxs = np.arange(x.shape[1])\n    cat_features = [i for i in all_feature_idxs if isinstance(x[0, i], str) or isinstance(x[0, i], object)]\n    numerical_feature_idxs = np.setdiff1d(all_feature_idxs, cat_features)\n\n    if numerical_feature_idxs.size > 0:\n        x[:, numerical_feature_idxs] = x[:, numerical_feature_idxs].astype(np.float32)\n        num_imputer.fit(x[:, numerical_feature_idxs])\n        x[:, numerical_feature_idxs] = num_imputer.transform(x[:, numerical_feature_idxs])\n\n    if len(cat_features) > 0:\n        cat_imputer = SimpleImputer(missing_values=np.nan, strategy='most_frequent')\n        x[:, cat_features] = cat_imputer.fit_transform(x[:, cat_features])\n\n        one_hot_encoder = ColumnTransformer(\n            transformers=[('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), cat_features)],\n            remainder='passthrough'\n        )\n        x = one_hot_encoder.fit_transform(pd.DataFrame(x))\n\n    scaler = StandardScaler()\n    x = scaler.fit_transform(x)\n\n    return torch.tensor(x, dtype=torch.float32), torch.tensor(y, dtype=torch.long)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(5, 100)\n        num_features = random.randint(2, 10)\n\n        x = np.random.randn(num_samples, num_features).astype(np.float32)\n        mask = np.random.rand(num_samples, num_features) < 0.1\n        x[mask] = np.nan\n\n        num_cat_features = random.randint(0, num_features // 2)\n        if num_cat_features > 0:\n            cat_data = np.random.choice(['A', 'B', 'C', np.nan], (num_samples, num_cat_features))\n            x = np.hstack((x, cat_data))\n\n        num_classes = random.randint(2, 5)\n        y = np.random.randint(0, num_classes, size=num_samples).astype(np.int64)\n\n        test_cases.append((x.tolist(), y.tolist()))\n\n    return test_cases"}
{"problem_id": "sklearn_50", "library": "sklearn", "code_problem": "You are tasked with evaluating the performance of a binary classification model using various metrics. The function `test_model` takes in test data and a trained model, computes the loss and several performance metrics, and returns them for further analysis.\n\nFunction signature:\n```python\ndef test_model(X_test, Y_test, model):\n```\n\nConstant used in the main code:\n- The constant `0.5` is used as the threshold for converting predicted logits into binary predictions.\n\nInput format:\n- `X_test`: A NumPy array or TensorFlow tensor containing the test features.\n- `Y_test`: A NumPy array or TensorFlow tensor containing the true binary labels for the test set.\n- `model`: A trained TensorFlow/Keras model used for making predictions.\n\nOutput format:\n- A tuple containing the following metrics in order: \n  - Accuracy (float)\n  - Loss (float)\n  - F1 Score (float)\n  - Precision (float)\n  - Recall (float)\n  - AUC Value (float)\n  - True Positive Rate (float)\n  - False Positive Rate (float)\n\nInput:\n```python\nX_test = tf.convert_to_tensor(np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]), dtype=tf.float32)\nY_test = tf.convert_to_tensor(np.array([[0], [1], [0]]), dtype=tf.float32)\n\ndef mock_model(input_shape):\n    model = tf.keras.Sequential([\n        tf.keras.layers.Input(shape=(input_shape,)),\n        tf.keras.layers.Dense(1, activation=None)\n    ])\n    model.build()\n    model.set_weights([np.array([[1], [1], [1]]), np.array([0])])  # Simple weights for testing\n    return model\n\nmodel = mock_model(3)\n```\n\nOutput:\n```python\n(0.3333333333333333, 1.2419125, 0.5, 0.3333333333333333, 1.0, 0.5, 0.0, 0.0)\n``` \n", "ground_truth_code": "from sklearn.metrics import (\n    accuracy_score, f1_score, precision_score, recall_score,\n    roc_auc_score, confusion_matrix\n)\nimport tensorflow as tf\n\n# main code\ndef test_model(X_test, Y_test, model):\n    bce = tf.keras.losses.BinaryCrossentropy(from_logits=True)\n    logits = model.predict(X_test)\n    loss = bce(Y_test, logits).numpy()\n\n    Y_pred = (logits > 0.5).astype(int)\n    Y_test = Y_test.numpy()\n\n    acc = accuracy_score(Y_test, Y_pred)\n    F1 = f1_score(Y_test, Y_pred, zero_division=1)\n    precision = precision_score(Y_test, Y_pred, zero_division=1)\n    recall = recall_score(Y_test, Y_pred, zero_division=1)\n    auc_value = roc_auc_score(Y_test, logits)\n\n    cm = confusion_matrix(Y_test, Y_pred)\n    TP, FN, FP, TN = cm.ravel() if cm.size == 4 else (0, 0, 0, 0)\n    TPR = TP / (TP + FN) if (TP + FN) > 0 else 0\n    FPR = FP / (FP + TN) if (FP + TN) > 0 else 0\n\n\n    return acc, loss, F1, precision, recall, auc_value, TPR, FPR", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    def mock_model(input_shape):\n        model = tf.keras.Sequential([\n            tf.keras.layers.Input(shape=(input_shape,)),\n            tf.keras.layers.Dense(1, activation=None)\n        ])\n        return model\n\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_features = np.random.randint(5, 50)\n        X_test = tf.convert_to_tensor(np.random.rand(num_samples, num_features), dtype=tf.float32)\n        Y_test = tf.convert_to_tensor(np.random.randint(0, 2, size=(num_samples, 1)), dtype=tf.float32)\n        model = mock_model(num_features)\n\n        test_cases.append((X_test, Y_test, model))\n\n    return test_cases"}
{"problem_id": "sklearn_51", "library": "sklearn", "code_problem": "You are tasked with implementing a function that optimizes a decision tree classifier based on cross-validation scores. The function will take a DataFrame containing input features and target labels, determine the optimal depth for the decision tree, and return either the optimal bin thresholds or the result of a Weight of Evidence (WoE) transformation based on the specified parameters.\n\nFunction signature:\n```python\ndef optimize(df, bins, cv, WoE):\n```\n\nConstants used in the main code:\n- `max_depth`: This constant is calculated as `int(np.log2(bins)) + 1`, which determines the maximum depth of the decision tree based on the number of bins provided.\n\nInput format:\n- `df`: A pandas DataFrame with at least two columns, 'X' (features) and 'Y' (target labels).\n- `bins`: An integer representing the number of bins for the decision tree.\n- `cv`: An integer representing the number of cross-validation folds.\n- `WoE`: A callable that performs Weight of Evidence transformation (or None).\n\nOutput format:\n- If `WoE` is provided, the output will be the result of the WoE transformation.\n- If `WoE` is not provided, the output will be a sorted array of optimal bin thresholds determined by the decision tree.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'X': np.array([-5.0, -3.0, -1.0, 0.0, 1.0, 3.0, 5.0, 7.0, 9.0, 10.0]),\n    'Y': np.array([0, 0, 1, 1, 1, 0, 0, 1, 1, 0])\n}\ndf = pd.DataFrame(data)\n\nbins = 5\ncv = 3\nWoE = None  # No WoE transformation\n\n# Call the optimize function\noutput = optimize(df, bins, cv, WoE)\n```\n\n**Output:**\n```python\narray([-2.])\n\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import tree\n\n\n# main code\ndef optimize(df, bins, cv, WoE):\n    tree_type = tree.DecisionTreeClassifier\n    max_depth = int(np.log2(bins)) + 1\n\n    x_train = np.array(df['X']).reshape(-1, 1)\n    y_train = np.array(df['Y'])\n\n    cv_scores = [cross_val_score(tree_type(max_depth=i), x_train, y_train, cv=cv).mean() for i in range(1, max_depth)]\n    best_depth = np.argmax(cv_scores) + 1\n\n    final_tree = tree_type(max_depth=best_depth)\n    final_tree.fit(x_train, y_train)\n\n    opt_bins = np.sort(final_tree.tree_.threshold[final_tree.tree_.feature >= 0])\n\n    return WoE(bins, opt_bins).fit(df['X'], df['Y']) if WoE else opt_bins", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    def mock_WoE(bins, opt_bins):\n        class WoETransformer:\n            def fit(self, X, Y):\n                return f\"WoE({bins}, {opt_bins}) fitted\"\n\n        return WoETransformer()\n\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        X = np.random.uniform(-10, 10, size=num_samples)\n        Y = np.random.choice([0, 1], size=num_samples)\n        df = pd.DataFrame({'X': X, 'Y': Y})\n        bins = np.random.randint(2, 20)\n        cv = np.random.randint(2, 10)\n        WoE = None if np.random.rand() < 0.5 else mock_WoE\n\n        test_cases.append((df, bins, cv, WoE))\n\n    return test_cases"}
{"problem_id": "sklearn_52", "library": "sklearn", "code_problem": "You are tasked with implementing a data preprocessing function for a machine learning pipeline. The function will handle missing values in both numerical and categorical features, apply one-hot encoding to categorical features, and standardize the numerical features. \n\nThe function signature is as follows:\n\n```python\ndef preprocess_fitting_data(x, y, cat_features):\n```\n\n### Constants Used:\n- `np.nan`: This constant is used to identify missing values in the dataset.\n\n### Input and Output Format:\n- **Input**:\n  - `x`: A 2D array-like structure (e.g., list of lists or a NumPy array) containing the feature data.\n  - `y`: A 1D array-like structure (e.g., list or a NumPy array) containing the target variable.\n  - `cat_features`: A list of indices indicating which features in `x` are categorical.\n\n- **Output**:\n  - A tuple containing:\n    - `x`: The preprocessed feature set after handling missing values, one-hot encoding, and standardization.\n    - `y`: The unchanged target variable.\n\nInput:\n```python\n(\n    [[1.0, 2.0, np.nan, 4.0],\n     [5.0, np.nan, 7.0, 8.0],\n     [np.nan, 10.0, 11.0, 12.0],\n     [13.0, 14.0, 15.0, np.nan]],\n    [0, 1, 0, 1],\n    [2, 3]\n)\n```\n\nOutput:\n```python\n(array([[ 1.00000000e+00, -5.77350269e-01, -5.77350269e-01,\n         1.00000000e+00, -5.77350269e-01, -5.77350269e-01,\n        -1.23442681e+00, -1.54303352e+00],\n       [ 1.00000000e+00, -5.77350269e-01, -5.77350269e-01,\n        -1.00000000e+00,  1.73205081e+00, -5.77350269e-01,\n        -3.08606709e-01,  5.51831782e-08],\n       [-1.00000000e+00,  1.73205081e+00, -5.77350269e-01,\n        -1.00000000e+00, -5.77350269e-01,  1.73205081e+00,\n         2.75915891e-08,  3.08606682e-01],\n       [-1.00000000e+00, -5.77350269e-01,  1.73205081e+00,\n         1.00000000e+00, -5.77350269e-01, -5.77350269e-01,\n         1.54303349e+00,  1.23442678e+00]]), \n array([0, 1, 0, 1]))\n```", "ground_truth_code": "from sklearn.impute import SimpleImputer\nimport numpy as np\nfrom sklearn.preprocessing import StandardScaler\nimport pandas as pd\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\n\n# main code\ndef preprocess_fitting_data(x, y, cat_features):\n    x = np.array(x, dtype=np.float32).copy()\n    y = np.array(y, dtype=np.int64).copy()\n\n    num_imputer = SimpleImputer(missing_values=np.nan, strategy='mean')\n    all_feature_idxs = np.arange(x.shape[1])\n    numerical_feature_idxs = np.setdiff1d(all_feature_idxs, cat_features)\n\n    if numerical_feature_idxs.size > 0:\n        num_imputer.fit(x[:, numerical_feature_idxs])\n        x[:, numerical_feature_idxs] = num_imputer.transform(x[:, numerical_feature_idxs])\n\n    if len(cat_features) > 0:\n        cat_imputer = SimpleImputer(missing_values=np.nan, strategy='most_frequent')\n        cat_imputer.fit(x[:, cat_features])\n        x[:, cat_features] = cat_imputer.transform(x[:, cat_features])\n\n        x = pd.DataFrame(x)\n        one_hot_encoder = ColumnTransformer(\n            transformers=[('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), cat_features)],\n            remainder='passthrough'\n        )\n        x = one_hot_encoder.fit_transform(x)\n\n    scaler = StandardScaler()\n    x = scaler.fit_transform(x)\n\n    return x, y", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        num_features = random.randint(3, 10)\n        x = np.random.randn(num_samples, num_features).astype(np.float32)\n        nan_mask = np.random.rand(num_samples, num_features) < 0.1\n        x[nan_mask] = np.nan\n\n        y = np.random.randint(0, 3, size=num_samples, dtype=np.int64)\n\n        num_categorical = random.randint(0, num_features // 2)\n        cat_features = np.sort(np.random.choice(num_features, num_categorical, replace=False)).tolist()\n\n        test_cases.append((x.tolist(), y.tolist(), cat_features))\n\n    return test_cases"}
{"problem_id": "sklearn_53", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a classification model by calculating various metrics based on the true labels and predicted labels. The function should return a dictionary containing the accuracy and different types of F1 scores.\n\nFunction signature:\n```python\ndef metric_report(y_test, y_pred):\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- The function takes two inputs:\n  - `y_test`: A list or array of true labels (ground truth).\n  - `y_pred`: A list or array of predicted labels from the classification model.\n\nOutput format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - `'acc'`: The accuracy score (float).\n  - `'MicroF1'`: The micro-averaged F1 score (float).\n  - `'MacroF1'`: The macro-averaged F1 score (float).\n  - `'WeightedF1'`: The weighted F1 score (float).\n\n```python\n# Input\ny_test = [0, 1, 1, 0, 2, 2, 1, 0]\ny_pred = [0, 1, 0, 0, 2, 1, 1, 0]\n\n# Output\n{'acc': 0.75, 'MicroF1': 0.75, 'MacroF1': 0.7301587301587301, 'WeightedF1': 0.738095238095238}\n```", "ground_truth_code": "from sklearn.metrics import accuracy_score, f1_score\n\n# main code\ndef metric_report(y_test, y_pred):\n    metrics = {\n        'acc': accuracy_score(y_test, y_pred),\n        'MicroF1': f1_score(y_test, y_pred, average='micro'),\n        'MacroF1': f1_score(y_test, y_pred, average='macro'),\n        'WeightedF1': f1_score(y_test, y_pred, average='weighted')\n    }\n    return metrics\n", "test_script": "import numpy as np\nfrom random import randint\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = randint(10, 100)\n        num_classes = randint(2, 10)\n\n        y_test = np.random.randint(0, num_classes, size=num_samples)\n        y_pred = np.random.randint(0, num_classes, size=num_samples)\n\n        test_cases.append((y_test, y_pred))\n\n    return test_cases"}
{"problem_id": "sklearn_54", "library": "sklearn", "code_problem": "You are tasked with evaluating the performance of a classification model using various metrics. The evaluation should include accuracy, precision, recall, F1 score, ROC AUC score, root mean squared error (RMSE), and a confusion matrix. \n\nThe function signature for the main code is as follows:\n\n```python\ndef get_clf_eval(y_test, pred):\n```\n\nIn this function, the following constant is used:\n- The constant `average='macro'` is specified in the precision and recall calculations to compute the metrics for each class and then take the average.\n\nThe input format for the function is:\n- `y_test`: A list or array of true labels.\n- `pred`: A list or array of predicted labels.\n\nThe output format of the function is:\n- A dictionary containing the following keys and their corresponding values:\n  - 'accuracy': A float representing the accuracy of the model.\n  - 'precision': A float representing the precision of the model.\n  - 'recall': A float representing the recall of the model.\n  - 'f1_score': A float representing the F1 score of the model.\n  - 'roc_auc': A float representing the ROC AUC score of the model.\n  - 'rmse': A float representing the root mean squared error of the model.\n  - 'confusion_matrix': A 2D array representing the confusion matrix of the model.\n\nInput:\n```python\ny_test = np.array([[1, 0, 0], \n                   [0, 1, 0], \n                   [0, 0, 1], \n                   [1, 0, 0], \n                   [0, 1, 0]])\npred = np.array([[1, 0, 0], \n                  [0, 1, 0], \n                  [0, 1, 0], \n                  [1, 0, 0], \n                  [0, 0, 1]])\n```\n\nOutput:\n```python\n{\n    'accuracy': 0.6, \n    'precision': 0.5, \n    'recall': 0.5, \n    'f1_score': 0.5, \n    'roc_auc': 0.6527777777777778, \n    'rmse': 0.5163977794943222, \n    'confusion_matrix': array([[2, 0, 0],\n       [0, 1, 1],\n       [0, 1, 0]])\n}\n```", "ground_truth_code": "from sklearn.metrics import accuracy_score, precision_score, recall_score, roc_auc_score, mean_squared_error, \\\n    confusion_matrix\nimport numpy as np\n\n\ndef f1_score(precision, recall):\n    return 2 * (precision * recall) / (precision + recall) if (precision + recall) > 0 else 0\n\n# main code\ndef get_clf_eval(y_test, pred):\n    accuracy = accuracy_score(y_test, pred)\n    precision = precision_score(y_test, pred, average='macro')\n    recall = recall_score(y_test, pred, average='macro')\n    roc_auc = roc_auc_score(y_test, pred, average='macro')\n\n    rmse = mean_squared_error(y_test, pred) ** 0.5\n\n    f1score = f1_score(precision, recall)\n    cm = confusion_matrix(np.asarray(y_test).argmax(axis=1), np.asarray(pred).argmax(axis=1))\n\n    return {\n        'accuracy': accuracy,\n        'precision': precision,\n        'recall': recall,\n        'f1_score': f1score,\n        'roc_auc': roc_auc,\n        'rmse': rmse,\n        'confusion_matrix': cm\n    }\n", "test_script": "from sklearn.preprocessing import OneHotEncoder\nimport numpy as np\n\ndef test_case_input_generator(n=200, num_classes=3, num_samples=100):\n    test_cases = []\n\n    for _ in range(n):\n        y_labels = np.random.randint(0, num_classes, size=(num_samples, 1))\n        encoder = OneHotEncoder(sparse_output=False, categories=[np.arange(num_classes)])\n        y_test = encoder.fit_transform(y_labels)\n\n        pred_probs = np.random.rand(num_samples, num_classes)\n        pred_probs /= pred_probs.sum(axis=1, keepdims=True)\n        pred = (pred_probs == pred_probs.max(axis=1, keepdims=True)).astype(int)\n\n        test_cases.append((y_test, pred))\n\n    return test_cases"}
{"problem_id": "sklearn_55", "library": "sklearn", "code_problem": "You are tasked with implementing a text classification function that utilizes machine learning techniques to categorize text data based on specified features. The function will preprocess the text data, train a logistic regression model, and evaluate its performance.\n\nFunction signature:\n```python\ndef classify_text(df, key, value, test_size, min_df, ngram_range):\n```\n\n### Constants:\n- `random_state`: This constant is set to `0` to ensure reproducibility of the results when splitting the dataset and training the model.\n\n### Input Format:\n- `df`: A pandas DataFrame containing the text data and categories.\n- `key`: A string representing the column name in `df` that contains the category labels.\n- `value`: A string representing the column name in `df` that contains the text data to be classified.\n- `test_size`: A float representing the proportion of the dataset to include in the test split.\n- `min_df`: An integer representing the minimum document frequency for terms to be included in the TF-IDF vectorization.\n- `ngram_range`: A tuple representing the range of n-grams to be extracted from the text data.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `'accuracy'`: A float representing the accuracy of the model on the test set.\n  - `'features_shape'`: A tuple representing the shape of the feature matrix used for training the model.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    \"category\": [\"Category_0\", \"Category_1\", \"Category_0\", \"Category_1\", \"Category_2\"],\n    \"text\": [\n        \"data science machine learning\",\n        \"text classification random words\",\n        \"analysis data science\",\n        \"learning random generated text\",\n        \"machine analysis data\"\n    ]\n}\ndf = pd.DataFrame(data)\n\nkey = \"category\"\nvalue = \"text\"\ntest_size = 0.2\nmin_df = 1\nngram_range = (1, 2)\n\n# Call the function\nresult = classify_text(df, key, value, test_size, min_df, ngram_range)\n```\n\n**Output:**\n```python\n{'accuracy': 0.0, 'features_shape': (5, 21)}\n```", "ground_truth_code": "from sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import accuracy_score\n\n\n# main code\ndef classify_text(df, key, value, test_size, min_df, ngram_range):\n    if df is None or key not in df or value not in df:\n        return None\n\n    df['category_id'] = df[key].factorize()[0]\n\n    vectorizer = TfidfVectorizer(sublinear_tf=True, min_df=min_df, norm='l2',\n                                 encoding='latin-1', ngram_range=ngram_range, stop_words='english')\n    X = vectorizer.fit_transform(df[value])\n    y = df['category_id']\n\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=test_size, random_state=0)\n    model = LogisticRegression(random_state=0)\n    model.fit(X_train, y_train)\n    y_pred = model.predict(X_test)\n\n    return {\n        'accuracy': accuracy_score(y_test, y_pred),\n        'features_shape': X.shape\n    }", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_text(num_sentences=10, sentence_length=5):\n        words = [\"data\", \"science\", \"machine\", \"learning\", \"text\", \"classification\", \"random\", \"words\", \"generated\",\n                 \"analysis\"]\n        sentences = [\" \".join(np.random.choice(words, sentence_length)) for _ in range(num_sentences)]\n        return sentences\n\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_categories = np.random.randint(2, 10)\n\n        df = pd.DataFrame({\n            \"category\": np.random.choice([f\"Category_{i}\" for i in range(num_categories)], num_samples),\n            \"text\": generate_random_text(num_samples)\n        })\n\n        key = \"category\"\n        value = \"text\"\n        test_size = np.random.uniform(0.1, 0.3)\n        min_df = np.random.randint(1, 5)\n        ngram_range = (np.random.randint(1, 3), np.random.randint(2, 4))\n\n        test_cases.append((df, key, value, test_size, min_df, ngram_range))\n\n    return test_cases"}
{"problem_id": "sklearn_56", "library": "sklearn", "code_problem": "You are tasked with creating a function that constructs a neural network model using PyTorch. The function should allow for customizable input dimensions, hidden layer sizes, and activation functions. The final layer of the network should output probabilities for a specified number of actions.\n\nFunction signature:\n```python\ndef create_nn(dim_context, hidden_layer_size, n_actions, activation='relu'):\n```\n\nConstant used in the main code:\n- The activation functions available for selection are: 'identity', 'logistic', 'tanh', 'relu', and 'elu'.\n\nInput format:\n- `dim_context`: An integer.\n- `hidden_layer_size`: A list of integers.\n- `n_actions`: An integer.\n- `activation`: A string (optional, default is 'relu').\n\nOutput format:\n- Returns a PyTorch `nn.Sequential` model representing the constructed neural network.\n\nInput: (32, [64, 128, 64], 5, 'relu')  \nOutput:\nSequential(\n  (0): Linear(in_features=32, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=128, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=128, out_features=64, bias=True)\n  (5): ReLU()\n  (6): Linear(in_features=64, out_features=5, bias=True)\n  (7): Softmax(dim=1)\n)", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef create_nn(dim_context, hidden_layer_size, n_actions, activation='relu'):\n\n    activation_mapping = {\n        'identity': nn.Identity,\n        'logistic': nn.Sigmoid,\n        'tanh': nn.Tanh,\n        'relu': nn.ReLU,\n        'elu': nn.ELU\n    }\n    activation_layer = activation_mapping.get(activation, nn.ReLU)\n\n    layers = []\n    input_size = dim_context\n    for h in hidden_layer_size:\n        layers.append(nn.Linear(input_size, h))\n        layers.append(activation_layer())\n        input_size = h\n\n    layers.append(nn.Linear(input_size, n_actions))\n    layers.append(nn.Softmax(dim=1))\n\n    return nn.Sequential(*layers)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    activation_options = ['identity', 'logistic', 'tanh', 'relu', 'elu']\n\n    for _ in range(n):\n        dim_context = random.randint(1, 100)\n        hidden_layer_size = [random.randint(1, 100) for _ in range(random.randint(0, 5))]\n        n_actions = random.randint(1, 10)\n        activation = random.choice(activation_options)\n\n        test_cases.append((dim_context, hidden_layer_size, n_actions, activation))\n\n    return test_cases"}
{"problem_id": "sklearn_57", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a K-Nearest Neighbors (KNN) classifier using two different approaches to compute distances between data points. The function will utilize cross-validation to optimize hyperparameters and compare predictions made using the original distance metric with those made using precomputed Euclidean distances.\n\nFunction signature:\n```python\ndef search_cv_pairwise_property_equivalence(X, y, grid_params, n_splits):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the KNeighborsClassifier from the sklearn library, which is initialized without any specific parameters in the first instance.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., list of lists, NumPy array) representing the features.\n- `y`: A 1D array-like structure (e.g., list, NumPy array) representing the target labels.\n- `grid_params`: A dictionary containing hyperparameters for the KNN classifier.\n- `n_splits`: An integer representing the number of folds for cross-validation.\n\nOutput format:\n- A tuple containing:\n  - A list or array of predictions from the original feature set.\n  - A list or array of predictions from the precomputed distance matrix.\n  - A boolean indicating if the predictions from both methods are equivalent.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.2, 0.1], [0.3, 0.4], [0.4, 0.3]])\ny = np.array([0, 0, 1, 1])\ngrid_params = {'n_neighbors': [3]}\nn_splits = 2\n```\n\nOutput:\n```python\npreds_original = np.array([0, 0, 1, 1])\npreds_precomputed = np.array([0, 0, 1, 1])\nequivalence = True\n```", "ground_truth_code": "from sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics.pairwise import euclidean_distances\n\n# main code\ndef search_cv_pairwise_property_equivalence(X, y, grid_params, n_splits):\n    clf = KNeighborsClassifier()\n    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n    cv.fit(X, y)\n    preds_original = cv.predict(X)\n\n    X_precomputed = euclidean_distances(X)\n    clf = KNeighborsClassifier(metric='precomputed')\n    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n    cv.fit(X_precomputed, y)\n    preds_precomputed = cv.predict(X_precomputed)\n\n    return preds_original, preds_precomputed, (preds_original == preds_precomputed).all()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 200)\n        num_features = np.random.randint(1, 50)\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.randint(0, 2, size=num_samples)\n\n        grid_params = {'n_neighbors': [np.random.choice([1, 3, 5, 7, 9])]}\n        class_counts = np.bincount(y)\n        min_class_size = min(class_counts) if len(class_counts) > 1 else num_samples\n        max_valid_splits = max(2, min(min_class_size, 10))\n\n        n_splits = np.random.randint(2, max_valid_splits + 1)\n\n        test_cases.append((X, y, grid_params, n_splits))\n\n    return test_cases"}
{"problem_id": "sklearn_58", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs cross-validation on a given machine learning model and prepares a confusion matrix if the model is a classifier. The function will take in training data and a model, evaluate the model's performance using cross-validation, and return a DataFrame containing the model's name and its performance metrics.\n\nFunction signature:\n```python\ndef cross_validate_model(X_train, y_train, model):\n```\n\nConstant used in the main code:\n- The constant `scoring` is defined based on the type of the model (classifier or regressor).\n\nInput format:\n- `X_train`: A 2D array-like structure (e.g., a DataFrame or NumPy array) representing the training features.\n- `y_train`: A 1D array-like structure (e.g., a Series or NumPy array) representing the training labels.\n- `model`: An object that contains a machine learning pipeline and attributes such as `name`, `estimator_type`, and `cv`.\n\nOutput format:\n- The function returns a DataFrame containing the model's name and its performance metrics, where each row corresponds to the model's evaluation results.\n\n**Input:**\n```python\nX_train = np.array([[0.1, 0.2, 0.3], \n                    [0.4, 0.5, 0.6], \n                    [0.7, 0.8, 0.9], \n                    [0.1, 0.4, 0.7], \n                    [0.2, 0.5, 0.8]])\ny_train = np.array([[0], [1], [0], [1], [0]])\nmodel = MockModel(\"LogisticRegression\", \"classifier\",\n                  Pipeline([(\"clf\", LogisticRegression())]),\n                  KFold(n_splits=5))\n```\n\n**Output:**\n```python\n           model_name  accuracy\n0  LogisticRegression       0.0\n```\n", "ground_truth_code": "import pandas as pd\nimport numpy as np\nfrom sklearn import metrics\nfrom sklearn.model_selection import cross_validate, cross_val_predict\n\n\ndef prep_confusion_matrix(y_test, y_pred, model):\n    if y_test.ndim == 1:\n        matrix = metrics.confusion_matrix(y_test, y_pred)\n        columns = ['true_negative', 'false_positive', 'false_negative', 'true_positive']\n        model.confusion_matrix = pd.DataFrame(matrix.reshape(1, -1), columns=columns)\n    else:\n        matrix = metrics.multilabel_confusion_matrix(y_test, y_pred).reshape(-1, 4)\n        columns = ['true_negative', 'false_positive', 'false_negative', 'true_positive']\n        model.confusion_matrix = pd.DataFrame(matrix, columns=columns)\n\n    model.confusion_matrix.insert(0, 'model_name', model.name)\n\n\n# main code\ndef cross_validate_model(X_train, y_train, model):\n    y_train = y_train.ravel()\n    scoring = ['accuracy'] if model.estimator_type == 'classifier' else ['r2', 'neg_mean_squared_error',\n                                                                         'neg_mean_absolute_error']\n\n    scores = cross_validate(model.pipe, X_train, y_train, scoring=scoring, cv=model.cv, return_train_score=False)\n\n    if model.estimator_type == 'classifier':\n        y_pred = cross_val_predict(model.pipe, X_train, y_train, cv=model.cv)\n        prep_confusion_matrix(y_train, y_pred, model)\n\n    metrics_df = pd.DataFrame([{metric: np.mean(scores[f'test_{metric}']) for metric in scoring}])\n    metrics_df.insert(0, 'model_name', model.name)\n    return metrics_df", "test_script": "import numpy as np\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.model_selection import KFold\n\n\n\ndef test_case_input_generator(n=200):\n    class MockModel:\n        def __init__(self, name, estimator_type, pipe, cv):\n            self.name = name\n            self.estimator_type = estimator_type\n            self.pipe = pipe\n            self.cv = cv\n            self.confusion_matrix = None\n            self.metrics_df = None\n\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 20)\n\n        X_train = np.random.rand(num_samples, num_features)\n        y_train = np.random.randint(0, 2, size=(num_samples, 1))\n\n\n        if np.random.rand() > 0.5:\n            model = MockModel(\"LogisticRegression\", \"classifier\",\n                              Pipeline([(\"clf\", LogisticRegression())]),\n                              KFold(n_splits=5))\n        else:\n            y_train = np.random.rand(num_samples, 1)\n            model = MockModel(\"RandomForestRegressor\", \"regressor\",\n                              Pipeline([(\"reg\", RandomForestRegressor())]),\n                              KFold(n_splits=5))\n\n        test_cases.append((X_train, y_train, model))\n\n    return test_cases"}
{"problem_id": "sklearn_59", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a binary classification model. The function will compute various metrics based on the true labels and predicted probabilities of the positive class. The function signature is as follows:\n\n```python\ndef score_binary_classification(y_true, hat_y_pred, threshold):\n```\n\n### Constants:\n- The constant used in the main code is `threshold`, which is a float value that determines the cutoff for classifying predicted probabilities into binary outcomes.\n\n### Input Format:\n- `y_true`: A list or array of true binary labels (0 or 1).\n- `hat_y_pred`: A list or array of predicted probabilities for the positive class (float values between 0 and 1).\n- `threshold`: A float value representing the cutoff for classifying predicted probabilities into binary outcomes.\n\n### Output Format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - `'n_samples'`: Total number of samples (int).\n  - `'prevalence'`: Prevalence of the positive class (float).\n  - `'accuracy'`: Accuracy of the model (float).\n  - `'precision'`: Precision of the model (float).\n  - `'recall'`: Recall of the model (float).\n  - `'roc_auc'`: ROC AUC score (float).\n  - `'pr_auc'`: Average precision score (float).\n  - `'confusion_matrix'`: Confusion matrix (2D array).\n\nInput:\n```python\ny_true = [0, 1, 1, 0, 1]\nhat_y_pred = [0.2, 0.8, 0.6, 0.1, 0.9]\nthreshold = 0.5\n```\n\nOutput:\n```python\n{\n    'n_samples': 5, \n    'prevalence': 0.6, \n    'accuracy': 1.0, \n    'precision': 1.0, \n    'recall': 1.0, \n    'roc_auc': 1.0, \n    'pr_auc': 1.0, \n    'confusion_matrix': array([[2, 0], [0, 3]])\n}\n```", "ground_truth_code": "from sklearn.metrics import (\n    accuracy_score,\n    precision_score,\n    recall_score,\n    roc_auc_score,\n    average_precision_score,\n    confusion_matrix\n)\nimport numpy as np\n\n# main code\ndef score_binary_classification(y_true, hat_y_pred, threshold):\n    y_true, hat_y_pred = np.asarray(y_true), np.asarray(hat_y_pred)\n    hat_y = hat_y_pred >= threshold\n\n    return {\n        'n_samples': len(y_true),\n        'prevalence': np.mean(y_true),\n        'accuracy': accuracy_score(y_true, hat_y),\n        'precision': precision_score(y_true, hat_y),\n        'recall': recall_score(y_true, hat_y),\n        'roc_auc': roc_auc_score(y_true, hat_y_pred),\n        'pr_auc': average_precision_score(y_true, hat_y_pred),\n        'confusion_matrix': confusion_matrix(y_true, hat_y)\n    }\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 1001)\n\n        y_true = np.random.choice([0, 1], size=num_samples)\n        hat_y_pred = np.random.rand(num_samples)\n        threshold = np.random.rand()\n\n        test_cases.append((y_true, hat_y_pred, threshold))\n\n    return test_cases"}
{"problem_id": "sklearn_60", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a linear support vector classifier using a custom scoring method based on recall. The function will utilize grid search to find the best hyperparameters for the classifier.\n\nFunction signature:\n```python\ndef compare_scorers(X, y, param_grid):\n```\n\nIn this function, the following constant is used:\n- `cv`: This constant is set to `5`, which indicates the number of cross-validation folds to be used during the grid search.\n\nInput format:\n- `X`: A 2D array-like structure representing the feature data.\n- `y`: A 1D array-like structure representing the target labels.\n- `param_grid`: A dictionary or list of dictionaries containing the hyperparameters to be tested during the grid search.\n\nOutput format:\n- The function returns a float value representing the best recall score achieved during the grid search.\n\nInput:\n```python\nX = array([[ 1.48846306,  0.64338537,  1.12467714],\n           ...,\n           [ 0.8669767 ,  0.07912218, -0.04965382]])\ny = array([1, 1, 1, 0, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1, 0, 0,\n       1, 0, 0, 0, 1, 0, 1, 1, 0, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1, 1, 0,\n       0, 1, 1, 0, 0, 1])\nparam_grid = {'C': [0.001, 1.0, 1000.0], 'max_iter': [1000, 5000, 10000]}\n```\n\nOutput:\n```\n0.96\n```", "ground_truth_code": "from sklearn.svm import LinearSVC\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics import recall_score\n\n\n# main code\ndef compare_scorers(X, y, param_grid):\n    def custom_scorer(est, X, y):\n        y_pred = est.predict(X)\n        return recall_score(y, y_pred)\n\n    est = LinearSVC()\n\n    search_callable = GridSearchCV(est, param_grid, scoring=custom_scorer, cv=5, refit=True, n_jobs=-1)\n\n    search_callable.fit(X, y)\n\n    return search_callable.best_score_", "test_script": "import numpy as np\nfrom sklearn.datasets import make_classification\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(50, 200)\n        n_features = np.random.randint(3, 20)\n\n        X, y = make_classification(n_samples=n_samples, n_features=n_features,\n                                   n_informative=max(2, n_features // 2), n_redundant=0,\n                                   n_classes=2, random_state=np.random.randint(0, 10000))\n\n        param_grid = {\n            'C': np.logspace(-3, 3, num=np.random.randint(2, 5)).tolist(),\n            'max_iter': [1000, 5000, 10000]\n        }\n\n        test_cases.append((X, y, param_grid))\n\n    return test_cases"}
{"problem_id": "sklearn_61", "library": "sklearn", "code_problem": "The task is to implement a function that evaluates the performance of a machine learning model based on the type of problem (classification or regression). The function will fit the model to the training data, make predictions on both the training and testing datasets, and then compute relevant performance metrics.\n\nFunction Signature:\n```python\ndef evaluate_model(model, X_train, y_train, X_test, y_test, problem_type):\n```\n\nConstant Used:\n- The constant used in the main code is the string values 'Classification' and 'Regression' to determine the type of problem being evaluated.\n\nInput Format:\n- `model`: A machine learning model object that has `fit` and `predict` methods.\n- `X_train`: A 2D array-like structure containing the training features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `X_test`: A 2D array-like structure containing the testing features.\n- `y_test`: A 1D array-like structure containing the testing labels.\n- `problem_type`: A string indicating the type of problem ('Classification' or 'Regression').\n\nOutput Format:\n- The function returns a dictionary containing the calculated metrics based on the problem type. The keys of the dictionary will vary depending on whether the problem is a classification or regression task.\n\n**Input:**\n```python\nmodel = LogisticRegression()\nX_train = np.array([[0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6]])\ny_train = np.array([0, 0, 1, 1, 1])\nX_test = np.array([[0.15, 0.25], [0.35, 0.45]])\ny_test = np.array([0, 1])\nproblem_type = 'Classification'\n```\n\n**Output:**\n```python\n{'train_accuracy': 0.6, 'train_f1': 0.45, 'test_accuracy': 0.5, 'test_f1': 0.333}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import accuracy_score, f1_score, mean_squared_error\n\n# main code\ndef evaluate_model(model, X_train, y_train, X_test, y_test, problem_type):\n    model.fit(X_train, y_train)\n    y_train_pred = model.predict(X_train)\n    y_test_pred = model.predict(X_test)\n    if problem_type == 'Classification':\n        metrics = {'train_accuracy': np.round(accuracy_score(y_train, y_train_pred), 3), 'train_f1': np.round(f1_score(y_train, y_train_pred, average='weighted'), 3), 'test_accuracy': np.round(accuracy_score(y_test, y_test_pred), 3), 'test_f1': np.round(f1_score(y_test, y_test_pred, average='weighted'), 3)}\n    elif problem_type == 'Regression':\n        metrics = {'train_mse': np.round(mean_squared_error(y_train, y_train_pred), 3), 'train_rmse': np.round(mean_squared_error(y_train, y_train_pred), 3), 'test_mse': np.round(mean_squared_error(y_test, y_test_pred), 3), 'test_rmse': np.round(mean_squared_error(y_test, y_test_pred), 3)}\n    else:\n        metrics = {}\n    return metrics", "test_script": "import numpy as np\nfrom sklearn.linear_model import LogisticRegression, LinearRegression\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\nfrom sklearn.datasets import make_classification, make_regression\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        problem_type = np.random.choice(['Classification', 'Regression'])\n        n_samples_train, n_samples_test = np.random.randint(50, 200, size=2)\n        n_features = np.random.randint(5, 20)\n\n        if problem_type == 'Classification':\n            X_train, y_train = make_classification(n_samples=n_samples_train, n_features=n_features,\n                                                   random_state=np.random.randint(1000))\n            X_test, y_test = make_classification(n_samples=n_samples_test, n_features=n_features,\n                                                 random_state=np.random.randint(1000))\n            model = np.random.choice([LogisticRegression(), RandomForestClassifier()])\n        else:\n            X_train, y_train = make_regression(n_samples=n_samples_train, n_features=n_features,\n                                               random_state=np.random.randint(1000))\n            X_test, y_test = make_regression(n_samples=n_samples_test, n_features=n_features,\n                                             random_state=np.random.randint(1000))\n            model = np.random.choice([LinearRegression(), RandomForestRegressor()])\n\n        test_cases.append((model, X_train, y_train, X_test, y_test, problem_type))\n\n    return test_cases\n"}
{"problem_id": "sklearn_62", "library": "sklearn", "code_problem": "You are tasked with implementing a function that optimizes a decision tree model for either classification or regression tasks based on a given dataset. The function will determine the optimal depth of the decision tree by evaluating its performance using cross-validation.\n\nFunction signature:\n```python\ndef optimize(df, __qnt_num, t_type, cv, scoring, min_samples_leaf):\n```\n\n### Constants:\n- The constant used in the main code is `max_depth`, which is calculated as `int(np.log2(__qnt_num)) + 1`.\n\n### Input and Output Format:\n- **Input Format**: The function takes a DataFrame `df` and several parameters as described above.\n- **Output Format**: The function returns a sorted array of optimal bins (thresholds) as a NumPy array.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'X': [10, 20, 30, 40, 50, 60, 70, 80, 90, 100],\n    'Y': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n    'labels': ['l_0', 'l_1', 'l_2', 'l_3', 'l_4', 'l_5', 'l_6', 'l_7', 'l_8', 'l_9']\n}\ndf = pd.DataFrame(data)\n\n__qnt_num = 10\nt_type = 'b'  # binary classification\ncv = 3\nscoring = 'accuracy'\nmin_samples_leaf = 1\n\n# Call the optimize function\nopt_bins = optimize(df, __qnt_num, t_type, cv, scoring, min_samples_leaf)\n```\n\n**Output:**\n```python\narray([15.])\n```\n", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import cross_val_score\nfrom sklearn import tree\n\n# main code\ndef optimize(df, __qnt_num, t_type, cv, scoring, min_samples_leaf):\n    tree_type = tree.DecisionTreeClassifier if t_type == 'b' else tree.DecisionTreeRegressor\n    max_depth = int(np.log2(__qnt_num)) + 1\n    mask = df['labels'].apply(lambda z: not z.startswith('d_'))\n    x_train = np.array(df.loc[mask, 'X']).reshape(-1, 1)\n    y_train = np.array(df.loc[mask, 'Y'])\n\n    if t_type == 'b':\n        y_train = y_train.astype(int)\n    elif t_type == 'r':\n        y_train = y_train.astype(float)\n\n    if scoring == 'accuracy' and t_type == 'r':\n        scoring = 'r2'\n\n    cv_scores = []\n    for depth in range(1, max_depth):\n        model = tree_type(max_depth=depth, min_samples_leaf=min_samples_leaf)\n        scores = cross_val_score(model, x_train, y_train, cv=cv, scoring=scoring)\n        cv_scores.append(scores.mean())\n\n    best_depth = np.argmax(cv_scores) + 1\n    final_tree = tree_type(max_depth=best_depth, min_samples_leaf=min_samples_leaf)\n    final_tree.fit(x_train, y_train)\n    opt_bins = np.sort(final_tree.tree_.threshold[final_tree.tree_.feature >= 0])\n    return opt_bins\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        X = np.random.rand(num_samples) * 100\n        Y = np.random.randint(0, 2, size=num_samples)\n        labels = [f\"d_{i}\" if random.random() < 0.2 else f\"l_{i}\" for i in range(num_samples)]\n        df = pd.DataFrame({'X': X, 'Y': Y, 'labels': labels})\n        __qnt_num = random.randint(5, 20)\n        t_type = random.choice(['r', 'b'])\n        cv = random.choice([3, 5])\n        scoring = random.choice([None, 'accuracy', 'r2', 'neg_mean_squared_error'])\n        min_samples_leaf = random.randint(1, 3)\n\n        test_cases.append((df, __qnt_num, t_type, cv, scoring, min_samples_leaf))\n\n    return test_cases"}
{"problem_id": "sklearn_63", "library": "sklearn", "code_problem": "You are tasked with implementing a function that fits a model to a dataset using a combination of a forest model and local linear regression or averaging. The function will split the dataset into training and testing sets, fit the forest model on the training data, and then apply the fitted model to the test data to obtain predictions for each leaf node in the forest. Depending on the specified parameters, the function will either fit a local linear model or compute the average of the target values for the data points that fall into each leaf.\n\nFunction signature:\n```python\ndef fit_model(X, y, sample_weight, forest, alpha, local_linear):\n```\n\nConstants used in the main code:\n- The constant `0.5` is used to specify the test size when splitting the dataset.\n\nInput format:\n- `X`: A 2D array-like structure representing the feature matrix.\n- `y`: A 1D array-like structure representing the target variable.\n- `sample_weight`: A 1D array-like structure representing the weights for the samples (optional).\n- `forest`: A fitted forest model object.\n- `alpha`: A float representing the regularization strength for the ElasticNet model.\n- `local_linear`: A boolean indicating whether to use local linear regression.\n\nOutput format:\n- Returns a list of dictionaries, where each dictionary corresponds to a tree in the forest and contains either fitted models or average values for each leaf.\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3],\n              [0.4, 0.5, 0.6],\n              [0.7, 0.8, 0.9],\n              [0.2, 0.3, 0.4],\n              [0.5, 0.6, 0.7]])\ny = np.array([0.1, 0.4, 0.7, 0.2, 0.5])\nsample_weight = np.array([1, 1, 1, 1, 1])\nforest = RandomForestRegressor(n_estimators=10, max_depth=5, random_state=42)\nalpha = 0.5\nlocal_linear = True\n```\n\nOutput:\n```python\n[{0: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {0: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {0: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {0: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}, \n {1: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))]), 2: Pipeline(steps=[('bias', PolynomialFeatures(degree=1)),\n                ('lasso', ElasticNet(alpha=0.5))])}]\n```\n\n(Note: The actual output will depend on the random state and the specific data used, so the exact values in `mu_leafs` may vary.)", "ground_truth_code": "from sklearn.model_selection import train_test_split\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.preprocessing import PolynomialFeatures\nfrom sklearn.linear_model import ElasticNet\nimport numpy as np\n\n\n# main code\ndef fit_model(X, y, sample_weight, forest, alpha, local_linear):\n\n    split_data = train_test_split(X, y, sample_weight, test_size=0.5, shuffle=True) if sample_weight is not None \\\n        else train_test_split(X, y, test_size=0.5, shuffle=True)\n\n    X_train, X_test, y_train, y_test = split_data[:4]\n    sample_weight_train, sample_weight_test = split_data[4:] if sample_weight is not None else (None, None)\n\n    forest.fit(X_train, y_train, sample_weight=sample_weight_train)\n\n    leaf_test = forest.apply(X_test)\n    mu_leafs = [{} for _ in range(leaf_test.shape[1])]\n\n    for tree_idx, tree_leaves in enumerate(leaf_test.T):\n        for leaf in np.unique(tree_leaves):\n            mask = tree_leaves == leaf\n            X_leaf, y_leaf = X_test[mask], y_test[mask]\n            weights = sample_weight_test[mask] if sample_weight is not None else None\n\n            if local_linear:\n                model = Pipeline([\n                    ('bias', PolynomialFeatures(degree=1, include_bias=True)),\n                    ('lasso', ElasticNet(alpha=alpha))\n                ])\n                model.fit(X_leaf, y_leaf, lasso__sample_weight=weights)\n                mu_leafs[tree_idx][leaf] = model\n            else:\n                mu_leafs[tree_idx][leaf] = np.average(y_leaf, weights=weights)\n\n    return mu_leafs\n", "test_script": "import numpy as np\nfrom sklearn.ensemble import RandomForestRegressor\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_features = np.random.randint(3, 20)\n\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.rand(num_samples)\n        sample_weight = np.random.rand(num_samples) if np.random.rand() > 0.5 else None\n\n        forest = RandomForestRegressor(n_estimators=10, max_depth=5, random_state=42)\n        alpha = np.random.uniform(0.001, 1.0)\n        local_linear = np.random.choice([True, False])\n\n        test_cases.append((X, y, sample_weight, forest, alpha, local_linear))\n\n    return test_cases"}
{"problem_id": "sklearn_64", "library": "sklearn", "code_problem": "You are tasked with creating a function that builds a machine learning model based on the specified type and fitting behavior. The function should support multiple regression algorithms and allow for the option to fit the model separately for multiple outputs.\n\nFunction signature:\n```python\ndef build_model(model_type: str, fit_separate: bool) -> object:\n```\n\nConstant used in the main code:\n- The constant used in the SVR model is `C=1.0` and `epsilon=0.2`.\n\nInput format:\n- `model_type`: A string representing the type of regression model to build (e.g., \"linear_model\", \"SVR\", \"GradientBoostingRegressor\", \"sgdregressor\").\n- `fit_separate`: A boolean indicating whether to fit the model separately for multiple outputs.\n\nOutput format:\n- The function returns an object representing the constructed regression model, which can be either a single model or a MultiOutputRegressor instance, depending on the `fit_separate` parameter.\n\n```python\nInput: ('SVR', False)\nOutput: MultiOutputRegressor(estimator=LinearRegression())\n\n```", "ground_truth_code": "from sklearn import linear_model\nfrom sklearn.multioutput import MultiOutputRegressor\nfrom sklearn.svm import SVR\nfrom sklearn.ensemble import GradientBoostingRegressor\nfrom sklearn.linear_model import SGDRegressor\n\n# main code\ndef build_model(model_type, fit_separate):\n    model_mapping = {\n        'linear_model': linear_model.LinearRegression,\n        'SVR': lambda: SVR(C=1.0, epsilon=0.2),\n        'GradientBoostingRegressor': GradientBoostingRegressor,\n        'sgdregressor': SGDRegressor\n    }\n\n    model_type = model_type.lower()\n    model = model_mapping.get(model_type, linear_model.LinearRegression)()\n\n    if not fit_separate:\n        single_model = model\n        model = MultiOutputRegressor(single_model)\n\n    return model", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    model_types = ['linear_model', 'SVR', 'GradientBoostingRegressor', 'sgdregressor']\n\n    for _ in range(n):\n        model_type = random.choice(model_types)\n        fit_separate = random.choice([True, False])\n\n        test_cases.append((model_type, fit_separate))\n\n    return test_cases"}
{"problem_id": "sklearn_65", "library": "sklearn", "code_problem": "You are tasked with creating a function that builds a text classification model using either a Multinomial Naive Bayes (MNB) classifier or a Support Vector Machine (SVM) classifier. The function should preprocess the text data, split it into training and testing sets, train the selected classifier, and evaluate its accuracy.\n\nFunction Signature:\n```python\ndef create_classifier(df, classification_type='MNB', test_size=0.3):\n```\n\nConstants:\n- The constant used in the main code is `test_size`, which defaults to `0.3`.\n\nInput Format:\n- The input to the function is a DataFrame `df` with two columns: 'text' (string) and 'label' (categorical).\n\nOutput Format:\n- The output of the function is a dictionary containing:\n  - 'vectorizer': the fitted `TfidfVectorizer` object,\n  - 'classifier': the trained classifier object (either `MultinomialNB` or `SVC`),\n  - 'accuracy': a float representing the accuracy of the classifier on the test set. If the classification type is invalid, the output is `None`.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    'text': [\n        \"The quick brown fox jumps over the lazy dog.\",\n        \"Never gonna give you up, never gonna let you down.\",\n        \"To be or not to be, that is the question.\",\n        \"All that glitters is not gold.\",\n        \"A journey of a thousand miles begins with a single step.\"\n    ],\n    'label': [0, 1, 0, 1, 0]\n}\ndf = pd.DataFrame(data)\n\nclassification_type = 'MNB'\ntest_size = 0.4\n```\n\n**Output:**\n```python\n{\n    'vectorizer': TfidfVectorizer(), \n    'classifier': MultinomialNB(), \n    'accuracy': 0.5\n}\n```", "ground_truth_code": "from sklearn.feature_extraction.text import TfidfVectorizer\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.svm import SVC\n\n\n# main code\ndef create_classifier(df, classification_type='MNB', test_size=0.3):\n    vectorizer = TfidfVectorizer(analyzer='word', lowercase=True)\n    X = vectorizer.fit_transform(df['text'])\n\n    num_classes = len(df['label'].unique())\n    min_test_size = num_classes / len(df)\n\n    test_size = max(test_size, min_test_size)\n\n    stratify_option = df['label'] if test_size * len(df) >= num_classes else None\n\n    X_train, X_test, y_train, y_test = train_test_split(X, df['label'], test_size=test_size, stratify=stratify_option)\n\n    classifiers = {\n        'MNB': MultinomialNB(),\n        'SVM': SVC(kernel='linear')\n    }\n\n    if classification_type in classifiers:\n        classifier = classifiers[classification_type]\n        classifier.fit(X_train, y_train)\n        preds = classifier.predict(X_test)\n\n        accuracy = accuracy_score(y_test, preds)\n\n        return {\n            'vectorizer': vectorizer,\n            'classifier': classifier,\n            'accuracy': accuracy\n        }\n\n    return None\n", "test_script": "import random\nimport pandas as pd\nfrom sklearn.datasets import fetch_20newsgroups\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    dataset = fetch_20newsgroups(subset='all', remove=('headers', 'footers', 'quotes'))\n    texts, labels = dataset.data, dataset.target\n    num_classes = len(set(labels))\n\n    for _ in range(n):\n        sample_size = random.randint(max(50, 2 * num_classes), 500)\n        indices = random.sample(range(len(texts)), sample_size)\n\n        df = pd.DataFrame({\n            'text': [texts[i] for i in indices],\n            'label': [labels[i] for i in indices]\n        })\n\n        class_counts = df['label'].value_counts()\n        df = df[df['label'].isin(class_counts[class_counts > 1].index)]\n\n        test_size = round(random.uniform(0.1, 0.5), 2)\n        test_size = max(test_size, num_classes / len(df))\n\n        classification_type = random.choice(['MNB', 'SVM'])\n\n        test_cases.append((df, classification_type, test_size))\n\n    return test_cases\n"}
{"problem_id": "sklearn_66", "library": "sklearn", "code_problem": "You are tasked with creating a function that imputes missing values in a dataset using various strategies. The function should allow the user to specify the imputation method and any additional parameters required for that method.\n\nFunction signature:\n```python\ndef impute_missing_data(data, method, kwargs):\n```\n\nConstant used in the main code:\n- The default fill value for the 'constant' imputation method is set to `0`.\n\nInput format:\n- `data`: A 2D array or DataFrame containing numerical values with some missing entries.\n- `method`: A string indicating the imputation method to use.\n- `kwargs`: A dictionary containing additional parameters for the imputation method.\n\nOutput format:\n- The function returns a 2D array or DataFrame with the same shape as `data`, where missing values have been filled according to the specified imputation method.\n\n**Input:**\n```python\ndata = np.array([[1, 2, np.nan],\n                 [4, np.nan, 6],\n                 [np.nan, 8, 9]])\n\nmethod = 'mean'\nkwargs = {}\n```\n\n**Output:**\n```python\narray([[1. , 2. , 7.5],\n       [4. , 5. , 6. ],\n       [2.5, 8. , 9. ]])\n```", "ground_truth_code": "from sklearn.impute import SimpleImputer, KNNImputer\n\n\n# main code\ndef impute_missing_data(data, method, kwargs):\n    imputation_methods = {\n        'mean': SimpleImputer(strategy='mean'),\n        'median': SimpleImputer(strategy='median'),\n        'most_frequent': SimpleImputer(strategy='most_frequent'),\n        'constant': SimpleImputer(strategy='constant', fill_value=kwargs.get('fill_value', 0)),\n        'KNN': KNNImputer(n_neighbors=kwargs.get('n_neighbors', 5))\n    }\n\n    imputer = imputation_methods.get(method, SimpleImputer(strategy='mean'))\n    imputer.fit(data)\n    return imputer.transform(data)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    methods = ['mean', 'median', 'most_frequent', 'constant', 'KNN']\n\n    for _ in range(n):\n        rows = np.random.randint(5, 21)\n        cols = np.random.randint(5, 21)\n\n\n        data = np.random.randn(rows, cols)\n        mask = np.random.rand(rows, cols) < 0.2\n        data[mask] = np.nan\n\n        method = np.random.choice(methods)\n        kwargs = {}\n\n        if method == 'constant':\n            kwargs['fill_value'] = np.random.uniform(-10, 10)\n        elif method == 'KNN':\n            kwargs['n_neighbors'] = np.random.randint(1, min(6, rows))\n\n        test_cases.append((data, method, kwargs))\n\n    return test_cases\n"}
{"problem_id": "sklearn_67", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a binary classification model using various statistical metrics. The function will compute the confusion matrix, sensitivity, specificity, accuracy, Matthews correlation coefficient (MCC), and the area under the precision-recall curve (AUC-PRC) and the area under the ROC curve (AUC-ROC).\n\nThe function signature is as follows:\n```python\ndef statistical(y_true, y_pred, y_pro):\n```\n\n### Constants Used:\n- A small constant `1e-08` is used to prevent division by zero when calculating the Matthews correlation coefficient (MCC).\n\n### Input and Output Format:\n- **Input Format**:\n  - The function takes three parameters: `y_true`, `y_pred`, and `y_pro`, which are expected to be lists or arrays of numerical values representing the true labels, predicted labels, and predicted probabilities, respectively.\n\n- **Output Format**:\n  - The function returns a tuple containing the following values in order: `(tn, fp, fn, tp, se, sp, acc, mcc, auc_prc, auc_roc)`, where each value is a numerical metric representing the performance of the classification model.\n\nInput:\n```python\ny_true = np.array([1, 0, 1, 1, 0, 0, 1, 0, 1, 0])\ny_pred = np.array([1, 0, 1, 0, 0, 1, 1, 0, 0, 0])\ny_pro = np.array([0.9, 0.1, 0.8, 0.4, 0.2, 0.7, 0.6, 0.3, 0.5, 0.05])\n```\n\nOutput:\n```python\n(4, 1, 2, 3, 0.6, 0.8, 0.7, 0.40824829046046096, 0.8599999999999999, 0.8800000000000001)\n```", "ground_truth_code": "from sklearn.metrics import confusion_matrix, auc, roc_auc_score, precision_recall_curve\nimport numpy as np\n\n# main code\ndef statistical(y_true, y_pred, y_pro):\n    c_mat = confusion_matrix(y_true, y_pred)\n    tn, fp, fn, tp = c_mat.ravel()\n\n    se = tp / (tp + fn) if (tp + fn) > 0 else 0\n    sp = tn / (tn + fp) if (tn + fp) > 0 else 0\n    acc = (tp + tn) / (tn + fp + fn + tp) if (tn + fp + fn + tp) > 0 else 0\n    mcc_denominator = np.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn) + 1e-08)\n    mcc = (tp * tn - fp * fn) / mcc_denominator if mcc_denominator > 0 else 0\n\n    precision, recall, _ = precision_recall_curve(y_true, y_pro, pos_label=1)\n    auc_prc = auc(recall, precision)\n    auc_roc = roc_auc_score(y_true, y_pro)\n\n    return tn, fp, fn, tp, se, sp, acc, mcc, auc_prc, auc_roc", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(50, 500)\n        y_true = np.random.randint(0, 2, size)\n        y_pred = np.random.randint(0, 2, size)\n        y_pro = np.random.rand(size)\n\n        test_cases.append((y_true, y_pred, y_pro))\n\n    return test_cases"}
{"problem_id": "sklearn_68", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates various performance metrics for a multi-class classification problem based on the true labels and predicted labels of a model. The function will compute the confusion matrix and derive metrics such as True Positive Rate (TPR), True Negative Rate (TNR), Positive Predictive Value (PPV), and overall Accuracy (ACC) for each class, as well as the macro-average accuracy across all classes.\n\nFunction signature:\n```python\ndef evaluate_metrics(y_true, y_pred, n_classes):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `np.nan_to_num`, which is employed to handle any potential NaN values that may arise during the calculation of metrics.\n\nInput format:\n- `y_true`: A list or array of true labels (integers).\n- `y_pred`: A list or array of predicted labels (integers).\n- `n_classes`: An integer representing the number of unique classes.\n\nOutput format:\n- A tuple containing:\n  - `ACC_macro`: A float representing the macro-average accuracy.\n  - `ACC`: A numpy array of floats representing the accuracy for each class.\n  - `TPR`: A numpy array of floats representing the true positive rate for each class.\n  - `TNR`: A numpy array of floats representing the true negative rate for each class.\n  - `PPV`: A numpy array of floats representing the positive predictive value for each class.\n  - `conf_matrix`: A numpy array representing the confusion matrix.\n\n```python\n# Input\ny_true = np.array([0, 1, 2, 1, 0, 2, 1, 0, 2, 1])\ny_pred = np.array([0, 1, 1, 1, 0, 2, 0, 0, 2, 1])\nn_classes = 3\n\n# Output\n(0.8666666666666667, \n array([0.9, 0.8, 0.9]), \n array([1.        , 0.75      , 0.66666667]), \n array([0.85714286, 0.83333333, 1.        ]), \n array([0.75, 0.75, 1.  ]),\n array([[3, 0, 0],\n       [1, 3, 0],\n       [0, 1, 2]])\n )\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import confusion_matrix\n\n\n# main code\ndef evaluate_metrics(y_true, y_pred, n_classes):\n    conf_matrix = confusion_matrix(y_true, y_pred, labels=np.arange(n_classes))\n\n    if conf_matrix.size == 0:\n        return None\n\n    FP = conf_matrix.sum(axis=0) - np.diag(conf_matrix)\n    FN = conf_matrix.sum(axis=1) - np.diag(conf_matrix)\n    TP = np.diag(conf_matrix)\n    TN = conf_matrix.sum() - (FP + FN + TP)\n\n    TPR = np.nan_to_num(TP / (TP + FN))\n    TNR = np.nan_to_num(TN / (TN + FP))\n    PPV = np.nan_to_num(TP / (TP + FP))\n    ACC = np.nan_to_num((TP + TN) / (TP + FP + FN + TN))\n\n    ACC_macro = np.mean(ACC) if ACC.size > 0 else 0.0\n\n    return ACC_macro, ACC, TPR, TNR, PPV, conf_matrix\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_classes = np.random.randint(3, 20)\n\n        num_samples = np.random.randint(50, 500)\n\n        y_true = np.random.randint(0, n_classes, size=num_samples)\n        y_pred = np.random.randint(0, n_classes, size=num_samples)\n\n        test_cases.append((y_true, y_pred, n_classes))\n\n    return test_cases"}
{"problem_id": "sklearn_69", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a bagging ensemble method for classification tasks. The function will take in true labels, predicted labels from multiple classifiers, and a log set of classifiers, and it will compute various performance metrics based on the predictions.\n\nFunction Signature:\n```python\ndef bagging(labels: list, pred_labels: list, logset: list) -> dict:\n```\n\nConstant Used:\n- `num_clf`: This constant represents the number of classifiers in the ensemble, calculated as the length of the `logset`.\n\nInput Format:\n- `labels`: A list of true labels (binary classification).\n- `pred_labels`: A list of lists where each inner list contains predicted labels from individual classifiers.\n- `logset`: A list of classifiers used for bagging.\n\nOutput Format:\n- A dictionary containing:\n  - \"bagging_result\": The final predicted labels after bagging.\n  - \"balanced_accuracy\": The balanced accuracy score.\n  - \"precision\": The precision score.\n  - \"confusion_matrix\": The confusion matrix.\n  - \"recall\": The recall score.\n  - \"f1_score\": The F1 score.\n  - \"negative_accuracy\": The negative accuracy.\n  - \"positive_accuracy\": The positive accuracy.\n\nInput:\n```python\nlabels = np.array([[1, 0, 1, 1, 0]])\npred_labels = np.array([[1, 0, 1, 0, 0],\n                         [1, 1, 1, 1, 0],\n                         [0, 0, 1, 1, 0]])\nlogset = [None, None, None]\n```\n\nOutput:\n```python\n{\n    'bagging_result': array([1, 0, 1, 1, 0]), \n    'balanced_accuracy': 1.0, \n    'precision': 1.0, \n    'confusion_matrix': array([[2, 0], [0, 3]]), \n    'recall': 1.0, \n    'f1_score': 1.0, \n    'negative_accuracy': 1.0, \n    'positive_accuracy': 1.0\n}\n```", "ground_truth_code": "from sklearn.metrics import (\n    balanced_accuracy_score, precision_score, confusion_matrix,\n    recall_score, f1_score\n)\nimport numpy as np\n\n# main code\ndef bagging(labels, pred_labels, logset):\n    num_clf = len(logset)\n    all_pred_labels = np.array(pred_labels).sum(axis=0)\n    bagging_result = (all_pred_labels > num_clf / 2).astype(int)\n\n    bacc = balanced_accuracy_score(labels[0], bagging_result)\n    tp = precision_score(labels[0], bagging_result)\n    cm = confusion_matrix(labels[0], bagging_result)\n    recall = recall_score(labels[0], bagging_result)\n    f1 = f1_score(labels[0], bagging_result)\n\n    nacc = cm[0][0] / sum(cm[0]) if sum(cm[0]) > 0 else 0.0\n    pacc = cm[1][1] / sum(cm[1]) if sum(cm[1]) > 0 else 0.0\n\n    return {\n        \"bagging_result\": bagging_result,\n        \"balanced_accuracy\": bacc,\n        \"precision\": tp,\n        \"confusion_matrix\": cm,\n        \"recall\": recall,\n        \"f1_score\": f1,\n        \"negative_accuracy\": nacc,\n        \"positive_accuracy\": pacc\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_clf = np.random.randint(2, 10)\n        labels = np.random.randint(0, 2, size=(1, num_samples))\n        pred_labels = np.random.randint(0, 2, size=(num_clf, num_samples))\n\n        logset = [None] * num_clf\n\n        test_cases.append((labels, pred_labels, logset))\n\n    return test_cases\n"}
{"problem_id": "sklearn_70", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a classification model while considering fairness across different groups defined by a protected attribute. The function should compute various evaluation metrics and assess the disparity in these metrics across the groups.\n\nFunction Signature:\n```python\ndef gap_eval_scores(y_pred, y_true, protected_attribute, metrics=['TPR', 'FPR', 'PPR'], args=None):\n```\n\n### Constants Used:\n- `epsilon = 1e-5`: A small constant added to avoid division by zero in calculations.\n\n### Input Format:\n- `y_pred`: A list or array of predicted labels.\n- `y_true`: A list or array of true labels.\n- `protected_attribute`: A list or array indicating the protected attribute for each instance.\n- `metrics`: An optional list of metrics to evaluate gaps (default is `['TPR', 'FPR', 'PPR']`).\n- `args`: An optional object that may contain parameters for regression evaluation.\n\n### Output Format:\n- Returns a tuple containing:\n  - A dictionary of evaluation scores (e.g., accuracy, F1 scores, and gap metrics).\n  - A dictionary of confusion matrices for overall and group-wise evaluations.\n\n**Input:**\n```python\ny_pred = [0, 1, 1, 0, 1, 0, 1, 0]\ny_true = [0, 1, 0, 0, 1, 1, 1, 0]\nprotected_attribute = [0, 0, 1, 1, 0, 1, 1, 0]\nmetrics = ['TPR', 'FPR']\nargs = None\n```\n\n**Output:**\n```python\neval_scores = {'accuracy': 0.75, 'macro_fscore': 0.75, 'micro_fscore': 0.75, 'TPR_GAP': 0.4999950000499994, 'FPR_GAP': 0.5000025000125001}\n\nconfusion_matrices = {\n    'overall': array([[3, 1],[1, 3]]), 0: array([[2, 0],[0, 2]]), 1: array([[1, 1],[1, 1]])\n}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import confusion_matrix, mean_absolute_error, mean_squared_error, r2_score, accuracy_score, \\\n    f1_score\nimport pandas as pd\n\n\ndef power_mean(series, p, axis=0):\n    if p > 50:\n        return np.max(series, axis=axis)\n    elif p < -50:\n        return np.min(series, axis=axis)\n    else:\n        total = np.mean(np.power(series, p), axis=axis)\n        return np.power(total, 1 / p)\n\n\ndef confusion_matrix_based_scores(cnf):\n    epsilon = 1e-5\n    FP = cnf.sum(axis=0) - np.diag(cnf) + epsilon\n    FN = cnf.sum(axis=1) - np.diag(cnf) + epsilon\n    TP = np.diag(cnf) + epsilon\n    TN = cnf.sum() - (FP + FN + TP) + epsilon\n\n    scores = {\n        'TPR': TP / (TP + FN),\n        'TNR': TN / (TN + FP),\n        'PPV': TP / (TP + FP),\n        'NPV': TN / (TN + FN),\n        'FPR': FP / (FP + TN),\n        'FNR': FN / (TP + FN),\n        'FDR': FP / (TP + FP),\n        'ACC': (TP + TN) / (TP + FP + FN + TN),\n        'PPR': (TP + FP) / (TP + FP + FN + TN)\n    }\n    return scores\n\n\ndef aggregation_gap(distinct_groups, all_scores, metric='TPR', group_agg_power=None, class_agg_power=2):\n    group_scores = [all_scores[gid][metric] for gid in distinct_groups]\n    Scores = np.stack(group_scores, axis=1)\n    score_gaps = Scores - all_scores['overall'][metric].reshape(-1, 1)\n\n    if group_agg_power is None:\n        score_gaps = np.sum(abs(score_gaps), axis=1)\n    else:\n        score_gaps = power_mean(score_gaps, p=group_agg_power, axis=1)\n\n    return power_mean(score_gaps, class_agg_power)\n\n\n# main code\ndef gap_eval_scores(y_pred, y_true, protected_attribute, metrics=['TPR', 'FPR', 'PPR'], args=None):\n    y_pred = np.array(y_pred)\n    y_true = np.array(y_true)\n    protected_attribute = np.array(protected_attribute)\n\n    if args is not None and getattr(args, 'regression', False):\n        eval_scores = {\n            'mean_absolute_error': mean_absolute_error(y_true, y_pred),\n            'mean_squared_error': mean_squared_error(y_true, y_pred),\n            'r2_score': r2_score(y_true, y_pred)\n        }\n        y_true = pd.cut(np.squeeze(y_true), bins=args.regression_bins, labels=False, duplicates='drop')\n        y_pred = pd.cut(np.squeeze(y_pred), bins=args.regression_bins, labels=False, duplicates='drop')\n        y_true = np.nan_to_num(y_true, nan=0)\n        y_pred = np.nan_to_num(y_pred, nan=0)\n    else:\n        eval_scores = {\n            'accuracy': accuracy_score(y_true, y_pred),\n            'macro_fscore': f1_score(y_true, y_pred, average='macro'),\n            'micro_fscore': f1_score(y_true, y_pred, average='micro')\n        }\n\n    all_scores = {}\n    confusion_matrices = {}\n    distinct_labels = np.unique(y_true)\n\n    overall_confusion_matrix = confusion_matrix(y_true, y_pred, labels=distinct_labels)\n    confusion_matrices['overall'] = overall_confusion_matrix\n    all_scores['overall'] = confusion_matrix_based_scores(overall_confusion_matrix)\n\n    distinct_groups = np.unique(protected_attribute)\n\n    for gid in distinct_groups:\n        group_identifier = protected_attribute == gid\n        group_confusion_matrix = confusion_matrix(y_true[group_identifier], y_pred[group_identifier],\n                                                  labels=distinct_labels)\n        confusion_matrices[gid] = group_confusion_matrix\n        all_scores[gid] = confusion_matrix_based_scores(group_confusion_matrix)\n\n    for _metric in metrics:\n        eval_scores[f'{_metric}_GAP'] = aggregation_gap(distinct_groups, all_scores, metric=_metric)\n\n    return eval_scores, confusion_matrices", "test_script": "import numpy as np\nimport random\nfrom types import SimpleNamespace\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        num_classes = random.randint(2, 10)\n        y_pred = np.random.randint(0, num_classes, size=num_samples)\n        y_true = np.random.randint(0, num_classes, size=num_samples)\n\n        num_groups = random.randint(2, 5)\n        protected_attribute = np.random.randint(0, num_groups, size=num_samples)\n\n        regression = random.choice([True, False])\n\n        if regression:\n            y_pred = np.random.uniform(-10, 10, size=num_samples)\n            y_true = np.random.uniform(-10, 10, size=num_samples)\n            args = SimpleNamespace(regression=True, regression_bins=np.linspace(-10, 10, num_classes + 1))\n        else:\n            args = None\n\n        metrics = random.sample(['TPR', 'FPR', 'PPR', 'ACC'], k=random.randint(1, 3))\n\n        test_cases.append((y_pred.tolist(), y_true.tolist(), protected_attribute.tolist(), metrics, args))\n\n    return test_cases"}
{"problem_id": "sklearn_71", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs K-means clustering on a given dataset. The function will take in a structured input containing filtered signal data and will apply clustering techniques to identify patterns in the data based on specified parameters.\n\nFunction signature:\n```python\ndef k_means_clustering(input_data, channel, clustering):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used to adjust the cluster labels for the 'a' clusters.\n\n### Input Format:\n- `input_data`: A dictionary containing filtered signal data, where `input_data['sg_filtered'][channel]` provides the data for the specified channel and `input_data['sg_filtered']['piezoresponse']` provides the piezoresponse data.\n- `channel`: A string representing the key for the specific channel in the `sg_filtered` data.\n- `clustering`: A dictionary containing the number of clusters for initial and secondary clustering, with keys `'initial_clusters'`, `'a_clusters'`, and `'c_clusters'`.\n\n### Output Format:\n- The function returns a tuple consisting of:\n  - `combined_map`: A numpy array representing the final cluster assignments for all data points.\n  - `cluster_ca`: A numpy array representing the initial cluster assignments from the first K-means clustering.\n  - `c_map`: A numpy array representing the cluster assignments for the 'c' clusters.\n  - `a_map`: A numpy array representing the cluster assignments for the 'a' clusters.\n\n**Input:**\n```python\ninput_data = {\n    'sg_filtered': {\n        'piezoresponse': np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]),\n        'channel_1': np.array([[0.2, 0.3, 0.4], [0.5, 0.6, 0.7], [0.8, 0.9, 1.0]]),\n        'channel_2': np.array([[0.3, 0.4, 0.5], [0.6, 0.7, 0.8], [0.9, 1.0, 1.1]]),\n        'channel_3': np.array([[0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [1.0, 1.1, 1.2]])\n    }\n}\nchannel = 'channel_1'\nclustering = {\n    'initial_clusters': 2,\n    'a_clusters': 1,\n    'c_clusters': 1\n}\n```\n\n**Output:**\n```python\n(array([1., 2., 2.]), array([1, 0, 0], dtype=int32), array([0., 2., 2.]), array([1., 0., 0.]))\n```", "ground_truth_code": "import numpy as np\nfrom sklearn import preprocessing as pre\nfrom sklearn import cluster\n\n# main code\ndef k_means_clustering(input_data, channel, clustering):\n    data = input_data['sg_filtered'][channel]\n    data_piezo = input_data['sg_filtered']['piezoresponse']\n\n    scaled_data = pre.StandardScaler().fit_transform(data)\n    scaled_data_piezo = pre.StandardScaler().fit_transform(data_piezo)\n\n    cluster_ca = cluster.KMeans(n_clusters=clustering['initial_clusters']).fit_predict(scaled_data_piezo)\n\n    a_map = np.zeros(data.shape[0])\n    c_map = np.zeros(data.shape[0])\n\n    if np.any(cluster_ca == 1):\n        a_cluster = cluster.KMeans(n_clusters=clustering['a_clusters']).fit_predict(scaled_data[cluster_ca == 1])\n        a_map[cluster_ca == 1] = a_cluster + 1\n\n    if np.any(cluster_ca == 0):\n        c_cluster = cluster.KMeans(n_clusters=clustering['c_clusters']).fit_predict(scaled_data[cluster_ca == 0])\n        c_map[cluster_ca == 0] = c_cluster + clustering['a_clusters'] + 1\n\n    combined_map = a_map + c_map\n    return combined_map, cluster_ca, c_map, a_map", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        num_features = np.random.randint(5, 10)\n        sg_filtered = {\n            'piezoresponse': np.random.rand(num_samples, num_features),\n            'channel_1': np.random.rand(num_samples, num_features),\n            'channel_2': np.random.rand(num_samples, num_features),\n            'channel_3': np.random.rand(num_samples, num_features)\n        }\n        channel = np.random.choice(list(sg_filtered.keys()))\n        initial_clusters = np.random.randint(2, min(num_samples, num_features))\n\n        a_clusters = np.random.randint(1, initial_clusters)\n        c_clusters = np.random.randint(1, initial_clusters)\n\n        clustering = {\n            'initial_clusters': initial_clusters,\n            'a_clusters': a_clusters,\n            'c_clusters': c_clusters\n        }\n        input_data= {'sg_filtered': sg_filtered}\n        test_cases.append((input_data, channel, clustering))\n\n    return test_cases"}
{"problem_id": "sklearn_72", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a predictive model on a given subgroup of data. The function should compute various performance metrics, including the area under the receiver operating characteristic curve (AUROC), area under the precision-recall curve (AUPRC), sensitivity, specificity, positive predictive value (PPV), and negative predictive value (NPV). Additionally, the function should have the option to perform bootstrap confidence interval estimation for the AUROC of malignant cases.\n\nFunction Signature:\n```python\ndef calculate_subgroup_performance(subgroup_df, bootstrap=False, bootstrap_nsamples=2000, cm_threshold=0.045):\n```\n\nConstant Used:\n- `cm_threshold`: A constant value set to `0.045`, which is used as the decision threshold for classifying predictions into positive and negative classes.\n\nInput Format:\n- `subgroup_df`: A DataFrame containing the following columns:\n  - 'labels_lm', 'labels_rm' for malignant labels\n  - 'preds_lm', 'preds_rm' for malignant predictions\n  - 'labels_lb', 'labels_rb' for benign labels\n  - 'preds_lb', 'preds_rb' for benign predictions\n- `bootstrap`: A boolean indicating whether to perform bootstrap confidence interval estimation (default is False).\n- `bootstrap_nsamples`: An integer specifying the number of bootstrap samples to use (default is 2000).\n- `cm_threshold`: A float representing the decision threshold for classifying predictions (default is 0.045).\n\nOutput Format:\n- A dictionary containing the following keys and their corresponding values:\n  - 'AUROC malignant': AUROC score for malignant cases\n  - 'AUROC benign': AUROC score for benign cases\n  - 'cis': (optional) confidence intervals for AUROC of malignant cases (if bootstrap is True)\n  - 'AUPRC': area under the precision-recall curve for malignant cases\n  - 'Sensitivity': sensitivity of the model for malignant cases\n  - 'Specificity': specificity of the model for malignant cases\n  - 'PPV': positive predictive value for malignant cases\n  - 'NPV': negative predictive value for malignant cases\n  - 'malignant_fpr': false positive rates for malignant cases\n  - 'malignant_tpr': true positive rates for malignant cases\n  - 'malignant_thresholds': thresholds for malignant cases\n  - 'precision': precision values for malignant cases\n  - 'recall': recall values for malignant cases\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample input data\nlabels_lm = np.array([1, 0, 1, 0, 1])\nlabels_rm = np.array([0, 1, 0, 1, 0])\nlabels_lb = np.array([1, 0, 1, 0, 1])\nlabels_rb = np.array([0, 1, 0, 1, 0])\npreds_lm = np.array([0.8, 0.2, 0.9, 0.1, 0.7])\npreds_rm = np.array([0.3, 0.6, 0.4, 0.5, 0.2])\npreds_lb = np.array([0.9, 0.1, 0.8, 0.2, 0.7])\npreds_rb = np.array([0.4, 0.5, 0.3, 0.6, 0.2])\n\nsubgroup_df = pd.DataFrame({\n    'labels_lm': labels_lm,\n    'labels_rm': labels_rm,\n    'labels_lb': labels_lb,\n    'labels_rb': labels_rb,\n    'preds_lm': preds_lm,\n    'preds_rm': preds_rm,\n    'preds_lb': preds_lb,\n    'preds_rb': preds_rb\n})\n\nbootstrap = False\nbootstrap_nsamples = None\ncm_threshold = 0.045\n```\n\nOutput:\n```python\n{\n    'AUROC malignant': 1.0, \n    'AUROC benign': 1.0, \n    'AUPRC': 1.0, \n    'Sensitivity': 1.0, \n    'Specificity': 0.0, \n    'PPV': 0.5, \n    'NPV': 0, \n    'malignant_fpr': array([0. , 0. , 0. , 0.4, 0.8, 1. ]), \n    'malignant_tpr': array([0. , 0.2, 1. , 1. , 1. , 1. ]), \n    'malignant_thresholds': array([inf, 0.9, 0.5, 0.3, 0.2, 0.1]), \n    'precision': array([0.5       , 0.55555556, 0.71428571, 0.83333333, 1.        , 1.        , 1.        , 1.        , 1.        , 1.        ]), \n    'recall': array([1. , 1. , 1. , 1. , 1. , 0.8, 0.6, 0.4, 0.2, 0. ])\n}\n```", "ground_truth_code": "from tqdm import tqdm\nimport numpy as np\nfrom sklearn.metrics import roc_auc_score, precision_recall_curve, confusion_matrix, auc, roc_curve\nfrom scipy.special import expit\n\n\ndef bootstrap_ci(labels, logits, decision_threshold, nsamples):\n    metrics = {'auc_roc': [], 'auc_pr': [], 'sens': [], 'spec': [], 'ppv': [], 'npv': []}\n\n    for _ in tqdm(range(nsamples), leave=False):\n        idx = np.random.randint(len(labels), size=len(labels))\n\n        metrics['auc_roc'].append(roc_auc_score(labels[idx], logits[idx]))\n        precision, recall, _ = precision_recall_curve(labels[idx], logits[idx])\n        metrics['auc_pr'].append(auc(recall, precision))\n\n        tn, fp, fn, tp = confusion_matrix(labels[idx], logits[idx] > decision_threshold).ravel()\n\n        for key, value in zip(['sens', 'spec', 'ppv', 'npv'],\n                              [tp / (tp + fn), tn / (tn + fp), tp / (tp + fp), tn / (fn + tn)]):\n            metrics[key].append(value if np.isfinite(value) else 0)\n\n    return {k: np.percentile(v, (2.5, 97.5)) for k, v in metrics.items()}\n\n# main code\ndef calculate_subgroup_performance(subgroup_df, bootstrap=False, bootstrap_nsamples=2000, cm_threshold=0.045):\n    def extract_labels_preds(label_cols, pred_cols):\n        return np.append(*[subgroup_df[col] for col in label_cols]), np.append(*[subgroup_df[col] for col in pred_cols])\n\n    labels_malignant, preds_malignant = extract_labels_preds(['labels_lm', 'labels_rm'], ['preds_lm', 'preds_rm'])\n    labels_benign, preds_benign = extract_labels_preds(['labels_lb', 'labels_rb'], ['preds_lb', 'preds_rb'])\n\n    if preds_malignant.min() < 0:\n        preds_malignant, preds_benign = map(expit, [preds_malignant, preds_benign])\n\n    metrics = {\n        'AUROC malignant': round(roc_auc_score(labels_malignant, preds_malignant), 3),\n        'AUROC benign': round(roc_auc_score(labels_benign, preds_benign), 3),\n    }\n\n    if bootstrap:\n        metrics['cis'] = bootstrap_ci(labels_malignant, preds_malignant, cm_threshold, bootstrap_nsamples)\n\n    malignant_fpr, malignant_tpr, malignant_thresholds = roc_curve(labels_malignant, preds_malignant)\n    precision, recall, _ = precision_recall_curve(labels_malignant, preds_malignant)\n\n    cm = confusion_matrix(labels_malignant, preds_malignant > cm_threshold)\n    tn, fp, fn, tp = cm.ravel()\n\n    for key, value in zip(['AUPRC', 'Sensitivity', 'Specificity', 'PPV', 'NPV'],\n                          [auc(recall, precision), tp / (tp + fn), tn / (tn + fp), tp / (tp + fp), tn / (fn + tn)]):\n        metrics[key] = round(value if np.isfinite(value) else 0, 3)\n\n    return {**metrics, 'malignant_fpr': malignant_fpr, 'malignant_tpr': malignant_tpr,\n            'malignant_thresholds': malignant_thresholds, 'precision': precision, 'recall': recall}", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n\n        labels_lm = np.random.randint(0, 2, size=num_samples)\n        labels_rm = np.random.randint(0, 2, size=num_samples)\n        labels_lb = np.random.randint(0, 2, size=num_samples)\n        labels_rb = np.random.randint(0, 2, size=num_samples)\n\n        preds_lm = np.random.randn(num_samples)\n        preds_rm = np.random.randn(num_samples)\n        preds_lb = np.random.randn(num_samples)\n        preds_rb = np.random.randn(num_samples)\n\n        subgroup_df = pd.DataFrame({\n            'labels_lm': labels_lm,\n            'labels_rm': labels_rm,\n            'labels_lb': labels_lb,\n            'labels_rb': labels_rb,\n            'preds_lm': preds_lm,\n            'preds_rm': preds_rm,\n            'preds_lb': preds_lb,\n            'preds_rb': preds_rb\n        })\n\n        bootstrap = np.random.choice([True, False])\n        bootstrap_nsamples = np.random.randint(100, 200) if bootstrap else None\n\n        cm_threshold = np.random.uniform(0.01, 0.1)\n\n        test_cases.append((subgroup_df, bootstrap, bootstrap_nsamples, cm_threshold))\n\n    return test_cases"}
{"problem_id": "sklearn_73", "library": "sklearn", "code_problem": "You are tasked with implementing a function that processes numerical features in a dataset by binarizing them and then applying Principal Component Analysis (PCA) to reduce their dimensionality. The function will take in training and testing datasets, along with their corresponding labels, and a list of data types to filter the numerical columns.\n\nFunction signature:\n```python\ndef numeric_binarizer_pca(X_train, X_test, Y_train, Y_test, num_dtypes):\n```\n\n### Constants:\n- The constant used in the main code is `n_components=2`, which specifies that PCA should reduce the data to 2 principal components.\n\n### Input and Output Format:\n- **Input**:\n  - `X_train`: A pandas DataFrame containing the training features.\n  - `X_test`: A pandas DataFrame containing the testing features.\n  - `Y_train`: A pandas Series or DataFrame containing the training labels.\n  - `Y_test`: A pandas Series or DataFrame containing the testing labels.\n  - `num_dtypes`: A list of data types (e.g., ['int64', 'float64']) to filter the numerical columns.\n\n- **Output**:\n  - Returns a tuple containing:\n    - The modified `X_train` DataFrame with binarized columns and PCA components.\n    - The modified `X_test` DataFrame with binarized columns and PCA components.\n    - The original `Y_train`.\n    - The original `Y_test`.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample input data\nX_train = pd.DataFrame({\n    'num_feature_0': [1.5, 0.0, -2.3, 4.1],\n    'num_feature_1': [0.0, 3.2, 1.1, -1.0],\n    'num_feature_2': [2.2, -1.5, 0.0, 0.0]\n})\n\nX_test = pd.DataFrame({\n    'num_feature_0': [0.0, 2.5],\n    'num_feature_1': [-3.0, 1.0],\n    'num_feature_2': [0.0, 1.5]\n})\n\nY_train = pd.Series([1, 0, 1, 0], name='target')\nY_test = pd.Series([0, 1], name='target')\n\nnum_dtypes = [np.float64]\n```\n\n**Output:**\n```python\n# Expected output after processing\nX_train_out = \n   num_feature_0  num_feature_1  ...  Num_PC-1_num_pca  Num_PC-2_num_pca\n0            1.5            0.0  ...          0.952845          0.393174\n1            0.0            3.2  ...         -0.747378          0.062658\n2           -2.3            1.1  ...         -0.747378          0.062658\n3            4.1           -1.0  ...          0.541911         -0.518491\n[4 rows x 8 columns]\n\nX_test_out = \n   num_feature_0  num_feature_1  ...  Num_PC-1_num_pca  Num_PC-2_num_pca\n0            0.0           -3.0  ...         -0.102734         -0.227916\n1            2.5            1.0  ...          0.308201          0.683749\n[2 rows x 8 columns]\n\nY_train_out = pd.Series([1, 0, 1, 0])\nY_test_out = pd.Series([0, 1])\n```\n", "ground_truth_code": "import pandas as pd\nfrom sklearn.decomposition import PCA\n\n# main code\ndef numeric_binarizer_pca(X_train, X_test, Y_train, Y_test, num_dtypes):\n    encoded_num_cols = []\n    all_filtered_columns = []\n\n    for vartype in num_dtypes:\n        filtered_columns = X_train.select_dtypes(include=[vartype]).columns.to_list()\n        filtered_columns = [col for col in filtered_columns if\n                            col not in ['Num_PC-1_num_pca', 'Num_PC-2_num_pca'] and 'tfids_' not in col]\n        all_filtered_columns.extend(filtered_columns)\n\n    if all_filtered_columns:\n        num_cols_binarized_created = []\n        for num_col in all_filtered_columns:\n            X_train[f'{num_col}_binarized'] = X_train[num_col].apply(lambda x: 1 if x > 0 else 0)\n            X_test[f'{num_col}_binarized'] = X_test[num_col].apply(lambda x: 1 if x > 0 else 0)\n            num_cols_binarized_created.append(f'{num_col}_binarized')\n            encoded_num_cols.append(num_col)\n\n        pca = PCA(n_components=2)\n        X_train_branch = X_train[num_cols_binarized_created].copy()\n        X_test_branch = X_test[num_cols_binarized_created].copy()\n\n        train_comps = pca.fit_transform(X_train_branch)\n        test_comps = pca.transform(X_test_branch)\n\n        X_train_branch = pd.DataFrame(train_comps, columns=['Num_PC-1', 'Num_PC-2'])\n        X_test_branch = pd.DataFrame(test_comps, columns=['Num_PC-1', 'Num_PC-2'])\n\n        for col in X_train_branch.columns:\n            X_train[f'{col}_num_pca'] = X_train_branch[col]\n            X_test[f'{col}_num_pca'] = X_test_branch[col]\n\n    return X_train, X_test, Y_train, Y_test", "test_script": "import pandas as pd\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n        X = pd.DataFrame(np.random.randn(num_samples, num_features),\n                         columns=[f'num_feature_{i}' for i in range(num_features)])\n        Y = pd.Series(np.random.choice([0, 1], size=num_samples), name='target')\n        X_train, X_test, Y_train, Y_test = train_test_split(X, Y, test_size=0.2,\n                                                            random_state=np.random.randint(0, 1000))\n        num_dtypes = [np.float64]\n        test_cases.append((X_train, X_test, Y_train, Y_test, num_dtypes))\n\n    return test_cases"}
{"problem_id": "sklearn_74", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs cross-validation using a Multi-layer Perceptron (MLP) regressor from the scikit-learn library. The function will evaluate the model's performance on a given dataset and optionally assess the performance on a randomly shuffled version of the dataset.\n\nFunction signature:\n```python\ndef MLP_cv(X, y, k, group_labels, rand_added_flag):\n```\n\nConstants used in the main code:\n- The MLPRegressor is initialized with the following parameters:\n  - `hidden_layer_sizes=(50, 10)`: This specifies the architecture of the neural network with two layers, the first containing 50 neurons and the second containing 10 neurons.\n  - `activation='logistic'`: This sets the activation function to the logistic function (sigmoid).\n  - `alpha=0.01`: This is the regularization parameter to prevent overfitting.\n  - `early_stopping=True`: This enables early stopping to halt training when the validation score is not improving.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., pandas DataFrame or NumPy array) representing the features of the dataset.\n- `y`: A 1D array-like structure (e.g., pandas Series or NumPy array) representing the target variable.\n- `k`: An integer representing the number of folds for cross-validation.\n- `group_labels`: A 1D array-like structure indicating the group membership for each sample.\n- `rand_added_flag`: A boolean indicating whether to evaluate on a randomly shuffled version of the dataset.\n\nOutput format:\n- The function returns a tuple containing:\n  - `scores`: An array of cross-validation scores from the original dataset.\n  - `scores_rand`: An array of cross-validation scores from the shuffled dataset if `rand_added_flag` is `True`, otherwise `None`.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\nX = pd.DataFrame(np.random.rand(100, 10))  # 100 samples, 10 features\ny = pd.Series(np.random.rand(100))           # 100 target values\nk = 5                                         # 5 splits for GroupKFold\ngroup_labels = pd.Series(np.random.randint(0, k, size=100))  # Random group labels for 100 samples\nrand_added_flag = True                        # Randomized flag set to True\n```\n\nOutput:\n```python\n(array([-0.0017417 , -0.00546091,  0.00076833, -0.57978154, -0.54149998]), \n array([-0.22275086,  0.01240554, -0.0490781 , -0.00811929, -0.09577254]))\n``` \n", "ground_truth_code": "from sklearn.neural_network import MLPRegressor\nfrom sklearn.model_selection import GroupKFold, cross_val_score\n\n\n# main code\ndef MLP_cv(X, y, k, group_labels, rand_added_flag):\n    regr = MLPRegressor(hidden_layer_sizes=(50, 10), activation='logistic', alpha=0.01, early_stopping=True)\n    split_obj = GroupKFold(n_splits=k)\n    scores = cross_val_score(regr, X, y, groups=group_labels, cv=split_obj, n_jobs=-1)\n\n    scores_rand = cross_val_score(regr, X, y.sample(frac=1), groups=group_labels, cv=split_obj,\n                                  n_jobs=-1) if rand_added_flag else None\n\n    return scores, scores_rand", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n\n        X = pd.DataFrame(np.random.rand(num_samples, num_features))\n        y = pd.Series(np.random.rand(num_samples))\n        k = np.random.randint(2, min(10, num_samples // 5))\n        group_labels = pd.Series(np.random.randint(0, k, size=num_samples))\n        rand_added_flag = np.random.choice([True, False])\n\n        test_cases.append((X, y, k, group_labels, rand_added_flag))\n\n    return test_cases"}
{"problem_id": "sklearn_75", "library": "sklearn", "code_problem": "You are tasked with implementing a function that uncovers hidden patterns in a dataset using Support Vector Machines (SVM) and cross-validation. The function will preprocess the input data, train an SVM model, and evaluate its performance using accuracy scores and permutation tests.\n\nFunction signature:\n```python\ndef uncover_hidden_patterns(X, y, use_x_normalization=True, kernel=None):\n```\n\n### Constants:\n- The constant used in the main code is `n_splits=5`, which indicates that the dataset will be split into 5 folds for cross-validation.\n\n### Input and Output Format:\n- **Input**: \n  - `X`: A 2D array-like structure of shape (n_samples, n_features).\n  - `y`: A 1D array-like structure of shape (n_samples,).\n  - `use_x_normalization`: A boolean value (default is `True`).\n  - `kernel`: A string representing the kernel type (default is `None`).\n\n- **Output**: \n  - A tuple containing:\n    - `avg_train_accuracy`: A float representing the average training accuracy.\n    - `avg_val_accuracy`: A float representing the average validation accuracy.\n    - `score`: A float representing the score from the permutation test.\n    - `permutation_scores`: An array of permutation scores.\n    - `pvalue`: A float representing the p-value from the permutation test.\n\nInput:\n```python\nX = np.array([\n    [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.5, 0.2, 0.1],\n    [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0],\n    [0.2, 0.1, 0.4, 0.3, 0.5, 0.8, 0.7, 0.6, 0.9, 1.0],\n    [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    [0.0, 0.9, 0.8, 0.5, 0.6, 0.5, 0.4, 0.3, 0.9, 0.1],\n    [0.5, 0.5, 0.3, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5],\n    [0.9, 0.8, 0.7, 0.6, 0.5, 0.3, 0.3, 0.2, 0.8, 0.0],\n    [0.2, 0.1, 0.4, 0.3, 0.5, 0.8, 0.2, 0.6, 0.9, 1.0]\n])\ny = np.array([1, 0, 1, 0, 1, 1, 0, 1, 0, 0])\n\nuse_x_normalization = True\nkernel = 'rbf'\n```\n\nOutput:\n```python\n(100.0, 90.0, 0.9, array([0. , 0.1, 0. , 0.3, 0.1]), 0.16666666666666666)\n``` \n", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import KFold, permutation_test_score\nfrom sklearn import svm\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\n\n\n# main code\ndef uncover_hidden_patterns(X, y, use_x_normalization=True, kernel=None):\n    X = np.nan_to_num(X)\n    if use_x_normalization:\n        scaler = StandardScaler()\n        X = scaler.fit_transform(X)\n    else:\n        scaler = MinMaxScaler()\n        X = scaler.fit_transform(X)\n    train_scores = []\n    val_scores = []\n    kf = KFold(n_splits=5, shuffle=True)\n    score, permutation_scores, pvalue = None, None, None\n    for i, (train_index, val_index) in enumerate(kf.split(X)):\n        X_train, X_val = X[train_index], X[val_index]\n        y_train, y_val = y[train_index], y[val_index]\n        clf = svm.SVC(kernel=kernel if kernel else 'rbf')\n        clf.fit(X_train, y_train)\n        score, permutation_scores, pvalue = permutation_test_score(\n            clf, X_train, y_train, scoring='accuracy', cv=kf, n_permutations=5, n_jobs=1\n        )\n\n        train_accuracy = clf.score(X_train, y_train) * 100\n        val_accuracy = clf.score(X_val, y_val) * 100\n        train_scores.append(train_accuracy)\n        val_scores.append(val_accuracy)\n\n    avg_train_accuracy = np.mean(train_scores)\n    avg_val_accuracy = np.mean(val_scores)\n\n    return avg_train_accuracy, avg_val_accuracy, score, permutation_scores, pvalue", "test_script": "import numpy as np\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X, y = make_classification(\n            n_samples=100, n_features=10, n_informative=5,\n            n_redundant=2, n_classes=2, random_state=np.random.randint(1000)\n        )\n        use_x_normalization = np.random.choice([True, False])\n        kernel = np.random.choice(['linear', 'poly', 'rbf', 'sigmoid', None])\n\n        test_cases.append((X, y, use_x_normalization, kernel))\n\n    return test_cases"}
{"problem_id": "sklearn_76", "library": "sklearn", "code_problem": "You are tasked with implementing a function that generates statistical metrics for evaluating the performance of a binary classification model. The function should compute the Area Under the Receiver Operating Characteristic curve (AUROC) and the Area Under the Precision-Recall curve (AUPRC) based on the provided true labels and predicted probabilities. Additionally, if specified, the function should perform bootstrapping to estimate confidence intervals for these metrics.\n\nFunction Signature:\n```python\ndef generate_statistics(labels: List[int], predictions: List[float], bootstrapping: bool = False) -> Dict[str, Union[float, Tuple[float, float]]]:\n```\n\nConstants used in the main code:\n- `n_bootstraps = 200`: This constant defines the number of bootstrap samples to be generated when bootstrapping is enabled.\n\nInput Format:\n- `labels`: A list of integers representing the true binary labels (0 or 1).\n- `predictions`: A list of floats representing the predicted probabilities for the positive class.\n- `bootstrapping`: A boolean indicating whether to perform bootstrapping for confidence interval estimation.\n\nOutput Format:\n- A dictionary containing:\n  - \"AUROC\": The computed AUROC score (float).\n  - \"AUPRC\": The computed AUPRC score (float).\n  - If bootstrapping is enabled, it also includes:\n    - \"AUROC_CI\": A tuple representing the lower and upper bounds of the AUROC confidence interval (float, float).\n    - \"AUPRC_CI\": A tuple representing the lower and upper bounds of the AUPRC confidence interval (float, float).\n    - \"bootstrap_replicates\": The number of bootstrap samples used (int).\n\nInput:\n```python\nlabels = np.array([0, 1, 1, 0, 1, 0, 1, 0])\npredictions = np.array([0.1, 0.4, 0.35, 0.8, 0.7, 0.2, 0.9, 0.6])\nbootstrapping = True\n```\n\nOutput:\n```python\n{'AUROC': 0.6875, 'AUPRC': 0.6916666666666667, 'AUROC_CI': (0.19999999999999996, 1.0), 'AUPRC_CI': (0.16666666666666666, 1.0), 'bootstrap_replicates': 2000}\n```", "ground_truth_code": "import numpy as np\nimport sklearn.metrics as metrics\nfrom sklearn.utils import resample\n\ndef calc_confidence_interval(sample, confidence=0.95):\n    sorted_scores = np.sort(np.array(sample))\n    margin = (1 - confidence) / 2\n    lower_idx = int(margin * len(sorted_scores))\n    upper_idx = int((1 - margin) * len(sorted_scores))\n    return sorted_scores[lower_idx], sorted_scores[upper_idx]\n\n# main code\ndef generate_statistics(labels, predictions, bootstrapping=False):\n    roc_auc = metrics.roc_auc_score(labels, predictions)\n    precision, recall, _ = metrics.precision_recall_curve(labels, predictions)\n    pr_auc = metrics.auc(recall, precision)\n\n    stats = {\n        \"AUROC\": roc_auc,\n        \"AUPRC\": pr_auc\n    }\n\n    if bootstrapping and len(labels) >= 8:\n        n_bootstraps = 200\n        b_roc_auc_list = []\n        b_pr_auc_list = []\n\n        for _ in range(n_bootstraps):\n            boot = resample(list(zip(labels, predictions)), replace=True, n_samples=len(labels))\n            b_labels, b_predictions = zip(*boot)\n\n            if len(set(b_labels)) == 1:\n                continue\n\n            b_roc_auc_list.append(metrics.roc_auc_score(b_labels, b_predictions))\n            precision, recall, _ = metrics.precision_recall_curve(b_labels, b_predictions)\n            b_pr_auc_list.append(metrics.auc(recall, precision))\n\n        roc_CI_lower, roc_CI_upper = calc_confidence_interval(b_roc_auc_list)\n        pr_CI_lower, pr_CI_upper = calc_confidence_interval(b_pr_auc_list)\n\n        stats[\"AUROC_CI\"] = (roc_CI_lower, roc_CI_upper)\n        stats[\"AUPRC_CI\"] = (pr_CI_lower, pr_CI_upper)\n        stats[\"bootstrap_replicates\"] = n_bootstraps\n\n    return stats", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(2, 20)\n        labels = np.random.choice([0, 1], size=size)\n        predictions = np.random.rand(size)\n        bootstrapping = np.random.choice([True, False])\n\n        test_cases.append((labels, predictions, bootstrapping))\n\n    return test_cases"}
{"problem_id": "sklearn_77", "library": "sklearn", "code_problem": "You are tasked with implementing a function that computes the balanced accuracy score for a set of predictions against the true labels. The function should handle both single-label and multi-label classification scenarios.\n\nFunction Signature:\n```python\ndef compute_balanced_accuracy(target, y_test, y_preds):\n```\n\nConstant Used:\n- The function utilizes the `balanced_accuracy_score` from the `sklearn.metrics` module to compute the balanced accuracy.\n\nInput Format:\n- `target`: A string or a list/array-like structure representing the true labels.\n- `y_test`: A DataFrame or array-like structure containing the true labels for the test set.\n- `y_preds`: A DataFrame or array-like structure containing the predicted labels for the test set.\n\nOutput Format:\n- The function returns a float representing the mean balanced accuracy score.\n\n**Input:**\n```python\ntarget = \"class_label\"\ny_test = np.array([0, 1, 1, 0, 1, 0, 1, 0, 1, 0])\ny_preds = np.array([0, 1, 0, 0, 1, 1, 1, 0, 0, 1])\n```\n\n**Output:**\n```python\n0.6\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import balanced_accuracy_score\n\n# main code\ndef compute_balanced_accuracy(target, y_test, y_preds):\n    bal_scores = []\n\n    if isinstance(target, str) or (hasattr(target, '__len__') and len(target) <= 1):\n        bal_score = balanced_accuracy_score(y_test, y_preds)\n        bal_scores.append(bal_score)\n    else:\n        for each_i, target_name in enumerate(target):\n            bal_score = balanced_accuracy_score(y_test.iloc[:, each_i], y_preds[:, each_i])\n            bal_scores.append(bal_score)\n\n    return np.mean(bal_scores) if bal_scores else 0.0", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        is_single_target = random.choice([True, False])\n\n        if is_single_target:\n            target = \"class_label\"\n            num_samples = random.randint(50, 100)\n            num_classes = random.randint(2, 10)\n\n            y_test = np.random.randint(0, num_classes, size=(num_samples,))\n            y_preds = np.random.randint(0, num_classes, size=(num_samples,))\n\n        else:\n            # Multi-target case\n            num_targets = random.randint(2, 10)\n            target = [f\"class_{i}\" for i in range(num_targets)]\n            num_samples = random.randint(50, 100)\n            num_classes = [random.randint(2, 10) for _ in range(num_targets)]\n\n            y_test = pd.DataFrame({f\"class_{i}\": np.random.randint(0, num_classes[i], size=(num_samples,))\n                                   for i in range(num_targets)})\n            y_preds = np.random.randint(0, max(num_classes), size=(num_samples, num_targets))\n\n        test_cases.append((target, y_test, y_preds))\n\n    return test_cases"}
{"problem_id": "sklearn_78", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model based on its predictions. The function will compute different types of loss metrics and the area under the curve (AUC) based on the specified loss type. The function signature is as follows:\n\n```python\ndef evaluate(data, out, loss_type):\n```\n\n### Constants:\n- The constant used in the main code is `0.0001`, which is used to clip predicted probabilities in the case of log loss evaluation.\n\n### Input and Output Format:\n- **Input**:\n  - `data`: A dictionary with keys `'X'` (numpy array) and `'Y'` (numpy array).\n  - `out`: A list of two callable models (functions).\n  - `loss_type`: A string indicating the type of loss to compute.\n\n- **Output**:\n  - A tuple containing three values:\n    - The computed loss for the main predictions (float).\n    - The computed AUC (float).\n    - The computed loss for the low predictions (float).\n\nInput:\n```python\ndata = {\n    'X': np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]], dtype=np.float32),\n    'Y': np.array([0.2, 0.5, 0.8], dtype=np.float32)\n}\nout = [\n    lambda x: np.array([0.15, 0.55, 0.75], dtype=np.float32),\n    lambda x: np.array([0.1, 0.4, 0.7], dtype=np.float32)\n]\nloss_type = 'log_loss'\n```\n\nOutput:\n```python\n(0.3242870290489908, 1.0, 0.41623623220301226)\n```", "ground_truth_code": "import numpy as np\nimport math\nfrom sklearn.metrics import mean_squared_error\nfrom sklearn.metrics import log_loss\nfrom sklearn.metrics import roc_auc_score\n\n# main code\ndef evaluate(data, out, loss_type):\n    num_example = data['Y'].shape[0]\n\n    predictions, predictions_low = out[-1](data['X']), out[0](data['X'])\n\n    y_pred = np.reshape(predictions, (num_example,))\n    y_pred_low = np.reshape(predictions_low, (num_example,))\n    y_true = np.reshape(data['Y'], (num_example,))\n\n    if loss_type == 'square_loss':\n        predictions_dependent = np.clip(y_pred, min(y_true), max(y_true))\n        predictions_dependent_low = np.clip(y_pred_low, min(y_true), max(y_true))\n        loss = math.sqrt(mean_squared_error(y_true, predictions_dependent))\n        auc = 0\n        loss_low = math.sqrt(mean_squared_error(y_true, predictions_dependent_low))\n\n    elif loss_type == 'log_loss':\n        # Ensure binary classification labels\n        y_true = (y_true > 0.5).astype(int)  # Convert continuous labels to binary\n        y_pred = np.clip(y_pred, 0.0001, 0.9999)\n        y_pred_low = np.clip(y_pred_low, 0.0001, 0.9999)\n        loss = log_loss(y_true, y_pred)\n        auc = roc_auc_score(y_true, y_pred)\n        loss_low = log_loss(y_true, y_pred_low)\n\n    else:\n        loss = 0\n        auc = 0\n        loss_low = 0\n\n    return (loss, auc, loss_low)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_features = np.random.randint(5, 20)\n\n        X = np.random.rand(num_samples, num_features).astype(np.float32)\n        Y = np.random.rand(num_samples).astype(np.float32)\n\n        out = [\n            lambda x: np.random.rand(x.shape[0]).astype(np.float32),\n            lambda x: np.random.rand(x.shape[0]).astype(np.float32)\n        ]\n\n        loss_type = np.random.choice(['square_loss', 'log_loss'])\n\n        test_cases.append(({'X': X, 'Y': Y}, out, loss_type))\n\n    return test_cases"}
{"problem_id": "sklearn_79", "library": "sklearn", "code_problem": "You are tasked with implementing a function that optimizes the hyperparameters of a Support Vector Regression (SVR) model using randomized search. The function will take in training data and a set of hyperparameter values, and it will return the best SVR model based on the mean squared error.\n\nFunction signature:\n```python\ndef regressorOp(X, Y, C_values, gamma_values, epsilon_values):\n```\n\nConstant used in the main code:\n- The kernel type for the SVR model is set to 'rbf' (Radial Basis Function).\n\nInput format:\n- `X`: A 2D array-like structure containing the input features for training.\n- `Y`: A 1D array-like structure containing the target values.\n- `C_values`: A list of possible values for the regularization parameter `C`.\n- `gamma_values`: A list of possible values for the kernel coefficient `gamma`.\n- `epsilon_values`: A list of possible values for the epsilon parameter.\n\nOutput format:\n- The function returns the best SVR model (an instance of `SVR`) that has been optimized based on the provided hyperparameter values.\n\nInput:\n```python\nX = np.array([[ 0.49671415, -0.1382643 ,  0.64768854],\n              [ 1.52302986, -0.23415337, -0.23413696],\n              [-0.23413696,  1.57921282,  0.76743473],\n              [ 0.54256004, -0.46341769, -0.46572975],\n              [-0.56228753, -1.01283112,  0.31424733]])\nY = np.array([ 1.46564877, -0.2257763 ,  0.0675282 , -1.42474819, -0.54438272])\nC_values = np.logspace(-3, 3, 3)  # [0.001, 1, 1000]\ngamma_values = np.logspace(-2, 2, 3)  # [0.01, 1, 100]\nepsilon_values = [0.1, 0.5]\n```\n\nOutput:\n```python\nbest_estimator = SVR(gamma=0.01)\n``` \n\n(Note: The actual output may vary based on the random initialization and the data provided, but this format represents the expected structure of the input and output.)", "ground_truth_code": "from sklearn.svm import SVR\nfrom sklearn.model_selection import RandomizedSearchCV\n\n# main code\ndef regressorOp(X, Y, C_values, gamma_values, epsilon_values):\n    regr_rbf = SVR(kernel='rbf')\n    parameters = {'C': C_values, 'gamma': gamma_values, 'epsilon': epsilon_values}\n\n    gs = RandomizedSearchCV(regr_rbf, parameters, scoring='neg_mean_squared_error')\n    gs.fit(X, Y)\n    return gs.best_estimator_", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(10, 200)\n        d = np.random.randint(1, 20)\n        X = np.random.randn(m, d)\n        Y = np.random.randn(m)\n\n        C_values = np.logspace(-3, 3, 3)\n        gamma_values = np.logspace(-2, 2, 3)\n        epsilon_values = [0.1, 0.5]\n\n        test_cases.append((X, Y, C_values, gamma_values, epsilon_values))\n\n    return test_cases\n"}
{"problem_id": "sklearn_80", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a model's predictions against true labels for both training and testing datasets. The function will compute various metrics such as precision, recall, accuracy, and confusion matrix for both datasets.\n\nFunction Signature:\n```python\ndef evaluate_node(ypred, labels, train_idx, test_idx):\n```\n\nConstants Used:\n- The function utilizes the `average='macro'` parameter in the precision and recall calculations, which means that the metrics will be computed for each class separately and then averaged, treating all classes equally.\n\nInput Format:\n- `ypred`: A tensor of shape (n_samples, n_classes, n_timesteps) containing the predicted probabilities or logits for each class.\n- `labels`: A tensor of shape (n_samples, n_classes, n_timesteps) containing the true labels for each class.\n- `train_idx`: A list or array of indices indicating which samples belong to the training set.\n- `test_idx`: A list or array of indices indicating which samples belong to the testing set.\n\nOutput Format:\n- The function returns a tuple containing two dictionaries:\n  - The first dictionary contains the evaluation metrics for the training set.\n  - The second dictionary contains the evaluation metrics for the testing set. Each dictionary includes keys for 'prec', 'recall', 'acc', and 'conf_mat'.\n\nInput:\n```python\nypred = torch.tensor([[[0.1, 0.2, 0.7], [0.3, 0.4, 0.3], [0.6, 0.1, 0.3]],\n                      [[0.2, 0.5, 0.3], [0.1, 0.8, 0.1], [0.4, 0.4, 0.2]]])\nlabels = torch.tensor([[2, 1, 0], [1, 2, 0]])\ntrain_idx = np.array([0, 1])\ntest_idx = np.array([2])\n```\n\nOutput:\n```python\n({'prec': 0.8333333333333333, 'recall': 0.75, 'acc': 0.75, 'conf_mat': array([[2, 0],\n       [1, 1]])}, \n {'prec': 1.0, 'recall': 1.0, 'acc': 1.0, 'conf_mat': array([[2]])}\n )\n\n```", "ground_truth_code": "import torch\nimport sklearn.metrics as metrics\n\n# main code\ndef evaluate_node(ypred, labels, train_idx, test_idx):\n    _, pred_labels = torch.max(ypred, 2)\n    pred_labels = pred_labels.numpy()\n\n    pred_train = pred_labels[:, train_idx].ravel()\n    pred_test = pred_labels[:, test_idx].ravel()\n    labels_train = labels[:, train_idx].ravel()\n    labels_test = labels[:, test_idx].ravel()\n\n    def compute_metrics(true, pred):\n        return {\n            'prec': metrics.precision_score(true, pred, average='macro'),\n            'recall': metrics.recall_score(true, pred, average='macro'),\n            'acc': metrics.accuracy_score(true, pred),\n            'conf_mat': metrics.confusion_matrix(true, pred)\n        }\n\n    result_train = compute_metrics(labels_train, pred_train)\n    result_test = compute_metrics(labels_test, pred_test)\n\n    return result_train, result_test", "test_script": "import torch\nimport random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_classes = random.randint(2, 10)\n        num_nodes = random.randint(10, 100)\n        batch_size = random.randint(1, 5)\n        ypred = torch.randn(batch_size, num_nodes, num_classes)\n\n        labels = torch.randint(0, num_classes, (batch_size, num_nodes))\n\n        num_train = random.randint(1, num_nodes - 1)\n        train_idx = np.random.choice(num_nodes, num_train, replace=False)\n        test_idx = np.setdiff1d(np.arange(num_nodes), train_idx)\n\n        test_cases.append((ypred, labels, train_idx, test_idx))\n\n    return test_cases"}
{"problem_id": "sklearn_81", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a binary classification model using various metrics derived from the model's predictions. The function will compute the area under the ROC curve (AUC), F1 score, sensitivity, and specificity based on the true labels and predicted probabilities.\n\nFunction signature:\n```python\ndef single_score(y_true, y_pred):\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the main code.\n\nInput format:\n- `y_true`: A list or array of true binary labels (0 or 1).\n- `y_pred`: A list or array of predicted probabilities for the positive class (1).\n\nOutput format:\n- A tuple containing four values: \n  - The area under the ROC curve (AUC) as a float.\n  - The F1 score as a float.\n  - Sensitivity as a float.\n  - Specificity as a float.\n\n```python\n# Input\ny_true = np.array([0, 1, 1, 0, 1])\ny_pred = np.array([0.1, 0.4, 0.35, 0.8, 0.7])\n\n# Output\nroc_auc, f1, sensitivity, specificity = 0.5, 0.8571428571428571, 1.0, 0.5\n```", "ground_truth_code": "from sklearn.metrics import roc_curve, auc, f1_score, confusion_matrix\nimport numpy as np\n\n# main code\ndef single_score(y_true, y_pred):\n    fpr, tpr, thresholds = roc_curve(y_true, y_pred)\n    roc_auc = auc(fpr, tpr)\n\n    optimal_idx = np.argmax(tpr - fpr)\n    optimal_threshold = thresholds[optimal_idx]\n\n    y_pred = np.where(y_pred >= optimal_threshold, 1, 0)\n\n    tn, fp, fn, tp = confusion_matrix(y_true, y_pred).ravel()\n\n    sensitivity = tp / (tp + fn) if (tp + fn) > 0 else 0\n    specificity = tn / (tn + fp) if (tn + fp) > 0 else 0\n    f1 = f1_score(y_true, y_pred)\n\n    return roc_auc, f1, sensitivity, specificity", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(10, 1000)\n        y_true = np.random.randint(0, 2, size=length)\n        y_pred = np.random.rand(length)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "sklearn_82", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model on a test dataset. The function will compute various metrics such as loss, accuracy, precision, recall, F1 score, and a confusion matrix based on the model's predictions.\n\nFunction signature:\n```python\ndef validate(model, test_loader):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `zero_division=0`, which is specified in the precision, recall, and F1 score calculations to handle cases where there are no positive predictions.\n\nInput format:\n- The function takes two parameters: `model`, which is a trained machine learning model, and `test_loader`, which is an iterable that provides batches of test data.\n\nOutput format:\n- The function returns a tuple containing:\n  - A float representing the average test loss.\n  - A float representing the accuracy of the model on the test dataset.\n  - A float representing the precision of the model.\n  - A float representing the recall of the model.\n  - A float representing the F1 score of the model.\n  - A confusion matrix as a 2D array.\n\nInput:\n```python\n# Mock model and test loader for a single test case\nimport torch\n\nclass MockModel(torch.nn.Module):\n    def __init__(self, input_dim, output_dim):\n        super(MockModel, self).__init__()\n        self.fc = torch.nn.Linear(input_dim, output_dim)\n\n    def forward(self, batch):\n        return self.fc(batch.x)\n\n# Create a test case\nfeature_dim = 10\nnum_classes = 5\nbatch_size = 16\n\nmodel = MockModel(feature_dim, num_classes)\nx = torch.randn(batch_size, feature_dim)\ny = torch.randint(0, num_classes, (batch_size,))\nclass Batch:\n    def __init__(self, x, y):\n        self.x = x\n        self.y = y\ntest_loader = [Batch(x, y)]\n\n# Call the validate function\ntest_loss, accuracy, precision, recall, f1, cm = validate(model, test_loader)\n```\n\nOutput:\n```python\n# Example output values (these will vary due to randomness)\ntest_loss: 1.907461404800415\naccuracy: 0.125\nprecision: 0.07222222222222222\nrecall: 0.13333333333333333\nf1: 0.09047619047619046\ncm: array([[0, 0, 3, 0, 1],\n       [0, 0, 1, 0, 0],\n       [0, 0, 1, 1, 1],\n       [1, 1, 2, 0, 1],\n       [0, 0, 2, 0, 1]])\n```", "ground_truth_code": "from sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score, confusion_matrix\nimport torch\nimport torch.nn.functional as F\n\n# main code\ndef validate(model, test_loader):\n    test_loss = 0.0\n    y_true = []\n    y_pred = []\n\n    for batch in test_loader:\n        with torch.no_grad():\n            y_ = model(batch)\n        batch.y = batch.y.squeeze().long()\n        test_loss += F.cross_entropy(y_, batch.y).item()\n        pred = y_.max(-1, keepdim=True)[1]\n        y_true.extend(batch.y.numpy())\n        y_pred.extend(pred.numpy())\n\n    test_loss /= len(test_loader)\n    accuracy = accuracy_score(y_true, y_pred)\n    precision = precision_score(y_true, y_pred, zero_division=0, average=\"macro\")\n    recall = recall_score(y_true, y_pred, zero_division=0, average=\"macro\")\n    f1 = f1_score(y_true, y_pred, zero_division=0, average=\"macro\")\n    cm = confusion_matrix(y_true, y_pred)\n\n    return test_loss, accuracy, precision, recall, f1, cm", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    num_classes = 5\n    batch_size = 16\n    feature_dim = 10\n\n    class MockModel(torch.nn.Module):\n        def __init__(self, input_dim, output_dim):\n            super(MockModel, self).__init__()\n            self.fc = torch.nn.Linear(input_dim, output_dim)\n\n        def forward(self, batch):\n            return self.fc(batch.x)\n\n    for _ in range(n):\n        model = MockModel(feature_dim, num_classes)\n        x = torch.randn(batch_size, feature_dim)\n        y = torch.randint(0, num_classes, (batch_size,))\n        class Batch:\n            def __init__(self, x, y):\n                self.x = x\n                self.y = y\n        test_loader = [Batch(x, y)]\n\n        test_cases.append((model, test_loader))\n\n    return test_cases"}
{"problem_id": "sklearn_83", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of different machine learning classifiers on a given dataset. The function will train multiple classifiers on the training data and compute the Area Under the Curve (AUC) for each classifier based on the predictions made on the test data. The classifiers to be evaluated include a Random Forest Classifier, a Support Vector Machine (SVM), and a K-Nearest Neighbors (KNN) classifier.\n\nThe function signature is as follows:\n```python\ndef machine_classification(X_train, y_train, X_test, y_test):\n```\n\n### Constants Used:\n- The number of neighbors for the KNN classifier is set to 5.\n- The SVM classifier uses a regularization parameter `C` of 1, a radial basis function (RBF) kernel, and an automatic gamma setting.\n\n### Input Format:\n- `X_train`: A 2D NumPy array or DataFrame of shape (n_samples, n_features) for training features.\n- `y_train`: A 1D or 2D NumPy array or DataFrame of shape (n_samples,) or (n_samples, n_classes) for training labels.\n- `X_test`: A 2D NumPy array or DataFrame of shape (n_samples, n_features) for test features.\n- `y_test`: A 1D or 2D NumPy array or DataFrame of shape (n_samples,) or (n_samples, n_classes) for test labels.\n\n### Output Format:\n- The function returns a Pandas DataFrame with two columns:\n  - \"Model\": The name of the classifier.\n  - \"AUC\": The computed AUC score for that classifier.\n\n**Input:**\n```python\nX_train = np.array([[0.1, 0.2, 0.3], \n                    [0.4, 0.5, 0.6], \n                    [0.7, 0.8, 0.9], \n                    [0.2, 0.3, 0.1], \n                    [0.5, 0.4, 0.6]])\ny_train = np.array([[1], \n                    [0], \n                    [1], \n                    [0], \n                    [1]])\nX_test = np.array([[0.3, 0.2, 0.1], \n                   [0.6, 0.5, 0.4]])\ny_test = np.array([[1], \n                   [0]])\n```\n\n**Output:**\n```python\n     Model  AUC\n0   GCN+rf  0.0\n1  GCN+svm  1.0\n2  GCN+knn  0.5\n```\n", "ground_truth_code": "from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import roc_curve, auc\nfrom sklearn import svm\nfrom sklearn.neighbors import KNeighborsClassifier\nimport pandas as pd\nimport numpy as np\n\n\n# main code\ndef machine_classification(X_train, y_train, X_test, y_test):\n    scores = []\n\n    if y_train.ndim == 3:\n        y_train = y_train[:, 0, :]\n        y_test = y_test[:, 0, :]\n\n    if y_test.shape[-1] == 1:\n        classifiers = {\n            \"GCN+rf\": RandomForestClassifier(),\n            \"GCN+svm\": svm.SVC(C=1, kernel='rbf', gamma='auto', probability=True),\n            \"GCN+knn\": KNeighborsClassifier(n_neighbors=5)\n        }\n\n        for model_type, clf in classifiers.items():\n            clf.fit(X_train, y_train.ravel())  # Flatten target labels if necessary\n            y_score = clf.predict_proba(X_test)[:, 1] if hasattr(clf, \"predict_proba\") else clf.decision_function(X_test)\n            fpr, tpr, _ = roc_curve(y_test.ravel(), y_score)\n            scores.append([model_type, auc(fpr, tpr)])\n\n    else:\n        auc_results = {\"GCN+rf\": [], \"GCN+svm\": [], \"GCN+knn\": []}\n\n        classifiers = {\n            \"GCN+rf\": RandomForestClassifier(),\n            \"GCN+svm\": svm.SVC(C=1, kernel='rbf', gamma='auto', probability=True),\n            \"GCN+knn\": KNeighborsClassifier(n_neighbors=5)\n        }\n\n        for i in range(y_test.shape[1]):\n            if np.max(y_train[:, i]) == 0 or np.max(y_test[:, i]) == 0:\n                continue\n\n            for model_type, clf in classifiers.items():\n                clf.fit(X_train, y_train[:, i])\n\n                if hasattr(clf, \"predict_proba\"):\n                    y_score = clf.predict_proba(X_test)[:, 1]\n                else:\n                    y_score = clf.decision_function(X_test)\n\n                fpr, tpr, _ = roc_curve(y_test[:, i], y_score)\n                auc_score = auc(fpr, tpr)\n\n                if auc_score > 0:\n                    auc_results[model_type].append(auc_score)\n\n        for model_type, auc_list in auc_results.items():\n            scores.append([model_type, np.mean(auc_list) if auc_list else 0])\n\n    return pd.DataFrame(scores, columns=[\"Model\", \"AUC\"])\n\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples_train = np.random.randint(50, 500)\n        num_samples_test = np.random.randint(20, 100)\n        num_features = np.random.randint(5, 20)\n\n        X_train = np.random.rand(num_samples_train, num_features)\n        X_test = np.random.rand(num_samples_test, num_features)\n\n        is_multi_label = np.random.choice([True, False])\n\n        if is_multi_label:\n            num_classes = np.random.randint(2, 10)\n            y_train = np.random.randint(0, 2, (num_samples_train, num_classes))\n            y_test = np.random.randint(0, 2, (num_samples_test, num_classes))\n\n            if np.random.rand() > 0.5:\n                y_train = np.expand_dims(y_train, axis=1)\n                y_test = np.expand_dims(y_test, axis=1)\n        else:\n            y_train = np.random.randint(0, 2, (num_samples_train, 1))\n            y_test = np.random.randint(0, 2, (num_samples_test, 1))\n\n        test_cases.append((X_train, y_train, X_test, y_test))\n\n    return test_cases"}
{"problem_id": "sklearn_84", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the accuracy of predictions made on a dataset after preprocessing the data. The function will take in raw data, true labels, and a threshold value to binarize the predictions. \n\nFunction signature:\n```python\ndef mystery_unfolds(raw_data: np.ndarray, y_true: np.ndarray, threshold: float) -> float:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the `threshold`, which is provided as an argument to the function.\n\nInput format:\n- `raw_data`: A 2D numpy array of shape (n_samples, n_features) representing the input data.\n- `y_true`: A 1D numpy array of shape (n_samples,) representing the true labels corresponding to the input data.\n- `threshold`: A float value used to binarize the predictions.\n\nOutput format:\n- The function returns a float representing the accuracy of the predictions after binarization.\n\nInput:\n```python\nraw_data = np.array([[ 1.2,  2.3, np.nan],\n                     [ 3.4, np.nan,  1.1],\n                     [np.nan,  0.5,  2.2]])\ny_true = np.array([[0.5, 1.5, 0.0],\n                   [1.0, 0.0, 0.5],\n                   [0.0, 1.0, 1.5]])\nthreshold = 0.5\n```\n\nOutput:\n```python\nacc_full = 0.6666666666666666\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import accuracy_score\nfrom sklearn.preprocessing import StandardScaler, Binarizer\n\n# main code\ndef mystery_unfolds(raw_data, y_true, threshold):\n    scaler = StandardScaler()\n    cleaned_data = np.nan_to_num(raw_data)\n    normalized_data = scaler.fit_transform(cleaned_data)\n    binarizer = Binarizer(threshold=threshold)\n    y_pred = binarizer.fit_transform(normalized_data)\n    y_true_binarized = (y_true >= threshold).astype(int)\n    acc_full = accuracy_score(y_true_binarized.ravel(), y_pred.ravel())\n\n    return acc_full", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(10, 100)\n        cols = np.random.randint(2, 20)\n        raw_data = np.random.randn(rows, cols) * np.random.randint(1, 10)\n        mask = np.random.rand(rows, cols) < 0.1\n        raw_data[mask] = np.nan\n        y_true = np.random.uniform(-5, 5, size=(rows, cols))\n        threshold = np.random.uniform(-2, 2)\n\n        test_cases.append((raw_data, y_true, threshold))\n\n    return test_cases\n"}
{"problem_id": "sklearn_85", "library": "sklearn", "code_problem": "You are tasked with implementing a function that utilizes Support Vector Machines (SVM) for classification or regression tasks based on the provided input data. The function will perform hyperparameter tuning using Grid Search and will evaluate the model using cross-validation. The function signature is as follows:\n\n```python\ndef SVM(X, y, X_ind, y_ind, param_grid, reg=False):\n```\n\n### Constants:\n- The constant used in the main code is the number of folds for cross-validation, which is set to 5.\n\n### Input and Output Format:\n- **Input Format**:\n  - `X`: 2D array-like of shape (n_samples, n_features)\n  - `y`: 1D array-like of shape (n_samples,)\n  - `X_ind`: 2D array-like of shape (n_samples_ind, n_features)\n  - `y_ind`: 1D array-like of shape (n_samples_ind,)\n  - `param_grid`: Dictionary of hyperparameters for tuning\n  - `reg`: Boolean indicating regression or classification\n\n- **Output Format**:\n  - Returns a tuple:\n    - `cvs`: 1D array of cross-validated predictions\n    - `inds`: 1D array of average predictions for the independent dataset\n\n**Input:**\n```python\nX = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.1, 0.4, 0.7], [0.2, 0.5, 0.8]])\ny = np.array([0, 1, 1, 0, 1])\nX_ind = np.array([[0.3, 0.3, 0.3], [0.6, 0.6, 0.6]])\ny_ind = np.array([0, 1])\nreg = False\nparam_grid = {'C': [0.1, 1, 10], 'gamma': ['scale', 'auto']}\n```\n\n**Output:**\n```python\ncvs = array([0.5       , 0.47091838, 0.63920041, 0.5       , 0.47120679,\n       0.47037398, 0.47289549, 0.63912252, 0.47050225, 0.47143143])\n\ninds = array([0.51082765, 0.51033994])\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.svm import SVR\nfrom sklearn.svm import SVC\nfrom copy import deepcopy\nfrom sklearn.model_selection import KFold\nfrom sklearn.model_selection import StratifiedKFold\n\n# main code\ndef SVM(X, y, X_ind, y_ind, param_grid, reg=False):\n    if reg:\n        folds = KFold(5).split(X)\n        alg = SVR()\n    else:\n        folds = StratifiedKFold(5).split(X, y)\n        alg = SVC(probability=True)\n    cvs = np.zeros(y.shape)\n    inds = np.zeros(y_ind.shape)\n    gs = GridSearchCV(deepcopy(alg), param_grid, n_jobs=-1)\n    gs.fit(X, y)\n    params = gs.best_params_\n    print(params)\n    for (i, (trained, valided)) in enumerate(folds):\n        model = deepcopy(alg)\n        model.C = params['C']\n        model.gamma = params['gamma']\n        if not reg:\n            model.probability = True\n        model.fit(X[trained], y[trained], sample_weight=[1 if v >= 4 else 0.1 for v in y[trained]])\n        if reg:\n            cvs[valided] = model.predict(X[valided])\n            inds += model.predict(X_ind)\n        else:\n            cvs[valided] = model.predict_proba(X[valided])[:, 1]\n            inds += model.predict_proba(X_ind)[:, 1]\n    return (cvs, inds / 5)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n        num_test_samples = np.random.randint(10, 100)\n\n        X = np.random.randn(num_samples, num_features)\n        y = np.random.randint(0, 2, size=num_samples)\n        X_ind = np.random.randn(num_test_samples, num_features)\n        y_ind = np.random.randint(0, 2, size=num_test_samples)\n        reg = np.random.choice([True, False])\n        param_grid = {'C': [0.1, 1, 10], 'gamma': ['scale', 'auto']}\n\n        test_cases.append((X, y, X_ind, y_ind, param_grid, reg))\n\n    return test_cases"}
{"problem_id": "sklearn_86", "library": "sklearn", "code_problem": "You are tasked with implementing a function that trains and validates machine learning models based on the provided dataset and configuration. The function will handle both classification and regression problems, allowing for the selection of specific models and hyperparameter tuning using grid search.\n\nFunction signature:\n```python\ndef train_and_validate(X, y, problem_type, selected_models, model_config, scoring_config):\n```\n\nConstant used in the main code:\n- `random_state`: The constant value used for reproducibility in the `train_test_split` function is set to `42`.\n\nInput format:\n- `X`: A 2D array-like structure representing the feature set.\n- `y`: A 1D array-like structure representing the target variable.\n- `problem_type`: A string indicating the type of problem ('binary', 'multiclass', or 'regression').\n- `selected_models`: A list of strings representing the names of the models to be selected for training.\n- `model_config`: A dictionary containing model names as keys and tuples of model instances and their corresponding hyperparameter grids as values.\n- `scoring_config`: A dictionary mapping problem types to their respective scoring metrics.\n\nOutput format:\n- The function returns a tuple containing:\n  - `best_model`: The best-performing model after training and validation.\n  - `results`: A dictionary with model names as keys and their best parameters and scores as values.\n\n**Input:**\n```python\nX = array([[-0.28280607, -1.40876083],\n       [ 0.94702918,  0.55906844],\n       [ 1.15772163,  0.474995  ],\n       [ 1.99591479,  0.77282149],\n       [ 0.04049985,  1.39732687],\n       [ 1.47044441, -0.86055081],\n       [-0.70743459,  0.89217168],\n       [-1.45694256, -0.04564786],\n       [ 0.62203454,  2.36749526],\n       [-0.01544395,  1.09258513],\n       [ 1.61125245, -0.65678116],\n       [ 1.45454184,  0.91354664],\n       [-0.20714752,  1.33055499],\n       [ 1.9632335 , -0.7697201 ],\n       [-0.96400678, -0.82990054],\n       [ 2.07569216,  0.66009587],\n       [-0.65503537, -0.83585632],\n       [-1.42571554, -1.31373391],\n       [-0.87496777, -0.11350669],\n       [ 1.25579369, -0.37205015]])\ny = array([0, 0, 0, 1, 1, 0, 1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0])\n(X, y, 'binary', ['LogisticRegression'], {\n    'classification': {\n        'LogisticRegression': (LogisticRegression(), {'C': [0.1, 1, 10]}),\n        'RandomForestClassifier': (RandomForestClassifier(), {'n_estimators': [10, 50, 100], 'random_state': [42]})\n    },\n    'regression': {\n        'Ridge': (Ridge(), {'alpha': [0.1, 1, 10]}),\n        'RandomForestRegressor': (RandomForestRegressor(), {'n_estimators': [10, 50, 100], 'random_state': [42]})\n    }\n}, {\n    'binary': 'accuracy',\n    'multiclass': 'f1_weighted',\n    'regression': 'neg_mean_squared_error'\n})\n```\n\n**Output:**\n```python\n(LogisticRegression(C=1), {'LogisticRegression': {'best_params': {'C': 1}, 'score': 0.75}})\n```", "ground_truth_code": "from sklearn.model_selection import train_test_split, GridSearchCV\nfrom sklearn.metrics import accuracy_score, f1_score, mean_squared_error\n\n# main code\ndef train_and_validate(X, y, problem_type, selected_models, model_config, scoring_config):\n    (X_train, X_val, y_train, y_val) = train_test_split(X, y, test_size=0.2, random_state=42)\n    model_category = 'classification' if problem_type in ['binary', 'multiclass'] else 'regression'\n    models = model_config[model_category]\n    if selected_models:\n        models = {k: v for (k, v) in models.items() if k in selected_models}\n    (best_model, best_score) = (None, float('-inf') if problem_type in ['binary', 'multiclass'] else float('inf'))\n    results = {}\n    for (model_name, (model, param_grid)) in models.items():\n        optimizer = GridSearchCV(model, param_grid, cv=3, scoring=scoring_config[problem_type], n_jobs=-1)\n        optimizer.fit(X_train, y_train)\n        y_pred = optimizer.predict(X_val)\n        if problem_type in ['binary', 'multiclass']:\n            score = accuracy_score(y_val, y_pred) if problem_type == 'binary' else f1_score(y_val, y_pred, average='weighted')\n        else:\n            score = -mean_squared_error(y_val, y_pred)\n        results[model_name] = {'best_params': optimizer.best_params_, 'score': score}\n        if problem_type in ['binary', 'multiclass'] and score > best_score or (problem_type == 'regression' and score < best_score):\n            (best_score, best_model) = (score, optimizer.best_estimator_)\n    return (best_model, results)", "test_script": "from sklearn.datasets import make_classification, make_regression\nfrom sklearn.linear_model import LogisticRegression, Ridge\nfrom sklearn.ensemble import RandomForestClassifier, RandomForestRegressor\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for i in range(n):\n        problem_type = ['binary', 'multiclass', 'regression'][i % 3]\n        if problem_type == 'binary':\n            X, y = make_classification(n_samples=500, n_features=20, n_classes=2)\n        elif problem_type == 'multiclass':\n            X, y = make_classification(n_samples=500, n_features=20, n_classes=3, n_informative=15)\n        else:\n            X, y = make_regression(n_samples=500, n_features=20, noise=0.1)\n\n        model_config = {\n            'classification': {\n                'LogisticRegression': (LogisticRegression(), {'C': [0.1, 1, 10]}),\n                'RandomForestClassifier': (\n                RandomForestClassifier(), {'n_estimators': [10, 50, 100], 'random_state': [42]})\n            },\n            'regression': {\n                'Ridge': (Ridge(), {'alpha': [0.1, 1, 10]}),\n                'RandomForestRegressor': (\n                RandomForestRegressor(), {'n_estimators': [10, 50, 100], 'random_state': [42]})\n            }\n        }\n\n        scoring_config = {\n            'binary': 'accuracy',\n            'multiclass': 'f1_weighted',\n            'regression': 'neg_mean_squared_error'\n        }\n\n        selected_models = ['LogisticRegression'] if problem_type != 'regression' else ['Ridge']\n        test_cases.append((X, y, problem_type, selected_models, model_config, scoring_config))\n\n    return test_cases"}
{"problem_id": "sklearn_87", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of various classifiers on subsets of data grouped by cluster labels. The function will take in a dataset and a specified classifier, train the classifier on each cluster, and compute various performance metrics.\n\nFunction Signature:\n```python\ndef evaluate_cac(X: np.ndarray, y: np.ndarray, cluster_labels: np.ndarray, classifier: str) -> tuple:\n```\n\n### Constants Used:\n- The constant `n_samples` is set to `5` in the `get_base_model` function, which is used to determine the number of neighbors in the K-Nearest Neighbors classifier.\n\n### Input Format:\n- `X`: A 2D numpy array of shape (n_samples, n_features) representing the feature set.\n- `y`: A 1D numpy array of shape (n_samples,) representing the target labels.\n- `cluster_labels`: A 1D numpy array of shape (n_samples,) representing the cluster assignments for each sample.\n- `classifier`: A string indicating the type of classifier to use (e.g., 'LR', 'RF', 'SVM', etc.).\n\n### Output Format:\n- Returns a tuple containing:\n  - A list of five floats representing accuracy, F1 score, AUC score, specificity, and sensitivity.\n  - A float representing the total log loss across all clusters.\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3], \n              [0.4, 0.5, 0.6], \n              [0.7, 0.8, 0.9], \n              [0.2, 0.1, 0.3], \n              [0.5, 0.4, 0.6], \n              [0.8, 0.7, 0.9]])\ny = np.array([0, 1, 0, 1, 0, 1])\ncluster_labels = np.array([0, 0, 0, 1, 1, 1])\nclassifier = 'LR'\n```\n\nOutput:\n```python\n([0, 0, 0, 0, 0], 0, [])\n```", "ground_truth_code": "from sklearn.linear_model import LogisticRegression, RidgeClassifier\nfrom sklearn.ensemble import RandomForestClassifier, AdaBoostClassifier\nfrom sklearn.svm import LinearSVC\nfrom sklearn.naive_bayes import MultinomialNB\nfrom sklearn.neighbors import KNeighborsClassifier\nimport numpy as np\nfrom sklearn import metrics\nfrom sklearn.metrics import f1_score, roc_auc_score, log_loss, confusion_matrix\n\ndef get_base_model(classifier, n_samples=5):\n    models = {\n        'LR': LogisticRegression(class_weight='balanced', max_iter=1000),\n        'RF': RandomForestClassifier(n_estimators=10),\n        'SVM': LinearSVC(max_iter=10000),\n        'ADB': AdaBoostClassifier(n_estimators=50),\n        'Ridge': RidgeClassifier(),\n        'NB': MultinomialNB(),\n        'KNN': KNeighborsClassifier(n_neighbors=min(5, n_samples))\n    }\n    return models.get(classifier, LogisticRegression(class_weight='balanced', max_iter=1000))\n\n# main code\ndef evaluate_cac(X, y, cluster_labels, classifier):\n    (y_pred, y_true, y_proba, models, loss) = ([], [], [], [], [])\n    for j in np.unique(cluster_labels):\n        pts_index = np.where(cluster_labels == j)[0]\n        if len(pts_index) < 5:\n            continue\n        x_cluster, y_cluster = X[pts_index], y[pts_index]\n        if len(np.unique(y_cluster)) < 2:\n            continue\n        model = get_base_model(classifier, len(pts_index))\n        clf = model.fit(x_cluster, y_cluster)\n        pred = clf.predict(x_cluster)\n        y_predict_proba = clf.predict_proba(x_cluster) if hasattr(clf, 'predict_proba') else np.zeros_like(pred)\n        y_pred.extend(pred)\n        y_true.extend(y_cluster)\n        y_proba.extend(y_predict_proba[:, 1] if y_predict_proba.ndim > 1 else pred)\n        models.append(model)\n        loss.append(log_loss(y_cluster, y_predict_proba) if y_predict_proba.ndim > 1 else 0)\n\n    if not y_pred:\n        return ([0, 0, 0, 0, 0], 0, models)\n\n    acc = metrics.accuracy_score(y_true, y_pred)\n    f1 = f1_score(y_true, y_pred)\n    auc = roc_auc_score(y_true, y_proba) if len(set(y_true)) > 1 else 0\n    params = confusion_matrix(y_true, y_pred).ravel()\n    spe = params[0] / (params[0] + params[1]) if params[0] + params[1] != 0 else 0\n    sen = params[3] / (params[3] + params[2]) if params[3] + params[2] != 0 else 0\n    return ([acc, f1, auc, spe, sen], sum(loss))", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 500)\n        num_features = np.random.randint(5, 50)\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.randint(0, 2, size=num_samples)\n        num_clusters = np.random.randint(2, min(10, num_samples // 2))\n        cluster_labels = np.random.randint(0, num_clusters, size=num_samples)\n        for j in np.unique(cluster_labels):\n            pts_index = np.where(cluster_labels == j)[0]\n            if len(np.unique(y[pts_index])) < 2:\n                y[pts_index[0]] = 1 - y[pts_index[0]]\n        classifier = np.random.choice(['LR', 'RF', 'SVM', 'ADB', 'Ridge', 'NB', 'KNN'])\n        test_cases.append((X, y, cluster_labels, classifier))\n    return test_cases\n"}
{"problem_id": "sklearn_88", "library": "sklearn", "code_problem": "You are tasked with implementing an ensemble learning model that combines multiple classifiers to improve prediction accuracy on a given dataset. The main function, `ensemble_model`, will take in training data and corresponding target labels, apply different classifiers, and evaluate their performance using cross-validation.\n\nFunction signature:\n```python\ndef ensemble_model(train_data, train_target):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `cv=5`, which specifies the number of folds in cross-validation.\n\nInput format:\n- `train_data`: A 2D array-like structure (e.g., a pandas DataFrame or a NumPy array) containing the feature data for training.\n- `train_target`: A 1D array-like structure (e.g., a pandas Series or a NumPy array) containing the target labels corresponding to the training data.\n\nOutput format:\n- The function returns a dictionary where each key is the name of a classifier, and the value is another dictionary containing:\n  - `mean_accuracy`: The mean accuracy score from cross-validation.\n  - `std_accuracy`: The standard deviation of the accuracy scores from cross-validation.\n\nInput:\n```python\ntrain_data = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n                       [0.5, 0.4, 0.3, 0.2, 0.1],\n                       [0.2, 0.3, 0.4, 0.5, 0.6],\n                       [0.6, 0.5, 0.4, 0.3, 0.2],\n                       [0.3, 0.4, 0.5, 0.5, 0.7],\n                       [0.7, 0.6, 0.5, 0.4, 0.3],\n                       [0.1, 0.2, 0.3, 0.4, 0.5],\n                       [0.5, 0.4, 0.4, 0.2, 0.2],\n                       [0.2, 0.3, 0.4, 0.5, 0.6],\n                       [0.4, 0.5, 0.4, 0.3, 0.2],\n                       [0.3, 0.6, 0.9, 0.6, 0.9],\n                       [0.7, 0.6, 0.1, 0.5, 0.3]])\ntrain_target = np.array([0, 1, 0, 1, 0, 1, 1, 1, 0, 0, 1, 1])\n```\n\nOutput:\n```python\n{\n    'Logistic Regression': {\n        'mean_accuracy': 0.5, \n        'std_accuracy': 0.10540925533894598\n    }, \n    'Random Forest': {\n        'mean_accuracy': 0.6666666666666666, \n        'std_accuracy': 0.18257418583505536\n    }, \n    'Naive Bayes': {\n        'mean_accuracy': 0.6666666666666666, \n        'std_accuracy': 0.18257418583505536\n    }, \n    'Ensemble': {\n        'mean_accuracy': 0.6666666666666666, \n        'std_accuracy': 0.18257418583505536\n    }\n}\n```\n", "ground_truth_code": "from sklearn.linear_model import LogisticRegression\nfrom sklearn.ensemble import RandomForestClassifier, VotingClassifier\nfrom sklearn.naive_bayes import GaussianNB\nfrom sklearn.model_selection import cross_val_score\n\n# main code\ndef ensemble_model(train_data, train_target):\n    classifiers = {\n        'Logistic Regression': LogisticRegression(solver='lbfgs'),\n        'Random Forest': RandomForestClassifier(n_estimators=50),\n        'Naive Bayes': GaussianNB()\n    }\n\n    classifiers['Ensemble'] = VotingClassifier(\n        estimators=[(name.lower().replace(' ', '_'), clf) for name, clf in classifiers.items()],\n        voting='hard'\n    )\n\n    results = {}\n    for name, clf in classifiers.items():\n        scores = cross_val_score(clf, train_data, train_target, cv=5, scoring='accuracy')\n        results[name] = {'mean_accuracy': scores.mean(), 'std_accuracy': scores.std()}\n\n    return results\n\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_features = np.random.randint(5, 20)\n        num_classes = np.random.randint(3, 5)\n        num_samples = np.random.randint(50, 200)\n        train_data = np.random.rand(num_samples, num_features)\n        train_target = np.random.randint(0, num_classes, size=num_samples)\n\n        test_cases.append((train_data, train_target))\n\n    return test_cases"}
{"problem_id": "sklearn_89", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates a machine learning model using a Random Forest classifier. The function will take in a dataset and various parameters to train the model and assess its performance using cross-validation.\n\nFunction Signature:\n```python\ndef evaluate_model(modeldata, features, test_size, n_estimators, max_features, cv_folds):\n```\n\n### Constants Used:\n- `random_state`: A constant value of `42` is used for reproducibility in both the `train_test_split` and `RandomForestClassifier`.\n\n### Input Format:\n- `modeldata`: A pandas DataFrame containing the dataset.\n- `features`: A dictionary with a key `'predictive_features'` that maps to a list of column names.\n- `test_size`: A float (e.g., 0.2) indicating the proportion of the dataset to be used for testing.\n- `n_estimators`: An integer specifying the number of trees in the Random Forest.\n- `max_features`: An integer or string indicating the number of features to consider when looking for the best split.\n- `cv_folds`: An integer representing the number of folds for cross-validation.\n\n### Output Format:\n- A dictionary where each key is a scoring metric (e.g., 'recall', 'precision', 'accuracy', 'f1_macro') and each value is a list of cross-validation scores corresponding to that metric.\n\n**Input:**\n```python\nmodeldata = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [1.0, 1.1, 1.2, 1.3, 1.4],\n    'feature_2': [2.0, 2.1, 2.2, 2.3, 2.4],\n    'feature_3': [3.0, 3.1, 3.2, 3.3, 3.4],\n    'label': [0, 0, 1, 1, 0]\n})\n\nfeatures = {\"predictive_features\": ['feature_0', 'feature_1', 'feature_2']}\ntest_size = 0.2\nn_estimators = 10\nmax_features = 'sqrt'\ncv_folds = 3\n```\n\n**Output:**\n```python\n{'recall': array([0.25, 0.25, 0.  ]), 'precision': array([0.25, 0.25, 0.  ]), 'accuracy': array([0.25, 0.25, 0.  ]), 'f1_macro': array([0.25, 0.25, 0.  ])}\n```", "ground_truth_code": "from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import train_test_split, cross_val_score\n\n# main code\ndef evaluate_model(modeldata, features, test_size, n_estimators, max_features, cv_folds):\n    predictive_features = features.get('predictive_features', [])\n    if not predictive_features:\n        return {}\n    clf_X = modeldata[predictive_features].values\n    clf_y = modeldata['label'].values\n    X_train, X_test, y_train, y_test = train_test_split(clf_X, clf_y, test_size=test_size, random_state=42)\n\n    classifier = RandomForestClassifier(n_estimators=n_estimators, max_features=max_features, random_state=42)\n    classifier.fit(X_train, y_train)\n\n    scoring_metrics = ['recall', 'precision', 'accuracy', 'f1_macro']\n    cv_scores = cross_val_score(classifier, X_train, y_train, cv=cv_folds, scoring='f1_macro')\n\n    return {metric: cv_scores for metric in scoring_metrics}", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(100, 1000)\n        n_features = np.random.randint(8, 30)\n\n        n_classes = np.random.choice([2, 3, 4])\n        n_clusters_per_class = 2\n\n        min_informative = max(2, int(np.ceil(np.log2(n_classes * n_clusters_per_class))))\n        max_informative = max(min_informative, n_features - 2)\n\n        n_informative = np.random.randint(min_informative, max_informative + 1)\n\n        n_redundant = np.random.randint(0, max(1, n_features - n_informative))\n        n_repeated = np.random.randint(0, max(1, n_features - n_informative - n_redundant))\n\n        X, y = make_classification(\n            n_samples=n_samples,\n            n_features=n_features,\n            n_informative=n_informative,\n            n_redundant=n_redundant,\n            n_repeated=n_repeated,\n            n_classes=n_classes,\n            n_clusters_per_class=n_clusters_per_class,\n            random_state=np.random.randint(1000)\n        )\n\n        modeldata = pd.DataFrame(X, columns=[f'feature_{i}' for i in range(n_features)])\n        modeldata['label'] = y\n\n        predictive_features = np.random.choice(modeldata.columns[:-1],\n                                               size=np.random.randint(2, n_features),\n                                               replace=False).tolist()\n        features = {\"predictive_features\": predictive_features}\n\n        test_size = np.random.uniform(0.1, 0.4)\n        n_estimators = np.random.randint(10, 20)\n        max_features = np.random.choice(['sqrt', 'log2', None])\n        cv_folds = np.random.randint(3, 5)\n\n        test_cases.append((modeldata, features, test_size, n_estimators, max_features, cv_folds))\n\n    return test_cases"}
{"problem_id": "sklearn_90", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates various fairness metrics for a binary classification model. The function will compute accuracy, area under the ROC curve (AUC), demographic parity, AUC parity, and a specific fairness metric known as the p-rule. These metrics will help assess the performance of the model while considering a sensitive attribute that may influence the predictions.\n\nFunction signature:\n```python\ndef metric_evaluation(y_gt: np.ndarray, y_pre: np.ndarray, s: np.ndarray) -> dict:\n```\n\nConstant used in the main code:\n- The constant `1e-08` is used to prevent division by zero in the p-rule calculation.\n\nInput format:\n- `y_gt`: A 1D numpy array of shape (n,) containing binary ground truth labels (0 or 1).\n- `y_pre`: A 1D numpy array of shape (n,) containing predicted probabilities (float values between 0 and 1).\n- `s`: A 1D numpy array of shape (n,) containing binary values representing the sensitive attribute (0 or 1).\n\nOutput format:\n- The function returns a dictionary with the following keys and their corresponding values:\n  - `'acc'`: Accuracy of the model as a percentage.\n  - `'auc'`: AUC score of the model as a percentage.\n  - `'dp'`: Demographic parity as a percentage.\n  - `'aucp'`: AUC parity as a percentage.\n  - `'prule'`: p-rule as a percentage.\n\nInput:\n```python\ny_gt = np.array([1, 0, 1, 0, 1, 0])\ny_pred = np.array([0.8, 0.4, 0.6, 0.3, 0.9, 0.2])\nsensitive_attribute = np.array([1, 0, 1, 0, 1, 0])\n```\n\nOutput:\n```python\n{\n    'acc': 100.0, \n    'auc': 100.0, \n    'dp': 100.0, \n    'aucp': nan, \n    ': 1e-06\n}\n```", "ground_truth_code": "from sklearn import metrics\nimport numpy as np\n\ndef demographic_parity(y_pred, sensitive_attribute, threshold=0.5):\n    y_z_1 = y_pred[sensitive_attribute == 1] > threshold\n    y_z_0 = y_pred[sensitive_attribute == 0] > threshold\n    return abs(y_z_1.mean() - y_z_0.mean()) * 100 if y_z_1.size and y_z_0.size else 0\n\ndef auc_parity(y_pred, y_gt, sensitive_attribute):\n    auc1 = metrics.roc_auc_score(y_gt[sensitive_attribute == 1], y_pred[sensitive_attribute == 1])\n    auc0 = metrics.roc_auc_score(y_gt[sensitive_attribute == 0], y_pred[sensitive_attribute == 0])\n    return abs(auc1 - auc0) * 100\n\ndef accuracy_parity(y_pred, y_gt, sensitive_attribute):\n    acc1 = metrics.accuracy_score(y_gt[sensitive_attribute == 1], y_pred[sensitive_attribute == 1] > 0.5)\n    acc0 = metrics.accuracy_score(y_gt[sensitive_attribute == 0], y_pred[sensitive_attribute == 0] > 0.5)\n    return abs(acc1 - acc0) * 100\n\ndef p_rule(y_pred, sensitive_attribute, threshold=0.5):\n    y_z_1 = y_pred[sensitive_attribute == 1] > threshold\n    y_z_0 = y_pred[sensitive_attribute == 0] > threshold\n    odds = y_z_1.mean() / (y_z_0.mean() + 1e-08) if y_z_1.size and y_z_0.size else 0\n    return np.nanmin([odds, 1 / (odds + 1e-08)]) * 100\n\n# main code\ndef metric_evaluation(y_gt, y_pre, s):\n    y_gt, y_pre, s = y_gt.ravel(), y_pre.ravel(), s.ravel()\n    metrics_dict = {\n        'acc': metrics.accuracy_score(y_gt, y_pre > 0.5) * 100,\n        'auc': metrics.roc_auc_score(y_gt, y_pre) * 100,\n        'dp': demographic_parity(y_pre, s),\n        'aucp': auc_parity(y_pre, y_gt, s),\n        'prule': p_rule(y_pre, s)\n    }\n    return metrics_dict", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        y_gt = np.random.randint(0, 2, size=(num_samples,))\n        y_pred = np.random.rand(num_samples, )\n        sensitive_attribute = np.random.randint(0, 2, size=(num_samples,))\n        test_cases.append((y_gt, y_pred, sensitive_attribute))\n\n    return test_cases"}
{"problem_id": "sklearn_91", "library": "sklearn", "code_problem": "You are tasked with implementing a function that trains a logistic regression model using a given set of labels and features. The function should handle class imbalance by calculating appropriate class weights and applying a scaling transformation to the feature set. The model will be evaluated using a custom scoring metric based on the F-beta score.\n\nFunction signature:\n```python\ndef learn_model(labels: np.ndarray, X: np.ndarray) -> np.ndarray:\n```\n\nConstant used in the main code:\n- `pos_class_boost`: A constant value set to `1.5` that is used to amplify the weight of the positive class in the class weight calculation.\n\nInput format:\n- `labels`: A 1D numpy array of binary labels (0s and 1s) indicating the class of each sample.\n- `X`: A 2D numpy array where each row represents a sample and each column represents a feature.\n\nOutput format:\n- A 1D numpy array containing the predicted labels for each sample in the input feature set `X`.\n\nInput:\n```python\nlabels = np.array([0, 1, 0, 1, 1])\nX = np.array([[0.1, 0.2, 0.3],\n              [0.4, 0.5, 0.6],\n              [0.7, 0.8, 0.9],\n              [1.0, 1.1, 1.2],\n              [1.3, 1.4, 1.5]])\n```\n\nOutput:\n```python\narray([1, 1, 0, 1, 0])\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.preprocessing import LabelEncoder, StandardScaler\nfrom sklearn import utils, metrics\nfrom sklearn.linear_model import LogisticRegressionCV\n\n# main code\ndef learn_model(labels, X):\n    num_pos_labels = np.count_nonzero(labels)\n    num_labels = float(labels.shape[0])\n    num_neg_labels = num_labels - num_pos_labels\n    pos_class_weight = num_labels / num_pos_labels\n    neg_class_weight = num_labels / num_neg_labels\n    total_weight = pos_class_weight + neg_class_weight\n    pos_class_weight /= total_weight\n    neg_class_weight /= total_weight\n    pos_class_boost = 1.5\n\n    label_encoder = LabelEncoder()\n    labels = label_encoder.fit_transform(labels)\n\n    scaler = StandardScaler()\n    X = scaler.fit_transform(X)\n    X, labels = utils.shuffle(X, labels, random_state=999)\n\n    class_weights = {1: pos_class_weight * pos_class_boost, 0: neg_class_weight}\n\n    p_scorer = metrics.make_scorer(metrics.fbeta_score, pos_label=1, beta=0.5)\n    logreg_cv = LogisticRegressionCV(\n        Cs=[1000], class_weight=class_weights, cv=3, solver='sag',\n        n_jobs=6, scoring=p_scorer, verbose=False, random_state=999\n    )\n    logreg_cv.fit(X, labels)\n    model = logreg_cv\n\n    pred = model.predict(X)\n\n    return pred", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n\n        labels = np.random.choice([0, 1], size=(num_samples,))\n        X = np.random.randn(num_samples, num_features)\n\n        test_cases.append((labels, X))\n    return test_cases"}
{"problem_id": "sklearn_92", "library": "sklearn", "code_problem": "You are tasked with creating a function that returns a specific data transformation scaler based on a given parameter. The function should be able to handle various types of scalers from the `sklearn.preprocessing` module, allowing for flexible data preprocessing in machine learning tasks.\n\nFunction signature:\n```python\ndef get_scaler(param):\n```\n\nConstant used in the main code:\n- The default value for `n_quantiles` in the `QuantileTransformer` is set to 1000.\n\nInput format:\n- The input to the function is a dictionary `param` that may contain the keys `\"transformer\"` and `\"n_quantiles\"`.\n\nOutput format:\n- The output of the function is an instance of a scaler from the `sklearn.preprocessing` module based on the specified transformer or a default `QuantileTransformer`.\n\n**Input:**\n```python\n{\n    \"transformer\": \"minmax\",\n    \"input_data\": np.random.randn(10, 3)\n}\n```\n\n**Output:**\n```python\nMinMaxScaler()\n```", "ground_truth_code": "from sklearn.preprocessing import (\n    QuantileTransformer,\n    MaxAbsScaler,\n    RobustScaler,\n    MinMaxScaler,\n    PowerTransformer,\n    StandardScaler,\n    Normalizer,\n    KBinsDiscretizer,\n)\n\n# main code\ndef get_scaler(param):\n    transformers = {\n        \"quantile\": QuantileTransformer(output_distribution=\"normal\"),\n        \"maxabs\": MaxAbsScaler(),\n        \"robust\": RobustScaler(),\n        \"minmax\": MinMaxScaler(),\n        \"yeo-johnson\": PowerTransformer(method=\"yeo-johnson\"),\n        \"box_cox\": PowerTransformer(method=\"box-cox\"),\n        \"standard\": StandardScaler(),\n        \"l2\": Normalizer(norm=\"l2\"),\n        \"kbins_discretizer\": KBinsDiscretizer(n_bins=10, encode=\"ordinal\", strategy=\"uniform\"),\n    }\n\n    return transformers.get(param.get(\"transformer\"),\n                            QuantileTransformer(n_quantiles=param.get(\"n_quantiles\", 1000)))", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    transformer_options = [\n        \"quantile\", \"maxabs\", \"robust\", \"minmax\", \"yeo-johnson\", \"box_cox\", \"standard\", \"l2\", \"kbins_discretizer\"\n    ]\n\n    for _ in range(n):\n        param = {\"transformer\": random.choice(transformer_options)}\n        if param[\"transformer\"] == \"quantile\":\n            param[\"n_quantiles\"] = random.randint(10, 1000)\n        elif param[\"transformer\"] == \"box_cox\":\n            param[\"input_data\"] = np.abs(np.random.randn(random.randint(5, 50), random.randint(1, 10))) + 1e-3\n        else:\n            param[\"input_data\"] = np.random.randn(random.randint(5, 50), random.randint(1, 10))\n\n        test_cases.append(param)\n\n    return test_cases"}
{"problem_id": "sklearn_93", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs model selection and cross-validation for a Multi-layer Perceptron (MLP) regression model using the scikit-learn library. The function will utilize a grid search to find the best hyperparameters for the MLP model and evaluate its performance using Group K-Fold cross-validation.\n\nFunction Signature:\n```python\ndef MLP_cv_plus_model_selection(X0, y0, k, group_labels, n_jobs=-1, max_iter=500):\n```\n\n### Constants:\n- `max_iter`: This constant is set to 500, which defines the maximum number of iterations for the MLP model training.\n\n### Input Format:\n- `X0`: A 2D array-like structure representing the feature set.\n- `y0`: A 1D array-like structure representing the target values.\n- `k`: An integer representing the number of splits for Group K-Fold cross-validation.\n- `group_labels`: A 1D array-like structure representing the group labels for the samples.\n- `n_jobs`: An integer (default is -1) indicating the number of jobs to run in parallel.\n- `max_iter`: An integer (default is 500) specifying the maximum number of iterations for the MLP model.\n\n### Output Format:\n- The function returns a tuple containing:\n  - A list of scores from the grid search for each test set.\n  - A list of scores from the model evaluated on randomized target values.\n\nInput:\n```python\nX0 = np.array([[0.1, 0.2, 0.3], \n                [0.4, 0.5, 0.6], \n                [0.7, 0.8, 0.9], \n                [0.2, 0.3, 0.4], \n                [0.5, 0.6, 0.7]])\ny0 = np.array([[0.1], \n                [0.2], \n                [0.3], \n                [0.4], \n                [0.5]])\nk = 2\ngroup_labels = np.array([1, 1, 2, 2, 1])\n```\n\nOutput:\n```python\n([-0.6505827459676097, -7.0812862492210265], \n array([ -8.89565626, -73.27000302]))\n```", "ground_truth_code": "from sklearn.neural_network import MLPRegressor\nfrom sklearn.model_selection import GroupKFold, GridSearchCV, cross_val_score\nimport numpy as np\n\n\n# main code\ndef MLP_cv_plus_model_selection(X0, y0, k, group_labels, n_jobs=-1, max_iter=500):\n    mlp_model = MLPRegressor(random_state=0, max_iter=max_iter)\n    parameter_space = {\n        'hidden_layer_sizes': [(10,), (20,)],\n        'activation': ['relu', 'logistic'],\n        'alpha': [0.0001, 0.01, 0.1],\n        'learning_rate': ['constant']\n    }\n    grid_search = GridSearchCV(mlp_model, parameter_space, n_jobs=n_jobs, cv=2)\n\n    X, y = np.asarray(X0), np.asarray(y0).ravel()\n    scores = []\n\n    split_obj = GroupKFold(n_splits=k)\n    for train_index, test_index in split_obj.split(X, y, group_labels):\n        X_train, X_test = X[train_index], X[test_index]\n        y_train, y_test = y[train_index], y[test_index]\n\n        grid_search.fit(X_train, y_train)\n        scores.append(grid_search.score(X_test, y_test))\n\n    scores_rand = (\n        cross_val_score(mlp_model, X, np.random.permutation(y), groups=group_labels, cv=split_obj, n_jobs=n_jobs)\n    )\n\n    return scores, scores_rand", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 150)\n        num_features = np.random.randint(5, 15)\n\n        X0 = np.random.rand(num_samples, num_features)\n        y0 = np.random.rand(num_samples, 1)\n\n        k = np.random.randint(2, min(5, num_samples // 2))\n\n        group_labels = np.random.randint(1, k + 1, size=num_samples)\n\n        test_cases.append((X0, y0, k, group_labels))\n\n    return test_cases"}
{"problem_id": "sklearn_94", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs hyperparameter tuning for a K-Nearest Neighbors (KNN) classifier using both the original feature space and a precomputed distance matrix. The function will utilize cross-validation to evaluate the performance of the model with different hyperparameter settings.\n\nFunction signature:\n```python\ndef search_cv_pairwise_equivalence(X, y, grid_params, n_splits):\n```\n\nConstants used in the main code:\n- There are no explicit constants defined in the code, but the variable `n_splits` is used to determine the number of folds in cross-validation.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature matrix.\n- `y`: A 1D array-like structure representing the target labels corresponding to the samples in `X`.\n- `grid_params`: A dictionary containing the hyperparameters to be tuned for the KNN classifier.\n- `n_splits`: An integer representing the number of folds for cross-validation.\n\nOutput format:\n- The function returns a tuple containing two elements:\n  - `preds_original`: An array of predictions made on the original feature matrix.\n  - `preds_precomputed`: An array of predictions made using the precomputed distance matrix.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.2, 0.1], [0.3, 0.4], [0.4, 0.3]])\ny = np.array([0, 0, 1, 1])\ngrid_params = {'n_neighbors': [3]}\nn_splits = 2\n```\n\nOutput:\n```python\npreds_original = np.array([0, 0, 1, 1])\npreds_precomputed = np.array([0, 0, 1, 1])\n```", "ground_truth_code": "from sklearn.neighbors import KNeighborsClassifier\nfrom sklearn.model_selection import GridSearchCV\nfrom sklearn.metrics.pairwise import euclidean_distances\n\n\n# main code\ndef search_cv_pairwise_equivalence(X, y, grid_params, n_splits):\n    clf = KNeighborsClassifier()\n    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n    cv.fit(X, y)\n    preds_original = cv.predict(X)\n\n    X_precomputed = euclidean_distances(X)\n    clf = KNeighborsClassifier(metric='precomputed')\n    cv = GridSearchCV(clf, grid_params, cv=n_splits)\n    cv.fit(X_precomputed, y)\n    preds_precomputed = cv.predict(X_precomputed)\n\n    return preds_original, preds_precomputed", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_features = np.random.randint(2, 20)\n\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.randint(0, 2, size=num_samples)\n        grid_params = {'n_neighbors': [np.random.choice([1, 3, 5, 7, 9])]}\n\n        n_splits = np.random.randint(2, min(6, num_samples))\n\n        test_cases.append((X, y, grid_params, n_splits))\n\n    return test_cases"}
{"problem_id": "sklearn_95", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various performance metrics for a set of predictions in a binary classification problem. The function will handle both individual and multiple sets of predictions, allowing for the averaging of results when multiple sets are provided. The performance metrics to be calculated include the area under the receiver operating characteristic curve (AUROC) for malignant and benign classes, as well as the area under the precision-recall curve (AUPRC). The function will return a comprehensive dictionary containing these metrics along with the processed predictions and labels.\n\nFunction Signature:\n```python\ndef calculate_performance(preds_to_load: list, preds_lookup: dict, study_level: bool) -> dict:\n```\n\nConstants used in the main code:\n- There are no explicit constants defined in the code; however, the indices used for malignant and benign labels are hardcoded as 0, 1, 2, and 3.\n\nInput Format:\n- `preds_to_load`: A list of keys to load predictions from the `preds_lookup` dictionary.\n- `preds_lookup`: A dictionary where each key corresponds to a set of predictions and labels.\n- `study_level`: A boolean indicating whether to calculate metrics at the study level or not.\n\nOutput Format:\n- The function returns a dictionary containing the following keys:\n  - 'preds_to_load': The input list of predictions to load.\n  - 'malignant_auroc': The AUROC score for malignant predictions.\n  - 'benign_auroc': The AUROC score for benign predictions.\n  - 'total_auroc': The total AUROC score.\n  - 'auprc': The AUPRC score.\n  - 'score': The combined score of malignant AUROC and AUPRC.\n  - 'labels': The processed labels.\n  - 'logits': The processed logits.\n  - 'labels_malignant': The labels for malignant cases.\n  - 'labels_benign': The labels for benign cases.\n  - 'logits_malignant': The logits for malignant cases.\n  - 'logits_benign': The logits for benign cases.\n  - 'indices': The indices corresponding to the predictions.\n\n**Input:**\n```python\npreds_to_load = ['pred_0', 'pred_1']\npreds_lookup = {\n    'pred_0': {\n        'indices': [(0,), (1,), (2,)],\n        'labels': {0: [1, 0, 0, 1], 1: [0, 1, 0, 0], 2: [1, 1, 0, 0]},\n        'preds': {0: [0.9, 0.1, 0.2, 0.8], 1: [0.4, 0.6, 0.1, 0.3], 2: [0.7, 0.2, 0.4, 0.5]}\n    },\n    'pred_1': {\n        'indices': [(0,), (1,), (2,)],\n        'labels': {0: [1, 0, 0, 1], 1: [0, 1, 0, 0], 2: [1, 1, 0, 0]},\n        'preds': {0: [0.8, 0.2, 0.3, 0.7], 1: [0.5, 0.5, 0.2, 0.4], 2: [0.6, 0.3, 0.5, 0.6]}\n    }\n}\nstudy_level = False\n```\n\n**Output:**\n```python\n{\n    'preds_to_load': ['pred_0', 'pred_1'], \n    'malignant_auroc': 0.7222222222222222, \n    'benign_auroc': 1.0, \n    'total_auroc': nan, \n    'auprc': 0.7944444444444445, \n    'score': 1.5166666666666666, \n    'labels': array([[1, 0, 0, 1], [0, 1, 0, 0], [1, 1, 0, 0]]), \n    'logits': array([[0.85, 0.15, 0.25, 0.75], [0.45, 0.55, 0.15, 0.35], [0.65, 0.25, 0.45, 0.55]]), \n    'labels_malignant': array([0, 1, 1, 1, 0, 0]), \n    'labels_benign': array([1, 0, 1, 0, 0, 0]), \n    'logits_malignant': array([0.15, 0.55, 0.25, 0.75, 0.35, 0.55]), \n    'logits_benign': array([0.85, 0.45, 0.65, 0.25, 0.15, 0.45]), \n    'indices': [0, 1, 2]\n}\n```\n", "ground_truth_code": "import numpy as np\nfrom sklearn.metrics import roc_auc_score, precision_recall_curve, auc\n\n# main code\ndef calculate_performance(preds_to_load, preds_lookup, study_level):\n    if len(preds_to_load) == 1:\n        preds = preds_lookup[preds_to_load[0]]\n        if isinstance(preds['preds'], list):\n            preds['preds'] = {k[0]: list(v[0]) for k, v in zip(preds['indices'], preds['preds'])}\n        if isinstance(preds['labels'], list):\n            preds['labels'] = {k[0]: list(v[0]) for k, v in zip(preds['indices'], preds['labels'])}\n    else:\n        preds_array = [preds_lookup[p] for p in preds_to_load]\n        combined_preds_dict = {k: [] for k in preds_array[0]['preds'].keys()}\n\n        for p in preds_array:\n            for k, v in p['preds'].items():\n                combined_preds_dict[k].append(v)\n\n        averaged_preds_dict = {k: np.mean(v, axis=0) for k, v in combined_preds_dict.items()}\n        preds = {\n            'indices': preds_array[0]['indices'],\n            'labels': preds_array[0]['labels'],\n            'preds': averaged_preds_dict\n        }\n\n    labels = np.array(list(preds['labels'].values()))\n    logits = np.array(list(preds['preds'].values()))\n    indices = [x[0] for x in preds['indices']]\n\n    if not study_level:\n        labels_malignant = np.append(labels[:, 1], labels[:, 3])\n        logits_malignant = np.append(logits[:, 1], logits[:, 3])\n        labels_benign = np.append(labels[:, 0], labels[:, 2])\n        logits_benign = np.append(logits[:, 0], logits[:, 2])\n\n        malignant_auroc = roc_auc_score(labels_malignant, logits_malignant)\n        total_auroc = roc_auc_score(labels, logits) if len(np.unique(labels)) > 1 else 0.0\n        benign_auroc = roc_auc_score(labels_benign, logits_benign) if len(np.unique(labels_benign)) > 1 else 0.0\n\n        precision, recall, _ = precision_recall_curve(labels_malignant, logits_malignant)\n        auprc = auc(recall, precision)\n        score = malignant_auroc + auprc\n    else:\n        study_level_labels = [d_[1] or d_[3] for d_ in labels]\n        study_level_logits_avg = [np.mean((d_[1], d_[3])) for d_ in logits]\n\n        labels_malignant = study_level_labels\n        logits_malignant = study_level_logits_avg\n        logits_benign = None\n        labels_benign = None\n\n        malignant_auroc = roc_auc_score(labels_malignant, logits_malignant)\n        benign_auroc = 0.0\n        total_auroc = malignant_auroc\n\n        precision, recall, _ = precision_recall_curve(labels_malignant, logits_malignant)\n        auprc = auc(recall, precision)\n        score = malignant_auroc + auprc\n\n    return {\n        'preds_to_load': preds_to_load,\n        'malignant_auroc': malignant_auroc,\n        'benign_auroc': benign_auroc,\n        'total_auroc': total_auroc,\n        'auprc': auprc,\n        'score': score,\n        'labels': labels,\n        'logits': logits,\n        'labels_malignant': labels_malignant,\n        'labels_benign': labels_benign,\n        'logits_malignant': logits_malignant,\n        'logits_benign': logits_benign,\n        'indices': indices\n    }", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_preds = random.choice([1, random.randint(2, 5)])\n        preds_to_load = [f'pred_{i}' for i in range(num_preds)]\n\n        preds_lookup = {}\n        num_samples = random.randint(5, 20)\n        for pred_id in preds_to_load:\n            indices = [(i,) for i in range(num_samples)]\n            labels = {i: np.random.randint(0, 2, size=4).tolist() for i in range(num_samples)}\n            preds = {i: np.random.rand(4).tolist() for i in range(num_samples)}\n\n            preds_lookup[pred_id] = {\n                'indices': indices,\n                'labels': labels,\n                'preds': preds\n            }\n\n        study_level = random.choice([True, False])\n        test_cases.append((preds_to_load, preds_lookup, study_level))\n\n    return test_cases"}
{"problem_id": "sklearn_96", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates a machine learning model using a Random Forest classifier. The function will take in a set of features and a dataset, and it will return various performance metrics based on cross-validation.\n\nFunction signature:\n```python\ndef mmb_evaluate_model(features, modeldata):\n```\n\nConstant used in the main code:\n- `test_size=0.2`: This constant is used to specify that 20% of the data will be reserved for testing the model.\n\nInput format:\n- `features`: A dictionary with a key 'predictive_features' that maps to a list of feature names.\n- `modeldata`: A DataFrame containing the dataset with the specified predictive features and a 'label' column.\n\nOutput format:\n- The function returns a dictionary where the keys are the metric names ('recall', 'precision', 'accuracy', 'f1_macro') and the values are arrays of scores corresponding to each metric from the cross-validation.\n\n**Input:**\n```python\nfeatures = {'predictive_features': ['feature_0', 'feature_1', 'feature_2', 'feature_3', 'feature_4']}\nmodeldata = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    'feature_1': [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1],\n    'feature_2': [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4],\n    'feature_3': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n    'feature_4': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n    'label': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n```\n\n**Output:**\n```python\n{\n    'recall': array([1., 1., 1.]), \n    'precision': array([1., 1., 1.]), \n    'accuracy': array([1., 1., 1.]), \n    'f1_macro': array([1.  , 0.25, 1.  ])\n}\n```", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import cross_val_score\n\n# main code\ndef mmb_evaluate_model(features, modeldata):\n    predictive_features = features.get('predictive_features', [])\n    if not predictive_features:\n        return {}\n\n    clf_X = modeldata[predictive_features].values\n    clf_y = np.array(modeldata['label'])\n\n    X_train, X_test, y_train, y_test = train_test_split(clf_X, clf_y, test_size=0.2)\n\n    lb = LabelBinarizer()\n    y_train = np.array([n[0] for n in lb.fit_transform(y_train)])\n\n    eval_cls = RandomForestClassifier(n_estimators=100, max_features=0.2)\n    eval_cls.fit(X_train, y_train)\n\n    metrics = ['recall', 'precision', 'accuracy', 'f1_macro']\n    scores = {metric: cross_val_score(eval_cls, X_train, y_train, cv=3, scoring=metric) for metric in metrics}\n\n    return scores", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_features = np.random.randint(5, 11)\n        feature_names = [f'feature_{i}' for i in range(num_features)]\n\n        X, y = make_classification(n_samples=100, n_features=num_features, n_informative=num_features - 2,\n                                   n_redundant=2, n_classes=2, random_state=np.random.randint(0, 10000))\n        modeldata = pd.DataFrame(X, columns=feature_names)\n        modeldata['label'] = y\n        features = {'predictive_features': feature_names}\n\n        test_cases.append((features, modeldata))\n\n    return test_cases"}
{"problem_id": "sklearn_97", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates various regression metrics to evaluate the performance of a predictive model. The function will take in the true values and predicted values of a dataset, along with a name for the dataset, and return a dictionary containing the calculated metrics.\n\nFunction signature:\n```python\ndef get_metrics(y_true: np.ndarray, y_pred: np.ndarray, data_name: str) -> dict:\n```\n\n### Constants Used:\n- The constant used in the main code is `0.75` and `0.25`, which are used to calculate the interquartile range.\n\n### Input Format:\n- `y_true`: A NumPy array of true values.\n- `y_pred`: A NumPy array of predicted values.\n- `data_name`: A string representing the name of the dataset.\n\n### Output Format:\n- A dictionary containing the calculated metrics, where keys are metric names prefixed with the dataset name, and values are the corresponding metric values rounded to two decimal places.\n\nInput:\n```python\ny_true = np.array([100, 200, 300, 400, 500])\ny_pred = np.array([110, 190, 290, 410, 480])\ndata_name = \"test_data\"\n```\n\nOutput:\n```python\n{\n    'test_data_mape': 0.05, \n    'test_data_mae': 12.0, \n    'test_data_mse': 160.0, \n    'test_data_rmse': 12.65, \n    'test_data_nrmse_minmax': 0.03, \n    'test_data_nrmse_iq': 0.06, \n    'test_data_nrmse_sd': 0.09, \n    'test_data_nrmse_mean': 0.04, \n    'test_data_rsquared': 0.99\n}\n```", "ground_truth_code": "from sklearn.metrics import (\n    mean_absolute_percentage_error,\n    mean_absolute_error,\n    mean_squared_error,\n    r2_score,\n)\nimport numpy as np\n\n# main code\ndef get_metrics(y_true, y_pred, data_name):\n    if y_true.size == 0 or y_pred.size == 0:\n        return {}\n\n    mse = mean_squared_error(y_true, y_pred)\n    rmse = np.sqrt(mean_squared_error(y_true, y_pred))\n\n    minmax_range = y_true.max() - y_true.min()\n    interquartile_range = np.quantile(y_true, 0.75) - np.quantile(y_true, 0.25)\n    std_dev = np.std(y_true)\n    mean_val = np.mean(y_true)\n\n    return {\n        f\"{data_name}_mape\": round(mean_absolute_percentage_error(y_true, y_pred), 2),\n        f\"{data_name}_mae\": round(mean_absolute_error(y_true, y_pred), 2),\n        f\"{data_name}_mse\": round(mse, 2),\n        f\"{data_name}_rmse\": round(rmse, 2),\n        f\"{data_name}_nrmse_minmax\": round(rmse / minmax_range, 2) if minmax_range else None,\n        f\"{data_name}_nrmse_iq\": round(rmse / interquartile_range, 2) if interquartile_range else None,\n        f\"{data_name}_nrmse_sd\": round(rmse / std_dev, 2) if std_dev else None,\n        f\"{data_name}_nrmse_mean\": round(rmse / mean_val, 2) if mean_val else None,\n        f\"{data_name}_rsquared\": round(r2_score(y_true, y_pred), 2),\n    }", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = np.random.randint(1, 101)\n        y_true = np.random.uniform(low=-1000, high=1000, size=size)\n        noise_scale = np.random.uniform(0, 100)\n        y_pred = y_true + np.random.normal(loc=0, scale=noise_scale, size=size)\n        data_name = f\"data_{np.random.randint(0, 1000)}\"\n\n        test_cases.append((y_true, y_pred, data_name))\n    return test_cases"}
{"problem_id": "sklearn_98", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates the Canonical Correlation Analysis (CCA) score between two input arrays. The function should handle the preprocessing of the input data by removing dimensions with low variance and then fitting a CCA model to the processed data. Finally, it should compute the Pearson correlation coefficient between the transformed outputs of the CCA model.\n\nFunction signature:\n```python\ndef calculate_CCA_score(input_array_one, input_array_two, CCA_model=None, threshold=1e-8):\n```\n\nConstant used in the main code:\n- `threshold`: A small constant value set to `1e-8`, which is used to determine whether the standard deviation of a dimension is considered valid.\n\nInput format:\n- `input_array_one`: A 2D numpy array of shape (n_samples, n_features_one).\n- `input_array_two`: A 2D numpy array of shape (n_samples, n_features_two).\n- `CCA_model`: (Optional) A CCA model instance. If not provided, a default model will be created.\n- `threshold`: (Optional) A float value used to filter dimensions based on their standard deviation.\n\nOutput format:\n- The function returns a float value representing the Pearson correlation coefficient between the transformed outputs of the CCA model.\n\nInput:\n```python\ninput_array_one = np.array([[ 0.49671415, -0.1382643 ,  0.64768854,  1.52302986],\n                            [-0.23415337, -0.23413696,  1.57921282,  0.76743473],\n                            [-0.46947439,  0.54256004, -0.46341769, -0.46572975],\n                            [ 0.24196227, -1.91328024, -1.72491783, -0.56228753],\n                            [-1.01283112,  0.31424733, -0.90802408, -1.4123037 ]])\n                            \ninput_array_two = np.array([[ 0.73846658,  0.17136828, -0.11564828, -0.3011037 ],\n                            [ 1.85227818, -0.01349722, -1.05771093,  0.82254491],\n                            [-0.22084365,  1.95967012, -1.32818605,  0.19686124],\n                            [ 0.73846658,  0.17136828, -0.11564828, -0.3011037 ],\n                            [ 1.85227818, -0.01349722, -1.05771093,  0.82254491]])\n```\n\nOutput:\n```python\n1.0\n```", "ground_truth_code": "import numpy as np\nfrom scipy import stats\nfrom sklearn.cross_decomposition import CCA\n\n# main code\ndef calculate_CCA_score(input_array_one, input_array_two, CCA_model=None, threshold=1e-8):\n    if CCA_model is None:\n        CCA_model = CCA(n_components=1, max_iter=2000, scale=False)\n\n    std_one = np.std(input_array_one, axis=0)\n    std_two = np.std(input_array_two, axis=0)\n\n    valid_dims_one = std_one > threshold\n    valid_dims_two = std_two > threshold\n\n    input_array_one = input_array_one[:, valid_dims_one]\n    input_array_two = input_array_two[:, valid_dims_two]\n\n    CCA_model.fit(input_array_one, input_array_two)\n    enc_one, enc_two = CCA_model.transform(input_array_one, input_array_two)\n\n    r, _ = stats.pearsonr(enc_one.squeeze().astype('float64'), enc_two.squeeze().astype('float64'))\n\n    return r", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(10, 100)\n        num_features_one = np.random.randint(2, 50)\n        num_features_two = np.random.randint(2, 50)\n        shared_features = min(num_features_one, num_features_two, np.random.randint(1, 10))\n        shared_data = np.random.randn(num_samples, shared_features)\n        input_array_one = np.random.randn(num_samples, num_features_one)\n        input_array_two = np.random.randn(num_samples, num_features_two)\n        input_array_one[:, :shared_features] += shared_data\n        input_array_two[:, :shared_features] += shared_data\n        test_cases.append((input_array_one, input_array_two))\n\n    return test_cases"}
{"problem_id": "sklearn_99", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs a bagging ensemble method for classification. The function will take predictions from multiple classifiers, aggregate them, and compute various performance metrics based on the aggregated predictions. The function signature is as follows:\n\n```python\ndef bagging(pred_labels, bagging_print, logset, labels):\n```\n\n### Constants:\n- `num_clf`: This constant represents the number of classifiers used in the bagging process, which is determined by the length of the `logset`.\n\n### Input and Output Format:\n- **Input Format**:\n  - `pred_labels`: A 2D list or array of shape (n_classifiers, n_samples) containing the predictions from each classifier.\n  - `bagging_print`: A boolean indicating whether to print the metrics.\n  - `logset`: A list of classifiers used for bagging.\n  - `labels`: A tuple where the first element is a list or array of true labels for the samples.\n\n- **Output Format**:\n  - Returns a tuple:\n    - The first element is a 1D array of binary predictions (0 or 1).\n    - The second element is a dictionary containing the computed metrics.\n\n**Input:**\n```python\npred_labels = [\n    [1, 0, 1, 1, 0],\n    [0, 1, 1, 0, 1],\n    [1, 1, 0, 1, 0]\n]\nbagging_print = True\nlogset = [{}, {}, {}]\nlabels = [[1, 1, 1, 0, 0]]\n```\n\n**Output:**\n```python\n(\n    array([1, 1, 1, 1, 0]), \n    {\n        'balanced_accuracy': 0.75, \n        'precision': 0.75, \n        'confusion_matrix': array([[1, 1], [0, 3]]), \n        'recall': 1.0, \n        'f1_score': 0.8571428571428571, \n        'negative_accuracy': 0.5, \n        'positive_accuracy': 1.0\n    }\n)\n```", "ground_truth_code": "from sklearn.metrics import balanced_accuracy_score, precision_score, confusion_matrix, recall_score, f1_score\nimport numpy as np\n\n# main code\ndef bagging(pred_labels, bagging_print, logset, labels):\n    num_clf = len(logset)\n    all_pred_labels = np.array(pred_labels).sum(axis=0)\n    bagging = (all_pred_labels > num_clf / 2).astype(int)\n\n    metrics = {\n        \"balanced_accuracy\": balanced_accuracy_score(labels[0], bagging),\n        \"precision\": precision_score(labels[0], bagging),\n        \"confusion_matrix\": confusion_matrix(labels[0], bagging),\n        \"recall\": recall_score(labels[0], bagging),\n        \"f1_score\": f1_score(labels[0], bagging)\n    }\n\n    cm = metrics[\"confusion_matrix\"]\n    metrics[\"negative_accuracy\"] = float(cm[0][0]) / sum(cm[0])\n    metrics[\"positive_accuracy\"] = float(cm[1][1]) / sum(cm[1])\n\n    if bagging_print:\n        for key, value in metrics.items():\n            if key != \"confusion_matrix\":\n                print(f\"{key.replace('_', ' ').title()}: {value * 100:.2f}\")\n\n    return bagging, metrics", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_clf = np.random.randint(2, 10)\n        num_samples = np.random.randint(5, 50)\n        pred_labels = [np.random.randint(0, 2, size=num_samples).tolist() for _ in range(num_clf)]\n        bagging_print = np.random.choice([True, False])\n        logset = [{} for _ in range(num_clf)]\n        labels = [np.random.randint(0, 2, size=num_samples).tolist()]\n\n        test_cases.append((pred_labels, bagging_print, logset, labels))\n\n    return test_cases"}
{"problem_id": "sklearn_100", "library": "sklearn", "code_problem": "You are tasked with implementing a function that splits multiple arrays into training and testing sets while accounting for a specified gap between the two sets. The function should allow for flexible specification of the sizes of the training and testing sets, as well as the size of the gap. \n\nThe function signature is as follows:\n\n```python\ndef gap_train_test_split(arrays, options):\n```\n\n### Constants:\n- The constant used in the main code is `0.25`, which represents the default test size if neither `test_size` nor `train_size` is provided in the options.\n\n### Input and Output Format:\n- **Input**: \n  - `arrays`: A list of arrays (e.g., lists, numpy arrays) to be split.\n  - `options`: A dictionary containing optional parameters:\n    - `test_size`: (optional) The proportion or absolute number of samples to include in the test set.\n    - `train_size`: (optional) The proportion or absolute number of samples to include in the training set.\n    - `gap_size`: (optional) The number of samples to leave as a gap between the training and testing sets.\n\n- **Output**: \n  - A list containing the training and testing sets for each array, where the first half of the list corresponds to the training sets and the second half corresponds to the testing sets.\n\n**Input:**\n```python\narrays = (np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0]]), \n          np.array([1, 2, 3, 4, 5]))\noptions = {\n    'test_size': 0.4,\n    'train_size': None,\n    'gap_size': 0.2\n}\n```\n\n**Output:**\n```python\n[\n    array([[0.1, 0.2], [0.3, 0.4]]), \n    array([[0.7, 0.8], [0.9, 1. ]]), \n    array([1, 2]),\n    array([4, 5])\n]\n\n```\n", "ground_truth_code": "from math import modf\nimport numpy as np\nfrom sklearn.utils import indexable, _safe_indexing\nfrom sklearn.utils.validation import check_consistent_length, _num_samples\n\n\ndef size_to_number(size, n):\n    (b, a) = modf(size)\n    return int(max(a, round(b * n)))\n\n# main code\ndef gap_train_test_split(arrays, options):\n    n_arrays = len(arrays)\n    if n_arrays == 0:\n        return []\n\n    check_consistent_length(*arrays)\n    test_size = options.pop('test_size', None)\n    train_size = options.pop('train_size', None)\n    gap_size = options.pop('gap_size', 0)\n\n    arrays = indexable(*arrays)\n    n_samples = _num_samples(arrays[0])\n\n    n_gap = size_to_number(gap_size, n_samples)\n    n_remain = n_samples - n_gap\n\n    if test_size is None and train_size is None:\n        test_size = 0.25\n\n    if train_size is None:\n        n_test = size_to_number(test_size, n_remain)\n        n_train = n_remain - n_test\n    elif test_size is None:\n        n_train = size_to_number(train_size, n_remain)\n        n_test = n_remain - n_train\n    else:\n        n_test = size_to_number(test_size, n_remain)\n        n_train = n_remain - n_test\n\n    train = np.arange(n_train)\n    test = np.arange(n_train + n_gap, n_samples)\n\n    result = []\n    for a in arrays:\n        result.append(_safe_indexing(a, train))\n        result.append(_safe_indexing(a, test))\n\n    return result", "test_script": "import numpy as np\nfrom sklearn.utils import indexable\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = np.random.randint(30, 200)\n        n_features = np.random.randint(1, 20)\n\n        X = np.random.rand(n_samples, n_features)\n        y = np.random.rand(n_samples)\n\n        test_size = np.random.uniform(0.1, 0.5)\n        train_size = np.random.uniform(0.1, 0.9) if np.random.rand() > 0.5 else None\n        gap_size = np.random.uniform(0, 0.3)\n\n        options = {\n            'test_size': test_size,\n            'train_size': train_size,\n            'gap_size': gap_size\n        }\n\n        arrays = indexable(X, y)\n        test_cases.append((arrays, options))\n\n    return test_cases"}
{"problem_id": "sklearn_101", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs node classification using a multi-label or single-label classification approach. The function will utilize logistic regression as the underlying classifier and will evaluate its performance using the F1 score metric. \n\nThe function signature is as follows:\n```python\ndef node_classification(emb, labels, multi_label, training_ratio, repetitions):\n```\n\n### Constants:\n- The constant used in the main code is `solver='liblinear'`, which specifies the optimization algorithm for the logistic regression model.\n\n### Input Format:\n- `emb`: A 2D numpy array where each row represents the feature embeddings of a node.\n- `labels`: A list of tuples, where each tuple contains a node index and its corresponding label.\n- `multi_label`: A boolean indicating whether the classification is multi-label (True) or single-label (False).\n- `training_ratio`: A float representing the proportion of the dataset to include in the training set.\n- `repetitions`: An integer indicating how many times the training and testing process should be repeated.\n\n### Output Format:\n- The function returns a numpy array containing two elements: the mean micro F1 score and the mean macro F1 score across all repetitions.\n\nInput:\n```python\nemb = np.array([[0.1, 0.2, 0.3], \n                [0.4, 0.5, 0.6], \n                [0.7, 0.8, 0.9], \n                [0.1, 0.3, 0.5], \n                [0.2, 0.4, 0.6]])\nlabels = [(1, 0), (1, 1), (2, 1), (3, 0), (4, 1), (5, 0)]\nmulti_label = True\ntraining_ratio = 0.8\nrepetitions = 5\n```\n\nOutput:\n```python\nf1_scores = np.array([0.2, 0.2])\n```", "ground_truth_code": "from sklearn.preprocessing import MultiLabelBinarizer\nimport numpy as np\nfrom sklearn.multiclass import OneVsRestClassifier\nfrom sklearn.linear_model import LogisticRegression\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.metrics import f1_score\n\n\ndef convert_label_format(num_nodes, labels, multi_label=False):\n    label_list = [[] for _ in range(num_nodes)] if multi_label else [0] * num_nodes\n    for node, label in labels:\n        if multi_label:\n            label_list[node - 1].append(label)\n        else:\n            label_list[node - 1] = label\n    return MultiLabelBinarizer().fit_transform(label_list) if multi_label else np.asarray(label_list)\n\n\n# main code\ndef node_classification(emb, labels, multi_label, training_ratio, repetitions):\n    labels = convert_label_format(len(emb), labels, multi_label)\n    ovr_classifier = OneVsRestClassifier(LogisticRegression(solver='liblinear'))\n    f1_scores = np.zeros((repetitions, 2))\n\n    for rep in range(repetitions):\n        X_train, X_test, y_train, y_test = train_test_split(\n            emb, labels, train_size=training_ratio,\n        )\n        ovr_classifier.fit(X_train, y_train)\n\n        y_pred = np.zeros_like(y_test, dtype=int) if multi_label else ovr_classifier.predict(X_test)\n        if multi_label:\n            y_proba = ovr_classifier.predict_proba(X_test)\n            y_number = y_test.sum(axis=1)\n            for i, probs in enumerate(y_proba):\n                top_labels = np.argpartition(probs, -y_number[i])[-y_number[i]:]\n                y_pred[i, top_labels] = 1\n\n        f1_scores[rep] = [\n            f1_score(y_test, y_pred, average='micro', zero_division=0),\n            f1_score(y_test, y_pred, average='macro', zero_division=0)\n        ]\n\n    return f1_scores.mean(axis=0)", "test_script": "import numpy as np\nfrom random import randint, choice\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_nodes = randint(10, 500)\n        emb_dim = randint(5, 100)\n        emb = np.random.randn(num_nodes, emb_dim)\n        multi_label = choice([True, False])\n        num_labels = randint(2, 10)\n        labels = []\n        for node in range(num_nodes):\n            if multi_label:\n                label_set = set()\n                for _ in range(randint(1, num_labels)):\n                    label_set.add(randint(0, num_labels - 1))\n                for label in label_set:\n                    labels.append((node + 1, label))\n            else:\n                labels.append((node + 1, randint(0, num_labels - 1)))\n        training_ratio = round(random.random() * 0.8 + 0.1, 2)\n        repetitions = randint(1, 10)\n\n        test_cases.append((emb, labels, multi_label, training_ratio, repetitions))\n\n    return test_cases"}
{"problem_id": "sklearn_102", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs cross-validation on a given machine learning model using the scikit-learn library. The function should evaluate the model's performance based on whether it is a classifier or a regressor and return a DataFrame containing the relevant metrics.\n\nFunction signature:\n```python\ndef _cross_validate(model, X_train, y_train):\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\nInput format:\n- `model`: An object that has an `estimator_type` attribute (either 'classifier' or 'regressor'), a `pipe` attribute (the model pipeline), and a `cv` attribute (cross-validation strategy).\n- `X_train`: A DataFrame or array-like structure containing the training features.\n- `y_train`: A Series or array-like structure containing the training labels.\n\nOutput format:\n- The function returns a DataFrame containing the evaluation metrics for the model based on the type of estimator (classifier or regressor).\n\nInput:\n```python\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import KFold\nfrom sklearn.datasets import make_classification\nfrom sklearn.dummy import DummyClassifier\n\n# Generating a test case\nX_train, y_train = make_classification(n_samples=100, n_features=10, n_classes=2)\nmodel = DummyClassifier(strategy='most_frequent')\nmodel.estimator_type = 'classifier'\npipe = Pipeline([('dummy', model)])\nmodel.pipe = pipe\nmodel.cv = KFold(n_splits=5, shuffle=True)\n\n# Calling the function\nmetrics_df = _cross_validate(model, X_train, y_train)\n```\n\nOutput:\n```python\n     class  accuracy  precision  recall    fscore\n0  overall      0.41       0.26     0.6  0.362562\n```", "ground_truth_code": "import pandas as pd\nfrom sklearn.model_selection import cross_validate\n\n# main code\ndef _cross_validate(model, X_train, y_train):\n    if model.estimator_type == 'classifier':\n        scoring = {'accuracy': 'accuracy', 'precision': 'precision', 'recall': 'recall', 'f1': 'f1'}\n    elif model.estimator_type == 'regressor':\n        scoring = ['r2', 'neg_mean_squared_error', 'neg_mean_absolute_error', 'explained_variance']\n    scores = cross_validate(model.pipe, X_train, y_train, scoring=scoring, cv=model.cv,\n                            return_train_score=False)\n\n    if model.estimator_type == 'classifier':\n        metrics_df = pd.DataFrame({\n            'class': ['overall'],\n            'accuracy': [scores['test_accuracy'].mean()],\n            'precision': [scores['test_precision'].mean()],\n            'recall': [scores['test_recall'].mean()],\n            'fscore': [scores['test_f1'].mean()] if 'test_f1' in scores else [np.nan],\n        })\n        model.score = metrics_df['accuracy'].iloc[0]\n    elif model.estimator_type == 'regressor':\n        metrics_df = pd.DataFrame({\n            'r2_score': [scores['test_r2'].mean()],\n            'mean_squared_error': [scores['test_neg_mean_squared_error'].mean()],\n            'mean_absolute_error': [scores['test_neg_mean_absolute_error'].mean()],\n            'explained_variance_score': [scores['test_explained_variance'].mean()],\n        })\n        model.score = metrics_df['r2_score'].iloc[0]\n\n    model.metrics_df = metrics_df\n    return model.metrics_df", "test_script": "import numpy as np\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.model_selection import KFold\nfrom sklearn.datasets import make_classification, make_regression\nfrom sklearn.dummy import DummyClassifier, DummyRegressor\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        is_classifier = np.random.choice([True, False])\n\n        if is_classifier:\n            X_train, y_train = make_classification(n_samples=100, n_features=10, n_classes=2)\n            model = DummyClassifier(strategy='most_frequent')\n            model.estimator_type = 'classifier'\n        else:\n            X_train, y_train = make_regression(n_samples=100, n_features=10, noise=0.1)\n            model = DummyRegressor(strategy='mean')\n            model.estimator_type = 'regressor'\n        pipe = Pipeline([('dummy', model)])\n        model.pipe = pipe\n        model.cv = KFold(n_splits=5, shuffle=True)\n        test_cases.append((model, X_train, y_train))\n\n    return test_cases"}
{"problem_id": "sklearn_103", "library": "sklearn", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model using a Random Forest classifier. The function will take in a set of features and a dataset, train the model, and return various performance metrics.\n\nFunction signature:\n```python\ndef mmb_evaluate_model(features, modeldata):\n```\n\nIn the main code, the following constant is used:\n- `test_size=0.2`: This constant specifies that 20% of the dataset will be used for testing, while the remaining 80% will be used for training the model.\n\nInput format:\n- `features`: A dictionary containing a key `'predictive_features'` that maps to a list of column names to be used as features.\n- `modeldata`: A DataFrame containing the dataset with the specified predictive features and a column named `'label'` for the target variable.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `'accuracy'`: A list of accuracy scores from cross-validation.\n  - `'f1'`: A list of F1 scores from cross-validation.\n  - `'precision'`: A list of precision scores from cross-validation.\n  - `'recall'`: A list of recall scores from cross-validation.\n\n**Input:**\n```python\nfeatures = {\n    'predictive_features': ['feature_0', 'feature_1', 'feature_2', 'feature_3', 'feature_4']\n}\nmodeldata = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    'feature_1': [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1],\n    'feature_2': [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4],\n    'feature_3': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n    'feature_4': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n    'label': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n```\n\n**Output:**\n```python\n{\n    'accuracy': [1.0, 1.0, 1.0], \n    'f1': [1.0, 0.6666666666666666, 1.0], \n    'precision': [1.0, 1.0, 1.0], \n    'recall': [1.0, 1.0, 1.0]\n}\n```\n", "ground_truth_code": "import numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.preprocessing import LabelBinarizer\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import cross_val_score\n\n\n# main code\ndef mmb_evaluate_model(features, modeldata):\n    predictive_features = features['predictive_features']\n    clf_X = modeldata[predictive_features].values\n    clf_y = np.array(modeldata['label'])\n\n    X_train, X_test, y_train, y_test = train_test_split(clf_X, clf_y, test_size=0.2)\n\n    lb = LabelBinarizer()\n    y_train = np.array([number[0] for number in lb.fit_transform(y_train)])\n\n    eval_cls = RandomForestClassifier(n_estimators=100, max_features=0.2)\n    eval_cls.fit(X_train, y_train)\n\n    recall = cross_val_score(eval_cls, X_train, y_train, cv=3, scoring='recall')\n    precision = cross_val_score(eval_cls, X_train, y_train, cv=3, scoring='precision')\n    accuracy = cross_val_score(eval_cls, X_train, y_train, cv=3, scoring='accuracy')\n    f1_score = cross_val_score(eval_cls, X_train, y_train, cv=3, scoring='f1_macro')\n\n    return {\n        'accuracy': accuracy.tolist(),\n        'f1': f1_score.tolist(),\n        'precision': precision.tolist(),\n        'recall': recall.tolist()\n    }\n", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_predictive_features = np.random.randint(5, 11)\n\n        num_samples = np.random.randint(50, 101)\n        predictive_data = np.random.rand(num_samples, num_predictive_features)\n        features = {\n            'predictive_features': [f'feature_{i}' for i in range(num_predictive_features)]\n        }\n\n        labels = np.random.choice([0, 1], size=num_samples)\n\n        modeldata = pd.DataFrame(predictive_data, columns=features['predictive_features'])\n        modeldata['label'] = labels\n        test_cases.append((features, modeldata))\n\n    return test_cases"}
{"problem_id": "sklearn_104", "library": "sklearn", "code_problem": "You are tasked with implementing a data preprocessing function for a machine learning pipeline. The function will handle both numerical and categorical features, perform imputation for missing values, apply one-hot encoding for categorical features, and standardize the numerical features. The function signature is as follows:\n\n```python\ndef preprocess_fitting_data(x, y, cat_features):\n```\n\n### Constants Used:\n- `np.nan`: Represents missing values in the dataset.\n- `strategy='mean'`: Used for imputing missing values in numerical features.\n- `strategy='most_frequent'`: Used for imputing missing values in categorical features.\n- `sparse_output=False`: Ensures that the output of the one-hot encoding is a dense array.\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A 2D array-like structure containing the feature data (can be a list, NumPy array, or DataFrame).\n  - `y`: A 1D array-like structure containing the target labels (can be a list or NumPy array).\n  - `cat_features`: A list of indices representing the categorical features in `x`.\n\n- **Output**: \n  - Returns a tuple containing:\n    - A PyTorch tensor of the processed feature data.\n    - A PyTorch tensor of the target labels.\n\nInput:\n```python\nx = [\n    [1.0, 2.0, np.nan, 4.0, 'A'],\n    [5.0, np.nan, 6.0, 8.0, 'B'],\n    [9.0, 10.0, 11.0, np.nan, 'A'],\n    [np.nan, 14.0, 15.0, 16.0, 'C']\n]\ny = [0, 1, 0, 1]\ncat_features = [4]\n```\n\nOutput:\n```python\n(tensor([[-0.3333,  3.0000, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,\n         -0.3333, -0.3333, -1.4450,  0.0976,  0.0977, -2.2335],\n        [ 3.0000, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,\n         -0.3333, -0.3333, -1.0250, -1.5636, -0.2987,  1.3285],\n        [-0.3333, -0.3333, -0.3333, -0.3333,  3.0000, -0.3333, -0.3333, -0.3333,\n         -0.3333, -0.3333, -0.6021, -0.4391,  1.0612, -0.5954],\n        [-0.3333, -0.3333, -0.3333, -0.3333, -0.3333,  3.0000, -0.3333, -0.3333,\n         -0.3333, -0.3333, -0.3623, -0.1949, -1.0358, -0.8310],\n        [-0.3333, -0.3333,  3.0000, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,\n         -0.3333, -0.3333,  0.4458, -0.6046,  1.5993,  0.6000],\n        [-0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,\n         -0.3333,  3.0000,  0.9679, -0.2600,  0.9808,  1.1826],\n        [-0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,\n          3.0000, -0.3333,  1.7098,  1.4057, -0.1780, -0.2191],\n        [-0.3333, -0.3333, -0.3333,  3.0000, -0.3333, -0.3333, -0.3333, -0.3333,\n         -0.3333, -0.3333,  1.0049,  1.8458, -2.0182,  0.2610],\n        [-0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,  3.0000, -0.3333,\n         -0.3333, -0.3333,  0.3804, -0.9972, -0.2711,  0.5685],\n        [-0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333, -0.3333,  3.0000,\n         -0.3333, -0.3333, -1.0744,  0.7103,  0.0628, -0.0616]]),\n tensor([1, 0, 1, 1, 1, 0, 1, 0, 1, 0]))\n```", "ground_truth_code": "import numpy as np\nimport torch\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.preprocessing import StandardScaler\nfrom sklearn.compose import ColumnTransformer\nfrom sklearn.preprocessing import OneHotEncoder\nimport pandas as pd\n\n\n# main code\ndef preprocess_fitting_data(x, y, cat_features):\n    x = np.array(x, dtype=np.float32).copy()\n    y = np.array(y, dtype=np.int64).copy()\n    num_imputer = SimpleImputer(missing_values=np.nan, strategy='mean')\n    all_feature_idxs = np.arange(x.shape[1])\n    numerical_feature_idxs = np.setdiff1d(all_feature_idxs, cat_features)\n\n    if len(numerical_feature_idxs) > 0:\n        num_imputer.fit(x[:, numerical_feature_idxs])\n        x[:, numerical_feature_idxs] = num_imputer.transform(x[:, numerical_feature_idxs])\n\n    if len(cat_features) > 0:\n        cat_imputer = SimpleImputer(missing_values=np.nan, strategy='most_frequent')\n        cat_imputer.fit(x[:, cat_features])\n        x[:, cat_features] = cat_imputer.transform(x[:, cat_features])\n        x = pd.DataFrame(x)\n        one_hot_encoder = ColumnTransformer(\n            transformers=[('cat', OneHotEncoder(sparse_output=False, handle_unknown='ignore'), cat_features)],\n            remainder='passthrough')\n        one_hot_encoder.fit(x)\n        x = one_hot_encoder.transform(x)\n    scaler = StandardScaler()\n    scaler.fit(x)\n    x = scaler.transform(x)\n    return torch.tensor(x, dtype=torch.float), torch.tensor(y, dtype=torch.long)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(5, 15)\n        num_samples = np.random.randint(50, 200)\n\n        x = np.random.randn(num_samples, num_features).tolist()\n        y = np.random.randint(0, 2, size=num_samples).tolist()\n\n        cat_features_count = np.random.randint(0, num_features // 2)\n        cat_features = np.random.choice(num_features, size=cat_features_count, replace=False).tolist()\n\n        test_cases.append((x, y, cat_features))\n    return test_cases"}
{"problem_id": "sklearn_105", "library": "sklearn", "code_problem": "You are tasked with implementing a function that calculates the label ranking loss for multilabel classification problems. The function should take the true labels and predicted scores for a set of samples and compute the average ranking loss based on the provided scores.\n\nFunction signature:\n```python\ndef label_ranking_loss(y_true, y_score, sample_weight=None):\n```\n\n### Constants:\n- The constant used in the main code is `0.0`, which is used to set the loss to zero in specific conditions.\n\n### Input and Output Format:\n- **Input**:\n  - `y_true`: A 2D array-like structure representing the true labels in a multilabel format.\n  - `y_score`: A 1D array-like structure representing the predicted scores for each label.\n  - `sample_weight`: (Optional) An array-like structure representing weights for each sample.\n\n- **Output**:\n  - A float representing the average label ranking loss across all samples, or `0.0` if applicable conditions are met.\n\nInput:\n```python\ny_true = np.array([[1, 0, 1], \n                   [0, 1, 0], \n                   [1, 1, 0], \n                   [0, 0, 1]])\ny_score = np.array([[0.9, 0.1, 0.8], \n                    [0.2, 0.7, 0.3], \n                    [0.6, 0.4, 0.5], \n                    [0.1, 0.2, 0.9]])\n```\n\nOutput:\n```python\n0.125\n``` \n", "ground_truth_code": "import numpy as np\nfrom sklearn.utils import check_array\nfrom sklearn.utils import check_consistent_length\nfrom sklearn.utils.multiclass import type_of_target\nfrom scipy.sparse import csr_matrix\nfrom sklearn.utils.sparsefuncs import count_nonzero\n\n\ndef bincount(x, weights=None, minlength=None):\n    if len(x) > 0:\n        return np.bincount(x, weights, minlength)\n    else:\n        if minlength is None:\n            minlength = 0\n        minlength = np.asarray(minlength, dtype=np.intp).item()\n        return np.zeros(minlength, dtype=np.intp)\n\n# main code\ndef label_ranking_loss(y_true, y_score, sample_weight=None):\n    y_true = check_array(y_true, ensure_2d=False, accept_sparse='csr')\n    y_score = check_array(y_score, ensure_2d=False)\n    check_consistent_length(y_true, y_score, sample_weight)\n\n    y_type = type_of_target(y_true)\n    if y_type not in ('multilabel-indicator',):\n        return None\n\n    if y_true.shape != y_score.shape:\n        return None\n\n    n_samples, n_labels = y_true.shape\n    y_true = csr_matrix(y_true)\n    loss = np.zeros(n_samples)\n\n    for i, (start, stop) in enumerate(zip(y_true.indptr, y_true.indptr[1:])):\n        unique_scores, unique_inverse = np.unique(y_score[i], return_inverse=True)\n        true_at_reversed_rank = bincount(unique_inverse[y_true.indices[start:stop]], minlength=len(unique_scores))\n        all_at_reversed_rank = bincount(unique_inverse, minlength=len(unique_scores))\n        false_at_reversed_rank = all_at_reversed_rank - true_at_reversed_rank\n        loss[i] = np.dot(true_at_reversed_rank.cumsum(), false_at_reversed_rank)\n\n    n_positives = count_nonzero(y_true, axis=1)\n    with np.errstate(divide='ignore', invalid='ignore'):\n        loss /= (n_labels - n_positives) * n_positives\n\n    loss[np.logical_or(n_positives == 0, n_positives == n_labels)] = 0.0\n    return np.average(loss, weights=sample_weight) if loss.size > 0 else 0.0", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        n_labels = np.random.randint(1, 6)\n        n_samples = np.random.randint(10, 51)\n        y_true = np.random.randint(2, size=(n_samples, n_labels))\n        y_score = np.random.rand(n_samples, n_labels)\n        test_cases.append((y_true, y_score))\n\n    return test_cases"}
{"problem_id": "sklearn_106", "library": "sklearn", "code_problem": "You are tasked with implementing a function that performs dimensionality reduction on a given dataset using different methods. The function should allow the user to choose between Truncated Singular Value Decomposition (SVD), Sparse Principal Component Analysis (PCA), and standard PCA. The function will also compute the explained variance ratio of the components.\n\nFunction signature:\n```python\ndef _explainedvar(X, method, n_components, onehot, random_state, n_jobs, percentExplVar):\n```\n\nConstants used in the main code:\n- `onehot`: This constant is set to `True` when using the Sparse PCA method, indicating that the data should be treated as one-hot encoded.\n\nInput format:\n- `X`: A 2D numpy array representing the dataset.\n- `method`: A string indicating the dimensionality reduction method.\n- `n_components`: An integer or None specifying the number of components.\n- `onehot`: A boolean indicating if the data is one-hot encoded.\n- `random_state`: An integer for random seed.\n- `n_jobs`: An integer specifying the number of jobs for parallel processing.\n- `percentExplVar`: A numpy array or None for explained variance ratios.\n\nOutput format:\n- A tuple containing:\n  - The fitted model,\n  - The transformed principal components,\n  - The loadings,\n  - The explained variance ratio (if applicable).\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3],\n              [0.4, 0.5, 0.6],\n              [0.7, 0.8, 0.9]])\nmethod = 'pca'\nn_components = 2\nonehot = False\nrandom_state = 42\nn_jobs = 1\npercentExplVar = None\n```\n\nOutput:\n```python\n(model, PC, loadings, percentExplVar) = _explainedvar(X, method, n_components, onehot, random_state, n_jobs, percentExplVar)\n\n# Example output values (actual values may vary due to randomness):\nmodel: PCA(n_components=2, random_state=42)\nPC: array([[-5.19615242e-01, -1.52655666e-16],\n       [ 0.00000000e+00,  5.55111512e-17],\n       [ 5.19615242e-01,  8.32667268e-17]])\nloadings: array([[ 0.57735027,  0.57735027,  0.57735027],\n                [ 0.81649658, -0.40824829, -0.40824829]])\npercentExplVar: array([1., 1.])\n```", "ground_truth_code": "from sklearn.decomposition import TruncatedSVD, SparsePCA, PCA\nimport numpy as np\n\n# main code\ndef _explainedvar(X, method, n_components, onehot, random_state, n_jobs, percentExplVar):\n    if method == 'trunc_svd':\n        n_components = n_components or X.shape[1] - 1\n        model = TruncatedSVD(n_components=n_components, random_state=random_state)\n    elif method == 'sparse_pca':\n        onehot = True\n        model = SparsePCA(n_components=n_components, random_state=random_state, n_jobs=n_jobs)\n    else:\n        if n_components is None:\n            n_components = min(X.shape)\n        model = PCA(n_components=n_components, random_state=random_state)\n\n    model.fit(X)\n    loadings = model.components_\n    PC = model.transform(X)\n    if not onehot and percentExplVar is None:\n        percentExplVar = model.explained_variance_ratio_.cumsum()\n    return (model, PC, loadings, percentExplVar) if percentExplVar is not None else (model, PC, loadings)\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(10, 100)\n        n_features = np.random.randint(5, 20)\n        X = np.random.rand(n_samples, n_features)\n        method = np.random.choice(['pca', 'trunc_svd', 'sparse_pca'])\n\n        n_components = np.random.randint(1, min(n_samples, n_features) + 1)\n\n        onehot = np.random.choice([True, False])\n        random_state = np.random.randint(0, 1000)\n        n_jobs = np.random.choice([-1, 1])\n        percentExplVar = np.random.choice([None, np.random.rand()])\n\n        test_cases.append((X, method, n_components, onehot, random_state, n_jobs, percentExplVar))\n    return test_cases"}
{"problem_id": "sklearn_107", "library": "sklearn", "code_problem": "You are tasked with implementing a function that utilizes a Random Forest classifier to evaluate the performance of a machine learning model on a given dataset. The function will compute the recall, precision, and F1 score based on the predictions made by the classifier using cross-validation.\n\nFunction Signature:\n```python\ndef classifier(data, features, target, n_estimators, max_depth, random_state, cv_folds, n_jobs):\n```\n\nConstants used in the main code:\n- `average_method`: This variable is determined based on the number of unique classes in the target variable. It is set to \"macro\" if there are more than two classes, and \"binary\" otherwise.\n\nInput Format:\n- `data`: A pandas DataFrame containing the dataset.\n- `features`: A list of strings representing the feature column names.\n- `target`: A string representing the target column name.\n- `n_estimators`: An integer representing the number of trees in the Random Forest.\n- `max_depth`: An integer representing the maximum depth of the trees.\n- `random_state`: An integer for reproducibility.\n- `cv_folds`: An integer representing the number of cross-validation folds.\n- `n_jobs`: An integer representing the number of parallel jobs.\n\nOutput Format:\n- The function returns a dictionary with the following keys:\n  - `\"recall\"`: A float representing the recall score.\n  - `\"precision\"`: A float representing the precision score.\n  - `\"f1_score\"`: A float representing the F1 score.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample data generation\ndata = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    'feature_1': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n    'feature_2': [0.5, 0.6, 0.7, 0.8, 0.9, 0.1, 0.2, 0.3, 0.4, 0.0],\n    'target': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n\nfeatures = ['feature_0', 'feature_1', 'feature_2']\ntarget = 'target'\nn_estimators = 10\nmax_depth = 5\nrandom_state = 42\ncv_folds = 5\nn_jobs = 1\n```\n\n**Output:**\n```python\n{'recall': 1.0, 'precision': 1.0, 'f1_score': 1.0}\n\n```\n", "ground_truth_code": "from sklearn.ensemble import RandomForestClassifier\nfrom sklearn.model_selection import cross_val_predict, StratifiedKFold\nfrom sklearn.metrics import recall_score, precision_score, f1_score\n\n# main code\ndef classifier(data, features, target, n_estimators, max_depth, random_state, cv_folds, n_jobs):\n    X = data[features]\n    Y = data[target].astype(int).values.ravel()\n\n    clf = RandomForestClassifier(n_estimators=n_estimators, max_depth=max_depth, random_state=random_state)\n\n    y_pred = cross_val_predict(clf, X, Y, cv=StratifiedKFold(n_splits=cv_folds), n_jobs=n_jobs)\n\n    if len(set(Y)) > 2:\n        average_method = \"macro\"\n    else:\n        average_method = \"binary\"\n\n    return {\n        \"recall\": recall_score(Y, y_pred, average=average_method),\n        \"precision\": precision_score(Y, y_pred, average=average_method),\n        \"f1_score\": f1_score(Y, y_pred, average=average_method),\n    }", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = np.random.randint(50, 100)\n        n_features = np.random.randint(5, 20)\n        n_classes = np.random.choice([2, 3])\n\n        min_informative = max(2, int(np.ceil(np.log2(n_classes * 2))))\n        max_informative = max(min_informative + 1, n_features - 2)\n        n_informative = np.random.randint(min_informative, max_informative)\n\n        max_extra_features = n_features - n_informative\n        n_redundant = np.random.randint(0, max_extra_features // 2 + 1)\n        n_repeated = np.random.randint(0, max_extra_features - n_redundant + 1)\n\n\n        X, Y = make_classification(n_samples=n_samples,\n                                   n_features=n_features,\n                                   n_informative=n_informative,\n                                   n_redundant=n_redundant,\n                                   n_repeated=n_repeated,\n                                   n_classes=n_classes,\n                                   random_state=np.random.randint(1, 1000))\n\n        feature_names = [f\"feature_{i}\" for i in range(n_features)]\n        data = pd.DataFrame(X, columns=feature_names)\n        data['target'] = Y\n\n        n_estimators = np.random.randint(10, 200)\n        max_depth = np.random.choice([None] + list(range(3, 21)))\n        random_state = np.random.randint(1, 1000)\n        cv_folds = np.random.choice([3, 5, 10])\n        n_jobs = np.random.choice([-1, 1])\n\n        test_case = (data, feature_names, 'target', n_estimators, max_depth, random_state, cv_folds, n_jobs)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "matplotlib_0", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a scatter plot with histograms on the axes, visualizing the relationship between two sets of statistics. The function should allow for customization of the number of bins in the histograms, the size of the scatter points, and the output file name for saving the plot.\n\nFunction Signature:\n```python\ndef scatter_hist(stats_list_x, stats_list_y, labels, nbins, s, prct_bounds, output_file='output.png'):\n```\n\nConstants Used:\n- The `layout_params` dictionary defines the layout of the scatter plot and histograms within the figure.\n\nInput Format:\n- `stats_list_x`: List of arrays (each array contains numerical values).\n- `stats_list_y`: List of arrays (each array contains numerical values).\n- `labels`: List of strings (labels for each dataset).\n- `nbins`: Integer (number of bins for histograms).\n- `s`: Integer (size of scatter points).\n- `prct_bounds`: Tuple of two integers (percentile bounds for x and y axes).\n- `output_file`: String (name of the output file).\n\nOutput Format:\n- The function does not return any value. It saves a plot as an image file with the specified name.\n\n**Input:**\n```python\nstats_list_x = [\n    np.array([-1.2, 0.5, 1.3, -0.7, 2.1]),\n    np.array([3.0, 2.5, 4.1, 3.8, 2.9])\n]\nstats_list_y = [\n    np.array([0.1, -0.3, 0.5, 0.7, 1.0]),\n    np.array([2.0, 1.5, 2.5, 2.8, 3.1])\n]\nlabels = ['Group A', 'Group B']\nnbins = 10\ns = 20\nprct_bounds = [10, 90]\n```\n\n**Output:**\n```python\n# The output will be a saved figure 'output.png' containing:\n# - A scatter plot of the points from stats_list_x and stats_list_y\n# - Histograms for stats_list_x on the top and stats_list_y on the right\n# - The scatter points colored according to their respective groups (Group A in cyan and Group B in magenta)\n# - The axes limits set according to the percentile bounds\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format.)", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.ticker import NullFormatter\n\n# main code\ndef scatter_hist(stats_list_x, stats_list_y, labels, nbins, s, prct_bounds, output_file='output.png'):\n    labels = labels or [None] * len(stats_list_x)\n    x_lb, x_hb = np.percentile(np.hstack(stats_list_x), prct_bounds)\n    y_lb, y_hb = np.percentile(np.hstack(stats_list_y), prct_bounds)\n    x_bins = np.linspace(x_lb, x_hb, nbins)\n    y_bins = np.linspace(y_lb, y_hb, nbins)\n    layout_params = {\n        'scatter': [0.1, 0.1, 0.65, 0.65],\n        'histx': [0.1, 0.77, 0.65, 0.2],\n        'histy': [0.77, 0.1, 0.2, 0.65]\n    }\n\n    plt.figure(figsize=(8, 8))\n    axScatter = plt.axes(layout_params['scatter'])\n    axHistx = plt.axes(layout_params['histx'])\n    axHisty = plt.axes(layout_params['histy'])\n\n    axHistx.xaxis.set_major_formatter(NullFormatter())\n    axHisty.yaxis.set_major_formatter(NullFormatter())\n\n    alpha = 1 / len(stats_list_x)\n    colors = ['c', 'm', 'y', 'b']\n\n    for x, y, color, label in zip(stats_list_x, stats_list_y, colors, labels):\n        axHistx.hist(x, bins=x_bins, color=color, alpha=alpha, density=True)\n        axHisty.hist(y, bins=y_bins, color=color, alpha=alpha, density=True, orientation='horizontal')\n        axScatter.scatter(x, y, s=s, c=color, alpha=alpha, label=label)\n\n    axScatter.set_xlim((x_lb, x_hb))\n    axScatter.set_ylim((y_lb, y_hb))\n\n    if any(label is not None for label in labels):\n        axScatter.legend(loc='upper right')\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_lists = random.randint(2, 5)\n        data_sizes = [random.randint(50, 500) for _ in range(num_lists)]\n        stats_list_x = [np.random.normal(loc=random.uniform(-10, 10),\n                                         scale=random.uniform(1, 5),\n                                         size=size) for size in data_sizes]\n\n        stats_list_y = [np.random.normal(loc=random.uniform(-10, 10),\n                                         scale=random.uniform(1, 5),\n                                         size=size) for size in data_sizes]\n        labels = [random.choice([f'Label_{i}', None]) for i in range(num_lists)]\n        nbins = random.randint(5, 50)\n        s = random.uniform(5, 50)\n        prct_bounds = [random.uniform(0, 10), random.uniform(90, 100)]\n        test_cases.append((stats_list_x, stats_list_y, labels, nbins, s, prct_bounds))\n\n    return test_cases"}
{"problem_id": "matplotlib_1", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a plot for two datasets representing the Radar Cross Section (RCS) and the Signal-to-Noise Ratio (SCR) over time. The function will allow customization of the plot's appearance and save the resulting figure to a file.\n\nFunction Signature:\n```python\ndef plot_rcs_scr(t, rcs, scr, start, end, name, xlabel, ylabel, ylim, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- The function accepts the following parameters:\n  - `t`: List or array of time values.\n  - `rcs`: List or array of RCS values.\n  - `scr`: List or array of SCR values.\n  - `start`: Float or integer for the start of the x-axis.\n  - `end`: Float or integer for the end of the x-axis.\n  - `name`: String for the plot title.\n  - `xlabel`: String for the x-axis label.\n  - `ylabel`: String for the y-axis label.\n  - `ylim`: Tuple or list of two floats or integers for the y-axis limits.\n  - `output_file`: Optional string for the output filename.\n\nOutput Format:\n- The function does not return any value. Instead, it generates and saves a plot as a PNG file to the specified `output_file`.\n\n**Input:**\n```python\nt = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\nrcs = np.array([0.5, 1.0, 1.5, 2.0, 2.5])\nscr = np.array([-1.0, 0.0, 1.0, 0.5, 0.0])\nstart = 0.5\nend = 5.5\nname = 'Test_123'\nxlabel = 'Time (s)'\nylabel = 'Amplitude (dB)'\nylim = [-5, 5]\n```\n\n**Output:**\n```plaintext\nA plot is generated and saved as 'output.png' showing:\n- RCS (red line) and SCR (blue line) over the time range from 0.5 to 5.5 seconds.\n- Y-axis limits set from -5 to 5 dB.\n- Title: 'Corner Reflector response at Test_123'.\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n# main code\ndef plot_rcs_scr(t, rcs, scr, start, end, name, xlabel, ylabel, ylim, output_file='output.png'):\n    (fig, ax) = plt.subplots()\n    ax.plot(t, rcs, 'ro-', label='RCS')\n    ax.plot(t, scr, 'bo-', label='SCR')\n    ax.set_xlim(start, end)\n    ax.set_ylim(ylim)\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.legend(loc=4)\n    ax.grid(True)\n    ax.set_title(f'Corner Reflector response at {name}')\n    for label in ax.get_xticklabels():\n        label.set_rotation(90)\n    fig.savefig(output_file, bbox_inches='tight')", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = random.randint(5, 100)\n        t = np.sort(np.random.uniform(0, 100, num_points))\n        rcs = np.random.uniform(-10, 10, num_points)\n        scr = np.random.uniform(-10, 10, num_points)\n        start = random.uniform(t[0] - 5, t[0])\n        end = random.uniform(t[-1], t[-1] + 5)\n        ylim = [min(min(rcs), min(scr)) - 5, max(max(rcs), max(scr)) + 5]\n        name = f'Test_{random.randint(1, 1000)}'\n        xlabel = 'Time (s)'\n        ylabel = 'Amplitude (dB)'\n        test_cases.append((t, rcs, scr, start, end, name, xlabel, ylabel, ylim))\n    return test_cases"}
{"problem_id": "matplotlib_2", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a dataset representing \"clutter\" over a specified time period. The function will generate a line plot using the Matplotlib library, which will display the average clutter values against time. The plot will include labeled axes, a title, and a legend, and it will save the resulting figure to a specified output file.\n\nFunction signature:\n```python\ndef plot_clutter(t, clt, start, end, name, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `t`: A list or array of time values.\n- `clt`: A list or array of clutter values corresponding to the time values.\n- `start`: A value representing the start of the x-axis range.\n- `end`: A value representing the end of the x-axis range.\n- `name`: A string representing the title of the plot.\n- `output_file`: (optional) A string representing the filename to save the plot.\n\nOutput format:\n- The function saves a plot as an image file to the specified `output_file`.\n\nInput:\n```python\nt = np.array([1.2, 2.5, 3.1, 4.7, 5.9])\nclt = np.array([-3.2, 0.5, 1.0, -1.5, 2.3])\nstart = 1.0\nend = 6.0\nname = \"TestLocation\"\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing the average clutter at TestLocation with the specified time and clutter values.\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n\n# main code\ndef plot_clutter(t, clt, start, end, name, output_file='output.png'):\n    fig = plt.figure()\n    ax = fig.add_subplot(1, 1, 1)\n    ax.plot(t, clt, 'bo-', label='Clutter')\n    ax.set_xlim(start, end)\n    ax.set_ylim(min(clt) - 1, max(clt) + 1)\n    ax.set_xlabel('Date')\n    ax.set_ylabel('Average Clutter (dB)')\n    ax.legend(loc=1)\n    ax.grid(True)\n    ax.set_title(f'Average Clutter at {name}')\n    for label in ax.get_xticklabels():\n        label.set_rotation(90)\n\n    fig.savefig(output_file, bbox_inches='tight')", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    def random_string(length=8):\n        return ''.join(random.choices(string.ascii_letters, k=length))\n\n    test_cases = []\n    for _ in range(n):\n        length = random.randint(10, 100)\n        t = np.sort(np.random.rand(length) * 100)\n        clt = np.random.uniform(-5, 5, size=length)\n        start = random.uniform(min(t), max(t) - 1)\n        end = random.uniform(start + 1, max(t))\n        name = random_string()\n        test_cases.append((t, clt, start, end, name))\n\n    return test_cases"}
{"problem_id": "matplotlib_3", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes audio data, filter bank representations, and prediction probabilities using Matplotlib. The function will generate a multi-panel plot and save it as an image file.\n\nFunction signature:\n```python\ndef plotter(data, fbank, preds, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- `data`: A 1D array-like structure representing audio amplitude values.\n- `fbank`: A 2D array-like structure representing the filter bank features.\n- `preds`: A 1D array-like structure representing prediction probabilities.\n- `output_file`: A string representing the filename to save the output plot (optional).\n\nOutput format:\n- The function saves a PNG image file containing the plotted visualizations to the specified `output_file`.\n\nInput:\n```python\ndata = np.array([-0.123, 0.456, -0.789, 0.234, 0.567, -0.678, 0.890, -0.123, 0.456, -0.789, 0.234, 0.567, -0.678, 0.890, -0.123, 0.456, -0.789, 0.234, 0.567, -0.678], dtype=np.float32)\nfbank = np.random.rand(100, 50).astype(np.float32)\npreds = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0], dtype=np.float32)\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing:\n1. The last half of the 'data' array plotted as amplitude.\n2. The last half of the 'fbank' array displayed as an image.\n3. The last half of the 'preds' array plotted as probabilities.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plotter(data, fbank, preds, output_file='output.png'):\n    plt.figure(figsize=(10, 6))\n\n    plt.subplot(311)\n    plt.plot(data[-len(data) // 2:])\n    plt.gca().xaxis.set_major_locator(plt.NullLocator())\n    plt.ylabel('Amplitude')\n\n    plt.subplot(312)\n    plt.imshow(fbank[-fbank.shape[0] // 2:, :].T, aspect='auto')\n    plt.gca().xaxis.set_major_locator(plt.NullLocator())\n    plt.gca().invert_yaxis()\n    plt.ylim(0, 40)\n    plt.ylabel('$\\log \\, E_{m}$')\n\n    plt.subplot(313)\n    plt.plot(preds[-len(preds) // 2:], linewidth=4.0)\n    plt.ylim(0, 1)\n    plt.ylabel('Probability')\n    ax = plt.gca()\n    ax.xaxis.set_major_locator(plt.NullLocator())\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = random.randint(20, 500)\n        data = np.random.randn(data_length).astype(np.float32)\n        fbank_rows = random.randint(40, 200)\n        fbank_cols = random.randint(30, 60)\n        fbank = np.random.rand(fbank_rows, fbank_cols).astype(np.float32)\n        preds_length = random.randint(20, 500)\n        preds = np.random.rand(preds_length).astype(np.float32)\n\n\n        test_cases.append((data, fbank, preds))\n\n    return test_cases"}
{"problem_id": "matplotlib_4", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a given array of numerical data by plotting it on a logarithmic scale. The function should allow customization of the plot's title, x-axis label, y-axis label, and the output file name for saving the plot.\n\nFunction signature:\n```python\ndef plot_array(array, title, x_label, y_label, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The figure size is set to a constant value of (6.4, 4.8) inches.\n\nInput format:\n- The function takes the following inputs:\n  - `array`: A list or array of numerical values to be plotted.\n  - `title`: A string representing the title of the plot.\n  - `x_label`: A string representing the label for the x-axis.\n  - `y_label`: A string representing the label for the y-axis.\n  - `output_file`: An optional string representing the name of the file to save the plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated plot as an image file in the specified format (e.g., PNG) to the location indicated by `output_file`.\n\nInput:\n```python\n(array([  1.23456789,  23.45678901,  345.67890123,  4567.89012345,  56789.01234567]), \n \"Test Plot\", \n \"X-Axis\", \n \"Y-Axis\")\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' with the specified title, x_label, and y_label.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_array(array, title, x_label, y_label, output_file='output.png'):\n    plt.figure(figsize=(6.4, 4.8))\n    plt.plot(array)\n    plt.yscale('log')\n    plt.xlabel(x_label)\n    plt.ylabel(y_label)\n    plt.title(title)\n    plt.tight_layout()\n    plt.grid()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\ndef test_case_input_generator(n=200):\n    def random_string(length):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n    test_cases = []\n    for i in range(n):\n        array_length = random.randint(10, 1000)\n        array = np.random.uniform(1e-3, 1e3, size=array_length)\n        title = random_string(12)\n        x_label = random_string(8)\n        y_label = random_string(8)\n        test_cases.append((array, title, x_label, y_label))\n\n    return test_cases"}
{"problem_id": "matplotlib_5", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a loss function over a series of iterations or epochs. The function should generate a plot that displays the loss values on a logarithmic scale, allowing for better visualization of the loss function's behavior, especially when the values span several orders of magnitude.\n\nFunction Signature:\n```python\ndef plot_loss_function(loss_function, legend_label, y_label, title, x_label, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `loss_function`: A list or array of numerical values representing the loss function over iterations or epochs.\n- `legend_label`: A string representing the label for the legend.\n- `y_label`: A string representing the label for the y-axis.\n- `title`: A string representing the title of the plot.\n- `x_label`: A string representing the label for the x-axis.\n- `output_file`: (Optional) A string representing the name of the output file where the plot will be saved.\n\nOutput Format:\n- The function does not return any value. It generates and saves a plot as an image file in the specified format.\n\nInput:\n```python\nloss_function = [12.34, 23.45, 10.12, 5.67, 3.45, 1.23, 0.98, 0.76, 0.54, 0.34]\nlegend_label = \"Loss Function 0\"\ny_label = \"Loss Value\"\ntitle = \"Training Loss Curve 0\"\nx_label = \"Epochs\"\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing the loss function on a logarithmic scale with the specified labels and title.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_loss_function(loss_function, legend_label, y_label, title, x_label, output_file='output.png'):\n    plt.figure(figsize=(6.4, 4.8))\n    plt.plot(loss_function, label=legend_label)\n    plt.yscale('log')\n    plt.xlabel(x_label)\n    plt.ylabel(y_label)\n    plt.title(title)\n    plt.tight_layout()\n    plt.legend()\n    plt.grid()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(50, 500)\n        loss_function = np.random.rand(length) * 100\n        legend_label = f\"Loss Function {_}\"\n        y_label = \"Loss Value\"\n        x_label = \"Epochs\"\n        title = f\"Training Loss Curve {_}\"\n        test_cases.append((loss_function, legend_label, y_label, title, x_label))\n    return test_cases"}
{"problem_id": "matplotlib_6", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the activations of a feedforward neural network (FFNN) using a heatmap. The function should allow customization of the visualization parameters, such as the color scale and the output file name.\n\nFunction signature:\n```python\ndef plot_activations(activations, vmin, vmax, height, width_scale_per_item, output_file='output.png'):\n```\n\n### Constants:\n- `masking_threshold`: A constant value set to `0.01`, which is used to mask out activations that are below this threshold in the heatmap visualization.\n\n### Input Format:\n- The function takes a 2D NumPy array for `activations` and four additional parameters (`vmin`, `vmax`, `height`, `width_scale_per_item`) along with an optional `output_file` string.\n\n### Output Format:\n- The function does not return any value but saves a heatmap visualization of the activations to the specified output file.\n\nInput:\n```python\nactivations = np.array([[0.1, 0.2, 0.3], [0.4, 0.05, 0.6], [0.7, 0.8, 0.9]])\nvmin = 0.0\nvmax = 1.0\nheight = 10\nwidth_scale_per_item = 0.2\n```\n\nOutput:\n```plaintext\nA heatmap image saved as 'output.png' showing the activations with the specified parameters.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport copy\nimport numpy as np\n\n# main code\ndef plot_activations(activations, vmin, vmax, height, width_scale_per_item, output_file='output.png'):\n    masking_threshold = 0.01\n    masked = np.ma.masked_less(activations, masking_threshold)\n\n    width = activations.shape[1] * width_scale_per_item\n    fig = plt.figure(figsize=(width, height))\n    sns.set()\n\n    ax = plt.gca()\n    v = copy.copy(plt.get_cmap('viridis_r'))\n    v.set_bad('white')\n    sns.heatmap(activations, mask=masked.mask, cmap=v, ax=ax, vmin=vmin, vmax=vmax, cbar=False)\n\n    ax.tick_params(axis='x', which='major', labelsize=18)\n    ax.set_xlabel('\\nOutput Token', fontsize=14)\n    plt.title('FFNN Activations', fontsize=28)\n    plt.tick_params(axis='x', which='both', left=False, bottom=True, top=True, labeltop=True, labelbottom=True)\n    plt.xticks(rotation=-45)\n    fig.set_facecolor('w')\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(10, 100)\n        cols = random.randint(10, 100)\n        activations = np.random.rand(rows, cols) * random.uniform(0, 1)\n        vmin = random.uniform(0, 0.5)\n        vmax = random.uniform(vmin + 0.1, 1.0)\n\n        height = random.uniform(5, 15)\n        width_scale_per_item = random.uniform(0.1, 0.5)\n        test_cases.append((activations, vmin, vmax, height, width_scale_per_item))\n\n    return test_cases"}
{"problem_id": "matplotlib_7", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes data from a list of nodes by generating a series of subplots. Each subplot will represent a specific node's data over a range of steps. The function will allow the user to choose between two types of data to visualize: stall data or queue number data.\n\nFunction Signature:\n```python\ndef show_sum_graph(what, nodes, output_file='output.png'):\n```\n\nConstants:\n- The constant used in the main code is `output_file`, which defaults to `'output.png'`.\n\nInput Format:\n- The function accepts an integer `what`, a list of node objects `nodes`, and an optional string `output_file`.\n\nOutput Format:\n- The function generates a PNG file containing the plotted graphs, saved under the name specified by `output_file`.\n\nInput:\n```python\nwhat = 0\nnodes = [\n    Node(size=10),  # Node with 10 random stall_h values\n    Node(size=15)   # Node with 15 random stall_h values\n]\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' showing two subplots:\n# 1. The first subplot will display the stall_h values for the first node (10 values).\n# 2. The second subplot will display the stall_h values for the second node (15 values).\n# The y-axis will be limited to the range [-0.1, 2.1].\n``` \n\n(Note: The actual plot cannot be displayed here, but it will be saved as 'output.png' in the working directory.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef show_sum_graph(what, nodes, output_file='output.png'):\n\n    nn = len(nodes)\n    plt.subplots_adjust(hspace=0.8)\n\n    for i, n in enumerate(nodes, start=1):\n        plt.subplot(nn, 1, i)\n        plt.title(str(n))\n        plt.ylabel('stall')\n        plt.xlabel('step')\n\n        x = np.arange(0, len(n.stall_h if what == 0 else n.qe_num_h))\n        y = np.array(n.stall_h if what == 0 else n.qe_num_h)\n\n        if what == 0:\n            plt.ylim(-0.1, 2.1)\n\n        plt.plot(x, y)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    class Node:\n        def __init__(self, size):\n            self.stall_h = np.random.uniform(-0.1, 2.1, size).tolist()\n            self.qe_num_h = np.random.randint(0, 100, size).tolist()\n\n    test_cases = []\n\n    for _ in range(n):\n        what = random.choice([0, 1])\n        num_nodes = random.randint(1, 10)\n        node_sizes = [random.randint(5, 100) for _ in range(num_nodes)]\n        nodes = [Node(size) for size in node_sizes]\n\n        test_cases.append((what, nodes))\n\n    return test_cases"}
{"problem_id": "matplotlib_8", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D array as a colored matrix plot using Matplotlib. The function should allow customization of the plot's appearance, including axis labels, title, font size, and rotation of the labels. The function will also save the generated plot to a specified output file.\n\nFunction Signature:\n```python\ndef ShowFigure(var, labels, title, FontSize, XRot, YRot, output_file='output.png'):\n```\n\nConstants:\n- The default output file name is set to `'output.png'`.\n\nInput Format:\n- The function takes a 2D numpy array, a list of labels, a title string, an integer for font size, two integers for label rotations, and an optional output file name.\n\nOutput Format:\n- The function saves a visual representation of the input data as a PNG file to the specified output file path.\n\nInput:\n```python\nvar = np.array([[10, 20, 30], [40, 50, 60], [70, 80, 90]])\nlabels = ['A', 'B', 'C']\ntitle = \"Sample Test Case\"\nFontSize = 12\nXRot = 45\nYRot = 45\n```\n\nOutput:\n```plaintext\nA B C\nA 10 20 30\nB 40 50 60\nC 70 80 90\n``` \n\n(Note: The output is a representation of the data that would be visualized in the plot generated by the `ShowFigure` function, not the actual plot image.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef ShowFigure(var, labels, title, FontSize, XRot, YRot, output_file='output.png'):\n    NumData = np.shape(var)[0]\n    plt.figure(figsize=(NumData, NumData), dpi=100)\n    plt.pcolor(var, vmin=np.min(var), vmax=np.max(var))\n    plt.xlim([0, NumData])\n    plt.ylim([0, NumData])\n\n    cbar = plt.colorbar()\n    cbar.ax.tick_params(labelsize=FontSize)\n\n    ax = plt.gca()\n    ax.invert_yaxis()\n    ax.set_aspect(1)\n    ax.set_yticks(np.arange(NumData) + 0.5)\n    ax.set_xticks(np.arange(NumData) + 0.5)\n    ax.set_xticklabels(labels, fontsize=FontSize, rotation=XRot)\n    ax.set_yticklabels(labels, fontsize=FontSize, rotation=YRot)\n\n    ax.grid(False)\n    ax.set_frame_on(False)\n\n    for t in ax.xaxis.get_major_ticks():\n        t.tick1line.set_visible(False)\n        t.tick2line.set_visible(False)\n    for t in ax.yaxis.get_major_ticks():\n        t.tick1line.set_visible(False)\n        t.tick2line.set_visible(False)\n\n    plt.title(title)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    def generate_random_labels(size):\n        return [\"\".join(random.choices(string.ascii_uppercase, k=3)) for _ in range(size)]\n\n    test_cases = []\n    for _ in range(n):\n        size = random.randint(3, 20)\n        var = np.random.rand(size, size) * 100\n        labels = generate_random_labels(size)\n        title = \"Test Case \" + str(_ + 1)\n        FontSize = random.randint(8, 20)\n        XRot = random.choice([0, 45, 90])\n        YRot = random.choice([0, 45, 90])\n\n        test_cases.append((var, labels, title, FontSize, XRot, YRot))\n\n    return test_cases\n\n"}
{"problem_id": "matplotlib_9", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D array (matrix) using a heatmap representation. The function should allow customization of the title and font size of the color bar, and it should save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef ShowMat(var, title, font_size, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to 'output.png'.\n\nInput format:\n- `var`: A 2D array (matrix) to be visualized.\n- `title`: A string representing the title of the plot.\n- `font_size`: An integer representing the font size for the color bar tick labels.\n- `output_file`: (Optional) A string representing the name of the output file where the plot will be saved.\n\nOutput format:\n- The function does not return any value. It saves the generated heatmap plot to the specified output file.\n\nInput:\n```python\nvar = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ntitle = \"TestMatrix\"\nfont_size = 12\n```\n\nOutput:\n```plaintext\nA matrix visualization is saved as 'output.png' with the title 'TestMatrix' and font size 12 for the color bar.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef ShowMat(var, title, font_size, output_file='output.png'):\n    plt.matshow(var)\n    plt.xlim([0, var.shape[0]])\n    plt.ylim([0, var.shape[0]])\n    cbar = plt.colorbar()\n    cbar.ax.tick_params(labelsize=font_size)\n    frame1 = plt.gca()\n    for xlabel_i in frame1.axes.get_xticklabels():\n        xlabel_i.set_visible(False)\n        xlabel_i.set_fontsize(0.0)\n    for xlabel_i in frame1.axes.get_yticklabels():\n        xlabel_i.set_fontsize(0.0)\n        xlabel_i.set_visible(False)\n    for tick in frame1.axes.get_xticklines() + frame1.axes.get_yticklines():\n        tick.set_visible(False)\n    plt.title(title)\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\nimport random\nimport string\n\ndef test_case_input_generator(n=200):\n    def generate_random_title(length=10):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n    test_cases = []\n    for _ in range(n):\n        size = random.randint(10, 200)\n        var = np.random.rand(size, size)\n        title = generate_random_title()\n        font_size = random.randint(8, 20)\n        test_cases.append((var, title, font_size))\n    return test_cases"}
{"problem_id": "matplotlib_10", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the spiking activity of neurons over time. The function will generate a scatter plot where each neuron is represented on the y-axis, and the times at which each neuron spikes are represented on the x-axis. The spikes will be indicated by red vertical lines.\n\nFunction Signature:\n```python\ndef save_spike_plot(neuron_indices, spiketrain, output_file='output.png'):\n```\n\nConstants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `neuron_indices`: A list or range of integers representing the indices of neurons to plot.\n- `spiketrain`: A 2D numpy array of shape (neurons, timesteps) containing binary values indicating spike occurrences.\n\nOutput Format:\n- The function saves a plot as an image file with the name specified by `output_file`.\n\nInput:\n```python\nneuron_indices = [0, 2, 4]\nspiketrain = np.array([[0, 0, 1, 0, 0, 0, 1, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 1, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 1, 0, 0],\n                        [0, 0, 0, 0, 0, 0, 0, 0, 0, 0],\n                        [0, 0, 0, 0, 1, 0, 0, 0, 0, 0]])\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing spikes for neurons 0, 2, and 4 at specified timesteps.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef save_spike_plot(neuron_indices, spiketrain, output_file='output.png'):\n    neurons, timesteps = spiketrain.shape\n    if not neuron_indices:\n        neuron_indices = range(neurons)\n\n    plt.figure()\n    plt.title('SpikePlot')\n\n    for i, neuron_index in enumerate(neuron_indices):\n        times = np.where(spiketrain[neuron_index])[0]\n        y = i * np.ones(times.shape)\n        plt.scatter(times, y, c='r', s=40, marker='|', zorder=1)\n\n    plt.xlim(0, timesteps)\n    plt.ylabel('Neuron')\n    plt.yticks(range(len(neuron_indices)), neuron_indices)\n    plt.tight_layout()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        neurons = random.randint(5, 200)\n        timesteps = random.randint(10, 1000)\n\n        spiketrain = np.random.choice([0, 1], size=(neurons, timesteps), p=[0.9, 0.1])\n\n        if random.random() < 0.5:\n            neuron_indices = random.sample(range(neurons), random.randint(1, neurons))\n        else:\n            neuron_indices = []\n\n        test_cases.append((neuron_indices, spiketrain))\n\n    return test_cases"}
{"problem_id": "matplotlib_11", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a matryix using a Hinton diagram. A Hinton diagram is a graphical representation of a matrix where the size and color of the squares represent the magnitude and sign of the matrix elements, respectively.\n\nFunction signature:\n```python\ndef draw_hinton(matrix, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- A 2D array (matrix) of numerical values.\n\nOutput format:\n- A PNG file saved to the specified `output_file` path, containing the Hinton diagram representation of the input matrix.\n\nInput:\n```python\narray([[ 0.5, -1.2,  0.3],\n       [ 2.1,  0.0, -0.7],\n       [-0.4,  1.5,  0.8]])\n```\n\nOutput:\n`output.png` (A Hinton diagram visualizing the input matrix, where positive weights are represented in white and negative weights in black.)", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef draw_hinton(matrix, output_file='output.png'):\n    fig, ax = plt.subplots()\n\n    ax.patch.set_facecolor('gray')\n    ax.set_aspect('equal', 'box')\n    ax.xaxis.set_major_locator(plt.NullLocator())\n    ax.yaxis.set_major_locator(plt.NullLocator())\n\n    for ((x, y), w) in np.ndenumerate(matrix):\n        color = 'white' if w > 0 else 'black'\n        size = np.sqrt(np.abs(w))\n        rect = plt.Rectangle([x - size / 2, y - size / 2], size, size, facecolor=color, edgecolor=color)\n        ax.add_patch(rect)\n\n    ax.autoscale_view()\n    ax.invert_yaxis()\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = np.random.randint(1, 20)\n        cols = np.random.randint(1, 20)\n        matrix = np.random.randn(rows, cols) * np.random.uniform(0.1, 5)\n\n        test_cases.append(matrix)\n\n    return test_cases"}
{"problem_id": "matplotlib_12", "library": "matplotlib", "code_problem": "The task is to create a function that generates a 2D plot based on the eigenvalues and eigenvectors of a given matrix. The function will visualize the eigenvalues as contours in a specified color and style, and it will also mark the center of the plot with a specified marker. The function should save the resulting plot to a file.\n\nFunction signature:\n```python\ndef base_plot(K, ind, contour_color, contour_style, contour_size, contour_markersize, contour_marker, fontsize, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant `200` is used to define the number of points for the theta values, which are used to create a circle.\n\nInput format:\n- A matrix `K` (2D numpy array).\n- An index list `ind` (list of integers).\n- A string `contour_color` (color for the contour).\n- A string `contour_style` (style for the contour line).\n- A float `contour_size` (size of the contour line).\n- An integer `contour_markersize` (size of the marker at the center).\n- A string `contour_marker` (marker style for the center).\n- An integer `fontsize` (font size for the axis labels).\n- An optional string `output_file` (name of the output file, default is 'output.png').\n\nOutput format:\n- The function saves a plot as an image file with the specified name. The function does not return any value.\n\n**Input:**\n```python\nK = np.array([[2.0, -1.0], [-1.0, 2.0]])\nind = [0, 1]\ncontour_color = 'b'\ncontour_style = '-'\ncontour_size = 1.5\ncontour_markersize = 8.0\ncontour_marker = 'o'\nfontsize = 12\n```\n\n**Output:**\n```python\n# The function will generate a plot saved as 'output.png' with the specified parameters.\n# The plot will show a contour based on the eigenvalues and eigenvectors of the matrix K,\n# with the specified contour color, style, size, and marker.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef base_plot(K, ind, contour_color, contour_style, contour_size, contour_markersize, contour_marker, fontsize, output_file='output.png'):\n    fig, ax = plt.subplots()\n    v, U = np.linalg.eig(K[np.ix_(ind, ind)])\n    r = np.sqrt(np.abs(v))\n    theta = np.linspace(0, 2 * np.pi, 200)[:, np.newaxis]\n    circle = np.hstack([r[0] * np.sin(theta), r[1] * np.cos(theta)])\n    xy = circle @ U.T\n    contour = plt.Line2D(xy[:, 0], xy[:, 1], linewidth=contour_size, linestyle=contour_style, color=contour_color)\n    center = plt.Line2D([0], [0], marker=contour_marker, color=contour_color,\n                        linewidth=contour_size, markersize=contour_markersize)\n    ax.add_line(contour)\n    ax.add_line(center)\n    ax.set_xlabel(f'$f_{{{ind[1] + 1}}}$', fontsize=fontsize)\n    ax.set_ylabel(f'$f_{{{ind[0] + 1}}}$', fontsize=fontsize)\n    ax.set_aspect('equal')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dim = random.randint(2, 10)\n        A = np.random.randn(dim, dim)\n        K = A @ A.T\n\n        i, j = random.sample(range(dim), 2)\n        ind = [i, j]\n\n        contour_color = random.choice(['r', 'g', 'b', 'k', 'm', 'c', 'y'])\n        contour_style = random.choice(['-', '--', '-.', ':'])\n        contour_size = random.uniform(0.5, 3.0)\n        contour_markersize = random.uniform(4.0, 12.0)\n        contour_marker = random.choice(['o', 's', '^', 'x', '*', 'D'])\n        fontsize = random.randint(10, 20)\n\n        test_cases.append((K, ind, contour_color, contour_style, contour_size,\n                           contour_markersize, contour_marker, fontsize))\n    return test_cases"}
{"problem_id": "matplotlib_13", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a bar plot to visualize accuracy values from a given dataset. The function should take in a dictionary of accuracy values, a title for the plot, and an optional output file name to save the generated plot as an image.\n\nFunction signature:\n```python\ndef create_barplot(accs, title, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- A dictionary `accs` where keys are strings (labels) and values are floats (accuracy percentages).\n- A string `title` representing the title of the bar plot.\n- An optional string `output_file` representing the name of the output file (default is 'output.png').\n\nOutput format:\n- The function saves a bar plot image to the specified output file. The image file will contain a bar plot visualizing the accuracy values with appropriate labels and titles.\n\nInput:\n```python\n{\n    'accs': {\n        'Model_0': 85.3,\n        'Model_1': 92.7,\n        'Model_2': 78.4,\n        'Model_3': 88.1\n    },\n    'title': 'Test Plot 1'\n}\n```\n\nOutput:\n```python\n'output_file': 'output.png'\n``` \n\n(Note: The output file 'output.png' will be generated by the `create_barplot` function, containing a bar plot visualizing the accuracies of the models.)", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef create_barplot(accs, title, output_file='output.png'):\n    y = list(accs.values())\n    x = np.arange(len(y))\n    xticks = list(accs.keys())\n\n    plt.figure(figsize=(8, 5))\n    plt.bar(x, y)\n\n    for (i, j) in zip(x, y):\n        plt.text(i, j, f'{j:.1f}', ha='center', va='bottom', fontsize=7)\n\n    plt.title(title)\n    plt.ylabel('Accuracy (%)')\n    plt.ylim(0, 100)\n    plt.xticks(x, xticks, rotation=90)\n    plt.yticks(np.linspace(0, 100, 11))\n    plt.subplots_adjust(bottom=0.3)\n    plt.grid(axis='y')\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_models = random.randint(3, 20)\n        accs = {f'Model_{i}': round(random.uniform(50, 100), 1) for i in range(num_models)}\n        title = f\"Test Plot {_ + 1}\"\n        test_cases.append((accs, title))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_14", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the distribution of prediction confidence scores for a binary classification problem. The function will generate a histogram that displays the confidence scores of true positive and false positive predictions on a logarithmic scale. The function will also include a title that summarizes the counts of true positives, false positives, false negatives, and the total number of samples.\n\nFunction Signature:\n```python\ndef plot_prediction_hist(label_list, pred_list, type_list, outfile='output.png'):\n```\n\n### Constants:\n- The default output filename is set to `'output.png'`.\n\n### Input Format:\n- `label_list`: A list of integers (0 or 1) representing the true labels of the predictions.\n- `pred_list`: A list of floats representing the confidence scores of the predictions.\n- `type_list`: A list of strings indicating the type of each prediction (e.g., 'det_fp', 'det_fn', 'det_tp').\n- `outfile`: A string representing the filename to save the output plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a histogram plot as an image file to the specified output path.\n\nInput:\n```python\nlabel_list = [0, 1, 1, 0, 1, 0, 1, 0, 1, 0]\npred_list = [0.1, 0.9, 0.8, 0.2, 0.95, 0.05, 0.85, 0.15, 0.7, 0.3]\ntype_list = ['det_fp', 'det_tp', 'det_tp', 'det_fp', 'det_tp', 'det_fp', 'det_tp', 'det_fp', 'det_tp', 'det_fn']\n```\n\nOutput:\n```plaintext\nA histogram plot saved as 'output.png' with the following title: \n'tp:5 fp:4 fn:1 pos:6 count:10'\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_prediction_hist(label_list, pred_list, type_list, outfile='output.png'):\n    preds = np.array(pred_list)\n    labels = np.array(label_list)\n\n    plt.figure()\n    plt.yscale('log')\n\n    if 0 in labels:\n        plt.hist(preds[labels == 0], alpha=0.3, color='g', range=(0, 1), bins=50, label='false pos.')\n    if 1 in labels:\n        plt.hist(preds[labels == 1], alpha=0.3, color='b', range=(0, 1), bins=50, label='true pos. (false neg. @ score=0)')\n\n    if type_list:\n        fp_count = type_list.count('det_fp')\n        fn_count = type_list.count('det_fn')\n        tp_count = type_list.count('det_tp')\n        pos_count = fn_count + tp_count\n        title = f'tp:{tp_count} fp:{fp_count} fn:{fn_count} pos:{pos_count} count:{len(label_list)}'\n        plt.title(title)\n\n    plt.legend()\n    plt.xlabel('confidence score')\n    plt.ylabel('log n')\n\n    plt.savefig(outfile)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        list_size = random.randint(50, 200)\n        pred_list = np.random.rand(list_size).tolist()\n        label_list = np.random.choice([0, 1], size=list_size).tolist()\n        type_options = ['det_fp', 'det_fn', 'det_tp']\n        type_list = random.choices(type_options, k=list_size)\n\n        test_cases.append((label_list, pred_list, type_list))\n\n    return test_cases"}
{"problem_id": "matplotlib_15", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a square plot of a sine wave using Matplotlib. The function should allow customization of various plot parameters such as axis labels, line width, font size, and the size of the output figure. Additionally, the function should save the generated plot to a specified output file.\n\nFunction Signature:\n```python\ndef MySquarePlot(xlab: str, ylab: str, lw: int, lfs: int, size_x: int, size_y: int, output_file: str = 'output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- The function accepts the following parameters:\n  - `xlab`: A string representing the label for the x-axis.\n  - `ylab`: A string representing the label for the y-axis.\n  - `lw`: An integer representing the line width of the plot.\n  - `lfs`: An integer representing the font size for the axis labels.\n  - `size_x`: An integer representing the width of the figure.\n  - `size_y`: An integer representing the height of the figure.\n  - `output_file`: An optional string representing the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file in the specified format.\n\n```python\nInput: ('Time (s)', 'Amplitude', 2.5, 12, 6.5, 5.0)\nOutput: 'output.png'\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n\n# main code\ndef MySquarePlot(xlab, ylab, lw, lfs, size_x, size_y, output_file='output.png'):\n    fig = plt.figure(figsize=(size_x, size_y))\n    ax = fig.add_subplot(111)\n\n    ax.set_xlabel(xlab, fontsize=lfs)\n    ax.set_ylabel(ylab, fontsize=lfs)\n\n    ax.tick_params(which='major', direction='in', width=2, length=13, right=True, top=True, pad=7)\n    ax.tick_params(which='minor', direction='in', width=1, length=10, right=True, top=True)\n\n\n    x = np.linspace(0, 10, 100)\n    y = np.sin(x)\n    ax.plot(x, y, linewidth=lw)\n\n    fig.savefig(output_file)\n    plt.close(fig)", "test_script": "import random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    def random_string(length=5):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n    test_cases = []\n\n    for _ in range(n):\n        xlab = random_string(random.randint(3, 15))\n        ylab = random_string(random.randint(3, 15))\n        lw = round(random.uniform(0.5, 5.0), 2)\n        lfs = random.randint(8, 24)\n\n        size_x = round(random.uniform(4.0, 10.0), 1)\n        size_y = round(random.uniform(4.0, 10.0), 1)\n        test_cases.append((xlab, ylab, lw, lfs, size_x, size_y))\n\n    return test_cases"}
{"problem_id": "matplotlib_16", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a customizable plot using the Matplotlib library in Python. The function should allow users to specify various parameters for the plot, including labels, font sizes, figure size, grid visibility, and the file path for saving the plot.\n\nFunction Signature:\n```python\ndef MyDoublePlot(xlab1, ylab1, lfs, size_x, size_y, grid, save_path='output.png'):\n```\n\n### Constants Used:\n- The default value for the `save_path` parameter is set to `'output.png'`.\n\n### Input Format:\n- `xlab1`: A string representing the label for the x-axis.\n- `ylab1`: A string representing the label for the y-axis.\n- `lfs`: An integer representing the font size for the axis labels.\n- `size_x`: A float representing the width of the figure.\n- `size_y`: A float representing the height of the figure.\n- `grid`: A boolean indicating whether to display a grid on the plot.\n- `save_path`: A string representing the file path where the plot will be saved (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file at the specified location.\n\nInput:\n```python\n(\"Temperature (\u00b0C)\", \"Pressure (hPa)\", 12, 10.5, 6.0, True)\n```\n\nOutput:\n```python\n\"output.png\"\n``` \n\nThis input generates a plot with the x-axis labeled \"Temperature (\u00b0C)\", the y-axis labeled \"Pressure (hPa)\", a font size of 12 for the labels, a figure size of 10.5 by 6.0 inches, and a grid displayed on the plot. The output is the filename where the plot is saved.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef MyDoublePlot(xlab1, ylab1, lfs, size_x, size_y, grid, save_path='output.png'):\n    fig, ax1 = plt.subplots(figsize=(size_x, size_y))\n\n    ax1.tick_params(which='major', direction='in', width=2, length=13, right=True, top=True, pad=7)\n    ax1.tick_params(which='minor', direction='in', width=1, length=10, right=True, top=True)\n\n    ax1.set_xlabel(xlab1, fontsize=lfs)\n    ax1.set_ylabel(ylab1, fontsize=lfs)\n\n    if grid:\n        ax1.grid()\n\n    plt.savefig(save_path)\n    plt.close(fig)", "test_script": "import random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    def random_string(length=10):\n        return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n    test_cases = []\n    for _ in range(n):\n        xlab1 = random_string(random.randint(5, 15))\n        ylab1 = random_string(random.randint(5, 15))\n        lfs = random.randint(8, 30)\n        size_x = round(random.uniform(3.0, 15.0), 1)\n        size_y = round(random.uniform(3.0, 15.0), 1)\n        grid = random.choice([True, False])\n\n        test_cases.append((xlab1, ylab1, lfs, size_x, size_y, grid))\n    return test_cases"}
{"problem_id": "matplotlib_17", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a vertical double plot using the Matplotlib library in Python. The function should allow customization of various plot parameters, including axis labels, figure size, and grid visibility. The function will take in two sets of data points to be plotted on separate axes within the same figure.\n\nFunction signature:\n```python\ndef MyDoublePlot_Vertical(x1, y1, x2, y2, xlab1, ylab1, xlab2, ylab2, hspace, lfs, size_x, size_y, Grid, height_ratios, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The function takes the following parameters:\n  - `x1`: List or array of x-coordinates for the first plot.\n  - `y1`: List or array of y-coordinates for the first plot.\n  - `x2`: List or array of x-coordinates for the second plot.\n  - `y2`: List or array of y-coordinates for the second plot.\n  - `xlab1`: String for the x-axis label of the first plot.\n  - `ylab1`: String for the y-axis label of the first plot.\n  - `xlab2`: String for the x-axis label of the second plot.\n  - `ylab2`: String for the y-axis label of the second plot.\n  - `hspace`: Float for the height space between the two plots.\n  - `lfs`: Integer for the font size of the labels.\n  - `size_x`: Float for the width of the figure.\n  - `size_y`: Float for the height of the figure.\n  - `Grid`: Boolean indicating whether to display grid lines.\n  - `height_ratios`: List of floats specifying the relative heights of the two plots.\n  - `output_file`: String for the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated plot as an image file in the specified format (default is PNG) to the location defined by `output_file`.\n\n**Input:**\n```python\nx1 = np.linspace(0, 10, 50)\ny1 = np.sin(x1) + np.random.normal(0, 0.1, 50)\nx2 = np.linspace(0, 10, 50)\ny2 = np.cos(x2) + np.random.normal(0, 0.1, 50)\nxlab1 = \"X-axis 1 (unit m)\"\nylab1 = \"Y-axis 1 (unit kg)\"\nxlab2 = \"X-axis 2 (unit s)\"\nylab2 = \"Y-axis 2 (unit kPa)\"\nhspace = 0.3\nlfs = 12\nsize_x = 8\nsize_y = 10\nGrid = True\nheight_ratios = [1.0, 1.5]\noutput_file = 'test_output.png'\n```\n\n**Output:**\nThe function `MyDoublePlot_Vertical` will generate a vertical double plot saved as `test_output.png` with the following characteristics:\n- The first subplot will display a sine wave with noise, labeled with \"X-axis 1 (unit m)\" and \"Y-axis 1 (unit kg)\".\n- The second subplot will display a cosine wave with noise, labeled with \"X-axis 2 (unit s)\" and \"Y-axis 2 (unit kPa)\".\n- The space between the two plots will be 0.3, and the grid will be enabled for both plots. The figure size will be 8 inches wide and 10 inches tall, with height ratios of 1.0 for the first plot and 1.5 for the second plot.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n# main code\ndef MyDoublePlot_Vertical(x1, y1, x2, y2, xlab1, ylab1, xlab2, ylab2, hspace, lfs, size_x, size_y, Grid, height_ratios, output_file='output.png'):\n\n    fig, axarr = plt.subplots(2, 1, figsize=(size_x, size_y))\n    gs = gridspec.GridSpec(2, 1, height_ratios=height_ratios)\n    gs.update(hspace=hspace)\n\n    ax1 = plt.subplot(gs[0])\n    ax2 = plt.subplot(gs[1])\n\n    ax1.tick_params(which='major', direction='in', width=2, length=13, right=False, top=True, pad=10)\n    ax1.tick_params(which='minor', direction='in', width=1, length=10, right=False, top=True)\n    ax2.tick_params(which='major', direction='in', width=2, length=13, right=False, top=True, pad=10)\n    ax2.tick_params(which='minor', direction='in', width=1, length=10, right=False, top=True)\n\n    ax1.set_xlabel(xlab1, fontsize=lfs)\n    ax1.set_ylabel(ylab1, fontsize=lfs)\n    ax2.set_xlabel(xlab2, fontsize=lfs)\n    ax2.set_ylabel(ylab2, fontsize=lfs)\n\n    ax1.plot(x1, y1, label=\"Data 1\")\n    ax2.plot(x2, y2, label=\"Data 2\")\n\n    if Grid:\n        ax1.grid()\n        ax2.grid()\n\n    fig.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length1 = random.randint(10, 500)\n        length2 = random.randint(10, 500)\n\n        x1 = np.linspace(0, 10, length1)\n        y1 = np.sin(x1) + np.random.normal(0, 0.1, length1)\n\n        x2 = np.linspace(0, 10, length2)\n        y2 = np.cos(x2) + np.random.normal(0, 0.1, length2)\n        xlab1 = f\"X-axis 1 (unit {random.choice(['m', 'cm', 'mm'])})\"\n        ylab1 = f\"Y-axis 1 (unit {random.choice(['kg', 'g', 'mg'])})\"\n        xlab2 = f\"X-axis 2 (unit {random.choice(['s', 'ms', 'ns'])})\"\n        ylab2 = f\"Y-axis 2 (unit {random.choice(['Pa', 'kPa', 'MPa'])})\"\n        hspace = random.uniform(0.1, 0.5)\n        lfs = random.randint(8, 20)\n        size_x = random.uniform(4, 12)\n        size_y = random.uniform(6, 15)\n        Grid = random.choice([True, False])\n        height_ratios = [random.uniform(0.5, 2.0), random.uniform(0.5, 2.0)]\n        test_cases.append((x1, y1, x2, y2, xlab1, ylab1, xlab2, ylab2, hspace, lfs, size_x, size_y, Grid, height_ratios))\n\n    return test_cases"}
{"problem_id": "matplotlib_18", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a single plot using the Matplotlib library in Python. The function should allow customization of the plot's labels, size, grid visibility, and output file name.\n\nFunction Signature:\n```python\ndef MySinglePlot(xlab: str, ylab: str, lfs: int, size_x: float, size_y: float, grid: bool, output_file: str = 'output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- The function accepts the following parameters:\n  - `xlab`: A string for the x-axis label.\n  - `ylab`: A string for the y-axis label.\n  - `lfs`: An integer for the label font size.\n  - `size_x`: A float for the plot width.\n  - `size_y`: A float for the plot height.\n  - `grid`: A boolean indicating whether to show the grid.\n  - `output_file`: An optional string for the output file name (default is 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file with the specified name.\n\nInput:\n```python\n(\"Time (s)\", \"Accuracy\", 14, 8, 5, True)\n```\n\nOutput:\n```python\n\"output.png\"\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n# main code\ndef MySinglePlot(xlab, ylab, lfs, size_x, size_y, grid, output_file='output.png'):\n    fig, ax = plt.subplots(figsize=(size_x, size_y))\n    gs = gridspec.GridSpec(1, 1)\n    ax = plt.subplot(gs[0])\n    ax.tick_params(which='major', direction='in', width=2, length=13, right=True, top=True, pad=7)\n    ax.tick_params(which='minor', direction='in', width=1, length=10, right=True, top=True)\n\n    ax.set_xlabel(xlab, fontsize=lfs)\n    ax.set_ylabel(ylab, fontsize=lfs)\n\n    if grid:\n        ax.grid()\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    xlab_options = [\"X-axis\", \"Time (s)\", \"Value\", \"Iteration\", \"Epoch\"]\n    ylab_options = [\"Y-axis\", \"Accuracy\", \"Loss\", \"Error Rate\", \"Performance\"]\n    lfs_options = [8, 10, 12, 14, 16, 18, 20, 22]\n    size_x_options = [4, 6, 8, 10, 12, 14]\n    size_y_options = [3, 5, 7, 9, 11, 13]\n    grid_options = [True, False]\n\n    for i in range(n):\n        xlab = random.choice(xlab_options)\n        ylab = random.choice(ylab_options)\n        lfs = random.choice(lfs_options)\n        size_x = random.choice(size_x_options)\n        size_y = random.choice(size_y_options)\n        grid = random.choice(grid_options)\n\n        test_cases.append((xlab, ylab, lfs, size_x, size_y, grid))\n\n    return test_cases"}
{"problem_id": "matplotlib_19", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a line graph based on historical data for various countries. The function should visualize the proportion of a specified measure over a timeline, allowing for customization of the output appearance based on user preferences.\n\nFunction Signature:\n```python\ndef plot_graph(data, value, measure, max_days_back, dark, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `7`, which is used to set the major locator for the x-axis ticks to display every 7 days.\n\n### Input Format:\n- The function takes a list of dictionaries for `data`, strings for `value` and `measure`, an integer for `max_days_back`, a boolean for `dark`, and an optional string for `output_file`.\n\n### Output Format:\n- The function saves a plot as an image file (PNG format) to the specified `output_file`.\n\n**Input:**\n```python\ndata = [\n    {\n        'country': {'name': 'USA'},\n        'history': {\n            '01/10': {'proportion': 20.5},\n            '02/10': {'proportion': 22.0},\n            '03/10': {'proportion': 19.5},\n            '04/10': {'proportion': 21.0},\n            '05/10': {'proportion': 23.5}\n        }\n    },\n    {\n        'country': {'name': 'CAN'},\n        'history': {\n            '01/10': {'proportion': 15.0},\n            '02/10': {'proportion': 16.5},\n            '03/10': {'proportion': 14.0},\n            '04/10': {'proportion': 17.0},\n            '05/10': {'proportion': 18.5}\n        }\n    }\n]\nvalue = 'infection'\nmeasure = 'percentage'\nmax_days_back = 5\ndark = False\n```\n\n**Output:**\nThe output will be a saved plot image file named 'output.png' that visually represents the infection percentage over the last 5 days for the USA and Canada. The x-axis will show the dates from '01/10' to '05/10', and the y-axis will show the corresponding infection percentages. The plot will not have a dark theme.", "ground_truth_code": "import matplotlib.pyplot as plt\nfrom matplotlib.ticker import MultipleLocator\n\n# main code\ndef plot_graph(data, value, measure, max_days_back, dark, output_file='output.png'):\n    days_back = min(min(len(c['history']) for c in data), max_days_back)\n\n    all_dates = sorted(set(date for c in data for date in c['history'].keys()))\n    timeline = all_dates[-days_back:]\n    yvalues = [\n        [c['history'].get(d, {'proportion': 0})['proportion'] for d in timeline]\n        for c in data\n    ]\n\n    fig, ax = plt.subplots()\n    ax.spines['bottom'].set_visible(False)\n    ax.spines['top'].set_visible(False)\n    ax.spines['right'].set_visible(False)\n    ax.spines['left'].set_visible(False)\n\n    ax.xaxis.set_major_locator(MultipleLocator(7))\n    for yval in yvalues:\n        ax.plot(timeline, yval, '.-', alpha=0.5)\n\n    ticks = [i for i in range(len(timeline)) if i % (days_back // 5) == 0]\n    plt.xticks(ticks, ha='center')\n    ax.yaxis.grid(True)\n\n    plt.ylabel(f'{value.capitalize()} of {measure.capitalize()} (%)')\n    plt.xlabel('Timeline (DD/MM)')\n\n    if dark:\n        ax.xaxis.label.set_color('white')\n        ax.yaxis.label.set_color('white')\n        ax.tick_params(axis='x', colors='white')\n        ax.tick_params(axis='y', colors='white')\n        leg = plt.legend([name['country']['name'] for name in data], facecolor='0.1', loc='upper left')\n        for text in leg.get_texts():\n            text.set_color('white')\n        plt.savefig(output_file, transparent=True)\n    else:\n        plt.savefig(output_file)\n\n    plt.close(fig)\n", "test_script": "import random\nimport string\nfrom datetime import datetime, timedelta\n\ndef test_case_input_generator(n=200):\n    def generate_random_date_sequence(days):\n        today = datetime.today()\n        return [(today - timedelta(days=i)).strftime('%d/%m') for i in range(days)][::-1]\n\n    def generate_random_proportions(days):\n        return [{\n            'proportion': round(random.uniform(0, 100), 2)\n        } for _ in range(days)]\n\n    def generate_random_data_entry(days):\n        return {\n            'country': {'name': ''.join(random.choices(string.ascii_uppercase, k=3))},\n            'history': dict(zip(generate_random_date_sequence(days), generate_random_proportions(days)))\n        }\n    test_cases = []\n    for _ in range(n):\n        max_days_back = random.randint(10, 100)\n        num_data_entries = random.randint(2, 10)\n        data = [generate_random_data_entry(random.randint(max_days_back, max_days_back + 10)) for _ in range(num_data_entries)]\n        value = random.choice(['infection', 'recovery', 'death'])\n        measure = random.choice(['rate', 'count', 'percentage'])\n        dark = random.choice([True, False])\n\n        test_cases.append((data, value, measure, max_days_back, dark))\n    return test_cases\n"}
{"problem_id": "matplotlib_20", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a Receiver Operating Characteristic (ROC) curve from given labels and scores. The ROC curve is a graphical representation used to evaluate the performance of a binary classifier system as its discrimination threshold is varied. The function should also save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef plot_roc(labels, scores, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `labels`: A list or array of binary labels (0 or 1) indicating the true class of each sample.\n- `scores`: A list or array of scores (probabilities or decision function values) assigned by the classifier for each sample.\n- `output_file`: A string representing the filename where the plot will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. It generates and saves a ROC curve plot to the specified output file.\n\n```python\n# Input\nlabels = np.array([0, 1, 1, 0, 1, 0, 1, 0, 1, 0])\nscores = np.array([0.1, 0.4, 0.35, 0.8, 0.7, 0.2, 0.9, 0.6, 0.3, 0.5])\n\n# Output\noutput_file = 'output.png'  # The ROC curve will be saved as 'output.png'\n```", "ground_truth_code": "from sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_roc(labels, scores, output_file='output.png'):\n    (fpr, tpr, _) = roc_curve(labels, scores)\n    roc_auc = auc(fpr, tpr)\n    plt.figure()\n    plt.plot(fpr, tpr, color='darkorange', label=f'ROC curve (area = {roc_auc:.2f})')\n    plt.plot([0, 1], [0, 1], color='navy', linestyle='--')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate')\n    plt.ylabel('True Positive Rate')\n    plt.title('Receiver Operating Characteristic')\n    plt.legend(loc='lower right')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 1000)\n        labels = np.random.choice([0, 1], size=num_samples)\n        scores = np.random.rand(num_samples)\n        test_cases.append((labels, scores))\n    return test_cases"}
{"problem_id": "matplotlib_21", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a plot for visualizing data points and optional vertical lines based on specified divisions. The function should allow customization of the plot title and the output file name.\n\nFunction signature:\n```python\ndef plot(title_comment: str, p: list, div: list, output_file: str = 'output.png') -> None:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `6`, which is used to cycle through colors for the vertical lines.\n\nInput format:\n- `title_comment`: A string representing the title comment for the plot.\n- `p`: A list of numerical values representing the data points to be plotted.\n- `div`: A list of lists, where each inner list contains numerical values representing the x-coordinates for vertical lines.\n- `output_file`: An optional string representing the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It generates and saves a plot as an image file in the specified format.\n\nInput:\n```python\ntitle_comment = \"TestCase1\"\np = [0.1, 0.5, 0.3, 0.9, 0.2]\ndiv = [[1, 3]]\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with the following characteristics:\n# - Title: \"OpenGoddard inner variables TestCase1\"\n# - Points plotted at (0, 0.1), (1, 0.5), (2, 0.3), (3, 0.9), (4, 0.2)\n# - A vertical line at x=1 and x=3 with color corresponding to section 1\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot(title_comment, p, div, output_file='output.png'):\n    plt.figure()\n    plt.title(f'OpenGoddard inner variables {title_comment}')\n    plt.plot(p, 'o')\n    plt.xlabel('Variables')\n    plt.ylabel('Value')\n\n    if div:\n        for section, lines in enumerate(div):\n            for line in lines:\n                plt.axvline(line, color=f'C{(section + 1) % 6}', alpha=0.5)\n\n    plt.grid()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\nimport string\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        title_comment = ''.join(random.choices(string.ascii_letters + string.digits, k=random.randint(5, 20)))\n        p = np.random.rand(random.randint(10, 100)).tolist()\n        div = []\n        num_sections = random.randint(0, 5)\n        for _ in range(num_sections):\n            lines = sorted(random.sample(range(len(p)), random.randint(1, len(p) // 3)))\n            div.append(lines)\n\n        test_cases.append((title_comment, p, div))\n\n    return test_cases"}
{"problem_id": "matplotlib_22", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a line chart from a given dataset containing time-series data. The function should be able to handle two different types of data: acceleration data (with columns 'ax', 'ay', 'az') or gyroscope data (with columns 'gx', 'gy', 'gz'). The generated chart should be saved as an image file.\n\nFunction signature:\n```python\ndef fall_line_chart(data, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to 'output.png'.\n\nInput format:\n- The input to the function is a DataFrame `data` that contains either acceleration or gyroscope data, along with a timestamp column.\n\nOutput format:\n- The output of the function is a saved image file in PNG format, named according to the `output_file` parameter, which contains the line chart visualizing the data.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'timestamp': np.arange(10),\n    'ax': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n    'ay': [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1],\n    'az': [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\n})\nfall_line_chart(data, output_file='test_output.png')\n```\n\n**Output:**\n- A line chart saved as `test_output.png` with three lines representing the values of `ax`, `ay`, and `az` over the timestamps from 0 to 9. The x-axis will have ticks at intervals of 1, and the legend will indicate the labels 'x', 'y', and 'z' corresponding to `ax`, `ay`, and `az`, respectively.", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef fall_line_chart(data, output_file='output.png'):\n    num = data.timestamp.size\n    x = np.arange(num)\n\n    if 'ax' in data.columns and 'ay' in data.columns and 'az' in data.columns:\n        plt.plot(x, data.ax, label='x')\n        plt.plot(x, data.ay, label='y')\n        plt.plot(x, data.az, label='z')\n    elif 'gx' in data.columns and 'gy' in data.columns and 'gz' in data.columns:\n        plt.plot(x, data.gx, label='x')\n        plt.plot(x, data.gy, label='y')\n        plt.plot(x, data.gz, label='z')\n\n    plt.legend()\n    plt.xticks(np.linspace(0, num-1, 9, dtype=int))\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_timestamps = random.randint(50, 1000)\n\n        if random.choice([True, False]):\n            data = pd.DataFrame({\n                'timestamp': np.arange(num_timestamps),\n                'ax': np.random.randn(num_timestamps),\n                'ay': np.random.randn(num_timestamps),\n                'az': np.random.randn(num_timestamps),\n            })\n        else:\n            data = pd.DataFrame({\n                'timestamp': np.arange(num_timestamps),\n                'gx': np.random.randn(num_timestamps),\n                'gy': np.random.randn(num_timestamps),\n                'gz': np.random.randn(num_timestamps),\n            })\n        test_cases.append(data)\n\n    return test_cases"}
{"problem_id": "matplotlib_23", "library": "matplotlib", "code_problem": "You are tasked with creating a function that formats and saves a plot using the Matplotlib library. The function should allow customization of various plot parameters, including tick marks, labels, title, and axis limits. The function signature is as follows:\n\n```python\ndef format(xticks, labels, title, yPos, nPackages, end, xlabel, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- The function takes the following parameters:\n  - `xticks`: List of integers or floats (optional).\n  - `labels`: List of strings (optional).\n  - `title`: String.\n  - `yPos`: List or range of integers (optional).\n  - `nPackages`: Integer.\n  - `end`: List of integers or floats (optional).\n  - `xlabel`: String (optional).\n  - `output_file`: String (optional, defaults to 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file with the specified filename.\n\nInput:\n```python\n(\n    [0, 20, 40, 60, 80], \n    ['Label 1', 'Label 2', 'Label 3', 'Label 4'], \n    'Test Case Title 1', \n    [1, 2, 3, 4], \n    4, \n    [10, 30, 50, 70], \n    'X-Axis Label 1'\n)\n```\n\nOutput:\n```plaintext\nA plot is saved as 'output.png' with the following characteristics:\n- X-ticks: [0, 20, 40, 60, 80]\n- Y-ticks: [1, 2, 3, 4] labeled as ['Label 1', 'Label 2', 'Label 3', 'Label 4']\n- Title: 'Test Case Title 1'\n- X-axis label: 'X-Axis Label 1'\n- Y-axis limits: (0.5, 4.5)\n- X-axis limits: (0, 80)\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef format(xticks, labels, title, yPos, nPackages, end, xlabel, output_file='output.png'):\n    xticks = xticks or []\n    labels = labels or []\n    yPos = yPos or range(1, nPackages + 1)\n    end = end or [0]\n\n    plt.tick_params(axis='both', which='both', bottom=True, top=False, left=False, right=False)\n    plt.xlim(0, max(end))\n    plt.ylim(0.5, nPackages + 0.5)\n    plt.yticks(yPos, labels)\n    plt.title(title)\n    if xlabel:\n        plt.xlabel(xlabel)\n    if xticks:\n        plt.xticks(xticks, map(str, xticks))\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nPackages = random.randint(1, 50)\n        end_value = random.randint(10, 100)\n        xticks = sorted(random.sample(range(0, end_value + 1), random.randint(2, 10)))\n        labels = [f'Label {i}' for i in range(1, nPackages + 1)]\n        yPos = list(range(1, nPackages + 1))\n        end = sorted(random.sample(range(1, end_value + 1), random.randint(1, 5)))\n\n        title = f'Test Case Title {_ + 1}'\n        xlabel = f'X-Axis Label {_ + 1}' if random.choice([True, False]) else ''\n\n        test_cases.append((xticks, labels, title, yPos, nPackages, end, xlabel))\n\n    return test_cases"}
{"problem_id": "matplotlib_24", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a scatter plot using the Matplotlib library in Python. The function should allow customization of the plot's appearance and save the output to a specified file.\n\nFunction signature:\n```python\ndef plot_scatter(x, y, xlabel, ylabel, color, alpha, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the size of the scatter plot points, which is set to `2.5`.\n\nInput format:\n- The function accepts the following parameters:\n  - `x`: A list or array of x-coordinates (float values).\n  - `y`: A list or array of y-coordinates (float values).\n  - `xlabel`: A string representing the label for the x-axis.\n  - `ylabel`: A string representing the label for the y-axis.\n  - `color`: A string or list representing the color(s) of the points.\n  - `alpha`: A float value representing the transparency level of the points (between 0 and 1).\n  - `output_file`: A string representing the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a scatter plot image to the specified output file.\n\nInput:\n```python\nx = np.array([0.1, 0.4, 0.6, 0.8])\ny = np.array([0.2, 0.5, 0.7, 0.9])\nxlabel = \"X-axis\"\nylabel = \"Y-axis\"\ncolor = 'blue'\nalpha = 0.5\noutput_file = 'test_output.png'\n```\n\nOutput:\nThe function `plot_scatter` will generate a scatter plot saved as `test_output.png` with the following characteristics:\n- Points plotted at coordinates (0.1, 0.2), (0.4, 0.5), (0.6, 0.7), and (0.8, 0.9).\n- The x-axis labeled \"X-axis\" and the y-axis labeled \"Y-axis\".\n- Points colored blue with an alpha transparency of 0.5.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_scatter(x, y, xlabel, ylabel, color, alpha, output_file='output.png'):\n    plt.scatter(x, y, alpha=alpha, s=2.5, c=color, linewidths=0)\n    plt.grid(False)\n    plt.tick_params(labelbottom=False, labelleft=False, bottom=False, left=False, top=False, right=False)\n    plt.ylim(0.0, 1.0)\n    plt.xlim(0.0, 1.0)\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = random.randint(50, 200)\n\n        x = np.random.rand(num_points)\n        y = np.random.rand(num_points)\n\n\n        xlabel = \"X-axis\"\n        ylabel = \"Y-axis\"\n\n        if random.random() < 0.5:\n            color = random.choice(['red', 'green', 'blue', 'orange', 'purple'])\n        else:\n            color = np.random.rand(num_points, 3)\n        alpha = round(random.uniform(0.1, 1.0), 2)\n        test_cases.append((x, y, xlabel, ylabel, color, alpha))\n\n    return test_cases"}
{"problem_id": "matplotlib_25", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the convergence of an optimization algorithm by plotting the objective function values and the values of multiple variables over a series of iterations. The function should generate a plot and save it as an image file.\n\nFunction signature:\n```python\ndef plotGD(H, c, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n\nInput format:\n- The input to the function consists of:\n  - `H`: a tuple containing two elements:\n    - `Hv`: a 1D or 2D array of variable values.\n    - `Hf`: a 1D array of objective function values.\n  - `c`: a boolean value.\n  - `output_file`: an optional string specifying the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file specified by `output_file`.\n\nInput:\n```python\n((array([[0.1, 0.2],\n         [0.3, 0.4],\n         [0.5, 0.6],\n         [0.7, 0.8],\n         [0.9, 1.0]]), \n  array([0.5, 0.6, 0.7, 0.8, 0.9])), \n True)\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' with the title \"Convergence in 5 iterations.\" showing the objective function and two feature values V_0 and V_1.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plotGD(H, c, output_file='output.png'):\n    plt.figure()\n    Hv, Hf = H\n\n    Hv = np.atleast_2d(Hv).T if Hv.ndim == 1 else Hv\n\n    plt.plot(Hf)\n    plt.plot(Hv)\n\n    plt.xlabel('Iterations')\n    plt.legend(['Objective function'] + [f'$V_{i}$' for i in range(Hv.shape[1])])\n\n    str_title = f\"Convergence in {len(Hf)} iterations.\"\n    if not c:\n        str_title = 'No ' + str_title\n    plt.title(str_title)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_iterations = random.randint(10, 500)\n        Hf = np.random.rand(num_iterations)\n        num_features = random.randint(1, 10)\n\n        if random.choice([True, False]):\n            Hv = np.random.rand(num_iterations)\n        else:\n            Hv = np.random.rand(num_iterations, num_features)\n        c = random.choice([True, False])\n        test_cases.append(((Hv, Hf), c))\n\n    return test_cases"}
{"problem_id": "matplotlib_26", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a histogram plot based on a given dataset. The function will compute the histogram of the input data, calculate the mean and standard error of the mean, and visualize the results using a bar plot and a cumulative sum line. The function should also save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef beta_hist(beta, xlim, voxel_dim, plot_color, label_name, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `0.33`, which represents the width of the bars in the histogram.\n\n### Input Format:\n- The function accepts a list or array of numerical values, a tuple for x-axis limits, a numerical value for voxel dimension, a string for plot color, a string for label name, and an optional string for the output file name.\n\n### Output Format:\n- The function does not return any value but saves a plot as an image file to the specified output file path.\n\nInput:\n```python\nbeta = np.random.randn(1000)\nxlim = [2.5, 15.3, 30]\nvoxel_dim = 1.2\nplot_color = '#FF5733'\nlabel_name = 'Label1'\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing a histogram of the beta values with cumulative distribution, shaded error bars, and specified x and y limits.\n```", "ground_truth_code": "import numpy as np\nfrom matplotlib import pyplot as plt\n\n\n# main code\ndef beta_hist(beta, xlim, voxel_dim, plot_color, label_name, output_file='output.png'):\n    fig, ax = plt.subplots()\n    spacing = np.linspace(xlim[0], xlim[1], xlim[2], endpoint=False)\n    n, bins = np.histogram(beta, bins=spacing)\n    bincenters = 0.5 * (bins[1:] + bins[:-1])\n\n    mu = n * voxel_dim ** 3 / (len(beta) * voxel_dim ** 3)\n    n_safe = np.sqrt(n)\n    n_safe[n_safe == 0] = 1\n    sme = mu / n_safe\n\n    cumsum = np.cumsum(mu)\n\n    ax.plot(bincenters, cumsum, plot_color, lw=2, label=label_name)\n    ax.fill_between(bincenters, cumsum - sme, cumsum + sme, color=plot_color, alpha=0.5)\n    ax.bar(bincenters, mu, color=plot_color, width=0.33)\n\n    ax.set_xticks(np.linspace(spacing[0], spacing[-1], 6))\n    ax.set_xticklabels([f'{x:.2f}' for x in np.linspace(spacing[0], spacing[-1], 6)], fontsize=18, rotation=45)\n\n    ax.set_yticks(np.arange(0.2, 1.2, 0.2))\n    ax.set_yticklabels(['20%', '40%', '60%', '80%', '100%'], fontsize=18)\n\n    ax.set_xlim(spacing[0] + 0.15, spacing[-1] + 0.25)\n    ax.set_ylim(0, 1)\n\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        beta = np.random.randn(1000)\n\n        xlim = [np.random.uniform(0, 10), np.random.uniform(10, 20), np.random.randint(10, 50)]\n        voxel_dim = np.random.uniform(0.5, 2.0)\n        plot_color = np.random.choice(['#FF5733', '#33FF57', '#3357FF', '#FF33A1', '#FFFF33'])\n        label_name = np.random.choice(['Label1', 'Label2', 'Label3', 'Label4'])\n        test_cases.append((beta, xlim, voxel_dim, plot_color, label_name))\n\n    return test_cases"}
{"problem_id": "matplotlib_27", "library": "matplotlib", "code_problem": "You are tasked with creating a function that displays one or more images in a single figure using Matplotlib. The function should allow for customization of the figure size, labels for each image, and the color map used for displaying the images. Additionally, the function should save the resulting figure to a specified output file.\n\nFunction signature:\n```python\ndef display(img1, img2, lbl1, lbl2, x, y, img3, lbl3, cmap, n, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The function takes the following parameters:\n  - `img1`: The first image to display.\n  - `img2`: The second image to display.\n  - `lbl1`: The label for the first image.\n  - `lbl2`: The label for the second image.\n  - `x`: The width of the figure.\n  - `y`: The height of the figure.\n  - `img3`: The optional third image to display (can be `None`).\n  - `lbl3`: The optional label for the third image (can be `None`).\n  - `cmap`: The color map to use for displaying the images.\n  - `n`: The number of images to display (should be 2 or 3).\n  - `output_file`: The name of the output file to save the figure (default is `'output.png'`).\n\nOutput format:\n- The function does not return any value. Instead, it saves the displayed images to a file specified by `output_file`.\n\n**Input:**\n```python\n(\n    np.random.rand(64, 64),  # img1\n    np.random.rand(64, 64),  # img2\n    \"Label 45\",              # lbl1\n    \"Label 78\",              # lbl2\n    10.5,                    # x\n    7.5,                     # y\n    np.random.rand(64, 64),  # img3\n    \"Label 32\",              # lbl3\n    \"viridis\",               # cmap\n    3                        # n\n)\n```\n\n**Output:**\n```plaintext\nA figure saved as 'output.png' containing three subplots:\n1. img1 displayed with label \"Label 45\"\n2. img2 displayed with label \"Label 78\"\n3. img3 displayed with label \"Label 32\"\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n\n# main code\ndef display(img1, img2, lbl1, lbl2, x, y, img3, lbl3, cmap, n, output_file='output.png'):\n    plt.figure(figsize=(x, y))\n\n    plt.subplot(1, n, 1)\n    plt.imshow(img1, cmap=cmap)\n    plt.xlabel(lbl1, fontsize=15)\n    plt.xticks([])\n    plt.yticks([])\n\n    plt.subplot(1, n, 2)\n    plt.imshow(img2, cmap=cmap)\n    plt.xlabel(lbl2, fontsize=15)\n    plt.xticks([])\n    plt.yticks([])\n\n    if n == 3 and img3 is not None and lbl3 is not None:\n        plt.subplot(1, n, 3)\n        plt.imshow(img3, cmap=cmap)\n        plt.xlabel(lbl3, fontsize=15)\n        plt.xticks([])\n        plt.yticks([])\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        img1 = np.random.rand(64, 64)\n        img2 = np.random.rand(64, 64)\n        img3 = np.random.rand(64, 64)\n        lbl1 = f\"Label {np.random.randint(1, 100)}\"\n        lbl2 = f\"Label {np.random.randint(1, 100)}\"\n        lbl3 = f\"Label {np.random.randint(1, 100)}\"\n        x = np.random.uniform(8, 12)\n        y = np.random.uniform(6, 10)\n        n = 3\n        cmap = np.random.choice(['viridis', 'plasma', 'inferno', 'magma', 'cividis'])\n        test_cases.append((img1, img2, lbl1, lbl2, x, y, img3, lbl3, cmap, n))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_28", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of reward values over time using a line plot. The function should take in a list of reward values and plot them as red circles connected by dashed lines. Additionally, the function should label the x-axis and y-axis based on the provided parameters and save the resulting plot to a specified file.\n\nFunction signature:\n```python\ndef draw_mu(reward_mu, xlabel, ylabel, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_path` is set to `'output.png'`.\n\nInput format:\n- `reward_mu`: A list of numerical values representing the rewards to be plotted.\n- `xlabel`: A string representing the label for the x-axis.\n- `ylabel`: A string representing the label for the y-axis.\n- `output_path`: (Optional) A string representing the file path where the plot will be saved.\n\nOutput format:\n- The function does not return any value. It generates and saves a plot as an image file at the specified `output_path`.\n\nInput:\n```python\nreward_mu = [2.5, -3.1, 4.0, 1.2, -0.5]\nxlabel = 'TestX'\nylabel = 'TestY'\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' with the following characteristics:\n- Data points: (0, 2.5), (1, -3.1), (2, 4.0), (3, 1.2), (4, -0.5)\n- X-axis label: 'TestX'\n- Y-axis label: 'TestY'\n- Grid is enabled\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef draw_mu(reward_mu, xlabel, ylabel, output_path='output.png'):\n    plt.plot(reward_mu, 'ro--')\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.grid()\n    plt.savefig(output_path)\n    plt.close()\n", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        reward_mu_length = random.randint(5, 20)\n        reward_mu = np.random.uniform(low=-10.0, high=10.0, size=reward_mu_length).tolist()\n        xlabel = ''.join(random.choices(string.ascii_letters, k=10))\n        ylabel = ''.join(random.choices(string.ascii_letters, k=10))\n\n        test_cases.append((reward_mu, xlabel, ylabel))\n\n    return test_cases"}
{"problem_id": "matplotlib_29", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training loss and learning rate over a series of training steps. The function should generate a plot that displays both metrics on the same graph, allowing for easy comparison. The training loss will be represented on the primary y-axis, while the learning rate will be displayed on a secondary y-axis.\n\nFunction signature:\n```python\ndef plot_loss_and_lr(train_loss, learning_rate, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `train_loss`: A list of floating-point numbers representing the training loss values at each step.\n- `learning_rate`: A list of floating-point numbers representing the learning rate values at each step.\n- `output_file`: A string representing the filename where the plot will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output file.\n\n```python\n# Input\ntrain_loss = [0.5, 0.4, 0.35, 0.3, 0.25]\nlearning_rate = [0.01, 0.01, 0.005, 0.005, 0.001]\n\n# Output\noutput_file = 'output.png'  # This is the filename where the plot will be saved.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_loss_and_lr(train_loss, learning_rate, output_file='output.png'):\n    x = list(range(len(train_loss)))\n    fig, ax1 = plt.subplots()\n\n    ax1.plot(x, train_loss, 'r', label='loss')\n    ax1.set_xlabel('step')\n    ax1.set_ylabel('loss')\n\n    ax2 = ax1.twinx()\n    ax2.plot(x, learning_rate, label='learning rate')\n    ax2.set_ylabel('learning rate')\n\n    ax1.set_title('Train Loss and Learning Rate')\n    ax1.set_xlim(0, len(train_loss))\n    handles1, labels1 = ax1.get_legend_handles_labels()\n    handles2, labels2 = ax2.get_legend_handles_labels()\n    ax1.legend(handles1 + handles2, labels1 + labels2, loc='upper right')\n\n    fig.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(10, 100)\n\n        train_loss = np.random.rand(length).tolist()\n        learning_rate = np.random.rand(length).tolist()\n        test_cases.append((train_loss, learning_rate))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_30", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the mean Average Precision (mAP) values over a series of epochs and saves the resulting plot as an image file. The function should take in a list of mAP values and an optional output file name for the saved plot.\n\nFunction signature:\n```python\ndef plot_map(mAP, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- A list of float values representing the mean Average Precision (mAP) for each epoch.\n- An optional string representing the output file name (default is 'output.png').\n\nOutput format:\n- The function saves a plot as an image file in the specified format (e.g., PNG) to the given output file name.\n\n```python\n# Input\nmAP = [0.1, 0.5, 0.3, 0.7, 0.9, 0.4, 0.6, 0.8, 0.2, 0.0]\n\n# Output\noutput_file = 'output.png'  # The plot will be saved as 'output.png'\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_map(mAP, output_file='output.png'):\n    x = list(range(len(mAP)))\n    plt.plot(x, mAP, label='mAP')\n    plt.xlabel('epoch')\n    plt.ylabel('mAP')\n    plt.title('Eval mAP')\n    plt.xlim(0, len(mAP))\n    plt.legend(loc='best')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        mAP = [random.uniform(0, 1) for _ in range(10)]\n        test_cases.append(mAP)\n\n    return test_cases"}
{"problem_id": "matplotlib_31", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D representation of a dataset using a color map. The function will take in a one-dimensional array of data and generate a square plot, saving it as an image file. The function signature is as follows:\n\n```python\ndef vis_fig(data, title, vmax, vmin, cmap, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the size of the figure, which is set to 4 inches by 4 inches.\n\n### Input Format:\n- The function accepts a one-dimensional NumPy array for `data`, a string for `title`, two floats for `vmax` and `vmin`, a string for `cmap`, and an optional string for `output_file`.\n\n### Output Format:\n- The function does not return any value. Instead, it saves a visual representation of the data as an image file in the specified format.\n\nInput:\n```python\ndata = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n                 1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 2.0])\ntitle = True\nvmax = 2.0\nvmin = 0.0\ncmap = 'viridis'\n```\n\nOutput:\n```plaintext\nA 4x4 heatmap image saved as 'output.png' with the title displayed.\n``` \n\n(Note: The actual output is a visual image file, which cannot be represented in text format. The description indicates that a heatmap image is generated and saved.)", "ground_truth_code": "from matplotlib import pyplot as plt\nimport math\n\n# main code\ndef vis_fig(data, title, vmax, vmin, cmap, output_file='output.png'):\n    dim = int(math.sqrt(data.size))\n    plt.clf()\n    plt.pcolor(data.reshape(dim, dim), vmin=vmin, vmax=vmax, cmap=cmap)\n    plt.xticks([])\n    plt.yticks([])\n    fig = plt.gcf()\n    ax = plt.gca()\n    if title:\n        ax.set_title(title)\n    ax.invert_yaxis()\n    fig.set_size_inches(4, 4)\n    plt.savefig(output_file, bbox_inches='tight', pad_inches=0.0)\n    plt.close(fig)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        side_length = np.random.randint(5, 21)\n        size = side_length * side_length\n        data = np.random.rand(size)\n        title = np.random.choice([True, False])\n        vmax = np.random.uniform(0.5, 2.0)\n        vmin = np.random.uniform(-2.0, -0.5)\n        cmap = np.random.choice(['viridis', 'plasma', 'inferno', 'cividis', 'magma', 'twilight'])\n        test_cases.append((data, title, vmax, vmin, cmap))\n\n    return test_cases"}
{"problem_id": "matplotlib_32", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of matrices representing some data related to movies, using a specified colormap and layout. The function should generate a grid of subplots, where each subplot corresponds to a different matrix, and save the resulting figure to a file.\n\nFunction Signature:\n```python\ndef plot_all(fd_matrices, alphas, cmap_name, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `1.0`, which is the maximum value for the color mapping in the `matshow` function.\n\n### Input Format:\n- `fd_matrices`: A dictionary mapping alpha values (float) to 2D numpy arrays (matrices).\n- `alphas`: A list of float values representing the alpha parameters.\n- `cmap_name`: A string representing the name of the colormap.\n- `figsize`: A tuple of two integers representing the width and height of the figure.\n- `output_file`: A string representing the filename for saving the output image.\n\n### Output Format:\n- The function saves a visual representation of the matrices to a file specified by `output_file`. The output is an image file in PNG format.\n\n**Input:**\n```python\nfd_matrices = {\n    0.25: np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]),\n    0.75: np.array([[0.2, 0.3, 0.4], [0.5, 0.6, 0.7], [0.8, 0.9, 1.0]])\n}\nalphas = [0.25, 0.75]\ncmap_name = 'viridis'\nfigsize = (10, 10)\noutput_file = 'test_output.png'\n```\n\n**Output:**\nThe function `plot_all(fd_matrices, alphas, cmap_name, figsize, output_file)` will generate a plot saved as `test_output.png` with two subplots for the given `fd_matrices` and `alphas`, using the 'viridis' colormap and a figure size of 10x10 inches. The first subplot will display the matrix for alpha = 0.25, and the second subplot will display the matrix for alpha = 0.75. The axes will be labeled accordingly, and the aspect ratio will be equal.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport numpy as np\n\n# main code\ndef plot_all(fd_matrices, alphas, cmap_name, figsize, output_file='output.png'):\n    fig = plt.figure(figsize=figsize)\n    gs1 = gridspec.GridSpec(2, len(alphas))\n    gs1.update(wspace=0.05, hspace=0.05)\n\n    for i, alpha in enumerate(alphas):\n        ax1 = plt.subplot(gs1[i])\n        ax1.set_aspect('equal')\n        ax1.matshow(fd_matrices[alpha], vmin=0.0, vmax=1.0, cmap=plt.get_cmap(cmap_name) if cmap_name else None)\n        ax1.set_title(f'$\\\\phi={alpha}$', y=1.35)\n\n        if i == 0:\n            ax1.set_ylabel('Movie')\n            ax1.tick_params(labelbottom=False, labeltop=True, labelleft=True, labelright=False, labelsize=9)\n            yticks = ax1.get_yticks()\n            ax1.set_yticks(yticks)\n            ax1.set_yticklabels([int(x) + 1 for x in yticks])\n        else:\n            ax1.tick_params(labelbottom=False, labeltop=True, labelleft=False, labelright=False, labelsize=9)\n\n        ax1.xaxis.set_label_position('bottom')\n        ax1.yaxis.set_label_position('left')\n        xticks = np.arange(*ax1.get_xlim(), step=10)\n        ax1.set_xticks(xticks)\n        ax1.set_xticklabels([int(x) + 1 for x in xticks])\n\n        ax2 = plt.subplot(gs1[i + len(alphas)])\n        ax2.set_aspect('equal')\n        ax2.set_xlabel('Position')\n        xticks = np.arange(*ax2.get_xlim(), step=10)\n        ax2.set_xticks(xticks)\n        ax2.set_xticklabels([int(x) + 1 for x in xticks])\n\n        if i == 0:\n            ax2.set_ylabel('Movie')\n            ax2.tick_params(labelbottom=True, labeltop=False, labelleft=True, labelright=False, labelsize=9)\n            yticks = ax2.get_yticks()\n            ax2.set_yticks(yticks)\n            ax2.set_yticklabels([int(x) + 1 for x in yticks])\n        else:\n            ax2.tick_params(labelbottom=True, labeltop=False, labelleft=False, labelright=False, labelsize=9)\n\n        ax2.xaxis.set_label_position('bottom')\n        ax2.yaxis.set_label_position('left')\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_movies = random.randint(5, 20)\n        num_positions = random.randint(5, 20)\n        alphas = [round(random.uniform(0.1, 1.0), 2) for _ in range(random.randint(2, 5))]\n        fd_matrices = {alpha: np.random.rand(num_movies, num_positions) for alpha in alphas}\n        cmap_name = random.choice(['viridis', 'plasma', 'inferno', 'cividis', 'magma', None])\n        figsize = (random.uniform(8, 15), random.uniform(8, 15))\n        test_cases.append((fd_matrices, alphas, cmap_name, figsize))\n    return test_cases"}
{"problem_id": "matplotlib_33", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of matrices representing some data related to movies. The function will generate a grid of subplots, where each subplot corresponds to a specific parameter (alpha) and displays a matrix using a color map. The function should also handle the formatting of the axes and save the resulting figure to a file.\n\nFunction signature:\n```python\ndef plot_all(fd_matrices, alphas, cmap_name, figsize, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant `1.0` is used as the maximum value for the color mapping in the matrix display.\n- The constant `0.0` is used as the minimum value for the color mapping in the matrix display.\n- The constant `10` is used to set the ticks on the x-axis of the subplots.\n\nInput format:\n- `fd_matrices`: A dictionary where keys are alpha values and values are 2D matrices (numpy arrays).\n- `alphas`: A list of alpha values corresponding to the keys in `fd_matrices`.\n- `cmap_name`: A string representing the name of the color map to be used for displaying the matrices.\n- `figsize`: A tuple representing the size of the figure (width, height).\n- `output_file`: A string representing the filename to save the output figure.\n\nOutput format:\n- The function does not return any value. It saves a visual representation of the matrices to the specified output file.\n\n**Input:**\n```python\nfd_matrices = {\n    0.25: np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]),\n    0.75: np.array([[0.2, 0.3, 0.4], [0.5, 0.6, 0.7], [0.8, 0.9, 1.0]])\n}\nalphas = [0.25, 0.75]\ncmap_name = 'viridis'\nfigsize = (10, 10)\noutput_file = 'test_output.png'\n```\n\n**Output:**\n```python\n# A plot is generated and saved as 'test_output.png' with the following characteristics:\n# - Two rows of subplots corresponding to alphas 0.25 and 0.75.\n# - Each subplot displays a matrix with values ranging from 0.0 to 1.0 using the 'viridis' colormap.\n# - The first subplot has a ylabel 'Movie' and x-ticks labeled as [1, 2, 3].\n# - The second subplot has an xlabel 'Position' and y-ticks labeled as [1, 2, 3].\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport numpy as np\n\n# main code\ndef plot_all(fd_matrices, alphas, cmap_name, figsize, output_file='output.png'):\n    fig = plt.figure(figsize=figsize)\n    gs1 = gridspec.GridSpec(2, len(alphas))\n    gs1.update(wspace=0.05, hspace=0.05)\n\n    for i, alpha in enumerate(alphas):\n        ax1 = plt.subplot(gs1[i])\n        ax1.set_aspect('equal')\n        ax1.matshow(fd_matrices[alpha], vmin=0.0, vmax=1.0, cmap=plt.get_cmap(cmap_name) if cmap_name else None)\n        ax1.set_title(f'$\\\\phi={alpha}$', y=1.35)\n\n        if i == 0:\n            ax1.set_ylabel('Movie')\n            ax1.tick_params(labelbottom=False, labeltop=True, labelleft=True, labelright=False, labelsize=9)\n            locs = ax1.yaxis.get_ticklocs()\n            ax1.yaxis.set_ticks(locs)\n            ax1.yaxis.set_ticklabels([int(x) + 1 for x in locs])\n        else:\n            ax1.tick_params(labelbottom=False, labeltop=True, labelleft=False, labelright=False, labelsize=9)\n\n        ax1.xaxis.set_label_position('bottom')\n        ax1.yaxis.set_label_position('left')\n        start, end = ax1.get_xlim()\n        ax1.xaxis.set_ticks(np.arange(start, end, 10))\n        locs = ax1.xaxis.get_ticklocs()\n        ax1.xaxis.set_ticklabels([int(x) + 1 for x in locs])\n\n        ax2 = plt.subplot(gs1[i + len(alphas)])\n        ax2.set_aspect('equal')\n        ax2.set_xlabel('Position')\n        start, end = ax2.get_xlim()\n        ax2.xaxis.set_ticks(np.arange(start, end, 10))\n        locs = ax2.xaxis.get_ticklocs()\n        ax2.xaxis.set_ticklabels([int(x) + 1 for x in locs])\n\n        if i == 0:\n            ax2.set_ylabel('Movie')\n            ax2.tick_params(labelbottom=True, labeltop=False, labelleft=True, labelright=False, labelsize=9)\n            locs = ax2.yaxis.get_ticklocs()\n            ax2.yaxis.set_ticks(locs)\n            ax2.yaxis.set_ticklabels([int(x) + 1 for x in locs])\n        else:\n            ax2.tick_params(labelbottom=True, labeltop=False, labelleft=False, labelright=False, labelsize=9)\n\n        ax2.xaxis.set_label_position('bottom')\n        ax2.yaxis.set_label_position('left')\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_movies = random.randint(5, 20)\n        num_positions = random.randint(5, 20)\n        alphas = [round(random.uniform(0.1, 1.0), 2) for _ in range(random.randint(2, 5))]\n        fd_matrices = {alpha: np.random.rand(num_movies, num_positions) for alpha in alphas}\n        cmap_name = random.choice(['viridis', 'plasma', 'inferno', 'cividis', 'magma', None])\n        figsize = (random.uniform(8, 15), random.uniform(8, 15))\n        test_cases.append((fd_matrices, alphas, cmap_name, figsize))\n\n    return test_cases"}
{"problem_id": "matplotlib_34", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes spatial data using contour plots or image displays. The function should allow the user to choose between these two visualization methods and save the resulting plot to a specified file.\n\nFunction signature:\n```python\ndef spatplot(data, contour, outpath='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- The function takes a 2D array `data`, a boolean `contour`, and an optional string `outpath`.\n\nOutput format:\n- The function saves a visualization of the spatial data to a file specified by `outpath`. The output is a graphical representation of the data, either as a contour plot or an image display, depending on the value of `contour`.\n\nInput:\n```python\ndata = np.array([[0.1, 0.2, 0.3], \n                 [0.4, 0.5, 0.6], \n                 [0.7, 0.8, 0.9]])\ncontour = True\n```\n\nOutput:\nThe function `spatplot(data, contour)` generates a contour plot of the provided data and saves it as 'output.png'. The plot will have labeled axes and a color bar indicating the values represented in the contour.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef spatplot(data, contour, outpath='output.png'):\n    fig = plt.figure()\n\n    if contour:\n        im = plt.contour(data)\n    else:\n        im = plt.imshow(data, origin='lower', extent=(0, len(data), 0, len(data[0])))\n\n    ax = im.axes\n    ax.set_xlabel('Detector x axis pixel')\n    ax.set_ylabel('Detector y axis pixel')\n    fig.colorbar(mappable=im, shrink=0.75)\n    ax.set_title('Spatial Map')\n\n    plt.savefig(outpath)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(10, 100)\n        cols = random.randint(10, 100)\n        data = np.random.rand(rows, cols)\n        contour = random.choice([True, False])\n        test_cases.append((data, contour))\n\n    return test_cases"}
{"problem_id": "matplotlib_35", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes reward data over a series of iterations. The function will generate a plot of rewards based on the provided data and save the plot as an image file.\n\nFunction signature:\n```python\ndef plot_reward(iteration: int, iterations: int, rewards: list, output_file: str = 'output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- The function accepts:\n  - An integer `iteration`\n  - An integer `iterations`\n  - A list of lists `rewards`\n  - An optional string `output_file`\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot image to the specified output file.\n\nInput:\n```python\niteration = 1\niterations = 3\nrewards = [\n    np.array([0.1, 0.2, 0.3]),\n    np.array([0.4, 0.5, 0.6, 0.7]),\n    np.array([0.8, 0.9])\n]\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing the rewards for the second iteration (index 1) across 4 steps.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_reward(iteration, iterations, rewards, output_file='output.png'):\n    if iteration == -1:\n        for i in range(iterations):\n            plt.plot(np.arange(0, len(rewards[i])), rewards[i])\n    else:\n        plt.plot(np.arange(0, len(rewards[iteration])), rewards[iteration])\n\n    plt.ylabel('Reward')\n    plt.xlabel('Steps')\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        iterations = random.randint(1, 10)\n        steps = [random.randint(5, 20) for _ in range(iterations)]\n        rewards = [np.random.random(steps[i]) for i in range(iterations)]\n        iteration = random.choice([-1] + list(range(iterations)))\n        test_cases.append((iteration, iterations, rewards))\n\n    return test_cases"}
{"problem_id": "matplotlib_36", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes seismic data using a wiggle plot. The function will take in a 2D array of seismic data and generate a plot that represents the amplitude of the seismic waves over time. The plot will allow for customization in terms of trace skipping, gain adjustment, color options, and output file naming.\n\nFunction signature:\n```python\ndef plot_wiggle(data, zz, skip, gain, alpha, black, output_file='output.png'):\n```\n\n### Constants:\n- The default output file name is set to `'output.png'`.\n\n### Input Format:\n- The function accepts a 2D NumPy array for `data`, a float for `zz`, an integer for `skip`, a float for `gain`, a float for `alpha`, a boolean for `black`, and an optional string for `output_file`.\n\n### Output Format:\n- The function does not return any value but saves a plot as an image file with the name specified in `output_file`.\n\nInput:\n```python\ndata = np.array([[0.1, -0.2, 0.3], [0.4, -0.5, 0.6], [0.7, -0.8, 0.9], [0.1, 0.2, 0.3]])\nzz = 1.5\nskip = 1\ngain = 2.0\nalpha = 0.5\nblack = False\n```\n\nOutput:\n```plaintext\nThe function will generate a plot saved as 'output.png' with the specified parameters.\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_wiggle(data, zz, skip, gain, alpha, black, output_file='output.png'):\n    n_samples, n_traces = data.shape\n    t = np.arange(n_samples)\n    plt.figure(figsize=(9.6, 6))\n    for i in range(0, n_traces, skip):\n        trace = gain * data[:, i] / np.max(np.abs(data))\n        plt.plot(i + trace, t, color='k', linewidth=0.5)\n\n        if not black:\n            plt.fill_betweenx(t, trace + i, i, where=trace + i > i, facecolor=[0.6, 0.6, 1.0], linewidth=0)\n            plt.fill_betweenx(t, trace + i, i, where=trace + i < i, facecolor=[1.0, 0.7, 0.7], linewidth=0)\n        else:\n            plt.fill_betweenx(t, trace + i, i, where=trace + i > i, facecolor='black', linewidth=0, alpha=alpha)\n    locs, labels = plt.yticks()\n    plt.yticks(locs, [n * zz for n in locs])\n    plt.grid()\n    plt.gca().invert_yaxis()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(10, 100)\n        n_traces = np.random.randint(1, 10)\n        data = np.random.randn(n_samples, n_traces)\n\n        zz = np.random.uniform(0.5, 2.0)\n        skip = np.random.randint(1, 5)\n        gain = np.random.uniform(0.5, 3.0)\n        alpha = np.random.uniform(0.1, 1.0)\n        black = np.random.choice([True, False])\n\n        test_case = (data, zz, skip, gain, alpha, black)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "matplotlib_37", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a semi-logarithmic plot using the Matplotlib library in Python. The function should allow for the plotting of two sets of data on the same graph, with the option to include a legend and save the plot to a file.\n\nFunction signature:\n```python\ndef semilogy(x_vals, y_vals, x_label, y_label, x2_vals, y2_vals, legend, figsize, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The function accepts the following parameters:\n  - `x_vals`: List or array of x-values for the first dataset.\n  - `y_vals`: List or array of y-values for the first dataset.\n  - `x_label`: String for the x-axis label.\n  - `y_label`: String for the y-axis label.\n  - `x2_vals`: List or array of x-values for the second dataset (can be None).\n  - `y2_vals`: List or array of y-values for the second dataset (can be None).\n  - `legend`: List of strings for the legend labels (can be None).\n  - `figsize`: Tuple for the figure size (width, height).\n  - `output_file`: String for the output filename (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It generates and saves a semi-logarithmic plot to the specified output file.\n\nInput:\n```python\nx_vals = np.logspace(0.1, 3, 100)\ny_vals = np.random.rand(100) * 100\nx2_vals = np.logspace(0.1, 3, 100)\ny2_vals = np.random.rand(100) * 100\nlegend = ['Curve 1', 'Curve 2']\nfigsize = (6, 4)\n```\n\nOutput:\n```python\n# This will generate a plot saved as 'output.png' with a semilogarithmic scale on the y-axis.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef semilogy(x_vals, y_vals, x_label, y_label, x2_vals, y2_vals, legend, figsize, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.xlabel(x_label)\n    plt.ylabel(y_label)\n    plt.semilogy(x_vals, y_vals)\n    if x2_vals is not None and y2_vals is not None:\n        plt.semilogy(x2_vals, y2_vals, linestyle=':')\n        if legend is not None:\n            plt.legend(legend)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        x_vals = np.logspace(0.1, 3, 100)\n        y_vals = np.random.rand(100) * 100\n        if np.random.rand() > 0.5:\n            x2_vals = np.logspace(0.1, 3, 100)\n            y2_vals = np.random.rand(100) * 100\n        else:\n            x2_vals = None\n            y2_vals = None\n        legend = None\n        if x2_vals is not None and y2_vals is not None:\n            legend = ['Curve 1', 'Curve 2']\n        test_cases.append((x_vals, y_vals, 'X Axis', 'Y Axis', x2_vals, y2_vals, legend, (6, 4)))\n    return test_cases"}
{"problem_id": "matplotlib_38", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes multiple datasets on a single plot using Matplotlib. The function should allow customization of various plot attributes, including axis labels, title, and output file name. \n\nFunction Signature:\n```python\ndef show(x, y, label, title, xdes, ydes, x_scale, output_file='output.png'):\n```\n\n### Constants:\n- The function uses a predefined list of colors for the plot lines, which includes: \n  ```python\n  colors = ['tab:green', 'tab:orange', 'tab:blue', 'tab:red', 'tab:cyan', 'tab:gray', 'tab:brown', 'tab:purple', 'tab:olive', 'tab:pink']\n  ```\n\n### Input Format:\n- `x`: A list of lists, where each inner list contains the x-coordinates for a dataset.\n- `y`: A list of lists, where each inner list contains the y-coordinates for a dataset.\n- `label`: A list of strings representing the labels for each dataset.\n- `title`: A string representing the title of the plot.\n- `xdes`: A string representing the description for the x-axis.\n- `ydes`: A string representing the description for the y-axis.\n- `x_scale`: A string representing the scale type for the x-axis (e.g., 'linear', 'log').\n- `output_file`: A string representing the name of the output file (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file in the specified format.\n\n**Input:**\n```python\nx = [np.linspace(0, 5, 10), np.linspace(0, 5, 15)]\ny = [np.sin(x_i) + np.random.normal(0, 0.1, len(x_i)) for x_i in x]\nlabel = ['Series A', 'Series B']\ntitle = 'Sample Plot Title'\nxdes = 'X Axis Description'\nydes = 'Y Axis Description'\nx_scale = 'linear'\n```\n\n**Output:**\n```python\n# The output will be a saved plot file named 'output.png' in the current directory.\n# The plot will display two lines representing 'Series A' and 'Series B' with the specified labels, title, and axis descriptions.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef show(x, y, label, title, xdes, ydes, x_scale, output_file='output.png'):\n    plt.figure(figsize=(10, 8))\n\n    colors = ['tab:green', 'tab:orange', 'tab:blue', 'tab:red', 'tab:cyan', 'tab:gray', 'tab:brown', 'tab:purple',\n              'tab:olive', 'tab:pink']\n\n    for i in range(len(x)):\n        plt.plot(x[i], y[i], color=colors[i % len(colors)], label=label[i] if i < len(label) else None, linewidth=1.5)\n\n    plt.gca().get_xaxis().get_major_formatter().set_scientific(False)\n    plt.gca().get_yaxis().get_major_formatter().set_scientific(False)\n\n    plt.xlabel(xdes, fontsize=24)\n    plt.ylabel(ydes, fontsize=24)\n    plt.title(title, fontsize=24)\n\n    plt.xticks(fontsize=24)\n    plt.yticks(fontsize=24)\n\n    plt.legend(loc='lower right', fontsize=16)\n    plt.xscale(x_scale)\n\n    plt.savefig(output_file, bbox_inches='tight', pad_inches=0)\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_series = random.randint(1, 10)\n        x = [np.linspace(0, random.uniform(1, 10), random.randint(5, 20)) for _ in range(num_series)]\n        y = [np.sin(x_i) + np.random.normal(0, 0.1, len(x_i)) for x_i in x]\n        label = [''.join(random.choices(string.ascii_letters, k=random.randint(3, 8))) for _ in range(num_series)]\n        title = ''.join(random.choices(string.ascii_letters + ' ', k=20))\n        xdes = ''.join(random.choices(string.ascii_letters + ' ', k=10))\n        ydes = ''.join(random.choices(string.ascii_letters + ' ', k=10))\n        x_scale = random.choice(['linear', 'log'])\n        test_cases.append((x, y, label, title, xdes, ydes, x_scale))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_39", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes electrocardiogram (ECG) data. The function will take in raw ECG data, a sampling frequency, a gain factor, and an optional output file name to save the generated plot. The function will process the data and generate a time-series plot of the ECG signal, applying the specified gain and formatting the plot for clarity.\n\nFunction signature:\n```python\ndef plt_ecg(data, fs, gain, output_file='output.png'):\n```\n\n### Constants:\n- The default output file name is set to `'output.png'`.\n\n### Input Format:\n- The function accepts three required parameters: `data`, `fs`, and `gain`, along with an optional parameter `output_file`.\n\n### Output Format:\n- The function does not return any value but saves a plot of the ECG data to the specified output file.\n\nInput:\n```python\ndata = [0.5, -0.2, 0.3, -1.0, 0.7, -0.5, 1.2, -0.8, 0.0, 0.4]\nfs = 250\ngain = 1.0\n```\n\nOutput:\n```plaintext\nOutput file: 'output.png' (a plot of the ECG signal will be saved as output.png)\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n# main code\ndef plt_ecg(data, fs, gain, output_file='output.png'):\n    x = [i / fs for i in range(len(data))]\n    y = [val / gain for val in data]\n\n    plt.figure(figsize=(len(data) * 25 / (fs * 14), 4))\n\n    plt.xlabel('Time: s', fontsize=14)\n    plt.ylabel('Voltage: mV', fontsize=14)\n    plt.margins(x=0)\n\n    ax = plt.gca()\n    ax.xaxis.set_major_locator(plt.MultipleLocator(0.2))\n    ax.xaxis.set_minor_locator(plt.MultipleLocator(0.04))\n    ax.yaxis.set_major_locator(plt.MultipleLocator(0.5))\n    ax.yaxis.set_minor_locator(plt.MultipleLocator(0.1))\n    ax.grid(which='major', axis='both', linewidth=0.75, linestyle='-', color='r')\n    ax.grid(which='minor', axis='both', linewidth=0.25, linestyle='-', color='r')\n\n    plt.ylim([-2.5, 2.5])\n    plt.plot(x, y, 'black', linewidth=0.9)\n\n    plt.savefig(output_file)\n\n", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = random.randint(100, 500)\n        data = np.random.randn(data_length).tolist()\n        fs = random.randint(100, 1000)\n        gain = random.uniform(0.5, 5.0)\n        test_cases.append((data, fs, gain))\n    return test_cases"}
{"problem_id": "matplotlib_40", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes data by plotting it along with specified peak locations and their corresponding values. The function should generate a plot and save it as an image file.\n\nFunction signature:\n```python\ndef plot_peaks(data, locs, vals, title, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the figure size, which is set to (13, 3).\n\nInput format:\n- `data`: A list or array of numerical values representing the data to be plotted.\n- `locs`: A list or array of indices where the peaks are located in the `data`.\n- `vals`: A list or array of numerical values representing the heights of the peaks at the specified locations.\n- `title`: A string representing the title of the plot.\n- `output_file`: (optional) A string representing the filename to save the plot image.\n\nOutput format:\n- The function does not return any value. Instead, it saves the plot as an image file in the specified format (default is PNG).\n\nInput:\n```python\ndata = np.array([-0.234, 0.567, 1.234, -0.456, 0.789, -1.234, 0.345, 0.678, -0.123, 0.456])\nlocs = np.array([2, 5, 8])\nvals = np.array([1.234, -1.234, 0.678])\ntitle = 'Test Case 1'\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' with the specified data, peaks at locations [2, 5, 8], and title 'Test Case 1'.\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n# main code\ndef plot_peaks(data, locs, vals, title, output_file='output.png'):\n    plt.figure(figsize=(13, 3))\n    plt.plot(data)\n    plt.plot(locs, vals, 'r*')\n    plt.title(title)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = np.random.randint(50, 200)\n        data = np.random.randn(data_length)\n        num_peaks = np.random.randint(5, 20)\n        locs = np.sort(np.random.choice(data_length, num_peaks, replace=False))\n        vals = np.random.randn(num_peaks)\n        test_cases.append((data, locs, vals, f'Test Case {_ + 1}'))\n    return test_cases"}
{"problem_id": "matplotlib_41", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes two sets of data using line plots. The function will generate a single image file containing two vertically stacked plots, each representing one of the data sets. The function should also allow the user to specify titles for each plot and the name of the output file.\n\nFunction Signature:\n```python\ndef plot_simple_comp(data1, data2, title1, title2, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `data1`: A list or array-like structure containing numerical values for the first plot.\n- `data2`: A list or array-like structure containing numerical values for the second plot.\n- `title1`: A string representing the title for the first plot.\n- `title2`: A string representing the title for the second plot.\n- `output_file`: An optional string representing the name of the output file (default is 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it generates and saves a PNG image file containing the two plots.\n\nInput:\n```python\ndata1 = np.array([0.5, -1.2, 0.3, 1.5, -0.7])\ndata2 = np.array([-0.4, 0.8, -1.1, 0.6, 1.0])\ntitle1 = \"Plot A\"\ntitle2 = \"Plot B\"\n```\n\nOutput:\n```plaintext\nA plot is generated with two subplots:\n1. The first subplot titled \"Plot A\" displays the data from `data1`.\n2. The second subplot titled \"Plot B\" displays the data from `data2`.\nThe output file is saved as 'output.png'.\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n\n# main code\ndef plot_simple_comp(data1, data2, title1, title2, output_file='output.png'):\n    plt.figure(figsize=(12, 4))\n    plt.subplot(211)\n    plt.plot(data1)\n    plt.title(title1)\n    plt.subplot(212)\n    plt.plot(data2)\n    plt.title(title2)\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        data1_length = np.random.randint(5, 51)\n        data2_length = np.random.randint(5, 51)\n\n        data1 = np.random.randn(data1_length)\n        data2 = np.random.randn(data2_length)\n        title1 = f\"Plot {np.random.randint(1, 100)}\"\n        title2 = f\"Plot {np.random.randint(101, 200)}\"\n        test_cases.append((data1, data2, title1, title2))\n\n    return test_cases"}
{"problem_id": "matplotlib_42", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a dataset by plotting it along with specific points and threshold lines. The function will take in a dataset and several parameters to generate a plot and save it as an image file.\n\nFunction Signature:\n```python\ndef plot_peak_dot_th1_th2(data, x, y, th1, th2, output_file='output.png'):\n```\n\nConstant Used:\n- The constant used in the main code is the default value for `output_file`, which is set to `'output.png'`.\n\nInput Format:\n- `data`: A list or array of numerical values representing the main dataset to be plotted.\n- `x`: A list or array of x-coordinates for the points to be marked on the plot.\n- `y`: A list or array of y-coordinates for the points to be marked on the plot.\n- `th1`: A list or array of y-values representing the first threshold line to be plotted.\n- `th2`: A list or array of y-values representing the second threshold line to be plotted.\n- `output_file`: A string representing the name of the output file where the plot will be saved (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file in the specified format.\n\nInput:\n```python\ndata = np.array([ 0.49671415, -0.1382643 ,  0.64768854,  1.52302986, -0.23415337,\n                  -0.23413696,  1.57921282,  0.76743473, -0.46947439,  0.54256004,\n                  -0.46341769, -0.46572975,  0.24196227, -1.91328024, -1.72491783,\n                  -0.56228753, -1.01283112,  0.31424733, -0.90802408, -1.4123037 ,\n                   1.46564877, -0.2257763 ,  0.0675282 , -1.42474819, -0.54438272,\n                   0.11092259, -1.15099358,  0.37569802, -0.60063869, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,\n                   0.09707755, -0.49922525,  0.96864499, -0.70205309, -0.32766215,\n                   -0.39210815, -1.46351495,  0.29612028, -0.18565898, -0.14542924,\n                   0.15792128,  0.07674347, -0.40178094, -0.60021687, -0.29169375,\n                   0.60170661,  1.85227818, -0.01349722, -1.05771093,  0.82254491,\n                   0.2088636 , -1.95967012, -1.32818605,  0.19686124,  0.73846658,\n                   0.17136828, -0.11564828, -0.3011037 , -1.47852199, -0.71984421,\n                   0.46063877,  1.05712223,  0.34361829, -1.76304016,  0.32408397,\n                   -0.38508228, -0.676922  ,  0.61167629,  1.03099952,  0.93128012,", "ground_truth_code": "from matplotlib import pyplot as plt\n\n# main code\ndef plot_peak_dot_th1_th2(data, x, y, th1, th2, output_file='output.png'):\n    plt.figure(figsize=(12, 4))\n    plt.plot(data)\n    plt.plot(x, y, '*r')\n    plt.plot(x, th1)\n    plt.plot(x, th2)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        data_length = np.random.randint(50, 200)\n        data = np.random.randn(data_length)\n        peak_count = np.random.randint(1, 10)\n        x = np.sort(np.random.choice(data_length, peak_count, replace=False))\n        y = data[x] + np.random.randn(peak_count) * 0.5\n        th1 = np.random.uniform(np.min(data), np.max(data), peak_count)\n        th2 = np.random.uniform(np.min(data), np.max(data), peak_count)\n        test_cases.append((data, x, y, th1, th2))\n\n    return test_cases"}
{"problem_id": "matplotlib_43", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes data points and specific thresholds on a plot. The function will take in a dataset and several parameters to generate a graphical representation, which will be saved as an image file.\n\nFunction signature:\n```python\ndef plot_peak_dot_llv_rlv(data, x, y, LLV, RLV, th1, th2, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The figure size for the plot is set to a constant value of (12, 4).\n\nInput format:\n- `data`: A list or array of numerical values representing the main dataset to be plotted.\n- `x`: A list or array of x-coordinates for the points to be highlighted.\n- `y`: A list or array of y-coordinates for the points to be highlighted.\n- `LLV`: A list or array of numerical values representing the Lowest Low Values to be plotted.\n- `RLV`: A list or array of numerical values representing the Relative Low Values to be plotted.\n- `th1`: A list or array of threshold values to be plotted against `x`.\n- `th2`: A list or array of threshold values to be plotted against `x`.\n- `output_file`: A string representing the name of the output file where the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file in the specified format.\n\nInput:\n```python\ndata = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\nx = [2, 5, 7]\ny = [0.25, 0.75, 0.5]\nLLV = [0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9]\nRLV = [0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0]\nth1 = [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\nth2 = [1.0, 0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1]\n```\n\nOutput:\n```python\n# The output will be a saved plot as 'output.png' which visually represents:\n# - The data as a line plot\n# - The points (x, y) as red stars\n# - The LLV and RLV as line plots\n# - The thresholds th1 and th2 as line plots\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n\n# main code\ndef plot_peak_dot_llv_rlv(data, x, y, LLV, RLV, th1, th2, output_file='output.png'):\n    plt.figure(figsize=(12, 4))\n    plt.plot(data)\n    plt.plot(x, y, '*r')\n    plt.plot(LLV)\n    plt.plot(RLV)\n\n    plt.plot(x, th1[:len(x)])\n    plt.plot(x, th2[:len(x)])\n    plt.savefig(output_file)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = np.random.randint(50, 500)\n        data = np.random.rand(data_length)\n\n        x = np.random.randint(0, data_length, size=np.random.randint(5, 20))\n        y = np.random.rand(len(x))\n\n        LLV = np.random.rand(data_length)\n        RLV = np.random.rand(data_length)\n\n        th1 = np.random.rand(data_length)\n        th2 = np.random.rand(data_length)\n        test_cases.append((data, x, y, LLV, RLV, th1, th2))\n\n    return test_cases"}
{"problem_id": "matplotlib_44", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a line plot from a series of stochastic profiles representing power output over time. The function should save the plot as an image file.\n\nFunction signature:\n```python\ndef Profile_series_plot(stoch_profiles_series, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- The function accepts a list or array of numerical values representing power outputs over time as `stoch_profiles_series`.\n- An optional string parameter `output_file` that specifies the name of the output image file.\n\nOutput format:\n- The function does not return any value. Instead, it saves a line plot as an image file in the specified format (default is PNG).\n\n```python\nInput: [23.5, 67.8, 45.2, 12.1, 89.0, 34.5, 76.3, 54.2, 10.0, 99.9]\nOutput: 'output.png' (a plot saved as output.png showing the power series)\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef Profile_series_plot(stoch_profiles_series, output_file='output.png'):\n    plt.figure(figsize=(10, 5))\n    plt.plot(np.arange(len(stoch_profiles_series)), stoch_profiles_series)\n    plt.ylabel('Power (W)')\n    plt.ylim(ymin=0)\n    plt.margins(x=0)\n    plt.margins(y=0)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        series_length = random.randint(10, 100)\n        stoch_profiles_series = np.random.uniform(0, 100, series_length).tolist()\n        test_cases.append(stoch_profiles_series)\n    return test_cases\n"}
{"problem_id": "matplotlib_45", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of usage profiles over time. The function will take in a list of numerical values representing the usage data and generate a line plot. The plot will be saved as an image file.\n\nFunction signature:\n```python\ndef Usage_series_plot(stoch_profiles_series, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The function accepts a list or array of numerical values as the first argument (`stoch_profiles_series`).\n- The second argument (`output_file`) is an optional string that specifies the filename for the saved plot.\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a line plot as an image file in the specified format.\n\n```python\nInput: np.array([0.1, 0.5, 0.3, 0.7, 0.2])\nOutput: 'output.png' (a plot saved as output.png showing the usage series)\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef Usage_series_plot(stoch_profiles_series, output_file='output.png'):\n    plt.figure(figsize=(10, 5))\n    plt.plot(np.arange(len(stoch_profiles_series)), stoch_profiles_series)\n    plt.ylabel('Usage ')\n    plt.ylim(ymin=0)\n    plt.margins(x=0)\n    plt.margins(y=0)\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(1, 100)\n        stoch_profiles_series = np.random.random(length)\n        test_cases.append(stoch_profiles_series)\n    return test_cases"}
{"problem_id": "matplotlib_46", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a scatter plot based on two input datasets, `x` and `y`. The function should visualize the relationship between these two datasets using a kernel density estimate (KDE) to color the points based on their density. The function will also allow customization of the plot's labels, title, and output file path.\n\nFunction Signature:\n```python\ndef create_kde(x, y, xlabel, ylabel, sample_size, text, output_path='output.png'):\n```\n\nConstants:\n- The constant used in the main code is `output_path`, which defaults to `'output.png'`.\n\nInput Format:\n- The function accepts two 1D array-like structures for `x` and `y`, two strings for `xlabel` and `ylabel`, an integer for `sample_size`, a string for `text`, and an optional string for `output_path`.\n\nOutput Format:\n- The function does not return any value but saves a scatter plot image to the specified output path.\n\nInput:\n```python\nx = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\ny = np.array([0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0])\nxlabel = \"X-axis label 42\"\nylabel = \"Y-axis label 17\"\nsample_size = 5\ntext = \"Text message 23\"\n```\n\nOutput:\n```python\n# The output will be a saved file named 'output.png' containing a scatter plot\n# with the specified labels, text, and a KDE representation of the points.\n# The plot will show a diagonal line from (0,0) to (1,1) and the points colored\n# according to their density.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import gaussian_kde\n\n\n# main code\ndef create_kde(x, y, xlabel, ylabel, sample_size, text, output_path='output.png'):\n\n    if len(x) > sample_size:\n        sample = np.random.choice(len(x), size=sample_size, replace=False)\n        x = x[sample]\n        y = y[sample]\n\n    xy = np.vstack([y, x])\n    z = gaussian_kde(xy)(xy)\n\n    idx = z.argsort()\n    x, y, z = x[idx], y[idx], z[idx]\n\n    fig, ax = plt.subplots()\n    scatter = ax.scatter(x, y, c=z, s=10)\n    ax.set_title(f'{ylabel} vs {xlabel}')\n    ax.set_xlabel(xlabel)\n    ax.set_ylabel(ylabel)\n    ax.plot([0, 1], [0, 1], color='black', linestyle='--')\n    ax.margins(x=0, y=0)\n\n    if text:\n        ax.text(0.5, 0, str(text), ha='center', va='bottom')\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        sample_size = np.random.randint(50, 500)\n        x_length = np.random.randint(sample_size, 1000)\n        y_length = x_length\n        x = np.random.rand(x_length)\n        y = np.random.rand(y_length)\n        xlabel = f\"X-axis label {np.random.randint(1, 100)}\"\n        ylabel = f\"Y-axis label {np.random.randint(1, 100)}\"\n        text = f\"Text message {np.random.randint(1, 100)}\"\n        test_cases.append((x, y, xlabel, ylabel, sample_size, text))\n\n    return test_cases"}
{"problem_id": "matplotlib_47", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a profile cloud plot using the Matplotlib library. The function will visualize multiple stochastic profiles along with their average profile over a specified time period. The function signature is as follows:\n\n```python\ndef Profile_cloud_plot(stoch_profiles, stoch_profiles_avg, figure_size, line_colors, xticks, xtick_labels, output_filename='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `1440`, which represents the number of time intervals (in minutes) for a full day.\n\n### Input and Output Format:\n- **Input**: The function takes in the following parameters:\n  - `stoch_profiles`: List of lists of floats (power values).\n  - `stoch_profiles_avg`: List of floats (average power values).\n  - `figure_size`: Tuple of two integers (width, height).\n  - `line_colors`: List of strings (color codes).\n  - `xticks`: List of integers (positions for x-ticks).\n  - `xtick_labels`: List of strings (labels for x-ticks).\n  - `output_filename`: String (filename for the output image).\n\n- **Output**: The function does not return any value but saves a plot image to the specified `output_filename`.\n\n**Input:**\n```python\nstoch_profiles = [\n    np.array([0.1, 0.2, 0.3, 0.4, 0.5] * 288),  # 1440 values\n    np.array([0.2, 0.3, 0.4, 0.5, 0.6] * 288)   # 1440 values\n]\nstoch_profiles_avg = np.array([0.15] * 1440)  # Average profile\nfigure_size = (8, 6)\nline_colors = ['blue', 'red']\nxticks = [0, 120, 240, 360, 480, 600, 720, 840, 960, 1080, 1200, 1320, 1440]\nxtick_labels = ['0:00', '2:00', '4:00', '6:00', '8:00', '10:00', '12:00', '14:00', '16:00', '18:00', '20:00', '22:00', '24:00']\n```\n\n**Output:**\n```python\n# The function will generate a plot and save it as 'output.png'.\n# The output is a side effect (the saved plot) rather than a return value.\n``` \n\nNote: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef Profile_cloud_plot(stoch_profiles, stoch_profiles_avg, figure_size, line_colors, xticks, xtick_labels, output_filename='output.png'):\n    fig, ax = plt.subplots(figsize=figure_size)\n    for n in stoch_profiles:\n        ax.plot(np.arange(1440), n, color=line_colors[0])\n\n    ax.plot(np.arange(1440), stoch_profiles_avg, color=line_colors[1])\n    ax.set_xlabel('Time (hours)')\n    ax.set_ylabel('Power (W)')\n    ax.set_ylim(bottom=0)\n    ax.set_xticks(xticks)\n    ax.set_xticklabels(xtick_labels)\n    plt.savefig(output_filename)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_profiles = random.randint(1, 5)\n        stoch_profiles = [np.random.rand(1440) for _ in range(num_profiles)]\n\n        stoch_profiles_avg = np.random.rand(1440)\n\n        figure_size = (random.randint(6, 12), random.randint(6, 12))\n\n        line_colors = [random.choice(['blue', 'red', 'green', 'black', 'yellow', 'purple']) for _ in range(2)]\n\n        xticks = sorted(random.sample(range(0, 1440, 10), random.randint(5, 15)))\n\n        xtick_labels = [str(random.randint(0, 23)) + \":00\" for _ in range(len(xticks))]\n\n        test_cases.append((stoch_profiles, stoch_profiles_avg, figure_size, line_colors, xticks, xtick_labels))\n\n    return test_cases"}
{"problem_id": "matplotlib_48", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a given map image with specified geographical extents and aspect ratios. The function should also label the axes appropriately based on the extent values. The function signature is as follows:\n\n```python\ndef choose_start_and_goal_on_image(map_image, extent, aspect_ratio, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**: The function takes in a map image (as an array), a tuple for extent, a float for aspect ratio, and an optional string for the output file name.\n- **Output**: The function does not return any value but saves the visualized map image to the specified output file.\n\nInput:\n```python\nmap_image = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nextent = (-10, 10, -5, 5)\naspect_ratio = 1.0\n```\n\nOutput:\n```plaintext\nA grayscale image saved as 'output.png' with the specified extent and aspect ratio.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nfrom matplotlib import ticker\n\n# main code\ndef choose_start_and_goal_on_image(map_image, extent, aspect_ratio, output_file='output.png'):\n    fig, axs = plt.subplots()\n    plt.imshow(map_image, extent=extent, aspect=aspect_ratio, cmap='gray')\n\n    if extent[0] != 0:\n        axs.set(xlabel='LON', ylabel='LAT')\n        axs.xaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n        axs.yaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n    else:\n        axs.set(xlabel='x(m)', ylabel='y(m)')\n\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        height = random.randint(50, 500)\n        width = random.randint(50, 500)\n        map_image = np.random.random((height, width))\n\n        xmin = random.uniform(-180, 180)\n        xmax = random.uniform(xmin, 180)\n        ymin = random.uniform(-90, 90)\n        ymax = random.uniform(ymin, 90)\n        extent = (xmin, xmax, ymin, ymax)\n\n        aspect_ratio = random.uniform(0.5, 2.0)\n        test_case = (map_image, extent, aspect_ratio)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "matplotlib_49", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes multiple layers of data on a 2D plot using Matplotlib. The function should be able to display height maps with contour lines and provide a color bar for each layer.\n\nFunction signature:\n```python\ndef plot_layers(layers, is_height_map, colormap, layer_names, extent, aspect_ratio, maps_array, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `levels=9`, which specifies the number of contour levels to be drawn for height maps.\n\nInput format:\n- `layers`: A list of integers representing the indices of the layers to be plotted.\n- `is_height_map`: A list of booleans indicating whether each corresponding layer is a height map.\n- `colormap`: A string representing the colormap to be used for the plots.\n- `layer_names`: A list of strings containing the names of each layer for labeling the color bars.\n- `extent`: A tuple defining the bounding box in data coordinates that the image covers.\n- `aspect_ratio`: A float that defines the aspect ratio of the plot.\n- `maps_array`: A 3D NumPy array containing the data for all layers, where the first two dimensions correspond to the spatial dimensions and the third dimension corresponds to the layers.\n- `output_file`: A string specifying the filename for saving the output plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output file path.\n\n**Input:**\n```python\nlayers = [1, 3, 5]\nis_height_map = [True, False, True]\ncolormap = 'viridis'\nlayer_names = ['Layer_1', 'Layer_3', 'Layer_5']\nextent = (-100.0, 100.0, -50.0, 50.0)\naspect_ratio = 1.5\nmaps_array = np.random.rand(100, 100, 10)\n```\n\n**Output:**\n```python\n# The output will be a saved image file named 'output.png' containing the plotted layers.\n# The actual image cannot be represented in text format, but it will show:\n# - Layer_1 and Layer_5 with contour lines (since they are height maps)\n# - Layer_3 as a colored map without contours\n# - Colorbar indicating the values for each layer\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_layers(layers, is_height_map, colormap, layer_names, extent, aspect_ratio, maps_array, output_file='output.png'):\n    fig, axs = plt.subplots()\n\n    for i in range(len(layers)):\n        plot_map = maps_array[:, :, layers[i]]\n        img = axs.imshow(plot_map.T, cmap=colormap, extent=extent, aspect=aspect_ratio)\n        if is_height_map[i]:\n            axs.contour(np.flip(plot_map.T, axis=0), levels=9, linestyles='solid', linewidths=1,\n                        extent=extent)\n\n        cbar = plt.colorbar(img, ax=axs)\n        axs.set_xlabel('LON')\n        axs.set_ylabel('LAT')\n        cbar.ax.set_ylabel(layer_names[i])\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport matplotlib.pyplot as plt\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        layers = random.sample(range(10), random.randint(1, 5))\n        is_height_map = [random.choice([True, False]) for _ in layers]\n        colormap = random.choice(plt.colormaps())\n        layer_names = [f\"Layer_{layer}\" for layer in layers]\n\n        extent = (random.uniform(-180, 180), random.uniform(-180, 180),\n                  random.uniform(-90, 90), random.uniform(-90, 90))\n\n        aspect_ratio = random.uniform(0.5, 2)\n        maps_array = np.random.rand(100, 100, 10)\n        test_cases.append((layers, is_height_map, colormap, layer_names, extent, aspect_ratio, maps_array))\n\n    return test_cases"}
{"problem_id": "matplotlib_50", "library": "matplotlib", "code_problem": "You are tasked with creating a function that displays a 2D image using Matplotlib and saves it to a file. The function should allow for customization of the image's extent and aspect ratio, and it should label the axes based on the provided extent values.\n\nFunction signature:\n```python\ndef show_image(map_image, extent, aspect_ratio, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `map_image`: A 2D array representing the image data to be displayed.\n- `extent`: A tuple of four values (xmin, xmax, ymin, ymax) that defines the extent of the image.\n- `aspect_ratio`: A float that specifies the aspect ratio of the image.\n- `output_file`: A string representing the filename to save the output image (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. It saves the displayed image to the specified output file.\n\nInput:\n```python\nmap_image = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nextent = [-50, 50, -50, 50]\naspect_ratio = 1.0\n```\n\nOutput:\n```python\n# The function will save an image file named 'output.png' with the specified parameters.\n# The output cannot be directly represented as a value, but the image will be generated based on the input.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nfrom matplotlib import ticker\n\n\n# main code\ndef show_image(map_image, extent, aspect_ratio, output_file='output.png'):\n    (_, axs) = plt.subplots()\n    plt.imshow(map_image, extent=extent, aspect=aspect_ratio, cmap='gray')\n\n    if extent[0] != 0:\n        axs.set(xlabel='LON', ylabel='LAT')\n        axs.xaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n        axs.yaxis.set_major_formatter(ticker.StrMethodFormatter('{x:.3f}'))\n    else:\n        axs.set(xlabel='x(m)', ylabel='y(m)')\n\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(10, 100)\n        width = np.random.randint(10, 100)\n        map_image = np.random.random((height, width))\n\n        extent = np.random.uniform(-100, 100, 4)\n        extent = extent.tolist()\n\n        aspect_ratio = np.random.uniform(0.5, 2.0)\n\n        test_cases.append((map_image, extent, aspect_ratio))\n\n    return test_cases"}
{"problem_id": "matplotlib_51", "library": "matplotlib", "code_problem": "You are tasked with implementing a function that generates a periodogram or a power spectral density (PSD) plot based on input time series data. The function will allow for different types of periodogram calculations, including the standard periodogram, Welch's method, and Lomb-Scargle periodogram. The function will also handle optional parameters for sampling frequency, logarithmic scaling, and maximum period filtering.\n\nFunction signature:\n```python\ndef periodogram(X, Y, per_type, sampling_f, logscale, max_per, output_file='output.png'):\n```\n\n### Constants:\n- `p_t`: A constant value set to `0.05`, which is used in the calculation of the threshold for peak detection in the PSD.\n\n### Input Format:\n- `X`: A list or array of time values (float).\n- `Y`: A list or array of corresponding measurement values (float).\n- `per_type`: A string ('per', 'welch', or 'lombscargle').\n- `sampling_f`: A float representing the sampling frequency (optional).\n- `logscale`: A boolean indicating whether to use logarithmic scaling (True/False).\n- `max_per`: A float representing the maximum period to consider.\n- `output_file`: A string representing the output file name for the plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a plot as a PNG file to the specified `output_file`. If no periods remain after filtering, a warning message is printed to the console.\n\nInput:\n```python\nX = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\nY = np.array([1.0, 2.0, 1.5, 2.5, 2.0])\nper_type = 'welch'\nsampling_f = 1.0\nlogscale = True\nmax_per = 3.0\n```\n\nOutput:\n```python\n# The output will be a plot saved as 'output.png' with the title indicating the peaks found.\n# The actual visual output cannot be represented in text format, but the title might look like:\n# \"peaks=\n# 0.50, 0.40, 0.30\"\n``` \n\n(Note: The actual plot will be saved as 'output.png' and the title will depend on the computed peaks based on the input data.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\nimport scipy.signal as signal\n\n\n# main code\ndef periodogram(X, Y, per_type, sampling_f, logscale, max_per, output_file='output.png'):\n    if per_type == 'per' or per_type == 'welch':\n        X_u = np.unique(X)\n        Y_u = []\n        for x_u in X_u:\n            Y_u.append(np.median(Y[x_u == X]))\n        if not sampling_f:\n            sampling_f = 1 / (X[1] - X[0])\n        Y = Y_u\n\n    if per_type == 'per':\n        f, Pxx_den = signal.periodogram(Y, sampling_f)\n    elif per_type == 'welch':\n        f, Pxx_den = signal.welch(Y, sampling_f)\n    elif per_type == 'lombscargle':\n        min_per = 2\n        f = np.linspace(1 / max_per, 1 / min_per, 10)\n        Pxx_den = signal.lombscargle(X, Y, f)\n    else:\n        return\n\n    p_t = 0.05\n    N = len(Y)\n    T = (1 - (p_t / N) ** (1 / (N - 1))) * sum(Pxx_den)\n\n    if f[0] == 0:\n        per = 1 / f[1:]\n        Pxx = Pxx_den[1:]\n    else:\n        per = 1 / f\n        Pxx = Pxx_den\n\n    # Apply the filter condition to both per and Pxx arrays\n    mask = per <= max_per\n    per = per[mask]\n    Pxx = Pxx[mask]\n\n    # Add check for empty period array\n    if len(per) == 0:\n        print(\"Warning: No periods left after filtering by max_per.\")\n        return\n\n    if logscale:\n        plt.semilogx(per, Pxx, 'ko')\n        plt.semilogx(per, Pxx, 'k--', linewidth=0.5)\n        plt.semilogx([min(per), max(per)], [T, T], 'k--', linewidth=1)\n    else:\n        plt.plot(per, Pxx, 'ko')\n        plt.plot(per, Pxx, 'k--', linewidth=0.5)\n        plt.plot([min(per), max(per)], [T, T], 'k--', linewidth=1)\n\n    peak_label = ''\n    locs = Pxx >= T\n    if any(locs):\n        heights, locs = Pxx[locs], per[locs]\n        HL = list(zip(heights, locs))\n        HL.sort(reverse=True)\n        heights, locs = zip(*HL)\n        peak_label = ', peaks=\\n'\n        locs = locs[:11]\n        for loc in locs[:-1]:\n            peak_label += '{:.2f}'.format(loc) + ','\n        peak_label += '{:.2f}'.format(locs[-1])\n\n    plt.xlabel('period [hours]')\n    plt.ylabel('PSD')\n    plt.title(peak_label)\n\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        X_length = np.random.randint(10, 100)\n        X = np.sort(np.random.uniform(0, 10, X_length))\n        Y = np.random.uniform(0, 10, X_length)\n\n        per_types = ['per', 'welch', 'lombscargle']\n        per_type = np.random.choice(per_types)\n\n        logscale = np.random.choice([True, False])\n        max_per = np.random.uniform(1, 5)\n        sampling_f = np.random.uniform(0.1, 2) if np.random.choice(\n            [True, False]) else None\n\n        test_cases.append((X, Y, per_type, sampling_f, logscale, max_per))\n\n    return test_cases"}
{"problem_id": "matplotlib_52", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a polar plot based on given parameters. The function will visualize the relationship between angles and amplitudes for different tests, allowing for customization of colors, line styles, and labels. The function signature is as follows:\n\n```python\ndef plot_phases(acrs, amps, tests, period, colors, linestyles, title, labels, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `np.pi`, which is utilized to define the range of angles for the polar plot.\n\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `acrs`: A list of angles in radians.\n  - `amps`: A list of amplitudes.\n  - `tests`: A list of test names.\n  - `period`: A numerical value used for labeling.\n  - `colors`: A list of colors for the plot.\n  - `linestyles`: A list of line styles for the arrows.\n  - `title`: A string for the plot title.\n  - `labels`: A list of labels for the legend.\n  - `output_file`: A string specifying the output file name (default is 'output.png').\n\n- **Output**: The function does not return any value but saves a polar plot as an image file to the specified output path.\n\n**Input:**\n```python\nacrs = [0.78539816, 1.57079633, 2.35619449, 3.14159265]  # Example angles in radians\namps = [1.0, 1.2, 0.8, 1.5]  # Example amplitudes\ntests = ['Test_1', 'Test_2', 'Test_3', 'Test_4']  # Test names\nperiod = 50  # Example period\ncolors = ['red', 'green', 'blue', 'black']  # Colors for each test\nlinestyles = ['-', '--', ':', '-.']  # Line styles for each test\ntitle = 'Example Phase Plot'  # Title of the plot\nlabels = ['Label 1', 'Label 2', 'Label 3', 'Label 4']  # Labels for the legend\n```\n\n**Output:**\n```python\n# The output will be a polar plot saved as 'output.png' with the specified parameters.\n# The plot will show arrows representing the phases and amplitudes of the tests, \n# with the title 'Example Phase Plot' and a legend with the specified labels.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib.lines import Line2D\n\n# main code\ndef plot_phases(acrs, amps, tests, period, colors, linestyles, title, labels, output_file='output.png'):\n\n    acrs = np.array(acrs, dtype=float)\n    amps = np.array(amps, dtype=float)\n\n    if colors is None:\n        colors = ['black', 'red', 'green', 'blue']\n    if len(colors) < len(tests):\n        colors += ['black'] * (len(tests) - len(colors))\n\n    x = np.arange(0, 2 * np.pi, np.pi / 4)\n    x_labels = list(map(lambda i: f'CT {int((x[i] / (2 * np.pi) * period))}', range(len(x))))\n    x_labels[1::2] = [''] * len(x_labels[1::2])\n\n    ampM = np.max(amps)\n    amps /= ampM\n    acrs = -acrs\n    fig = plt.figure()\n    ax = fig.add_subplot(projection='polar')\n    ax.set_theta_offset(0.5 * np.pi)\n    ax.set_theta_direction(-1)\n    lines = []\n    for i, (acr, amp, test, color) in enumerate(zip(acrs, amps, tests, colors)):\n        if linestyles is not None and len(linestyles) > 0:\n            ax.annotate('', xy=(acr, amp), xytext=(0, 0),\n                        arrowprops=dict(arrowstyle='->', color=color, alpha=0.75, linewidth=2, linestyle=linestyles[i]))\n            lines.append(Line2D([0], [0], color=color, linewidth=2, linestyle=linestyles[i]))\n        else:\n            ax.annotate('', xy=(acr, amp), xytext=(0, 0),\n                        arrowprops=dict(arrowstyle='->', color=color, alpha=0.75, linewidth=2))\n            lines.append(Line2D([0], [0], color=color, linewidth=2))\n\n    ax.set_rmax(1)\n    ax.set_rticks([0.5])\n    ax.set_yticklabels([''])\n    ax.set_xticks(x)\n    ax.set_xticklabels(x_labels)\n    ax.grid(True)\n\n    if title:\n        ax.set_title(title, va='bottom')\n    else:\n        ax.set_title('_'.join(tests), va='bottom')\n\n    if labels:\n        plt.legend(lines, labels, bbox_to_anchor=(1.0, 1), loc='upper left', borderaxespad=0.0, frameon=False)\n    else:\n        plt.legend(lines, tests, bbox_to_anchor=(1.0, 1), loc='upper left', borderaxespad=0.0, frameon=False)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        acrs = np.random.uniform(0, 2 * np.pi, 4)\n        amps = np.random.uniform(0.5, 1.5, 4)\n        tests = [f\"Test_{i+1}\" for i in range(4)]\n        period = np.random.randint(10, 100)\n        colors = np.random.choice(['red', 'green', 'blue', 'black'], 4, replace=True)\n        linestyles = np.random.choice(['-', '--', ':', '-.'], 4, replace=True)\n        title = f\"Test Case {_ + 1}\"\n        labels = [f\"Label {i+1}\" for i in range(4)]\n        test_cases.append((acrs, amps, tests, period, colors, linestyles, title, labels))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_53", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the significance of features in a dataset by plotting their variances. The function will take a DataFrame as input and generate a bar plot that represents the significance of each feature based on its variance.\n\nFunction signature:\n```python\ndef significance(data, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The input to the function is a DataFrame containing numerical data, where each column represents a feature.\n\nOutput format:\n- The output of the function is a saved image file (PNG format) that contains the plot visualizing the significance of the features based on their variances. The file name can be specified by the `output_file` parameter.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\ndata = pd.DataFrame({\n    'feature_1': np.random.randn(20),\n    'feature_2': np.random.randn(20),\n    'feature_3': np.random.randn(20)\n})\n```\n\n**Output:**\n```python\n# The output will be a saved plot file named 'output.png' showing the significance of the features.\n# The actual output cannot be displayed here as it is a graphical output.\n``` \n\nNote: The actual plot will be saved as 'output.png' in the working directory, and the significance of each feature will be represented by vertical lines corresponding to their variance.", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef significance(data, output_file='output.png'):\n    data_df = data\n    nfeatures = data_df.shape[1]\n\n    var_v = np.var(np.array(data_df), axis=0)\n\n    var_sum = np.sum(var_v)\n    prob_v = var_v / var_sum\n\n    y = max(prob_v)\n    plt.axis([0, nfeatures + 1, 0, y])\n\n    x = np.arange(1, nfeatures + 1)\n    tag = list(data_df.columns)\n    plt.xticks(x, tag)\n    plt.yticks(np.linspace(0, y, 5))\n\n    for i, xc in enumerate(prob_v, start=1):\n        plt.axvline(x=i, ymin=0, ymax=xc)\n\n    plt.xlabel('Features')\n    plt.ylabel('Significance')\n\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nfeatures = random.randint(1, 10)\n        nsamples = random.randint(10, 50)\n        data = np.random.randn(nsamples, nfeatures)\n        columns = [f'feature_{i + 1}' for i in range(nfeatures)]\n        data_df = pd.DataFrame(data, columns=columns)\n        test_cases.append(data_df)\n\n    return test_cases"}
{"problem_id": "matplotlib_54", "library": "matplotlib", "code_problem": "You are tasked with visualizing the distances of points in a three-dimensional space using a polar plot. The main function, `plot_polar_nn_distances`, takes in a set of 3D coordinates and their corresponding distances, and generates a polar scatter plot where the points are colored based on their distances.\n\nFunction signature:\n```python\ndef plot_polar_nn_distances(coordinates, distances, marker_size, colormap, graph_title, output_file='output.png'):\n```\n\n### Constants:\n- The default value for `output_file` is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**:\n  - `coordinates`: A 2D NumPy array of shape (n, 3) where n is the number of points.\n  - `distances`: A 1D NumPy array of shape (n,) containing the distances for each point.\n  - `marker_size`: An integer for the size of the markers.\n  - `colormap`: A string representing the colormap.\n  - `graph_title`: A string for the title of the graph.\n  - `output_file`: A string for the output filename (optional).\n\n- **Output**:\n  - The function saves a polar scatter plot as an image file with the specified filename. The plot visually represents the distances of the points in a 2D polar coordinate system.\n\nInput:\n```python\ncoordinates = np.array([[1.0, 2.0, 3.0],\n                        [4.0, 5.0, 6.0],\n                        [7.0, 8.0, 9.0],\n                        [10.0, 11.0, 12.0],\n                        [13.0, 14.0, 15.0]])\ndistances = np.array([10.0, 20.0, 30.0, 40.0, 50.0])\nmarker_size = 50\ncolormap = 'viridis'\ngraph_title = \"Test Case Graph\"\n```\n\nOutput:\n```python\n# The output will be a saved figure 'output.png' with a polar scatter plot\n# The figure will display points based on the spherical projection of the input coordinates,\n# colored according to the distances provided, and titled \"Test Case Graph\".\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom matplotlib import colors\n\n\ndef convert_to_spherical(coordinates):\n    x, y, z = coordinates[:, 0], coordinates[:, 1], coordinates[:, 2]\n    r = np.linalg.norm(coordinates, axis=1)\n    theta = np.arccos(z / r)\n    phi = np.arctan2(y, x)\n    np.nan_to_num(phi, copy=False, nan=0.0)\n    np.nan_to_num(theta, copy=False, nan=0.0)\n    return r, theta, phi\n\n\ndef project_stereo(coord):\n    _, theta, phi = convert_to_spherical(coord)\n    projection_xy = np.column_stack((coord[:, 0] / (1 - coord[:, 2]), coord[:, 1] / (1 - coord[:, 2])))\n    projection_theta_r = np.column_stack((phi, np.sin(np.pi - theta) / (1 - np.cos(np.pi - theta))))\n    return projection_theta_r, projection_xy\n\n# main code\ndef plot_polar_nn_distances(coordinates, distances, marker_size, colormap, graph_title, output_file='output.png'):\n    coord_sorted = coordinates[coordinates[:, 2].argsort()]\n    dist_sorted = distances[coordinates[:, 2].argsort()]\n\n    projection_theta_r, projection_xy = project_stereo(coord_sorted)\n    dist_pos = dist_sorted[:projection_theta_r.shape[0]]\n\n    fig = plt.figure(figsize=(13, 5))\n    ax = fig.add_subplot(111, projection='polar')\n    ax.set_yticklabels([])\n    scatter = ax.scatter(projection_theta_r[:, 0], projection_theta_r[:, 1], c=dist_pos, s=marker_size)\n    ax.set_xlabel('Projection')\n\n    norm = colors.Normalize(vmin=np.amin(distances), vmax=np.amax(distances))\n    sm = plt.cm.ScalarMappable(cmap=colormap, norm=norm)\n    sm.set_array(dist_pos)\n\n    fig.colorbar(sm, ax=ax)\n\n    if graph_title:\n        fig.suptitle(graph_title)\n\n    fig.savefig(output_file)\n    plt.close(fig)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        coordinates = np.random.rand(100, 3) * 10\n        distances = np.random.rand(100) * 100\n        marker_size = np.random.randint(10, 100)\n        colormap = np.random.choice(['viridis', 'plasma', 'inferno', 'magma'])\n        graph_title = np.random.choice([None, \"Random Graph Title\"])\n\n        test_cases.append((coordinates, distances, marker_size, colormap, graph_title))\n\n    return test_cases"}
{"problem_id": "matplotlib_55", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the relationship between time and slope based on given frequency data and specific episodes. The function will generate a plot that highlights the episodes on the frequency graph.\n\nFunction signature:\n```python\ndef plot_episodes(frequencies, episodes, mcat, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `cap`: This constant is calculated as the maximum value in the `frequencies` list plus one. It determines the range of the y-axis for the plot.\n\nInput format:\n- `frequencies`: A list of numerical values representing frequency data.\n- `episodes`: A list of tuples or lists, where each tuple/list contains two numerical values representing the start and end of an episode.\n- `mcat`: A string representing the title of the plot.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file specified by `output_file`.\n\nInput:\n```python\nfrequencies = [10, 20, 30, 40, 50]\nepisodes = [(1, 3), (0, 2)]\nmcat = \"Category_42\"\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing:\n- A gray line representing the frequencies over time.\n- Green dashed lines at x=1 and x=3 indicating the start and end of the first episode.\n- Red dashed lines at x=0 and x=2 indicating the start and end of the second episode.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n\n# main code\ndef plot_episodes(frequencies, episodes, mcat, output_file='output.png'):\n    cap = max(frequencies) + 1\n    plt.figure()\n\n    plt.title(mcat)\n    plt.xlabel('Time ->')\n    plt.ylabel('Slope')\n\n    plt.plot(frequencies, color='gray')\n\n    for ep in episodes:\n        xax_start = [ep[0]] * cap\n        xax_end = [ep[1]] * cap\n        yax = list(range(cap))\n\n        plt.plot(xax_start, yax, color='green', linestyle=(0, (5, 10)))\n        plt.plot(xax_end, yax, color='red', linestyle=(0, (5, 10)))\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_frequencies = random.randint(5, 50)\n        frequencies = [random.randint(0, 100) for _ in range(num_frequencies)]\n        num_episodes = random.randint(1, 5)\n        episodes = [(random.randint(0, num_frequencies - 1), random.randint(i + 1, num_frequencies)) for i in\n                    range(num_episodes)]\n        mcat = f\"Category_{random.randint(1, 100)}\"\n        test_cases.append((frequencies, episodes, mcat))\n\n    return test_cases"}
{"problem_id": "matplotlib_56", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the evolution of various parameters during the training and testing phases of a machine learning model. The function will generate plots for the radius, learning rate, and squared distance metrics, allowing for a comparative analysis between training and testing data.\n\nFunction Signature:\n```python\ndef plotVariables(radiusTrain, radiusTest, learnRateTrain, learnRateTest, sqDistTrain, sqDistTest, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- The function accepts six lists or arrays of numerical values representing the training and testing metrics, and an optional string for the output file name.\n\nOutput Format:\n- The function generates and saves a PNG file containing the visualized plots of the specified metrics.\n\nInput:\n```python\nradiusTrain = [0.1, 0.2, 0.3, 0.4, 0.5]\nradiusTest = [0.15, 0.25, 0.35, 0.45, 0.55]\nlearnRateTrain = [0.01, 0.02, 0.03, 0.04, 0.05]\nlearnRateTest = [0.015, 0.025, 0.035, 0.045, 0.055]\nsqDistTrain = [0.5, 0.4, 0.3, 0.2, 0.1]\nsqDistTest = [0.45, 0.35, 0.25, 0.15, 0.05]\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with three subplots:\n# 1. Radius evolution showing radiusTrain in red and radiusTest in blue.\n# 2. Learning rate evolution showing learnRateTrain in red and learnRateTest in blue.\n# 3. Best Matching Unit 3D Distance showing sqDistTrain in red and sqDistTest in blue.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plotVariables(radiusTrain, radiusTest, learnRateTrain, learnRateTest, sqDistTrain, sqDistTest, output_file='output.png'):\n    fig, axs = plt.subplots(3, 1, figsize=(8, 12))\n    axs[0].plot(radiusTrain, 'r', label='Training Radius')\n    axs[0].plot(radiusTest, 'b', label='Testing Radius')\n    axs[0].set_title('Radius evolution')\n    axs[0].set_xlabel('Number of iterations')\n    axs[0].set_ylabel('Radius size')\n    axs[0].legend(loc=1)\n\n    axs[1].plot(learnRateTrain, 'r', label='Training Learning Rate')\n    axs[1].plot(learnRateTest, 'b', label='Testing Learning Rate')\n    axs[1].set_title('Learning rate evolution')\n    axs[1].set_xlabel('Number of iterations')\n    axs[1].set_ylabel('Learning rate')\n    axs[1].legend(loc=1)\n\n    axs[2].plot(sqDistTrain, 'r', label='Training (Squared) Distance')\n    axs[2].plot(sqDistTest, 'b', label='Testing (Squared) Distance')\n    axs[2].set_title('Best Matching Unit 3D Distance')\n    axs[2].set_xlabel('Number of iterations')\n    axs[2].set_ylabel('Smallest Distance Squared')\n    axs[2].legend(loc=1)\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_iterations = random.randint(50, 200)\n        radiusTrain = np.random.rand(num_iterations).tolist()\n        radiusTest = np.random.rand(num_iterations).tolist()\n        learnRateTrain = np.random.rand(num_iterations).tolist()\n        learnRateTest = np.random.rand(num_iterations).tolist()\n        sqDistTrain = np.random.rand(num_iterations).tolist()\n        sqDistTest = np.random.rand(num_iterations).tolist()\n\n        test_cases.append((radiusTrain, radiusTest, learnRateTrain, learnRateTest, sqDistTrain, sqDistTest))\n\n    return test_cases"}
{"problem_id": "matplotlib_57", "library": "matplotlib", "code_problem": "You are tasked with visualizing the reconstruction of images using a function that displays both the original and reconstructed images side by side. The function should be able to handle a set of sample images and their corresponding reconstructions, and save the output as a PNG file.\n\nFunction Signature:\n```python\ndef print_reconstruction(x_reconstruct, x_sample, output_file='output.png'):\n```\n\nConstant Used:\n- The constant used in the main code is `5`, which determines the maximum number of images to display.\n\nInput Format:\n- `x_reconstruct`: A list or array of reconstructed images, where each image can be represented as a flattened array.\n- `x_sample`: A list or array of original sample images, where each image can also be represented as a flattened array.\n- `output_file`: A string representing the filename for saving the output image (optional).\n\nOutput Format:\n- The function saves a PNG file containing the visual comparison of the original and reconstructed images side by side. The filename is specified by the `output_file` parameter.\n\n```python\nInput: (array([[0.1, 0.2, 0.3, ..., 0.5],  # x_reconstruct\n                [0.4, 0.5, 0.6, ..., 0.7],\n                [0.8, 0.9, 0.1, ..., 0.2],\n                [0.3, 0.4, 0.5, ..., 0.6],\n                [0.7, 0.8, 0.9, ..., 0.1]]), \n       array([[0.9, 0.8, 0.7, ..., 0.6],  # x_sample\n                [0.5, 0.4, 0.3, ..., 0.2],\n                [0.1, 0.2, 0.3, ..., 0.4],\n                [0.5, 0.6, 0.7, ..., 0.8],\n                [0.9, 0.1, 0.2, ..., 0.3]]))\n\nOutput: 'output.png'  # The output file where the images are saved\n``` \n\n(Note: The actual numerical values in the arrays are truncated for brevity and should be filled with random values between 0 and 1, reshaped to (5, 28*28). The output indicates the filename where the plot is saved.)", "ground_truth_code": "import matplotlib.pyplot as plt\n\n\n# main code\ndef print_reconstruction(x_reconstruct, x_sample, output_file='output.png'):\n    num_images = min(5, len(x_sample))\n    fig, axes = plt.subplots(num_images, 2, figsize=(8, 2 * num_images))\n\n    for i in range(num_images):\n        im1 = axes[i, 0].imshow(x_sample[i].reshape(28, 28), vmin=0, vmax=1)\n        axes[i, 0].set_title('Test input')\n        fig.colorbar(im1, ax=axes[i, 0])\n\n        im2 = axes[i, 1].imshow(x_reconstruct[i].reshape(28, 28), vmin=0, vmax=1)\n        axes[i, 1].set_title('Reconstruction')\n        fig.colorbar(im2, ax=axes[i, 1])\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        x_sample = np.random.rand(5, 28*28)\n        x_reconstruct = np.random.rand(5, 28*28)\n        test_cases.append((x_reconstruct, x_sample))\n\n    return test_cases"}
{"problem_id": "matplotlib_58", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of paths on a 2D plane, along with optional labels and endpoints. The function should generate a plot and save it as an image file.\n\nFunction Signature:\n```python\ndef DrawPath(lines, labels, endpoints, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `lines`: A list of lists of tuples, where each tuple contains two numerical values representing the x and y coordinates of points.\n- `labels`: A list of strings (optional) corresponding to each path in `lines`.\n- `endpoints`: A list of tuples (optional) representing specific points to highlight on the plot.\n- `output_file`: A string representing the name of the output file (optional).\n\nOutput Format:\n- The function saves a plot as an image file with the name specified by `output_file`. The image will visually represent the paths, labels, and endpoints as described.\n\n**Input:**\n```python\n(\n    [\n        [(10, 10), (20, 20), (30, 10)],\n        [(15, 5), (25, 15), (35, 5)],\n        [(0, 0), (10, 10)]\n    ],\n    [\"Line_0\", \"Line_1\", \"Line_2\"],\n    [(5, 5), (20, 15)]\n)\n```\n\n**Output:**\nThe function `DrawPath` will generate a plot saved as `output.png` with the following characteristics:\n- Three lines drawn on the plot, labeled \"Line_0\", \"Line_1\", and \"Line_2\".\n- Two endpoints marked with red circles at coordinates (5, 5) and (20, 15).\n- The plot will have a title \"X-Y Plane Fault Map\", and axes labeled \"X\" and \"Y\".", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef DrawPath(lines, labels, endpoints, output_file='output.png'):\n    labels = labels or []\n    endpoints = endpoints or []\n\n    plt.figure(figsize=(10, 10), dpi=80, facecolor='w', edgecolor='k')\n    font = {'family': 'serif', 'color': 'black', 'weight': 'normal', 'size': 16}\n\n    for i, verts in enumerate(lines):\n        plt.plot(*zip(*verts), label=labels[i] if i < len(labels) else '')\n    if endpoints:\n        plt.scatter(*zip(*endpoints), facecolors='none', edgecolors='r', alpha=0.7, s=20)\n\n    plt.axis('equal')\n    plt.gca().invert_xaxis()\n    plt.title('X-Y Plane Fault Map', fontdict=font)\n    plt.xlabel('X', fontdict=font)\n    plt.ylabel('Y', fontdict=font)\n    plt.grid()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_lines = random.randint(1, 10)\n        lines = []\n\n        for _ in range(num_lines):\n            num_points = random.randint(3, 15)\n            verts = [(random.uniform(-100, 100), random.uniform(-100, 100)) for _ in range(num_points)]\n            lines.append(verts)\n\n        labels = [f\"Line_{i}\" for i in range(num_lines)] if random.random() > 0.5 else []\n\n        num_endpoints = random.randint(0, 5)\n        endpoints = [(random.uniform(-100, 100), random.uniform(-100, 100)) for _ in range(num_endpoints)]\n\n        test_cases.append((lines, labels, endpoints))\n\n    return test_cases"}
{"problem_id": "matplotlib_59", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the Mean Squared Error (MSE) loss values for different noise levels using a line plot. The function will take in a grid of results and generate a plot that displays how the MSE loss changes with varying noise levels. The plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef KFPlot(res_grid, output_file='output.png'):\n```\n\nConstant used in the main code:\n- `x_plt`: This constant is a list of x-coordinates representing different noise levels, specifically `[-6, 0, 6]`.\n\nInput format:\n- `res_grid`: A 2D list or array where each sublist contains MSE loss values corresponding to the noise levels defined in `x_plt`.\n- `output_file`: A string representing the filename for saving the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value but saves a plot as an image file to the specified output file.\n\nInput:\n```python\nres_grid = np.array([\n    [-10.5, -5.2, 0.3],\n    [1.1, 3.4, 5.6],\n    [-15.0, -10.0, -5.0],\n    [0.0, 2.0, 4.0]\n])\n```\n\nOutput:\nThe function `KFPlot(res_grid)` will generate a plot saved as 'output.png' with the following characteristics:\n- The x-axis will have points at -6, 0, and 6.\n- The plotted lines will represent the MSE Loss Values in dB for each of the four markers:\n  - 'minus' (xg) will plot the values from the first row of `res_grid`.\n  - 'base' (ob) will plot the values from the second row of `res_grid`.\n  - 'plus' (r+) will plot the values from the third row of `res_grid`.\n  - 'base NN' (oy) will plot the values from the fourth row of `res_grid`.\n- The legend will display the labels corresponding to each marker.\n- The x-axis will be labeled 'Noise' and the y-axis will be labeled 'MSE Loss Value [dB]'.\n- The title of the plot will be 'Change'.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef KFPlot(res_grid, output_file='output.png'):\n    plt.figure(figsize=(10, 4))\n\n    x_plt = [-6, 0, 6]\n    labels = ['minus', 'base', 'plus', 'base NN']\n    markers = ['xg', 'ob', '+r', 'oy']\n\n    for i, marker in enumerate(markers):\n        plt.plot(x_plt, res_grid[i][:], marker, label=labels[i])\n\n    plt.legend()\n    plt.xlabel('Noise', fontsize=12)\n    plt.ylabel('MSE Loss Value [dB]', fontsize=12)\n    plt.title('Change', fontsize=14)\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        res_grid = np.random.uniform(low=-20, high=20, size=(4, 3))\n        test_cases.append((res_grid))\n\n    return test_cases"}
{"problem_id": "matplotlib_60", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the energy dynamics of a pendulum system, both with and without friction. The function will generate a plot that displays the kinetic and potential energy over time, along with predictions for both energies during training and testing phases.\n\nFunction signature:\n```python\ndef plot_test(t, E_kin, E_pot, pred_E_kin, pred_E_pod, friction, length, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `t`: List or array of time values.\n- `E_kin`: List or array of kinetic energy values.\n- `E_pot`: List or array of potential energy values.\n- `pred_E_kin`: List or array of predicted kinetic energy values.\n- `pred_E_pod`: List or array of predicted potential energy values.\n- `friction`: Boolean value indicating the presence of friction.\n- `length`: Integer value representing the length of the training data.\n- `output_file`: (Optional) String for the output file name.\n\n### Output Format:\n- The function saves a plot as an image file (default is 'output.png') and does not return any value.\n\nInput:\n```python\nt = np.array([0.1, 0.5, 1.0, 1.5, 2.0])\nE_kin = np.array([1.0, 2.0, 1.5, 3.0, 2.5])\nE_pot = np.array([5.0, 4.0, 4.5, 3.0, 3.5])\npred_E_kin = np.array([1.1, 1.9, 1.6, 2.8, 2.4])\npred_E_pod = np.array([4.9, 4.1, 4.6, 3.1, 3.4])\nfriction = True\nlength = 3\n```\n\nOutput:\n```python\n# This will generate a plot saved as 'output.png' with the following characteristics:\n# - Title: 'Pendulum with friction'\n# - Kinetic Energy (KE) plotted in black\n# - Potential Energy (PE) plotted in light gray\n# - Train-Predictions KE plotted in magenta for the first 3 points\n# - Train-Predictions PE plotted in cyan for the first 3 points\n# - Test-Predictions KE plotted in red for the last 2 points\n# - Test-Predictions PE plotted in dodger blue for the last 2 points\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_test(t, E_kin, E_pot, pred_E_kin, pred_E_pod, friction, length, output_file='output.png'):\n    plt.figure(figsize=(7.5, 6.0))\n    plt.title('Pendulum with friction' if friction else 'Pendulum without friction')\n    plt.ylabel('Energy in J')\n    plt.xlabel('Time')\n    plt.autoscale(axis='t', tight=True)\n\n    plt.plot(t, E_kin, label='Kinetic Energy (KE)', c='black')\n    plt.plot(t, E_pot, label='Potential Energy (PE)', c='#d3d3d3')\n    plt.plot(t[:length], pred_E_kin[:length], label='Train-Predictions KE', c='magenta', linewidth=3)\n    plt.plot(t[:length], pred_E_pod[:length], label='Train-Predictions PE', c='cyan', linewidth=3)\n    plt.plot(t[length:], pred_E_kin[length:], label='Test-Predictions KE', c='red', linewidth=3)\n    plt.plot(t[length:], pred_E_pod[length:], label='Test-Predictions PE', c='dodgerblue', linewidth=3)\n\n    plt.axvline(t[length - 1], -1, 1, c='black')\n    plt.legend()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        N = random.randint(50, 500)\n        t = np.sort(np.random.rand(N) * 100)\n        E_kin = np.random.rand(N) * 10\n        E_pot = np.random.rand(N) * 10\n        pred_E_kin = E_kin + np.random.normal(0, 0.5, N)\n        pred_E_pod = E_pot + np.random.normal(0, 0.5, N)\n        friction = random.choice([True, False])\n        length = random.randint(1, N - 1)\n        test_cases.append((t, E_kin, E_pot, pred_E_kin, pred_E_pod, friction, length))\n\n    return test_cases"}
{"problem_id": "matplotlib_61", "library": "matplotlib", "code_problem": "You are tasked with visualizing attention weights associated with a set of bags (data samples) and their corresponding instance labels. The goal is to create a grid of images representing each bag, highlighting the most significant bags based on their attention weights.\n\nFunction Signature:\n```python\ndef vis_attention(bags, attention_weights, instance_labels, topk, output_file='output.png'):\n```\n\n### Constants:\n- `topk`: An integer that specifies the number of top bags to highlight based on their attention weights.\n- `output_file`: A string that specifies the name of the output file where the visualization will be saved. The default value is 'output.png'.\n\n### Input Format:\n- `bags`: A 2D array where each row represents a bag (image data).\n- `attention_weights`: A 1D array of attention weights corresponding to each bag.\n- `instance_labels`: A 1D array of labels indicating the instance type for each bag (e.g., binary labels).\n- `topk`: An integer indicating how many top bags to highlight.\n- `output_file`: A string for the output file name (optional).\n\n### Output Format:\n- The function saves a visualization as an image file (PNG format) specified by `output_file`. The image contains a grid of bags with their attention weights displayed, highlighting the top `k` bags.\n\n**Input:**\n```python\nbags = np.array([[[0.1, 0.2], [0.3, 0.4]], \n                  [[0.5, 0.6], [0.7, 0.8]], \n                  [[0.9, 1.0], [1.1, 1.2]], \n                  [[1.3, 1.4], [1.5, 1.6]]])\nattention_weights = np.array([0.2, 0.5, 0.9, 0.1])\ninstance_labels = np.array([0, 1, 1, 0])\ntopk = 2\n```\n\n**Output:**\n```python\n# The function vis_attention will generate a plot saved as 'output.png'\n# The topk indices based on attention_weights would be [2, 1] (corresponding to the highest weights 0.9 and 0.5)\n# The output file 'output.png' will contain visualizations of the bags with attention weights annotated.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef vis_attention(bags, attention_weights, instance_labels, topk, output_file='output.png'):\n    topk_ind = attention_weights.argsort()[-topk:][::-1]\n    bag_length = bags.shape[0]\n\n    nrows = 2\n    ncols = (bag_length + nrows - 1) // nrows\n\n    fig, axes = plt.subplots(nrows=nrows, ncols=ncols,\n                             figsize=(ncols * 2 - 1.5, nrows * 2))\n\n    axes = axes.flatten()\n\n    for i in range(bag_length):\n        ax = axes[i]\n        cmap = 'hot' if int(instance_labels[i]) == 1 else 'gray'\n        ax.imshow(bags[i], cmap=cmap)\n\n        color = 'red' if i in topk_ind else 'black'\n        ax.text(0.47, -0.08, f'$a_{{{i}}}$ = {attention_weights[i]:.5f}',\n                {'color': color, 'fontsize': 14},\n                horizontalalignment='center',\n                verticalalignment='center',\n                transform=ax.transAxes)\n\n        ax.axis('off')\n\n    for ax in axes[bag_length:]:\n        ax.axis('off')\n\n    plt.tight_layout()\n    plt.subplots_adjust(wspace=0.05, hspace=0.2)\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        bag_length = random.randint(5, 30)\n        bag_dim = (random.randint(20, 50), random.randint(20, 50))\n        bags = np.random.rand(bag_length, *bag_dim)\n        attention_weights = np.random.rand(bag_length)\n        instance_labels = np.random.choice([0, 1], size=bag_length)\n        topk = random.randint(1, bag_length)\n        test_cases.append((bags, attention_weights, instance_labels, topk))\n\n    return test_cases"}
{"problem_id": "matplotlib_62", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the density distribution of lattice parameters from a given dataset. The function should generate histograms for each dimension of the lattice data, fit a normal distribution to the data, and annotate the plots with the mean and standard deviation of the fitted distributions.\n\nFunction signature:\n```python\ndef draw_lattice_density(Lat, n_bins, num_crop, labels, colors, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The default value for `output_file` is set to `'output.png'`.\n\n### Input Format:\n- `Lat`: A numpy array of shape (m, n) or (p, q, r) representing lattice parameters.\n- `n_bins`: An integer specifying the number of bins for the histogram.\n- `num_crop`: An integer indicating how many rows to crop from the beginning of `Lat`.\n- `labels`: A list of strings for labeling each dimension (optional).\n- `colors`: A list of color specifications for each dimension (optional).\n- `figsize`: A tuple specifying the size of the figure (width, height).\n- `output_file`: A string specifying the filename to save the output plot (optional).\n\n### Output Format:\n- The function does not return any value but saves a plot as an image file to the specified `output_file`.\n\n**Input:**\n```python\nLat = np.array([[0.5, 1.2], [1.0, 0.8], [1.5, 1.5], [0.2, 0.3], [0.9, 1.1]])\nn_bins = 5\nnum_crop = 1\nlabels = ['Feature 1', 'Feature 2']\ncolors = ['C0', 'C1']\nfigsize = (6, 4)\n```\n\n**Output:**\n```python\n# The function will generate a plot saved as 'output.png' with the following characteristics:\n# - Two subplots for 'Feature 1' and 'Feature 2'\n# - Histograms based on the provided Lat data\n# - Mean and standard deviation annotations for each feature\n# - The plot will be displayed with the specified figsize\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format.)", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# main code\ndef draw_lattice_density(Lat, n_bins, num_crop, labels, colors, figsize, output_file='output.png'):\n    if num_crop != 0:\n        Lat = Lat[num_crop:, :]\n    if Lat.ndim == 3:\n        Lat = Lat.reshape((Lat.shape[0] * Lat.shape[1], Lat.shape[2]))\n\n    n_dim = Lat.shape[1]\n    labels = labels or [f'Dim {i+1}' for i in range(n_dim)]\n    colors = colors or [f'C{i}' for i in range(n_dim)]\n\n    histranges = np.array([[np.quantile(Lat[:, i], 0.02), np.quantile(Lat[:, i], 0.98)]\n                            for i in range(n_dim)])\n\n    histrange = [np.amin(histranges[:, 0]) - 0.2 * np.ptp(histranges),\n                 np.amax(histranges[:, 1]) + 0.2 * np.ptp(histranges)]\n\n    figs, axs = plt.subplots(n_dim, 1, figsize=figsize)\n\n    if n_dim == 1:\n        axs = [axs]\n\n    Mu, Std = [], []\n    for i in range(n_dim):\n        y, binEdges = np.histogram(Lat[:, i], bins=n_bins, range=histrange)\n        bincenters = 0.5 * (binEdges[1:] + binEdges[:-1])\n        axs[i].plot(bincenters, y, label=labels[i], color=colors[i], linewidth=2.4)\n        axs[i].text(0.03, 0.82, labels[i], horizontalalignment='center', fontsize=15,\n                     verticalalignment='center', transform=axs[i].transAxes, style='italic')\n\n        mu, std = norm.fit(Lat[:, i])\n        Mu.append(mu)\n        Std.append(std)\n        axs[i].text(0.88, 0.82, f'Mean: {mu:.2f}', horizontalalignment='center', fontsize=12,\n                     verticalalignment='center', transform=axs[i].transAxes)\n        axs[i].text(0.88, 0.58, f'SD: {std:.4f}', horizontalalignment='center', fontsize=12,\n                     verticalalignment='center', transform=axs[i].transAxes)\n\n        axs[i].tick_params(axis='both', which='major', labelsize=14)\n        axs[i].set_ylabel('Counts (a.u.)', fontsize=15)\n        axs[i].set_xlabel('Lattice Parameter ($\\mathrm{\\AA}$)', fontsize=15)\n        axs[i].set_xlim(histrange)\n        axs[i].set_yticks([])\n\n    for ax in axs[:-1]:\n        ax.set_xlabel('')\n        ax.xaxis.set_ticklabels([])\n        ax.yaxis.set_ticklabels([])\n\n    axs[-1].set_ylabel('')\n    axs[-1].yaxis.set_ticklabels([])\n\n    plt.tight_layout()\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        is_3d = random.choice([True, False])\n        if is_3d:\n            batch_size = random.randint(5, 50)\n            height = random.randint(5, 20)\n            n_dim = random.randint(1, 5)\n            Lat = np.random.randn(batch_size, height, n_dim)\n        else:\n            batch_size = random.randint(100, 1000)\n            n_dim = random.randint(1, 5)\n            Lat = np.random.randn(batch_size, n_dim)\n        n_bins = random.randint(10, 50)\n        num_crop = random.randint(0, Lat.shape[0] // 2)\n        labels = [f'Feature {i + 1}' for i in range(n_dim)]\n        colors = [f'C{i}' for i in range(n_dim)]\n        figsize = (random.uniform(4, 10), random.uniform(4, 10))\n        test_cases.append((Lat, n_bins, num_crop, labels, colors, figsize))\n\n    return test_cases"}
{"problem_id": "matplotlib_63", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the evolution of tilt angles over a series of steps. The function will generate a scatter plot where each tilt angle is represented by a different color based on its category. The function will also allow customization of the x-axis label based on the type of data provided.\n\nFunction signature:\n```python\ndef draw_tilt_evolution_sca(T, steps, xaxis_type, scasize, output_file='output.png'):\n```\n\n### Constants:\n- The y-axis limits are set to a range of [-45, 45].\n- The y-ticks are defined at intervals of [-45, -30, -15, 0, 15, 30, 45].\n\n### Input Format:\n- `T`: A 3D numpy array of shape (n_steps, n_categories, 3) where n_steps is the number of steps and n_categories is the number of tilt categories.\n- `steps`: A 1D array or list of length n_steps.\n- `xaxis_type`: A string that can be 'N', 'T', or 't'.\n- `scasize`: An integer representing the size of the scatter plot markers.\n- `output_file`: A string representing the filename for the output plot (optional).\n\n### Output Format:\n- The function does not return any value but saves a scatter plot as an image file to the specified output file.\n\nInput:\n```python\nimport numpy as np\n\nT = np.array([[[ 10.5, -20.3,  15.0],\n                [  5.0,  30.0, -10.0],\n                [  0.0, -15.0,  25.0]],\n\n               [[ 20.0, -10.0,  30.0],\n                [ 15.0,  25.0, -20.0],\n                [  5.0, -10.0,  20.0]],\n\n               [[ 30.0,  0.0,  10.0],\n                [ 20.0,  15.0, -5.0],\n                [ 10.0, -5.0,  15.0]]])\n\nsteps = np.array([0, 1, 2])\nxaxis_type = 'N'\nscasize = 50\n```\n\nOutput:\n```python\n# The function draw_tilt_evolution_sca will generate a plot saved as 'output.png'\n# The plot will show scatter points for tilt angles of three series over the steps.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef draw_tilt_evolution_sca(T, steps, xaxis_type, scasize, output_file='output.png'):\n    plt.figure()\n    for i in range(T.shape[1]):\n        plt.scatter(steps, T[:, i, 0], label='$\\mathit{a}$' if i == 0 else None, s=scasize, c='green')\n        plt.scatter(steps, T[:, i, 1], label='$\\mathit{b}$' if i == 0 else None, s=scasize, c='blue')\n        plt.scatter(steps, T[:, i, 2], label='$\\mathit{c}$' if i == 0 else None, s=scasize, c='red')\n\n    plt.legend()\n    ax = plt.gca()\n    ax.set_ylim([-45, 45])\n    ax.set_yticks([-45, -30, -15, 0, 15, 30, 45])\n\n    xlabel_map = {'N': 'MD step', 'T': 'Temperature (K)', 't': 'Time (ps)'}\n    plt.xlabel(xlabel_map.get(xaxis_type, 'Time (ps)'))\n\n    plt.ylabel('Tilt angle (deg)')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        random_steps = random.randint(10, 100)\n        random_series = random.randint(1, 10)\n        T = np.random.uniform(-45, 45, (random_steps, random_series, 3))\n        steps = np.sort(np.random.uniform(0, 1000, random_steps))\n        xaxis_type = random.choice(['N', 'T', 't'])\n        scasize = random.uniform(10, 100)\n        test_cases.append((T, steps, xaxis_type, scasize))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_64", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the distribution of different types of chemical compounds based on their configurations and counts. The function will generate a stacked bar chart that represents the counts of various configurations of these compounds.\n\nFunction signature:\n```python\ndef plot_partition(typelib, config_types, halcounts, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `typelib`: List of lists (e.g., `[['type1'], ['type2'], ...]`)\n- `config_types`: List of integers (e.g., `[0, 1, 2, ...]`)\n- `halcounts`: List of two integers (e.g., `[count1, count2]`)\n- `output_file`: Optional string (default is `'output.png'`)\n\n### Output Format:\n- The function saves a PNG file containing the generated stacked bar chart to the specified `output_file`.\n\n```python\n# Input\ntypelib = [[3, 5], [2], [4, 1, 3], [6], [2, 2], [1, 1, 1], [5, 5, 5, 5]]\nconfig_types = [0, 2, 1, 3, 4, 5, 6]\nhalcounts = [45, 30]\n\n# Output\n# The function will generate a bar plot saved as 'output.png' with the title:\n# \"Total: 45 I, 30 Br\"\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_partition(typelib, config_types, halcounts, output_file='output.png'):\n    config_types = list(config_types)\n    title = f'Total: {halcounts[0]} I, {halcounts[1]} Br'\n\n    num_types = max(config_types) + 1\n    types = np.zeros((num_types,), dtype=int)\n    for i, t in enumerate(typelib):\n        types[config_types[i]] = len(t)\n\n    y1, y2, y3 = np.zeros((7,)), np.zeros((7,)), np.zeros((7,))\n\n    y1[:2] = types[:2]\n    y2[2:5] = types[[2, 4, 6]]\n    y3[2:5] = types[[3, 5, 7]]\n    y1[5:] = types[7:9] if len(types) > 8 else np.pad(types[7:], (0, max(0, 2 - len(types[7:]))), 'constant')\n\n    x_labels = [str(i) for i in range(7)]\n\n    fig, ax1 = plt.subplots(figsize=(8, 6))\n    ax1.bar(x_labels, y1, label='pure')\n    ax1.bar(x_labels, y2, bottom=y1, label='cis/fac')\n    ax1.bar(x_labels, y3, bottom=y1 + y2, label='trans/mer')\n    ax1.set_title(title, fontsize=13)\n    ax1.set_xlabel('Br content', fontsize=12)\n    ax1.set_ylabel('Counts', fontsize=12)\n    ax1.legend()\n\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        num_config_types = np.random.randint(9, 15)\n        typelib = [np.random.randint(1, 10, size=np.random.randint(1, 5)).tolist() for _ in range(num_config_types)]\n        config_types = np.random.permutation(np.arange(num_config_types))\n        halcounts = np.random.randint(10, 100, size=(2,))\n\n        test_cases.append((typelib, config_types, halcounts))\n\n    return test_cases"}
{"problem_id": "matplotlib_65", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the density of lattice parameters based on given concentrations of a chemical compound. The function will take in a list of lattice concentration data and a list of corresponding concentrations, and it will generate a scatter plot with error bars representing the mean and standard deviation of the lattice parameters. The plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef draw_halideconc_lat_density(Lconc, concent, output_file='output.png'):\n```\n\nConstants used in the main code:\n- `dist_gap`: A small constant value (0.0005) used to adjust the x-coordinates of the scatter plot points for better visibility.\n- `scaalpha`: A constant (0.8) that sets the transparency level of the scatter plot points.\n- `scasize`: A constant (50) that defines the size of the scatter plot points.\n\nInput format:\n- `Lconc`: A list of NumPy arrays, where each array contains lattice parameter data. Each array can be either 2D or 3D.\n- `concent`: A list of concentration values corresponding to the lattice parameters.\n- `output_file`: A string representing the filename to save the output plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It generates and saves a plot as an image file to the specified output path.\n\nInput:\n```python\nLconc = np.array([[[1.2, 2.3, 3.1], [4.5, 5.6, 6.7], [7.8, 8.9, 9.0]],\n                  [[1.1, 2.2, 3.3], [4.4, 5.5, 6.6], [7.7, 8.8, 9.9]],\n                  [[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]]])\nconcent = np.array([10, 20, 30])\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with the density plot.\n# The actual visual output cannot be represented in text format.\n# However, the function will generate a plot with the following characteristics:\n# - Three sets of points corresponding to the parameters a, b, and c.\n# - Error bars representing the standard deviation of each parameter.\n# - The x-axis labeled with the Br content values from the 'concent' array.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# main code\ndef draw_halideconc_lat_density(Lconc, concent, output_file='output.png'):\n    Lgauss = np.empty((0, 3))\n    Lgaussstd = np.empty((0, 3))\n    for L in Lconc:\n        if L.ndim == 3:\n            L = L.reshape(L.shape[0] * L.shape[1], 3)\n\n        Mu, Std = [], []\n        for i in range(3):\n            dfil = L[:, i].copy()\n            dfil = dfil[~np.isnan(dfil)]\n            mu, std = norm.fit(dfil)\n            Mu.append(mu)\n            Std.append(std)\n\n\n        Lgauss = np.concatenate((Lgauss, np.array(Mu).reshape(1, -1)), axis=0)\n        Lgaussstd = np.concatenate((Lgaussstd, np.array(Std).reshape(1, -1)), axis=0)\n\n    plotx = np.array(concent)\n    dist_gap = 0.0005\n    scaalpha = 0.8\n    scasize = 50\n\n    plt.figure()\n    ax = plt.gca()\n\n    ax.scatter(plotx - 2 * dist_gap, Lgauss[:, 0], label='$\\\\mathit{a}$', alpha=scaalpha, s=scasize)\n    ax.errorbar(plotx - 2 * dist_gap, Lgauss[:, 0], yerr=Lgaussstd[:, 0], fmt='o', solid_capstyle='projecting',\n                capsize=5)\n    ax.scatter(plotx, Lgauss[:, 1], label='$\\\\mathit{b}$', alpha=scaalpha, s=scasize)\n    ax.errorbar(plotx, Lgauss[:, 1], yerr=Lgaussstd[:, 1], fmt='o', solid_capstyle='projecting', capsize=5)\n    ax.scatter(plotx + 2 * dist_gap, Lgauss[:, 2], label='$\\\\mathit{c}$', alpha=scaalpha, s=scasize)\n    ax.errorbar(plotx + 2 * dist_gap, Lgauss[:, 2], yerr=Lgaussstd[:, 2], fmt='o', solid_capstyle='projecting',\n                capsize=5)\n\n    ax.legend(prop={'size': 12})\n    ax.tick_params(axis='both', which='major', labelsize=14)\n    ax.set_ylabel('Lattice Parameter ($\\\\mathrm{\\\\AA}$)', fontsize=15)\n    ax.set_xlabel('Br content', fontsize=15)\n\n\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = np.random.randint(5, 11)\n        Lconc = np.random.rand(m, m, 3) * 10\n        concent = np.random.rand(m) * 100\n        test_cases.append((Lconc, concent))\n\n    return test_cases"}
{"problem_id": "matplotlib_66", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the evolution of spatial correlations over a series of steps. The function will generate a scatter plot based on the provided data and save the plot as an image file. \n\nFunction Signature:\n```python\ndef draw_tilt_corr_evolution_sca(T, steps, xaxis_type, scasize, y_lim, output_file='output.png'):\n```\n\n### Constants Used:\n- The constant `output_file` is set to `'output.png'` by default, which specifies the name of the file where the plot will be saved.\n\n### Input Format:\n- `T`: A 3D numpy array of shape (n_steps, n_samples, n_correlations) containing spatial correlation data.\n- `steps`: A 1D array or list of length `n_steps` representing the steps corresponding to the data in `T`.\n- `xaxis_type`: A string indicating the type of x-axis label ('N', 'T', or 't').\n- `scasize`: An integer representing the size of the scatter plot markers.\n- `y_lim`: A tuple or list specifying the limits for the y-axis (or `None` for automatic limits).\n- `output_file`: A string specifying the filename for saving the plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a scatter plot as an image file specified by `output_file`.\n\nInput:\n```python\nT = np.array([[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], \n               [[0.2, 0.3, 0.4], [0.5, 0.6, 0.7]], \n               [[0.3, 0.4, 0.5], [0.6, 0.7, 0.8]], \n               [[0.4, 0.5, 0.6], [0.7, 0.8, 0.9]]])\nsteps = np.array([0, 1, 2, 3])\nxaxis_type = 'N'\nscasize = 10.0\ny_lim = (0, 1)\n```\n\nOutput:\n```python\n# The function will generate a scatter plot saved as 'output.png' with:\n# - X-axis labeled as 'MD step'\n# - Y-axis labeled as 'Spatial correlation (a.u.)'\n# - Points colored as specified in the ground truth code\n# - Y-axis limits set to (0, 1)\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef draw_tilt_corr_evolution_sca(T, steps, xaxis_type, scasize, y_lim, output_file='output.png'):\n    plt.figure()\n    if T.shape[2] == 3:\n        colors = ['green', 'blue', 'red']\n        labels = ['$\\mathit{a}$', '$\\mathit{b}$', '$\\mathit{c}$']\n        for i in range(T.shape[1]):\n            for j, color, label in zip(range(3), colors, labels):\n                plt.scatter(steps, T[:, i, j], label=label if i == 0 else None, s=scasize, c=color)\n\n    elif T.shape[2] == 6:\n        colors = ['green', 'green', 'blue', 'blue', 'red', 'red']\n        labels = ['$\\mathit{a}$', None, '$\\mathit{b}$', None, '$\\mathit{c}$', None]\n        for i in range(T.shape[1]):\n            for j, color, label in zip(range(6), colors, labels):\n                plt.scatter(steps, T[:, i, j], label=label if i == 0 else None, s=scasize, c=color)\n\n    plt.legend()\n    ax = plt.gca()\n    if y_lim is not None:\n        ax.set_ylim(y_lim)\n    ax.set_yticks([])\n\n    x_labels = {'N': 'MD step', 'T': 'Temperature (K)', 't': 'Time (ps)'}\n    plt.xlabel(x_labels.get(xaxis_type, 'Time (ps)'))\n    plt.ylabel('Spatial correlation (a.u.)')\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        third_dim = random.choice([3, 6])\n        m = random.randint(10, 200)\n        n = random.randint(1, 10)\n        T = np.random.rand(m, n, third_dim)\n        steps = np.arange(m)\n        xaxis_type = random.choice(['N', 'T', 't'])\n        scasize = random.uniform(1.0, 50.0)\n        y_lim = random.choice([None, (random.uniform(0, 0.5), random.uniform(0.5, 1.0))])\n        test_cases.append((T, steps, xaxis_type, scasize, y_lim))\n\n    return test_cases"}
{"problem_id": "matplotlib_67", "library": "matplotlib", "code_problem": "You are tasked with visualizing a 3D domain using voxel representation based on certain features and indices. The main function to implement is as follows:\n\n```python\ndef vis3D_domain_frame(cfeat, ss, bin_indices, cmap, clbedge, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `ss`, which represents the size of the 3D grid.\n\n### Input and Output Format:\n- **Input Format**:\n  - `cfeat`: A 2D numpy array of shape `(n, 4)` where `n` is the number of features.\n  - `ss`: An integer representing the size of the grid.\n  - `bin_indices`: A 2D numpy array of shape `(3, m)` where `m` is the number of indices.\n  - `cmap`: A string representing the colormap to be used.\n  - `clbedge`: A float representing the color bar edge limit.\n  - `output_file`: A string representing the name of the output file.\n\n- **Output Format**:\n  - The function saves a 3D visualization of the voxel grid to a file specified by `output_file`. The output is a PNG image file containing the rendered 3D plot.\n\nInput:\n```python\ncfeat = np.array([[0.1, 0.2, 0.3, 0.4],\n                  [0.5, 0.6, 0.7, 0.8],\n                  [0.9, 1.0, 1.1, 1.2]])\nss = 10\nbin_indices = np.array([[1, 2, 3],\n                        [1, 2, 3],\n                        [10, 9, 8]])\ncmap = 'viridis'\nclbedge = 2.5\n```\n\nOutput:\n```python\n# The function vis3D_domain_frame will generate a 3D voxel plot saved as 'output.png'.\n# The output is a visual representation and cannot be directly printed as text.\n# However, the function will execute without errors given the input above.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef vis3D_domain_frame(cfeat, ss, bin_indices, cmap, clbedge, output_file='output.png'):\n    (x1, x2, x3) = np.indices((ss + 1, ss + 1, ss + 1))\n    grids = np.zeros((ss, ss, ss), dtype='bool')\n    selind = list(set(list(np.where(bin_indices[2, :] == ss)[0]) +\n                      list(np.where(bin_indices[0, :] == ss)[0]) +\n                      list(np.where(bin_indices[1, :] == 1)[0])))\n    sel = bin_indices[:, selind]\n    for i in range(len(selind)):\n        grids[sel[:, i][0] - 1, sel[:, i][1] - 1, sel[:, i][2] - 1] = True\n    cmval = np.empty((ss, ss, ss, 4))\n    for j in range(cfeat.shape[0]):\n        cmval[bin_indices[0, j] - 1, bin_indices[1, j] - 1, bin_indices[2, j] - 1, :] = cfeat[j, :]\n    plt.figure()\n    ax = plt.axes(projection='3d')\n    ax.voxels(x1, x2, x3, grids, facecolors=cmval)\n    ax.axis('off')\n    ax.set_aspect('auto')\n    clb = plt.colorbar(mappable=plt.cm.ScalarMappable(cmap=cmap, norm=plt.Normalize(vmin=-clbedge, vmax=clbedge)), ax=ax)\n    clb.set_label(label='Tilting (degree)')\n    plt.savefig(output_file, dpi=350)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        ss = np.random.randint(5, 20)\n        num_points = np.random.randint(10, ss**3 // 2)\n        cfeat = np.random.rand(num_points, 4)\n        bin_indices = np.random.randint(1, ss + 1, size=(3, num_points))\n        cmap = np.random.choice(['viridis', 'plasma', 'inferno', 'magma', 'cividis'])\n        clbedge = np.random.uniform(0.5, 5.0)\n        test_cases.append((cfeat, ss, bin_indices, cmap, clbedge))\n\n    return test_cases"}
{"problem_id": "matplotlib_68", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a plot of the polarization curve for a given set of cell current density and voltage data. The function will visualize the relationship between cell current density and voltage, highlighting specific boundaries and providing a linear approximation.\n\nFunction signature:\n```python\ndef plot_polarizationpts(CurrDensityMin, nc, Voltage, num, CellCurrDensity, iV1, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `output_path`, which defaults to `'output.png'`.\n\nInput format:\n- `CurrDensityMin`: A float representing the minimum current density.\n- `nc`: A float representing the scaling factor for cell voltage.\n- `Voltage`: A list or array of floats representing the cell voltage values.\n- `num`: An integer representing the number of points for the linear approximation.\n- `CellCurrDensity`: A list or array of floats representing the cell current density values.\n- `iV1`: A callable function that takes an array of current density values and returns corresponding voltage values.\n- `output_path`: A string representing the file path to save the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. It saves a plot as an image file at the specified `output_path`.\n\nInput:\n```python\nCurrDensityMin = 0.75\nnc = 3.2\nVoltage = np.array([0.8, 1.0, 1.2, 1.4, 1.1])\nCellCurrDensity = np.array([0.1, 0.5, 1.0, 1.5, 1.9])\nnum = 100\niV1 = interp1d(CellCurrDensity, Voltage, kind='linear', fill_value='extrapolate')\n```\n\nOutput:\n```python\n# The output will be a saved plot at 'output.png' showing:\n# - A scatter plot of the Voltage vs. CellCurrDensity\n# - A vertical line at CurrDensityMin (0.75)\n# - A dashed line representing the linear interpolation (iV1)\n# - A line representing Cell Voltage / nc\n# - A grid and legend indicating the various components of the plot\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_polarizationpts(CurrDensityMin, nc, Voltage, num, CellCurrDensity, iV1, output_path='output.png'):\n    x = np.linspace(min(CellCurrDensity), max(CellCurrDensity), num)\n\n    plt.figure(figsize=(5, 3.5))\n    plt.plot(CellCurrDensity, Voltage, label='Data', color='b', marker='.', linestyle='None',\n             mec='r', markersize=7, markerfacecolor='white', zorder=0)\n    plt.axvline(x=CurrDensityMin, color='b', linestyle=':', label='Lower Functioning Boundary',\n                zorder=3, linewidth=1.2)\n    plt.plot(x, iV1(x), label='Linear', linestyle='--')\n    plt.plot(x, iV1(x) / nc, color='steelblue', label='Cell Voltage / nc')\n    plt.axvline(x=CurrDensityMin, color='k', linestyle=':', label='CurDens$_\\\\mathregular{min}$',\n                zorder=3, linewidth=1.2)\n    plt.grid(alpha=0.5)\n    plt.legend(fontsize=8)\n\n    xlabel_text = 'Cell Current Density [A/m$^{2}$]'\n    plt.xlabel(xlabel_text)\n    plt.ylabel('Cell Voltage [V]')\n    plt.title('EL Polarization Curve - SplineInterp')\n\n    plt.savefig(output_path)\n    plt.close()\n", "test_script": "import numpy as np\nfrom scipy.interpolate import interp1d\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_points = np.random.randint(10, 100)\n        CellCurrDensity = np.sort(np.random.uniform(0, 2.0, size=num_points))\n        Voltage = np.random.uniform(0.5, 1.5, size=num_points)\n        CurrDensityMin = np.random.uniform(min(CellCurrDensity), max(CellCurrDensity))\n        nc = np.random.uniform(1, 5)\n        num = np.random.randint(50, 200)\n        iV1 = interp1d(CellCurrDensity, Voltage, kind='linear', fill_value='extrapolate')\n        test_cases.append((CurrDensityMin, nc, Voltage, num, CellCurrDensity, iV1))\n\n    return test_cases"}
{"problem_id": "matplotlib_69", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a Receiver Operating Characteristic (ROC) curve from actual and predicted binary classification results. The function should also save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef roc_plot(total_actual, total_predicted, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: A string that specifies the name of the file where the ROC curve plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `total_actual`: A list or array of binary values (0s and 1s) representing the actual labels.\n- `total_predicted`: A list or array of predicted probabilities or scores for the positive class.\n- `output_file`: A string representing the filename to save the ROC curve plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function saves a PNG file containing the ROC curve plot to the specified output file.\n\nInput:\n```python\ntotal_actual = np.array([0, 1, 1, 0, 1, 0, 1, 0, 0, 1])\ntotal_predicted = np.array([0.1, 0.4, 0.35, 0.8, 0.7, 0.2, 0.9, 0.6, 0.3, 0.5])\n```\n\nOutput:\n```python\n# The ROC curve will be saved as 'output.png' and the AUC will be calculated.\n# AUC: 0.75 (this value may vary based on the random predictions)\n``` \n\n(Note: The actual AUC value may vary depending on the random values generated for `total_predicted`.)", "ground_truth_code": "from sklearn.metrics import roc_curve, auc\nimport matplotlib.pyplot as plt\n\n# main code\ndef roc_plot(total_actual, total_predicted, output_file='output.png'):\n    fpr, tpr, _ = roc_curve(total_actual, total_predicted)\n    roc_auc = auc(fpr, tpr)\n\n    plt.figure(figsize=(5, 5))\n    plt.plot(fpr, tpr, color='darkorange', lw=2, label='ROC (area = %0.2f)' % roc_auc)\n    plt.plot([0, 1], [0, 1], color='navy', lw=2, linestyle='--')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.05])\n    plt.xlabel('False Positive Rate', fontsize=12)\n    plt.ylabel('True Positive Rate', fontsize=12)\n    plt.title('ROC curve', fontsize=12)\n    plt.legend(loc='lower right')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        array_length = random.randint(10, 1000)\n        total_actual = np.random.choice([0, 1], size=array_length)\n        total_predicted = np.random.rand(array_length)\n        test_cases.append((total_actual, total_predicted))\n\n    return test_cases"}
{"problem_id": "matplotlib_70", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the learning curve of a machine learning model by plotting the training, validation, and test accuracies over a series of epochs. The function should generate a line graph that clearly distinguishes between the training and validation accuracies, and it should save the resulting plot as an image file.\n\nFunction signature:\n```python\ndef learning_curve(train_accuracy, val_accuracy, test_accuracy, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `train_accuracy`: A list of floats representing the training accuracy at each epoch.\n- `val_accuracy`: A list of floats representing the validation accuracy at each epoch.\n- `test_accuracy`: A float representing the final test accuracy.\n- `output_file`: A string representing the name of the output file where the plot will be saved (optional).\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot image to the specified output file.\n\nInput:\n```python\ntrain_accuracy = np.array([0.50, 0.52, 0.55, 0.57, 0.60])\nval_accuracy = np.array([0.48, 0.50, 0.53, 0.54, 0.56])\ntest_accuracy = 0.58\n```\n\nOutput:\n```plaintext\nA plot is saved as 'output.png' showing:\n- Train accuracy (blue line) increasing from 0.50 to 0.60\n- Validation accuracy (red line) increasing from 0.48 to 0.56\n- Legend indicating final train accuracy: 0.60 and validation accuracy: 0.56, test accuracy: 0.58\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef learning_curve(train_accuracy, val_accuracy, test_accuracy, output_file='output.png'):\n    plt.figure(figsize=(5, 5))\n    plt.plot(train_accuracy, ls='-', color='blue', label=f'train_accuracy: {train_accuracy[-1]:.2f}')\n    plt.plot(val_accuracy, ls='-', color='red', label=f'val_acc: {val_accuracy[-1]:.2f} test_acc: {test_accuracy:.2f}')\n    plt.title('Learning Curve', fontsize=20)\n    plt.ylabel('Accuracy', fontsize=12)\n    plt.xlabel('Epoch', fontsize=12)\n    plt.legend(loc='lower right', fontsize=12)\n    plt.tight_layout()\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_epochs = random.randint(5, 100)\n        train_accuracy = np.clip(np.cumsum(np.random.randn(num_epochs) * 0.02 + 0.5), 0, 1)\n        val_accuracy = np.clip(np.cumsum(np.random.randn(num_epochs) * 0.02 + 0.5), 0, 1)\n        test_accuracy = round(random.uniform(0.5, 1.0), 2)\n\n        test_cases.append((train_accuracy, val_accuracy, test_accuracy))\n\n    return test_cases"}
{"problem_id": "matplotlib_71", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training and validation loss over epochs during the training of a machine learning model. The function should generate a plot that helps in understanding how the model's performance changes over time.\n\nFunction signature:\n```python\ndef loss_curve(total_val_loss, total_train_loss, figsize, train_color, val_color, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the output file where the plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `total_val_loss`: A list or array of validation loss values over epochs.\n- `total_train_loss`: A list or array of training loss values over epochs.\n- `figsize`: A tuple specifying the size of the figure (width, height).\n- `train_color`: A string representing the color for the training loss line.\n- `val_color`: A string representing the color for the validation loss line.\n- `output_file`: (optional) A string representing the filename to save the plot.\n\nOutput format:\n- The function does not return any value. It saves a plot as an image file to the specified output file.\n\nInput:\n```python\ntotal_train_loss = [0.5, 0.4, 0.3, 0.2, 0.1]\ntotal_val_loss = [0.6, 0.5, 0.4, 0.3, 0.2]\nfigsize = (8, 5)\ntrain_color = 'b'\nval_color = 'r'\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing the loss curves for training and validation losses over 5 epochs, with the training loss in blue dashed line and validation loss in red dashed line.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef loss_curve(total_val_loss, total_train_loss, figsize, train_color, val_color, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.plot(total_train_loss, ls='--', color=train_color, label='train_loss')\n    plt.plot(total_val_loss, ls='--', color=val_color, label='val_loss')\n    plt.title('Loss Curve', fontsize=20)\n    plt.ylabel('Loss', fontsize=12)\n    plt.xlabel('Epoch', fontsize=12)\n    plt.legend(loc='upper right', fontsize=12)\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_epochs = random.randint(10, 200)\n        total_train_loss = np.random.rand(num_epochs).tolist()\n        total_val_loss = np.random.rand(num_epochs).tolist()\n\n        figsize = (random.uniform(4, 12), random.uniform(3, 10))\n\n        colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', '#ff6347', '#4682b4']\n        train_color = random.choice(colors)\n        val_color = random.choice(colors)\n\n\n        test_cases.append((total_train_loss, total_val_loss, figsize, train_color, val_color))\n    return test_cases"}
{"problem_id": "matplotlib_72", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training and validation loss of a machine learning model over a series of epochs. The function will generate a plot that helps in analyzing the model's performance during training.\n\nFunction signature:\n```python\ndef plot_loss(train_loss, val_loss, expt_idx, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the file where the plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `train_loss`: A list or array of floating-point numbers representing the training loss values for each epoch.\n- `val_loss`: A list or array of floating-point numbers representing the validation loss values for each epoch.\n- `expt_idx`: An integer representing the index of the experiment.\n- `output_file`: (Optional) A string representing the filename to save the plot.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\n```python\n# Input\ntrain_loss = [0.01, 0.02, 0.015, 0.005, 0.003]\nval_loss = [0.02, 0.018, 0.017, 0.012, 0.008]\nexpt_idx = 42\n\n# Output\noutput_file = 'output.png'  # The plot will be saved as 'output.png'\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_loss(train_loss, val_loss, expt_idx, output_file='output.png'):\n    plt.figure()\n    plt.plot(train_loss, label='train loss')\n    plt.plot(val_loss, label='val loss')\n    plt.ylim([0.0, 0.05])\n    plt.xlabel('epochs')\n    plt.title(f'expt #{expt_idx}')\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_epochs = np.random.randint(10, 201)\n        train_loss = np.random.uniform(0.0, 0.05, num_epochs).tolist()\n        val_loss = np.random.uniform(0.0, 0.05, num_epochs).tolist()\n        expt_idx = np.random.randint(1, 1001)\n        test_cases.append((train_loss, val_loss, expt_idx))\n\n    return test_cases"}
{"problem_id": "matplotlib_73", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the zeros and poles of a transfer function in the complex plane. The function will plot these points and optionally include a unit circle if specified. The function signature is as follows:\n\n```python\ndef zeropole(b, a, zPlane, title, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the radius of the unit circle, which is set to 1.\n\n### Input Format:\n- The function takes in the following parameters:\n  - A list or array of coefficients for the numerator polynomial (`b`).\n  - A list or array of coefficients for the denominator polynomial (`a`).\n  - A boolean value (`zPlane`).\n  - A string for the title of the plot (`title`).\n  - An optional string for the output file name (`output_file`).\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file specified by `output_file`.\n\nInput:\n```python\nb = np.array([0.5, -1.2, 0.3])\na = np.array([1.0, -0.5, 0.2])\nzPlane = True\ntitle = \"Test Case 1\"\n```\n\nOutput:\n```plaintext\nZeros: [0.4+0.j 0.5+0.j]\nPoles: [2.5+0.j 0.2+0.j]\n```\n\nIn this example, the input consists of the coefficients for the numerator (`b`) and denominator (`a`) of a transfer function, a boolean indicating whether to plot in the z-plane (`zPlane`), and a title for the plot. The output shows the calculated zeros and poles based on the provided coefficients.", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef zeropole(b, a, zPlane, title, output_file='output.png'):\n    z = np.roots(b)\n    p = np.roots(a)\n\n    fig, ax = plt.subplots()\n    ax.set_aspect('equal')\n\n    ax.scatter(np.real(z), np.imag(z), marker='o', label='Zeros')\n    ax.scatter(np.real(p), np.imag(p), marker='x', label='Poles')\n\n    if zPlane:\n        circle1 = plt.Circle([0, 0], 1, facecolor='none', edgecolor='r')\n        ax.add_artist(circle1)\n        ax.set_xlim(-1.1, 1.1)\n        ax.set_ylim(-1.1, 1.1)\n        ax.set_xlabel('$\\Re(z)$')\n        ax.set_ylabel('$\\Im(z)$')\n    else:\n        ax.axhline(0, color='black', zorder=0)\n        ax.axvline(0, color='red', zorder=0)\n        ax.set_xlabel('$\\Re(s)$')\n        ax.set_ylabel('$\\Im(s)$')\n\n    ax.legend(loc=2)\n    ax.grid(True)\n    ax.set_title(title)\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\nimport string\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        degree_b = np.random.randint(1, 10)\n        degree_a = np.random.randint(1, 10)\n        b = np.random.randn(degree_b + 1)\n        a = np.random.randn(degree_a + 1)\n        zPlane = np.random.choice([True, False])\n        title = ''.join(random.choices(string.ascii_letters + string.digits, k=10))\n        test_cases.append((b, a, zPlane, title))\n    return test_cases"}
{"problem_id": "matplotlib_74", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a plot of volumetric soil moisture data over time for a given GNSS-IR soil moisture station. The function should allow for customization of the plot's appearance based on user input.\n\nFunction signature:\n```python\ndef vwc_plot(station, t_datetime, vwcdata, circles, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `0.5`, which is used to filter the volumetric soil moisture data.\n\n### Input Format:\n- The function takes in a string, an array of datetime objects, an array of floats, a boolean, and an optional string for the output filename.\n\n### Output Format:\n- The function does not return any value but saves a plot image to the specified output file.\n\nInput:\n```python\nstation = 'ST456'\nt_datetime = [datetime(2023, 1, 1) + timedelta(days=i) for i in range(10)]\nvwcdata = np.array([0.1, 0.2, 0.3, 0.6, -0.1, 0.4, 0.5, 0.7, 0.2, 0.3])\ncircles = True\n```\n\nOutput:\n```python\n# The output will be a plot saved as 'output.png' with the following characteristics:\n# - Title: 'GNSS-IR Soil Moisture Station ST456'\n# - Y-axis limits: 0 to 0.5\n# - Data points plotted as blue circles for valid vwcdata values (0.1, 0.2, 0.3, 0.4, 0.5, 0.2, 0.3)\n# - Invalid values (0.6, -0.1, 0.7) are represented as NaN and not plotted.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef vwc_plot(station, t_datetime, vwcdata, circles, output_file='output.png'):\n    vwcdata = np.where((vwcdata > 0.5) | (vwcdata < 0), np.nan, vwcdata)\n    plt.figure(figsize=(10, 6))\n    if circles:\n        plt.plot(t_datetime, vwcdata, 'bo')\n    else:\n        plt.plot(t_datetime, vwcdata, 'b-')\n        plt.plot(t_datetime, vwcdata, 'b.')\n\n    plt.title(f'GNSS-IR Soil Moisture Station {station.upper()}')\n    plt.ylim(0, 0.5)\n    plt.ylabel('Volumetric Soil Moisture')\n    plt.grid()\n    plt.gcf().autofmt_xdate()\n    plt.savefig(output_file)", "test_script": "import numpy as np\nfrom datetime import datetime, timedelta\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        station = f'ST{random.randint(100, 999)}'\n        start_date = datetime.now() - timedelta(days=random.randint(0, 365))\n        t_datetime = [start_date + timedelta(days=i) for i in range(random.randint(10, 100))]\n\n        vwcdata = np.random.uniform(-0.1, 0.6, len(t_datetime))\n        circles = random.choice([True, False])\n        test_cases.append((station, t_datetime, vwcdata, circles))\n\n    return test_cases\n\n"}
{"problem_id": "matplotlib_75", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of labeled segments along with a confidence line plot. The function will generate a bar chart for each label and overlay a confidence line that indicates the confidence levels associated with each label. The output will be saved as an image file.\n\nFunction signature:\n```python\ndef segment_bars_with_confidence(confidence, labels, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant value `0.3` is used to draw a horizontal red line on the confidence plot, representing a threshold for confidence.\n\nInput format:\n- `confidence`: A list of float values representing confidence levels.\n- `labels`: A list of strings representing the labels for each segment.\n- `output_file`: A string representing the name of the output image file (optional).\n\nOutput format:\n- The function saves an image file containing the visual representation of the segments and the confidence plot, but does not return any value.\n\nInput:\n```python\nconfidence = [0.1, 0.4, 0.6, 0.8, 0.3]\nlabels = [\n    [1, 2, 1, 0, 3],\n    [0, 1, 2, 3, 4],\n    [4, 3, 2, 1, 0]\n]\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' with 4 segmented bars representing the labels and a confidence line graph.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n\n# main code\ndef segment_bars_with_confidence(confidence, labels, output_file='output.png'):\n    num_pics = len(labels) + 1\n    color_map = plt.get_cmap('seismic')\n    barprops = dict(aspect='auto', cmap=color_map, interpolation='nearest', vmin=0)\n\n    fig = plt.figure(figsize=(15, num_pics * 1.5))\n    interval = 1 / (num_pics + 1)\n\n    for i, label in enumerate(labels, start=1):\n        ax = fig.add_axes([0, 1 - i * interval, 1, interval])\n        ax.imshow([label], **barprops)\n\n    ax_conf = fig.add_axes([0, interval, 1, interval])\n    ax_conf.set_xlim(0, len(confidence))\n    ax_conf.set_ylim(0, 1)\n    ax_conf.plot(range(len(confidence)), confidence)\n    ax_conf.plot(range(len(confidence)), [0.3] * len(confidence), color='red', label='0.5')\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        seq_length = random.randint(50, 500)\n        confidence = np.random.rand(seq_length).tolist()\n        num_labels = random.randint(2, 10)\n        labels = [np.random.randint(0, 5, seq_length).tolist() for _ in range(num_labels)]\n        test_cases.append((confidence, labels))\n\n    return test_cases"}
{"problem_id": "matplotlib_76", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the pointwise error between two sets of values: the true values and the predicted values. The function will generate a plot that displays the absolute error as a function of a given x-axis variable. The plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_pointwise_error(y_true, y_pred, x, figsize, y_scale, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the file where the plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `y_true`: A list or array of true values.\n- `y_pred`: A list or array of predicted values.\n- `x`: A list or array of x-axis values corresponding to the true and predicted values.\n- `figsize`: A tuple representing the size of the figure (width, height).\n- `y_scale`: A string indicating the scale of the y-axis ('linear' or 'log').\n- `output_file`: A string representing the name of the output file (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file to the specified output location.\n\nInput:\n```python\ny_true = np.array([1.5, 2.0, 3.5, 4.0, 5.5])\ny_pred = np.array([1.0, 2.5, 3.0, 4.5, 5.0])\nx = np.array([0, 1, 2, 3, 4])\nfigsize = (8, 6)\ny_scale = 'linear'\n```\n\nOutput:\n```python\n# This will generate a plot saved as 'output.png' showing the absolute errors:\n# Absolute errors: [0.5, 0.5, 0.5, 0.5, 0.5]\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_pointwise_error(y_true, y_pred, x, figsize, y_scale, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.plot(x, np.abs(y_true - y_pred))\n    plt.xscale('linear')\n    plt.yscale(y_scale)\n    plt.xlabel('x')\n    plt.ylabel('Absolute error')\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    possible_scales = ['linear', 'log', 'symlog', 'logit']\n\n    for i in range(n):\n        shape = np.random.randint(10, 1000)\n        y_true = np.random.rand(shape) * random.uniform(0.1, 100)\n        y_pred = np.random.rand(shape) * random.uniform(0.1, 100)\n        x = np.linspace(0, 10, shape)\n        figsize = (random.uniform(4, 12), random.uniform(4, 12))\n        y_scale = random.choice(possible_scales)\n        test_cases.append((y_true, y_pred, x, figsize, y_scale))\n\n    return test_cases"}
{"problem_id": "matplotlib_77", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a set of image samples and saves the resulting figure to a file. The function should be able to handle both color and grayscale images, and it should also have the option to preprocess the samples if they are in a specific format.\n\nFunction signature:\n```python\ndef data2fig(samples, nr, nc, channel, is_tanh, is_color, size, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `255`, which is used to scale the sample values when converting them from a range of [-1, 1] to [0, 255].\n\n### Input and Output Format:\n- **Input Format**: The function takes in a numpy array of samples and several parameters as described above.\n- **Output Format**: The function saves a figure as an image file (default is 'output.png') and does not return any value.\n\nInput:\n```python\nsamples = np.random.randn(4, 64, 64, 3).astype(np.float32)  # 4 samples, 64x64 size, 3 channels (color)\nnr = 2  # 2 rows\nnc = 2  # 2 columns\nchannel = 3  # color\nis_tanh = True  # apply tanh transformation\nis_color = True  # color images\nsize = 64  # size of each image\n```\n\nOutput:\n```python\noutput_file = 'output.png'  # The output file where the figure will be saved\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n# main code\ndef data2fig(samples, nr, nc, channel, is_tanh, is_color, size, output_file='output.png'):\n    if is_tanh:\n        samples = ((samples + 1) / 2 * 255).astype(np.uint8)\n\n    fig = plt.figure(figsize=(nr, nc))\n    gs = gridspec.GridSpec(nr, nc)\n    gs.update(wspace=0.05, hspace=0.05)\n\n    for i, sample in enumerate(samples):\n        ax = plt.subplot(gs[i])\n        plt.axis('off')\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_aspect('equal')\n        if is_color:\n            plt.imshow(sample.reshape(size, size, channel), cmap='Greys_r')\n        else:\n            plt.imshow(sample.reshape(size, size), cmap='Greys_r')\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nr = random.randint(1, 10)\n        nc = random.randint(1, 10)\n        size = random.choice([32, 64, 128])\n        channel = random.choice([1, 3])\n        is_tanh = random.choice([True, False])\n        is_color = channel == 3\n        sample_shape = (nr * nc, size, size, channel) if is_color else (nr * nc, size, size)\n        samples = np.random.randn(*sample_shape).astype(np.float32)\n        test_cases.append((samples, nr, nc, channel, is_tanh, is_color, size))\n\n    return test_cases"}
{"problem_id": "matplotlib_78", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a set of image samples by arranging them in a grid format. The function will take in several parameters to control the layout and appearance of the images. The function signature is as follows:\n\n```python\ndef data2fig(samples, nr, nc, channel, is_tanh, size, output_file='output.png'):\n```\n\n### Parameters:\n- `samples`: A list or array of image samples that need to be visualized.\n- `nr`: An integer representing the number of rows in the grid.\n- `nc`: An integer representing the number of columns in the grid.\n- `channel`: An integer indicating the number of color channels in the images (e.g., 1 for grayscale, 3 for RGB).\n- `is_tanh`: A boolean flag that indicates whether the input samples are scaled using the hyperbolic tangent function. If `True`, the samples will be transformed to a range of [0, 1].\n- `size`: An integer that specifies the width and height of each image in the grid (assuming square images).\n- `output_file`: A string representing the filename for saving the output image. The default value is 'output.png'.\n\n### Input Format:\n- The function accepts a list or array of samples, integers for rows and columns, an integer for channels, a boolean for normalization, an integer for size, and an optional string for the output filename.\n\n### Output Format:\n- The function saves a grid of images to a file specified by `output_file`. The output is a visual representation of the input samples arranged in a grid format.\n\nInput:\n```python\n(samples, nr, nc, channel, is_tanh, size) = (\n    np.array([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n              [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n              [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]]).astype(np.float32),\n    1, 3, 1, False, 2\n)\n```\n\nOutput:\n```python\n# The function will generate a figure with 1 row and 3 columns, displaying 3 grayscale images \n# (each of size 2x2) based on the provided samples. The output file will be saved as 'output.png'.\n``` \n\nNote: The actual output file 'output.png' will contain the visual representation of the input samples, but it cannot be displayed here as text.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\n\n# main code\ndef data2fig(samples, nr, nc, channel, is_tanh, size, output_file='output.png'):\n    if is_tanh:\n        samples = (samples + 1) / 2\n\n    fig = plt.figure(figsize=(nr, nc))\n    gs = gridspec.GridSpec(nr, nc)\n    gs.update(wspace=0.05, hspace=0.05)\n\n    for i, sample in enumerate(samples):\n        ax = plt.subplot(gs[i])\n        plt.axis('off')\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_aspect('equal')\n        plt.imshow(sample.reshape(size, size, channel), cmap='Greys_r')\n\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        nr = random.randint(1, 5)\n        nc = random.randint(1, 5)\n        channel = random.choice([1, 3])\n        size = random.randint(8, 64)\n        is_tanh = random.choice([True, False])\n        samples = np.random.rand(nr * nc, size * size * channel).astype(np.float32)\n\n\n        test_cases.append((samples, nr, nc, channel, is_tanh, size))\n\n    return test_cases"}
{"problem_id": "matplotlib_79", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a set of image samples in a grid format. The function will take in a list of samples, the dimensionality of each sample, the number of color channels, and an optional output file name to save the generated plot.\n\nFunction signature:\n```python\ndef plot(samples, X_dim, channel, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `output_file`, which defaults to `'output.png'`.\n\nInput format:\n- `samples`: A list or array of image samples, where each sample is a flattened array of pixel values.\n- `X_dim`: An integer representing the total number of pixels in each sample.\n- `channel`: An integer representing the number of color channels (e.g., 1 for grayscale, 3 for RGB).\n- `output_file`: A string representing the name of the output file where the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated plot as an image file specified by `output_file`.\n\nInput:\n```python\nsamples = np.array([[0.5, -0.2, 0.1, 0.3, -0.4, 0.6, -0.1, 0.2],\n                    [-0.3, 0.4, 0.5, -0.6, 0.1, -0.2, 0.3, 0.7]])\nX_dim = 8\nchannel = 1\n```\n\nOutput:\n```plaintext\nA grayscale image grid with 2 samples, each reshaped to 2x2, saved as 'output.png'.\n``` \n\n(Note: The actual output image cannot be displayed in this format, but it would be a PNG file containing the plotted samples.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport numpy as np\n\n# main code\ndef plot(samples, X_dim, channel, output_file='output.png'):\n    grid_size = int(np.ceil(np.sqrt(len(samples))))\n    fig = plt.figure(figsize=(grid_size, grid_size))\n    gs = gridspec.GridSpec(grid_size, grid_size)\n    gs.update(wspace=0.05, hspace=0.05)\n\n    dim1 = int(np.sqrt(X_dim))\n    samples = (samples + 1) / 2\n\n    for i, sample in enumerate(samples):\n        ax = plt.subplot(gs[i])\n        plt.axis('off')\n        ax.set_xticklabels([])\n        ax.set_yticklabels([])\n        ax.set_aspect('equal')\n\n        if channel == 1:\n            plt.imshow(sample.reshape([dim1, dim1]), cmap='gray')\n        else:\n            plt.imshow(sample.reshape([dim1, dim1, channel]))\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(1, 100)\n        dim1 = random.choice([8, 16, 32, 64, 128])\n        X_dim = dim1 ** 2\n        channel = random.choice([1, 3])\n        if channel == 1:\n            samples = np.random.rand(num_samples, X_dim) * 2 - 1\n        else:\n            samples = np.random.rand(num_samples, X_dim * channel) * 2 - 1\n        test_cases.append((samples, X_dim, channel))\n\n    return test_cases\n"}
{"problem_id": "matplotlib_80", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the loss values over a series of training batches. The function will generate a line plot using the Matplotlib library, which will help in analyzing the performance of a machine learning model during training.\n\nFunction Signature:\n```python\ndef plot_function(losses, ylabel, title, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- The input to the function consists of:\n  - A list of tuples `losses`, where each tuple contains two elements (batch number and loss value).\n  - A string `ylabel` for the y-axis label.\n  - A string `title` for the plot title.\n  - An optional string `output_file` for the output file name.\n\nOutput Format:\n- The function does not return any value. Instead, it generates and saves a plot as an image file in the specified format.\n\nInput:\n```python\nlosses = [(0, 2.5), (1, 3.0), (2, 1.5), (3, 4.0), (4, 2.0)]\nylabel = \"Loss\"\ntitle = \"Training Loss\"\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing the training loss over batches.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_function(losses, ylabel, title, output_file='output.png'):\n    plt.figure()\n    t = [x[0] for x in losses]\n    loss = [x[1] for x in losses]\n    plt.figure()\n    plt.plot(t, loss, 'b')\n    plt.xlabel('Batch #')\n    plt.ylabel(ylabel if ylabel else '')\n    plt.title(title)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = random.randint(10, 500)\n        t_values = list(range(num_points))\n        loss_values = [random.uniform(0.1, 10.0) for _ in range(num_points)]\n        losses = list(zip(t_values, loss_values))\n        ylabel = random.choice([\"Loss\", \"Error\", \"Cost\", None])\n        title = random.choice([\"Training Loss\", \"Validation Loss\", \"Test Error\", \"Model Performance\"])\n        test_cases.append((losses, ylabel, title))\n\n    return test_cases"}
{"problem_id": "matplotlib_81", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the original data, its reconstruction, and the residuals (the difference between the original data and the reconstruction). The function should generate a plot that displays these three components in a grid format and save the resulting figure to a specified output file.\n\nFunction signature:\n```python\ndef plot_1dreconstruct(data, recon, output_path='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `R = 3`, which represents the number of rows in the plot grid.\n\n### Input Format:\n- `data`: A tensor or array-like structure representing the original data.\n- `recon`: A tensor or array-like structure representing the reconstructed data.\n- `output_path`: A string representing the file path where the output image will be saved (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file at the specified output path.\n\nInput:\n```python\ndata = torch.tensor([[[ 0.1234, -1.2345,  2.3456, -0.4567,  1.5678, -3.6789,  0.9876, -2.3456,  1.2345, -0.1234]]])\nrecon = torch.tensor([[[ 0.2345, -1.3456,  2.4567, -0.5678,  1.6789, -3.7890,  1.0876, -2.4567,  1.3456, -0.2345]]])\n```\n\nOutput:\n```python\n# The output will be a saved plot at 'output.png' showing:\n# 1. The original data (data)\n# 2. The reconstructed data (recon)\n# 3. The residual (data - recon)\n# The plot will have 3 rows (Original, Reconstruction, Residual) and 1 column.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nfrom matplotlib import gridspec\n\n# main code\ndef plot_1dreconstruct(data, recon, output_path='output.png'):\n\n    res = data - recon\n    pl = [data, recon, res]\n    vmax = data.max().item()\n    vmin = data.min().item()\n\n    R, C = 3, min(data.size(0), 10)\n    plt.figure(figsize=(C + 1, R + 1), dpi=200)\n    gs = gridspec.GridSpec(R, C, wspace=0.0, hspace=0.0,\n                           top=1.0 - 0.5 / (R + 1),\n                           bottom=0.5 / (R + 1),\n                           left=0.5 / (C + 1),\n                           right=1 - 0.5 / (C + 1))\n\n    labs = ['Original', 'Reconstruction', 'Residual']\n    for r in range(R):\n        for c in range(C):\n            ax = plt.subplot(gs[r, c])\n            ax.plot(pl[r][c][0])\n            ax.set_ylim((vmin - 1, vmax))\n            ax.axis('off')\n            if c == 0:\n                ax.set_ylabel(labs[r])\n\n    plt.savefig(output_path)\n    plt.close()\n", "test_script": "import torch\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 21)\n        seq_len = np.random.randint(50, 201)\n\n        data = torch.randn(batch_size, 1, seq_len) * 5\n        recon = data + torch.randn_like(data) * 0.5\n\n        test_cases.append((data, recon))\n    return test_cases"}
{"problem_id": "matplotlib_82", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes one-dimensional filter data using Matplotlib. The function should plot the provided filter data, optionally include titles for each filter, and save the resulting plot to a specified output file.\n\nFunction signature:\n```python\ndef plot_1dfilts(filts, is_title, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- The function accepts a list of filters, a boolean for title display, a tuple for figure size, and an optional string for the output file name.\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output location.\n\nInput:\n```python\n(\n    [np.array([-3.5, 2.1, 0.0, 4.3, -1.2]), np.array([1.5, -2.3, 3.6, -4.0])],\n    True,\n    (6.5, 3.0)\n)\n```\n\nOutput:\n```python\n'output.png'  # The output file will be saved as 'output.png' with the plotted filters.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_1dfilts(filts, is_title, figsize, output_file='output.png'):\n    v_min = min((f.min() for f in filts))\n    v_max = max((f.max() for f in filts))\n    titles = ['lowpass', 'highpass'][:len(filts)]\n    plt.figure(figsize=figsize)\n    for (i, filt) in enumerate(filts):\n        plt.plot(filt, label=titles[i] if is_title else None)\n    plt.ylim((v_min - 1, v_max + 1))\n    plt.axis('off')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_filters = random.choice([1, 2])\n        filts = [np.random.uniform(-10, 10, size=random.randint(50, 300)) for _ in range(num_filters)]\n        is_title = random.choice([True, False])\n        figsize = (random.uniform(4, 10), random.uniform(2, 5))\n        test_cases.append((filts, is_title, figsize))\n    return test_cases"}
{"problem_id": "matplotlib_83", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a series of 1D filter responses using Matplotlib. The function should plot the filter responses on a single graph, allowing for optional titles and saving the output to a specified file.\n\nFunction signature:\n```python\ndef plot_1dfilts(filts, is_title, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- The function accepts a list of 1D arrays, a boolean, a tuple for figure size, and an optional string for the output file name.\n\n### Output Format:\n- The function saves a plot as an image file in the specified format (default is PNG) and does not return any value.\n\nInput:\n```python\n(\n    [array([-3.5,  2.1, -1.2,  4.3, -0.5]), array([ 1.0, -2.3,  3.5, -4.1,  0.2])],\n    True,\n    (6.5, 3.0)\n)\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' with two lines representing the lowpass and highpass filters, titled appropriately.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_1dfilts(filts, is_title, figsize, output_file='output.png'):\n    v_min = min(f.min() for f in filts)\n    v_max = max(f.max() for f in filts)\n\n    titles = ['lowpass', 'highpass'][:len(filts)]\n\n    plt.figure(figsize=figsize)\n    for i, filt in enumerate(filts):\n        plt.plot(filt, label=titles[i] if is_title else None)\n    plt.ylim((v_min - 1, v_max + 1))\n    plt.axis('off')\n    plt.legend()\n\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_filters = random.choice([1, 2])\n        filts = [np.random.uniform(-10, 10, size=random.randint(50, 300)) for _ in range(num_filters)]\n        is_title = random.choice([True, False])\n        figsize = (random.uniform(4, 10), random.uniform(2, 5))\n        test_cases.append((filts, is_title, figsize))\n\n    return test_cases"}
{"problem_id": "matplotlib_84", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes two images alongside a mask that highlights certain features in the images. The function will display the images and the mask in a single figure, allowing for easy comparison and analysis.\n\nFunction Signature:\n```python\ndef print_two_images(image1, image2, mask, labels, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the output file name, which defaults to `'output.png'`.\n\n### Input Format:\n- `image1`: A tensor representing the first image.\n- `image2`: A tensor representing the second image.\n- `mask`: A tensor representing the mask to be overlaid on the first image.\n- `labels`: A list of strings containing titles for the images.\n- `figsize`: A tuple specifying the size of the figure.\n- `output_file`: A string specifying the name of the output file (optional, defaults to 'output.png').\n\n### Output Format:\n- The function saves a visual representation of the two images and the mask to the specified output file. No return value is provided.\n\n**Input:**\n```python\nimage1 = torch.randn(1, 3, 256, 256)\nimage2 = torch.randn(1, 3, 256, 256)\nmask = np.random.rand(256, 256)\nlabels = [\"Label_42\", \"Label_17\"]\nfigsize = (12, 6)\n```\n\n**Output:**\n```python\n# The output will be a saved image file named 'output.png' containing:\n# - The first subplot showing image1 with the title \"Label_42\"\n# - The second subplot showing image2 with the title \"Label_17\"\n# - The third subplot showing image1 overlaid with the mask, titled \"mask\"\n# The actual visual output cannot be represented in text format.\n```", "ground_truth_code": "from matplotlib import gridspec\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef print_two_images(image1, image2, mask, labels, figsize, output_file='output.png'):\n    def minmax(image):\n        return (image - image.min()) / (image.max() - image.min())\n\n    gs = gridspec.GridSpec(1, 3, wspace=0.0, hspace=0.0)\n    plt.figure(figsize=figsize)\n    plt.tight_layout()\n\n    plt.subplot(gs[0, 0])\n    plt.axis('off')\n    plt.imshow(minmax(image1[0].detach().cpu().permute(1, 2, 0)))\n    plt.title(labels[0])\n\n    plt.subplot(gs[0, 1])\n    plt.axis('off')\n    plt.imshow(minmax(image2[0].detach().cpu().permute(1, 2, 0)))\n    plt.title(labels[1])\n\n    plt.subplot(gs[0, 2])\n    plt.imshow(minmax(image1[0]).detach().cpu().permute(1, 2, 0))\n    plt.imshow(mask, cmap='RdBu_r', vmin=0.03, vmax=0.14, alpha=0.8)\n    plt.axis('off')\n    plt.title('mask')\n    plt.colorbar()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import torch\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        H, W = np.random.randint(100, 500, size=2)\n        image1 = torch.randn(1, 3, H, W)\n        image2 = torch.randn(1, 3, H, W)\n        mask = np.random.rand(H, W)\n        labels = [f\"Label_{np.random.randint(100)}\", f\"Label_{np.random.randint(100)}\"]\n        figsize = (np.random.randint(10, 20), np.random.randint(4, 10))\n\n        test_cases.append((image1, image2, mask, labels, figsize))\n\n    return test_cases"}
{"problem_id": "matplotlib_85", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a set of images in a grid format using Matplotlib. The function should be able to handle a varying number of images and display them in a structured layout based on the total number of images provided. The function will also allow for the transposition of images and will save the resulting plot to a specified output file.\n\nFunction signature:\n```python\ndef plot_samples(X_images, img_height, img_width, figsize, transpose, output_file='output.png'):\n```\n\n### Constants:\n- The constant values used in the main code for determining the grid layout are:\n  - `samp_cnt`: This is set to 100 if there are 100 or more images, 64 if there are between 64 and 99 images, and 0 otherwise.\n\n### Input Format:\n- `X_images`: A 2D numpy array of shape (img_cnt, feature_cnt).\n- `img_height`: An integer representing the height of each image.\n- `img_width`: An integer representing the width of each image.\n- `figsize`: A tuple (width, height) representing the size of the figure.\n- `transpose`: A boolean indicating whether to transpose the images.\n- `output_file`: A string representing the name of the output file.\n\n### Output Format:\n- The function does not return any value. It saves the generated plot as an image file specified by `output_file`.\n\n**Input:**\n```python\nX_images = np.random.rand(64, 32 * 32)  # 64 images of size 32x32\nimg_height = 32\nimg_width = 32\nfigsize = (10, 10)\ntranspose = False\n```\n\n**Output:**\n```python\n# The function will generate a plot with 64 images arranged in an 8x8 grid,\n# and save it as 'output.png'. The title will be '64 out of 64 Samples'.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport matplotlib.gridspec as gridspec\nimport math\n\n\n# main code\ndef plot_samples(X_images, img_height, img_width, figsize, transpose, output_file='output.png'):\n    img_cnt, feature_cnt = X_images.shape\n    images = X_images\n    if img_cnt >= 100:\n        n_row, n_col, samp_cnt = 10, 10, 100\n    elif img_cnt >= 64:\n        n_row, n_col, samp_cnt = 8, 8, 64\n    else:\n        n_row, n_col, samp_cnt = 0, 0, 0\n\n    if img_cnt >= samp_cnt > 0:\n        samps = images[:samp_cnt]\n        plt.figure(figsize=figsize)\n        gs = gridspec.GridSpec(n_row, n_col, wspace=0.0, hspace=0.0)\n        for i in range(n_row):\n            for j in range(n_col):\n                ax = plt.subplot(gs[i, j])\n                idx = i * n_col + j\n                img = samps[idx].reshape(img_height, img_width)\n                if transpose:\n                    img = img.T\n                ax.imshow(img, interpolation='nearest')\n                ax.axis('off')\n        plt.suptitle(f'{samp_cnt} out of {img_cnt} Samples', size=12, x=0.515, y=0.935)\n    else:\n        samps = images\n        n_col = math.ceil(math.sqrt(img_cnt))\n        n_row = math.ceil(img_cnt / n_col)\n        fig = plt.figure(figsize=figsize)\n        for i in range(img_cnt):\n            ax = fig.add_subplot(n_row, n_col, i + 1)\n            img = samps[i].reshape(img_height, img_width)\n            if transpose:\n                img = img.T\n            ax.imshow(img, interpolation='nearest')\n            ax.axis('off')\n        plt.suptitle(f'All {img_cnt} Samples', size=12, x=0.518, y=0.935)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        img_cnt = random.randint(1, 200)\n        feature_cnt_options = [(28, 28), (32, 32), (64, 64), (100, 100)]\n        img_height, img_width = random.choice(feature_cnt_options)\n        X_images = np.random.rand(img_cnt, img_height * img_width)\n        figsize = (random.uniform(5, 15), random.uniform(5, 15))\n        transpose = random.choice([True, False])\n        test_cases.append((X_images, img_height, img_width, figsize, transpose))\n\n    return test_cases"}
{"problem_id": "matplotlib_86", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training and validation loss of a machine learning model over epochs. The function will generate a plot that helps in understanding how well the model is performing during training and validation phases.\n\nFunction signature:\n```python\ndef plot_train_vs_val_loss(skip_last, train_losses, val_losses, figsize, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- An integer `skip_last` indicating how many of the last entries to skip.\n- A list of floats `train_losses` representing the training loss values.\n- A list of floats `val_losses` representing the validation loss values.\n- A tuple `figsize` representing the dimensions of the plot (width, height).\n- An optional string `output_file` for the filename to save the plot.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\nInput:\n```python\nskip_last = 3\ntrain_losses = [0.1, 0.2, 0.15, 0.3, 0.25, 0.4, 0.35]\nval_losses = [0.2, 0.25, 0.3, 0.35, 0.4, 0.45, 0.5]\nfigsize = (8, 5)\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' \n# showing the train and validation losses, excluding the last 3 points.\n``` \n\n(Note: The actual visual output cannot be represented in text format, but the saved file will contain the plot as described.)", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_train_vs_val_loss(skip_last, train_losses, val_losses, figsize, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.plot(train_losses[:len(train_losses) - skip_last], label='train data')\n\n    plt.plot(val_losses[:len(val_losses) - skip_last], label='validation data')\n\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        seq_length = random.randint(10, 500)\n        skip_last = random.randint(0, seq_length - 1)\n        train_losses = np.random.uniform(0, 1, seq_length).tolist()\n        val_losses = np.random.uniform(0, 1, seq_length).tolist()\n        figsize = (random.uniform(4, 12), random.uniform(3, 8))\n        test_cases.append((skip_last, train_losses, val_losses, figsize))\n\n    return test_cases"}
{"problem_id": "matplotlib_87", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D array of data using a heatmap representation. The function should allow customization of the color map, axis limits, and whether to invert the y-axis. The output should be saved as an image file.\n\nFunction signature:\n```python\ndef plotimg(data, cmap, z, zact, vmax, invert, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `np.sqrt(3)`, which is utilized to calculate the extent of the y-axis in the plot.\n\nInput format:\n- `data`: A 2D numpy array representing the data to be visualized.\n- `cmap`: A string representing the color map to be used for the heatmap.\n- `z`: A float representing a value that influences the extent of the axes.\n- `zact`: A float representing the center value for the z-axis.\n- `vmax`: A float or None representing the maximum value for color scaling.\n- `invert`: A boolean indicating whether to invert the y-axis.\n- `output_file`: A string representing the name of the output image file (default is 'output.png').\n\nOutput format:\n- The function saves a heatmap image to the specified output file.\n\nInput:\n```python\ndata = np.array([[0.5, 0.2, 0.1], [0.3, 0.8, 0.6], [0.4, 0.9, 0.7]])\ncmap = 'viridis'\nz = 50.0\nzact = 100.0\nvmax = None\ninvert = False\n```\n\nOutput:\n```python\n# The output will be a saved image file named 'output.png' with the specified parameters.\n# The actual image cannot be displayed here, but it will be generated by the plotimg function.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plotimg(data, cmap, z, zact, vmax, invert, output_file='output.png'):\n    plt.figure()\n    extent_values = [zact - z, zact, z / np.sqrt(3), -z / np.sqrt(3)] if invert else [zact - z, zact, -z / np.sqrt(3),\n                                                                                      z / np.sqrt(3)]\n\n    plt.imshow(data, cmap=cmap, extent=extent_values, vmin=np.amin(data), vmax=np.amax(data) if vmax is None else vmax)\n\n    if invert:\n        plt.gca().invert_yaxis()\n\n    plt.xlabel('mm in z-direction')\n    plt.ylabel('mm in x-direction')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import matplotlib.pyplot as plt\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = (random.randint(10, 500), random.randint(10, 500))\n        data = np.random.rand(*shape) * random.uniform(0.1, 100.0)\n\n        cmap = random.choice(plt.colormaps())\n\n        z = random.uniform(0.1, 100.0)\n        zact = random.uniform(0.1, 200.0)\n        vmax = random.choice([None, np.amax(data) * random.uniform(0.5, 2.0)])\n        invert = random.choice([True, False])\n\n        test_cases.append((data, cmap, z, zact, vmax, invert))\n\n    return test_cases"}
{"problem_id": "matplotlib_88", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes energy data over a series of simulations. The function will generate a line graph using the Matplotlib library, where each line represents the energy values from different simulation runs.\n\nFunction signature:\n```python\ndef plot_graph(data, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `colors`: A list containing the colors `['blue', 'red', 'yellow', 'green', 'black']`, which will be used to differentiate the lines in the plot.\n\nInput format:\n- `data`: A list of lists, where each inner list contains numerical values representing energy measurements from different simulations.\n- `output_file`: A string (optional) representing the filename for saving the plot.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file with the specified filename.\n\nInput:\n```python\ndata = [\n    [10.5, 20.3, 30.1, 40.2, 50.0],\n    [15.0, 25.5, 35.5, 45.5, 55.5],\n    [5.0, 10.0, 15.0, 20.0, 25.0],\n    [12.0, 22.0, 32.0, 42.0, 52.0],\n    [8.0, 18.0, 28.0, 38.0, 48.0]\n]\noutput_file = 'test_output.png'\n```\n\nOutput:\n```python\n# A graph is saved as 'test_output.png' showing 5 lines with the specified data.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n\n# main code\ndef plot_graph(data, output_file='output.png'):\n    plt.figure()\n    x = list(range(len(data[0])))\n\n    colors = ['blue', 'red', 'yellow', 'green', 'black']\n    for idx, line_data in enumerate(data[:5]):\n        plt.plot(x, line_data, color=colors[idx], label=f'Line {idx + 1}')\n\n    plt.xlabel('Number of Simulations')\n    plt.ylabel('Energy')\n    plt.title('Energy through iteration')\n    plt.legend()\n\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(10, 1000)\n        num_lines = np.random.randint(1, 6)\n        data = [np.random.uniform(0, 100, size=num_points).tolist() for _ in range(num_lines)]\n        test_cases.append(data)\n\n    return test_cases"}
{"problem_id": "matplotlib_89", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D embedding of data points, where each point can be annotated with a label and optionally displayed with an associated image. The function should normalize the coordinates of the points, plot them on a scatter plot, and save the resulting visualization to a file.\n\nFunction signature:\n```python\ndef plot_embedding(X, y, imgs, title, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `10.0`, which is used for color mapping of the labels.\n\n### Input and Output Format:\n- **Input**:\n  - `X`: A 2D numpy array of shape (n_samples, 2) representing the coordinates of the points to be plotted.\n  - `y`: A 1D numpy array of shape (n_samples,) containing the labels for each point.\n  - `imgs`: A list or array of images corresponding to each point, or `None` if no images are to be displayed.\n  - `title`: A string representing the title of the plot.\n  - `output_file`: A string representing the filename to save the plot (default is 'output.png').\n\n- **Output**:\n  - The function does not return any value. Instead, it saves a visualization of the points with labels and images (if provided) to the specified output file.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.4, 0.5], [0.3, 0.8], [0.9, 0.1]])\ny = np.array([0, 1, 0, 1])\nimgs = np.random.rand(4, 8, 8)  # Random images for the points\ntitle = \"Test Case 1\"\n```\n\nOutput:\n```python\n# The function will generate a plot and save it as 'output.png'.\n# The output file will contain a scatter plot of the points with their corresponding labels and images.\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib import offsetbox\n\n# main code\ndef plot_embedding(X, y, imgs, title, output_file='output.png'):\n    x_min, x_max = np.min(X, 0), np.max(X, 0)\n    X = (X - x_min) / (x_max - x_min)\n\n    plt.figure(figsize=(10, 10))\n    ax = plt.subplot(111)\n\n    for i in range(X.shape[0]):\n        plt.text(X[i, 0], X[i, 1], str(y[i]),\n                 color=plt.cm.Set1(y[i] / 10.0),\n                 fontdict={'weight': 'bold', 'size': 9})\n\n    if imgs is not None and hasattr(offsetbox, 'AnnotationBbox'):\n        shown_images = np.array([[1.0, 1.0]])\n        for i in range(X.shape[0]):\n            dist = np.sum((X[i] - shown_images) ** 2, 1)\n            if np.min(dist) < 0.004:\n                continue\n            shown_images = np.r_[shown_images, [X[i]]]\n            imagebox = offsetbox.AnnotationBbox(\n                offsetbox.OffsetImage(imgs[i], cmap=plt.cm.gray_r),\n                X[i])\n            ax.add_artist(imagebox)\n\n    plt.xticks([])\n    plt.yticks([])\n\n    plt.title(title)\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(5, 501)\n        X = np.random.rand(num_points, 2).astype(np.float32)\n        y = np.random.randint(0, 10, size=(num_points,))\n        if np.random.rand() > 0.5:\n            imgs = np.random.rand(num_points, 8, 8)\n        else:\n            imgs = None\n        title = f\"Test Case {_ + 1}\"\n\n        test_cases.append((X, y, imgs, title))\n\n    return test_cases"}
{"problem_id": "matplotlib_90", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the distributions of data generated by a Generative Adversarial Network (GAN) alongside the real data and the decision boundary. The function will take in samples from the GAN, a specified range for the x-axis, and an optional output filename for saving the plot.\n\nFunction signature:\n```python\ndef plot_distributions(samps, sample_range, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- `samps`: A tuple containing three numpy arrays: (decision boundary, real data distribution, generated data distribution).\n- `sample_range`: A float or integer specifying the range for the x-axis.\n- `output_file`: A string specifying the filename to save the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function saves a plot as an image file in the specified format (e.g., PNG) to the location defined by `output_file`.\n\nInput:\n```python\n(((0.1, 0.5, 0.3, 0.7, 0.2), (0.4, 0.6, 0.8, 0.1, 0.9), (0.3, 0.2, 0.5, 0.4, 0.6)), 5.0)\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing:\n- Decision boundary represented by the line connecting points (0.1, 0.5), (0.5, 0.3), (0.3, 0.7), (0.7, 0.2)\n- Real data represented by the line connecting points (0.4, 0.6), (0.6, 0.8), (0.8, 0.1), (0.1, 0.9)\n- Generated data represented by the line connecting points (0.3, 0.2), (0.2, 0.5), (0.5, 0.4), (0.4, 0.6)\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_distributions(samps, sample_range, output_file='output.png'):\n    db, pd, pg = samps\n    db_x = np.linspace(-sample_range, sample_range, len(db))\n    p_x = np.linspace(-sample_range, sample_range, len(pd))\n    fig, ax = plt.subplots(1)\n    ax.plot(db_x, db, label='decision boundary')\n    ax.set_ylim(0, 1)\n    ax.plot(p_x, pd, label='real data')\n    ax.plot(p_x, pg, label='generated data')\n    plt.title('1D Generative Adversarial Network')\n    plt.xlabel('Data values')\n    plt.ylabel('Probability density')\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sample_size = random.randint(50, 500)\n\n        db = np.random.rand(sample_size)\n        pd = np.random.rand(sample_size)\n        pg = np.random.rand(sample_size)\n        sample_range = random.uniform(1, 10)\n        test_cases.append(((db, pd, pg), sample_range))\n\n    return test_cases"}
{"problem_id": "matplotlib_91", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates and saves a precision-recall curve plot based on given precision and recall values for different methods. The function should allow customization of line styles and widths for each method, and it should save the resulting plot to a specified output file.\n\nFunction signature:\n```python\ndef plot_save_pr_curves(PRE, REC, method_names, line_styles, linewidths, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `PRE`: A list of lists or arrays containing precision values for different methods.\n- `REC`: A list of lists or arrays containing recall values for different methods.\n- `method_names`: A list of strings representing the names of the methods corresponding to the precision and recall values.\n- `line_styles`: A list of strings representing the line styles for each method in the plot.\n- `linewidths`: A list of numerical values representing the widths of the lines for each method.\n- `output_file`: A string representing the name of the file to which the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file in the specified format (e.g., PNG) to the location defined by `output_file`.\n\n**Input:**\n```python\nPRE = [\n    np.array([0.9, 0.8, 0.7, 0.6, 0.5]),\n    np.array([0.85, 0.75, 0.65, 0.55, 0.45])\n]\nREC = [\n    np.array([0.1, 0.2, 0.3, 0.4, 0.5]),\n    np.array([0.15, 0.25, 0.35, 0.45, 0.55])\n]\nmethod_names = ['Method_A', 'Method_B']\nline_styles = ['-', '--']\nlinewidths = [2.0, 1.5]\noutput_file = 'test_output.png'\n```\n\n**Output:**\n```python\n# This will generate a plot saved as 'test_output.png' with the specified precision and recall curves for Method_A and Method_B.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_save_pr_curves(PRE, REC, method_names, line_styles, linewidths, output_file='output.png'):\n    plt.figure(figsize=(8, 6))\n\n    for precision, recall, style, width, method in zip(PRE, REC, line_styles, linewidths, method_names):\n        if np.array(precision).ndim != 0:\n            plt.plot(recall, precision, style, linewidth=width, label=method)\n\n    plt.xlim(0.0, 1.0)\n    plt.ylim(0.0, 1.0)\n    xyrange = np.linspace(0.0, 1.0, 11)\n\n    plt.tick_params(direction='in')\n    plt.xticks(xyrange, fontsize=15, fontname='serif')\n    plt.yticks(xyrange, fontsize=15, fontname='serif')\n\n    plt.text(0.5, 0.02, 'Dataset', ha='center', fontsize=20, fontname='serif', fontweight='bold')\n    plt.xlabel('Recall', fontsize=20, fontname='serif')\n    plt.ylabel('Precision', fontsize=20, fontname='serif')\n    plt.legend(loc='lower left', fontsize=7)\n\n    plt.grid(linestyle='--')\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    line_styles_options = ['-', '--', '-.', ':']\n\n    for _ in range(n):\n        num_methods = random.randint(1, 10)\n        array_length = random.randint(5, 100)\n        PRE = [np.sort(np.random.rand(array_length)[::-1]) for _ in range(num_methods)]\n        REC = [np.sort(np.random.rand(array_length)) for _ in range(num_methods)]\n        method_names = [f'Method_{i}' for i in range(num_methods)]\n        line_styles = random.choices(line_styles_options, k=num_methods)\n        linewidths = [random.uniform(0.5, 3.0) for _ in range(num_methods)]\n        test_cases.append((PRE, REC, method_names, line_styles, linewidths))\n\n    return test_cases"}
{"problem_id": "matplotlib_92", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a 2D embedding of data points, where each point is labeled and colored based on a specific value. The function will normalize the input data, plot the points, and save the resulting visualization to a file.\n\nFunction signature:\n```python\ndef plot_embedding(X, y, d, title=None, output_file='output.png'):\n```\n\n### Constants:\n- The constant `1.0` is used in the color mapping for the data points.\n\n### Input Format:\n- The function accepts a 2D numpy array `X`, a list or array `y`, a list or array `d`, an optional string `title`, and an optional string `output_file`.\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot image to the specified output file.\n\nInput:\n```python\nX = np.array([[0.1, 0.2], [0.4, 0.5], [0.3, 0.8], [0.6, 0.1]])\ny = np.array([0, 1, 2, 3])\nd = np.array([0.1, 0.5, 0.9, 0.3])\ntitle = 'Test Plot'\n```\n\nOutput:\nThe function `plot_embedding(X, y, d, title)` will generate a plot saved as 'output.png' with the following characteristics:\n- Points will be plotted at coordinates (0.1, 0.2), (0.4, 0.5), (0.3, 0.8), and (0.6, 0.1).\n- The text labels will be 0, 1, 2, and 3 corresponding to each point.\n- The colors of the text will be determined by the values in `d`, mapped through the `bwr` colormap.\n- The title of the plot will be 'Test Plot'.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_embedding(X, y, d, title=None, output_file='output.png'):\n\n    X = (X - np.min(X, axis=0)) / (np.max(X, axis=0) - np.min(X, axis=0))\n\n    plt.figure(figsize=(10, 10))\n    ax = plt.subplot(111)\n\n    for i in range(X.shape[0]):\n        plt.text(X[i, 0], X[i, 1], str(y[i]),\n                 color=plt.cm.bwr(d[i] / 1.0),\n                 fontdict={'weight': 'bold', 'size': 9})\n\n    plt.xticks([])\n    plt.yticks([])\n\n    if title:\n        plt.title(title)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(10, 501)\n        X = np.random.rand(num_points, 2)\n        y = np.random.randint(0, 10, size=num_points)\n        d = np.random.rand(num_points)\n        title = np.random.choice([None, 'Sample Title'])\n        test_cases.append((X, y, d, title))\n\n    return test_cases"}
{"problem_id": "matplotlib_93", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the cumulative durations of two sets of data, along with associated text labels and a mel spectrogram. The function will generate a plot that displays vertical lines representing the cumulative durations, with the text labels positioned accordingly. Additionally, a mel spectrogram will be displayed in the background of the plot.\n\nFunction signature:\n```python\ndef dur_to_figure(dur_gt, dur_pred, txt, mels, vmin, vmax, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant `8` is used to determine the vertical shift for the text labels in the plot.\n\nInput format:\n- `dur_gt`: A list or array of ground truth durations.\n- `dur_pred`: A list or array of predicted durations.\n- `txt`: A list of text labels corresponding to each duration.\n- `mels`: A 2D array representing the mel spectrogram data.\n- `vmin`: A scalar value representing the minimum value for the colormap.\n- `vmax`: A scalar value representing the maximum value for the colormap.\n- `output_file`: A string representing the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file with the name specified by `output_file`.\n\n**Input:**\n```python\ndur_gt = np.array([5, 10, 15])\ndur_pred = np.array([6, 12, 14])\ntxt = ['A', 'B', 'C']\nmels = np.random.random((80, 31))  # Example mel spectrogram\nvmin = np.min(mels)\nvmax = np.max(mels)\n```\n\n**Output:**\n```python\n# This will generate a figure saved as 'output.png' with the specified parameters.\n# The figure will have blue vertical lines at dur_gt positions and red vertical lines at dur_pred positions,\n# with text labels 'A', 'B', 'C' positioned accordingly.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef dur_to_figure(dur_gt, dur_pred, txt, mels, vmin, vmax, output_file='output.png'):\n    dur_gt = np.cumsum(dur_gt).astype(int)\n    dur_pred = np.cumsum(dur_pred).astype(int)\n\n    fig = plt.figure(figsize=(12, 6))\n    for i in range(len(dur_gt)):\n        shift = i % 8 + 1\n        plt.text(dur_gt[i], shift * 4, txt[i])\n        plt.text(dur_pred[i], 40 + shift * 4, txt[i])\n        plt.vlines(dur_gt[i], 0, 40, colors='b')\n        plt.vlines(dur_pred[i], 40, 80, colors='r')\n\n    plt.xlim(0, max(dur_gt[-1], dur_pred[-1]))\n\n    plt.pcolor(mels, vmin=vmin, vmax=vmax)\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport string\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dur_gt = np.sort(np.random.randint(1, 50, size=random.randint(5, 20))).astype(int)\n        dur_pred = np.sort(np.random.randint(1, 50, size=len(dur_gt))).astype(int)\n        txt = [''.join(random.choices(string.ascii_letters, k=random.randint(1, 5)))\n               for _ in range(len(dur_gt))]\n        mel_height = 80\n        mel_width = max(dur_gt[-1], dur_pred[-1]) + 10\n        mels = np.random.random((mel_height, mel_width))\n        vmin = np.min(mels)\n        vmax = np.max(mels)\n        test_cases.append((dur_gt, dur_pred, txt, mels, vmin, vmax))\n\n    return test_cases"}
{"problem_id": "matplotlib_94", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the performance of two stock strategies using a stacked bar chart. The function will take in a DataFrame containing stock data and generate a plot that compares the total performance of Microsoft (MSFT) and Google (GOOG) stocks based on a specified gain for each strategy.\n\nFunction Signature:\n```python\ndef plot_strategies(df, output_file='output.png'):\n```\n\nConstant used in the main code:\n- `bar_width`: This constant is set to `0.5` and defines the width of the bars in the bar chart.\n\nInput Format:\n- The input to the function is a DataFrame `df` that must contain the following columns: 'MSFT', 'GOOG', 'gain', and 'strategyName'.\n\nOutput Format:\n- The output of the function is a saved image file (default 'output.png') that contains the stacked bar chart visualizing the performance of the two stock strategies.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'strategyName': ['STRAT1', 'STRAT2', 'STRAT3'],\n    'MSFT': [100, 200, 150],\n    'GOOG': [300, 400, 350],\n    'gain': [1.5, 1.2, 1.8]\n}\n\ndf = pd.DataFrame(data)\n```\n\n**Output:**\nThe output will be a bar chart saved as 'output.png' with the following characteristics:\n- The x-axis will have the strategy names 'STRAT1', 'STRAT2', 'STRAT3'.\n- The y-axis will represent the total rank calculated as `MSFT_tot` and `GOOG_tot`.\n- The bars for 'MSFT' will be in blue and stacked with the bars for 'GOOG' in red.\n- The total values for `MSFT_tot` and `GOOG_tot` will be:\n  - For STRAT1: MSFT_tot = 100 * 1.5 * 100 = 15000, GOOG_tot = 300 * 1.5 * 100 = 45000\n  - For STRAT2: MSFT_tot = 200 * 1.2 * 100 = 24000, GOOG_tot = 400 * 1.2 * 100 = 48000\n  - For STRAT3: MSFT_tot = 150 * 1.8 * 100 = 27000, GOOG_tot = 350 * 1.8 * 100 = 63000\n\nThe resulting chart will visually represent these values.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_strategies(df, output_file='output.png'):\n    fig, ax1 = plt.subplots(1, figsize=(10, 10))\n\n    bar_width = 0.5\n    bar_l = [i + 1 for i in range(len(df['MSFT']))]\n    tick_pos = [i + bar_width / 2 - 0.25 for i in bar_l]\n\n    df['MSFT_tot'] = df['MSFT'] * df['gain'] * 100\n    df['GOOG_tot'] = df['GOOG'] * df['gain'] * 100\n\n    ax1.bar(bar_l, df['MSFT_tot'], width=bar_width, label='MSFT', alpha=0.8, color='#48B0F7')\n    ax1.bar(bar_l, df['GOOG_tot'], width=bar_width, bottom=df['MSFT_tot'], label='GOOG', alpha=0.8, color='#F55753')\n\n    ax1.set_xticks(tick_pos)\n    ax1.set_xticklabels(df['strategyName'])\n    ax1.set_ylabel('Rank')\n    ax1.set_xlabel('Strategy')\n    plt.legend(loc='upper right')\n    plt.xlim([min(tick_pos) - bar_width, max(tick_pos) + bar_width])\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import pandas as pd\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_strategies = random.randint(5, 50)\n        strategy_names = [\"\".join(random.choices(string.ascii_uppercase, k=5)) for _ in range(num_strategies)]\n        df = pd.DataFrame({\n            'strategyName': strategy_names,\n            'MSFT': [random.uniform(10, 500) for _ in range(num_strategies)],\n            'GOOG': [random.uniform(10, 500) for _ in range(num_strategies)],\n            'gain': [random.uniform(0.5, 2.0) for _ in range(num_strategies)]\n        })\n\n        test_cases.append(df)\n\n    return test_cases"}
{"problem_id": "matplotlib_95", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training error over iterations of a machine learning model. The function will generate a line plot using the provided error data and save it as an image file.\n\nFunction signature:\n```python\ndef plot_history(data, figsize, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the output file where the plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `data`: A list or array of numerical values (floats or integers).\n- `figsize`: A tuple of two integers representing the width and height of the figure in inches.\n- `output_file`: A string representing the filename for the output image (optional).\n\nOutput format:\n- The function does not return any value. Instead, it saves the plot as an image file in the specified location.\n\n```python\n# Input\ndata = [0.1, 0.2, 0.15, 0.3, 0.25]\nfigsize = (6.5, 4.0)\n\n# Output\noutput_file = 'output.png'  # The plot will be saved as 'output.png'\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_history(data, figsize, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.plot(data)\n    plt.ylabel('Error')\n    plt.xlabel('Iteration')\n    plt.title('Training Error')\n    plt.savefig(output_file)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = np.random.random(np.random.randint(50, 501))\n\n        figsize = (np.random.uniform(4, 10), np.random.uniform(3, 8))\n\n\n        test_cases.append((data, figsize))\n    return test_cases"}
{"problem_id": "matplotlib_96", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes a set of data points in a scatter plot. The function will take in a 2D array of data points, along with specified limits for the x and y axes, and will save the resulting plot to a file.\n\nFunction signature:\n```python\ndef data_plot(x, xlim, ylim, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `x`: A 2D numpy array of shape (n, m) where n is the number of data points and m is the number of dimensions (at least 2).\n- `xlim`: A tuple or list of two values specifying the limits for the x-axis (min, max).\n- `ylim`: A tuple or list of two values specifying the limits for the y-axis (min, max).\n- `output_file`: A string specifying the name of the output file where the plot will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. It saves a scatter plot as an image file to the specified output file.\n\nInput:\n```python\nx = np.array([[ 0.49671415, -0.1382643 ],\n              [ 0.64768854,  1.52302986],\n              [-0.23415337, -0.23413696],\n              [ 1.57921282,  0.76743473],\n              [ 0.54256004, -0.46341769]])\nxlim = (-1.0, 2.0)\nylim = (-1.0, 2.0)\n```\n\nOutput:\n```plaintext\nA scatter plot is generated and saved as 'output.png' with the title '5 time steps'.\n```", "ground_truth_code": "from matplotlib import pyplot as plt\n\n# main code\ndef data_plot(x, xlim, ylim, output_file='output.png'):\n    plt.figure()\n    plt.ylim(ylim)\n    plt.xlim(xlim)\n    plt.scatter(x[:, 0], x[:, -1], s=3)\n    plt.title('{} time steps'.format(len(x)))\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(50, 500)\n        num_features = np.random.randint(2, 5)\n        x = np.random.randn(num_points, num_features)\n\n        xlim = (x[:, 0].min() - 1, x[:, 0].max() + 1)\n        ylim = (x[:, -1].min() - 1, x[:, -1].max() + 1)\n\n        test_cases.append((x, xlim, ylim))\n\n    return test_cases"}
{"problem_id": "matplotlib_97", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a box plot to visualize the accuracy of different methods based on provided accuracy data. The function should take a list of accuracy values and save the resulting plot as an image file.\n\nFunction Signature:\n```python\ndef acc_graph(acc_list, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput Format:\n- The input to the function is a list of numerical values representing accuracy percentages for different methods.\n\nOutput Format:\n- The output of the function is a saved image file (PNG format) containing the box plot visualizing the accuracy data. The file name can be specified by the user or defaults to 'output.png'.\n\nInput:\n```python\nacc_list = [\n    [45.2, 67.8, 55.1, 80.0, 60.5],  # M1\n    [70.0, 75.5, 80.2, 65.3],        # M2\n    [90.0, 85.5, 88.0, 92.5, 78.0]   # M3\n]\n```\n\nOutput:\nThe function `acc_graph(acc_list, output_file='output.png')` generates a boxplot and saves it as 'output.png'. The boxplot will display the accuracy distributions for three methods (M1, M2, M3) based on the provided accuracy lists.", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef acc_graph(acc_list, output_file='output.png'):\n\n    fig, ax = plt.subplots()\n    ax.boxplot(acc_list, showmeans=True)\n\n    methods = ['M1', 'M2', 'M3']\n    ax.set_xticks([1, 2, 3])\n    ax.set_xticklabels(methods, fontsize=18)\n\n    ax.set_ylabel('Accuracy [%]', fontsize=18)\n    ax.set_yticks([0, 20, 40, 60, 80, 100])\n    ax.set_ylim([0, 100])\n    ax.yaxis.grid(True)\n\n    plt.tight_layout()\n    fig.savefig(output_file)", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = [random.randint(5, 50) for _ in range(3)]\n        acc_list = [\n            np.random.uniform(0, 100, size=num_samples[i]).tolist()\n            for i in range(3)\n        ]\n\n        test_cases.append(acc_list)\n    return test_cases"}
{"problem_id": "matplotlib_98", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes ECG (electrocardiogram) data over time, highlighting specific segments of interest based on a given binary array. The function should generate a plot that displays the ECG values and marks the areas of interest.\n\nFunction signature:\n```python\ndef visualize(X, Y, output_path='output.png'):\n```\n\nIn this function:\n- `X` is a list or array of ECG values representing the signal over time.\n- `Y` is a binary list or array where a value of `1` indicates a segment of interest in the ECG data, and `0` indicates non-interest segments.\n- `output_path` is a string that specifies the file path where the generated plot will be saved. The default value is 'output.png'.\n\nThe constant used in the main code is:\n- The default output file name: `'output.png'`.\n\nInput format:\n- `X`: A list or array of numerical values representing the ECG signal.\n- `Y`: A binary list or array of the same length as `X`, indicating segments of interest.\n\nOutput format:\n- The function saves a plot as an image file at the specified `output_path`. The function does not return any value.\n\nInput:\n```python\nX = np.array([ 0.17640523,  0.04001572,  0.0978738 ,  0.22408932,  0.1867558 ,\n               0.40227221,  0.40015721,  0.19831507,  0.19831507,  0.17640523,\n               0.04001572,  0.0978738 ,  0.22408932,  0.1867558 ,  0.40227221,\n               0.40015721,  0.19831507,  0.19831507,  0.17640523,  0.04001572])\nY = np.array([0, 0, 0, 0, 0, 1, 1, 1, 1, 0,\n              0, 0, 0, 0, 0, 0, 0, 0, 0, 0])\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing the ECG signal with an anomaly highlighted between indices 5 and 8.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef visualize(X, Y, output_path='output.png'):\n    plt.style.use('ggplot')\n    plt.figure(figsize=(15, 5))\n    plt.xlabel('time')\n    plt.ylabel(\"ECG's value\")\n    plt.plot(np.arange(len(X)), X, color='b')\n    plt.ylim(min(X) - 1, max(X) + 1)\n\n    x = np.where(Y == 1)[0]\n    y1 = [min(X) - 1] * len(x)\n    y2 = [max(X) + 1] * len(x)\n    plt.fill_between(x, y1, y2, facecolor='g', alpha=0.3)\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        signal_length = random.randint(500, 2000)\n        X = np.sin(np.linspace(0, 4 * np.pi, signal_length))\n        X += np.random.normal(0, 0.1, signal_length)\n        Y = np.zeros(signal_length, dtype=int)\n        anomaly_count = random.randint(1, 10)\n        for _ in range(anomaly_count):\n            start = random.randint(0, signal_length - 50)\n            end = min(start + random.randint(5, 50), signal_length)\n            Y[start:end] = 1\n\n        test_cases.append((X, Y))\n\n    return test_cases"}
{"problem_id": "matplotlib_99", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the training and validation loss of a machine learning model over the last few epochs. The function will generate a plot that helps in understanding the model's performance during the training process.\n\nFunction signature:\n```python\ndef plot_train_vs_val_loss_last_epochs(train_losses, val_losses, figsize, show_last, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `train_losses`: A list of floating-point numbers representing the training losses.\n- `val_losses`: A list of floating-point numbers representing the validation losses.\n- `figsize`: A tuple of two integers representing the width and height of the figure.\n- `show_last`: An integer representing the number of last epochs to display.\n- `output_file`: A string representing the filename to save the plot (optional).\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\nInput:\n```python\ntrain_losses = [0.1, 0.2, 0.15, 0.05, 0.03, 0.02, 0.01]\nval_losses = [0.12, 0.18, 0.14, 0.06, 0.04, 0.03, 0.02]\nfigsize = (8, 6)\nshow_last = 5\noutput_file = 'test_output.png'\n```\n\nOutput:\n```python\n# The function will save a plot to 'test_output.png' showing the last 5 epochs of train and validation losses.\n``` \n\n(Note: The actual output file cannot be displayed here, but it will contain a plot with the specified data.)", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_train_vs_val_loss_last_epochs(train_losses, val_losses, figsize, show_last, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    plt.plot(train_losses[-show_last:], label='train data')\n    plt.plot(val_losses[-show_last:], label='validation data')\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        seq_length = random.randint(50, 500)\n        train_losses = np.random.random(seq_length).tolist()\n        val_losses = np.random.random(seq_length).tolist()\n        show_last = random.randint(1, seq_length)\n        figsize = (random.uniform(4, 12), random.uniform(4, 12))\n        test_cases.append((train_losses, val_losses, figsize, show_last))\n\n    return test_cases"}
{"problem_id": "matplotlib_100", "library": "matplotlib", "code_problem": "You are tasked with implementing a function that generates and saves a plot of a low-pass filter's frequency response. The function should allow for two different shapes of the filter response: triangular and rectangular (line). The triangular response is defined by a linear decrease in magnitude from a maximum value to zero, while the rectangular response is defined by vertical lines at specified frequencies.\n\nFunction Signature:\n```python\ndef lp_samp(fb, fs, fmax, N, shape, fsize, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `400`, which defines the number of points in the frequency range for plotting.\n\n### Input Format:\n- The function takes the following parameters:\n  - `fb`: float\n  - `fs`: float\n  - `fmax`: float\n  - `N`: int\n  - `shape`: str\n  - `fsize`: tuple of (width, height)\n  - `output_file`: str (optional)\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file with the name specified in `output_file`.\n\nInput:\n```python\nfb = 3.25\nfs = 2.10\nfmax = 50.00\nN = 5\nshape = 'tri'\nfsize = (6, 5)\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing a triangular low-pass filter with frequency cutoff at 3.25 Hz, and 5 additional shifted filters at intervals of 2.10 Hz.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n\ndef lp_tri(f, fb):\n    x = np.zeros(len(f))\n    for k in range(len(f)):\n        if abs(f[k]) <= fb:\n            x[k] = 1 - abs(f[k]) / float(fb)\n    return x\n\n# main code\ndef lp_samp(fb, fs, fmax, N, shape, fsize, output_file='output.png'):\n    plt.figure(figsize=fsize)\n    f = np.linspace(-fmax, fmax, 400)\n\n    if shape.lower() == 'tri':\n        plt.plot(f, lp_tri(f, fb))\n        for n in range(N):\n            plt.plot(f, lp_tri(f - (n + 1) * fs, fb), '--r')\n            plt.plot(f, lp_tri(f + (n + 1) * fs, fb), '--g')\n    elif shape.lower() == 'line':\n        line_ampl = [0, 0.5]\n        plt.plot([fb, fb], line_ampl, 'b', linewidth=2)\n        plt.plot([-fb, -fb], line_ampl, 'b', linewidth=2)\n        for n in range(N):\n            plt.plot([fb + (n + 1) * fs, fb + (n + 1) * fs], line_ampl, '--r', linewidth=2)\n            plt.plot([-fb + (n + 1) * fs, -fb + (n + 1) * fs], line_ampl, '--r', linewidth=2)\n            plt.plot([fb - (n + 1) * fs, fb - (n + 1) * fs], line_ampl, '--g', linewidth=2)\n            plt.plot([-fb - (n + 1) * fs, -fb - (n + 1) * fs], line_ampl, '--g', linewidth=2)\n\n    plt.ylabel('Spectrum Magnitude')\n    plt.xlabel('Frequency in Hz')\n    plt.axis([-fmax, fmax, 0, 1])\n    plt.grid()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        fb = round(random.uniform(0.1, 10), 2)\n        fs = round(random.uniform(0.5, 5), 2)\n        fmax = round(random.uniform(20, 100), 2)\n        N = random.randint(1, 10)\n        shape = random.choice(['tri', 'line'])\n        fsize = (random.randint(4, 10), random.randint(4, 10))\n\n        test_cases.append((fb, fs, fmax, N, shape, fsize, ))\n\n    return test_cases"}
{"problem_id": "matplotlib_101", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates an eye plot from a given signal. An eye plot is a graphical representation used in signal processing to visualize the performance of a communication system. The function will take a signal and plot its amplitude over time, allowing for the analysis of the signal's characteristics.\n\nFunction signature:\n```python\ndef eye_plot(x, L, S=0, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the figure size, which is set to (6, 4) for the plot.\n\nInput format:\n- The function takes in a 1D array-like structure for `x`, an integer for `L`, an optional integer for `S`, and an optional string for `output_file`.\n\nOutput format:\n- The function does not return any value but saves the generated eye plot as an image file with the name specified in `output_file`.\n\n```python\n# Input\nx = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n              0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0,\n              0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\nL = 10\nS = 0\n\n# Output\noutput_file = 'output.png'  # The output file will be generated as a plot\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef eye_plot(x, L, S=0, output_file='output.png'):\n    plt.figure(figsize=(6, 4))\n    idx = np.arange(0, L + 1)\n    plt.plot(idx, x[S:S + L + 1], 'b')\n    k_max = int((len(x) - S) / L) - 1\n    for k in range(1, k_max):\n        plt.plot(idx, x[S + k * L:S + L + 1 + k * L], 'b')\n    plt.grid(True)\n    plt.xlabel('Time Index - n')\n    plt.ylabel('Amplitude')\n    plt.title('Eye Plot')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        L = np.random.randint(10, 100)\n        S = np.random.randint(0, 50)\n        k_max = np.random.randint(2, 10)\n        x_len = S + k_max * L + np.random.randint(1, 20)\n        x = np.random.rand(x_len)\n\n        test_cases.append((x, L, S))\n\n    return test_cases"}
{"problem_id": "matplotlib_102", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the Root Mean Square Deviation (RMSD) of a molecular system over time. The function will take in a DataFrame containing RMSD data, the name of the system, and an optional output file name for saving the plot. The function will generate a line plot of the RMSD values against time and save the plot as an image file.\n\nFunction signature:\n```python\ndef plot_rmsd(rmsd_df, system_name, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- `rmsd_df`: A pandas DataFrame containing at least two columns: 'time(ns)' and one or more RMSD value columns.\n- `system_name`: A string representing the name of the molecular system.\n- `output_file`: An optional string specifying the filename for the output plot image.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot image to the specified output file.\n\nInput:\n```python\nimport pandas as pd\n\n# Sample DataFrame\nrmsd_df = pd.DataFrame({\n    'time(ns)': [0.0, 1.0, 2.0, 3.0, 4.0],\n    'System_1': [0.5, 1.0, 1.5, 2.0, 2.5],\n    'System_2': [0.6, 1.1, 1.6, 2.1, 2.6]\n})\n\nsystem_name = \"Test_System\"\n```\n\nOutput:\n```plaintext\nA plot titled \"RMSD of Test_System\" is saved as 'output.png' with the following characteristics:\n- X-axis labeled \"Time (ns)\"\n- Y-axis labeled \"RMSD (\u00c5)\"\n- Legend located at the lower right\n```", "ground_truth_code": "import matplotlib.pyplot as plt\n\n# main code\ndef plot_rmsd(rmsd_df, system_name, output_file='output.png'):\n    plot = rmsd_df.set_index('time(ns)').plot(title=f'RMSD of {system_name}')\n    plt.ylabel('RMSD (\u00c5)')\n    plt.xlabel('Time (ns)')\n    plt.legend(loc='lower right', ncol=max(1, len(rmsd_df.columns) // 2), frameon=False)\n    plot.figure.savefig(output_file)\n    plt.close()\n", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = random.randint(10, 1000)\n        time_values = np.sort(np.random.uniform(0, 100, num_points))\n        num_columns = random.randint(1, 5)\n        rmsd_values = {\n            f'System_{i + 1}': np.random.uniform(0.5, 5.0, num_points)\n            for i in range(num_columns)\n        }\n        rmsd_df = pd.DataFrame({'time(ns)': time_values, **rmsd_values})\n        system_name = f\"System_{random.randint(1, 100)}\"\n        test_cases.append((rmsd_df, system_name))\n\n    return test_cases"}
{"problem_id": "matplotlib_103", "library": "matplotlib", "code_problem": "You are tasked with creating a function that generates a bar chart to visually represent two metrics: precision and helpfulness, along with their respective variances. The function should also annotate the bars with the values and their variances.\n\nFunction signature:\n```python\ndef make_bar(prec, helpful, var_prec, var_help, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The width of the bars in the bar chart is set to a constant value of `0.6`.\n- The colors used for the bars are defined as `#8FC9F4` for precision and `#4472B0` for helpfulness.\n\nInput format:\n- The function accepts four numerical inputs: `prec`, `helpful`, `var_prec`, and `var_help`, along with an optional string input `output_file`.\n\nOutput format:\n- The function generates a bar chart and saves it as an image file with the name specified by `output_file`.\n\n```python\nInput: (85.67, 92.34, 3.45, 2.78)\nOutput: A bar chart saved as 'output.png' with:\n- Precision bar height: 85.67 \u00b1 3.45\n- Helpfulness bar height: 92.34 \u00b1 2.78\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\n\n# main code\ndef make_bar(prec, helpful, var_prec, var_help, output_file='output.png'):\n    fig, ax = plt.subplots(figsize=(8, 4))\n    x = np.arange(2)\n    y = [prec, helpful]\n    ax.bar(x, y, color=['#8FC9F4', '#4472B0'], width=0.6)\n    ax.errorbar(x, y, yerr=[var_prec, var_help], fmt='none', color='red')\n    ax.set_xticks(x)\n    ax.set_xticklabels(['Precision', 'Helpfulness'])\n    for i, v in enumerate(y):\n        ax.text(i, v + 2, f'{v} \u00b1 {var_prec if i == 0 else var_help}', ha='center', fontsize=12)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        prec = np.round(np.random.uniform(50, 100), 2)\n        helpful = np.round(np.random.uniform(50, 100), 2)\n\n        var_prec = np.round(np.random.uniform(1, 10), 2)\n        var_help = np.round(np.random.uniform(1, 10), 2)\n\n\n        test_cases.append((prec, helpful, var_prec, var_help))\n    return test_cases"}
{"problem_id": "matplotlib_104", "library": "matplotlib", "code_problem": "You are tasked with creating a function that visualizes the average returns of different quantile groups based on a given endogenous variable and an exogenous variable. The function will categorize the exogenous variable into quantiles, compute the mean of the endogenous variable for each quantile group, and then plot the results.\n\nFunction signature:\n```python\ndef plot_quantile_group_ret(endog, exog, title, group_count, figsize=(18, 6), output_path='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `5`, which is used for the rolling sum calculation and the major locator for the x-axis.\n\nInput Format:\n- `endog` (pd.Series): A pandas Series containing the returns data.\n- `exog` (pd.Series): A pandas Series containing the explanatory variable data.\n- `title` (str): A string representing the title of the plot.\n- `group_count` (int): An integer representing the number of quantile groups to create.\n- `figsize` (tuple, optional): A tuple of two integers representing the width and height of the figure (default is (18, 6)).\n- `output_path` (str, optional): A string representing the file path where the plot image will be saved (default is 'output.png').\n\nOutput format:\n- The function returns a matplotlib axes object representing the plot created.\n\nInput:\n```python\nendog = pd.Series([-0.5, 0.2, 1.5, -1.0, 0.3, 0.7, -0.2, 1.0, -0.3, 0.4])\nexog = pd.Series([-5.0, 3.0, 7.0, -2.0, 1.0, 4.0, -1.0, 2.0, 6.0, -3.0])\ntitle = \"Test Case 1\"\ngroup = 4\n```\n\nOutput:\n```python\n# The output will be a bar plot with the mean returns for each quantile group,\n# and a red line representing the rolling sum of the means over 5 periods.\n# The y-axis will be formatted as percentages, and the x-axis will have major ticks at intervals of 5.\n# The plot will have a title \"Test Case 1\".\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nfrom matplotlib.ticker import MultipleLocator\n\n# main code\ndef plot_quantile_group_ret(endog, exog, title, group):\n    ax = plt.gca()\n    group = pd.qcut(exog, group, labels=False) + 1\n    group_ret = endog.groupby(group).mean()\n    ax.set_title(title)\n    ax = group_ret.plot(kind='bar', figsize=(18, 6))\n    group_ret.rolling(5).sum().plot(kind='line', color='red', secondary_y=True)\n    ax.yaxis.set_major_formatter('{x:.2%}')\n    ax.xaxis.set_major_locator(MultipleLocator(5))\n    ax.xaxis.set_major_formatter('{x:.0f}')\n    ax.axhline(0, color='black')\n    return ax", "test_script": "\nimport numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for i in range(n):\n        # Generate random data\n        size = np.random.randint(50, 500)  # Random dataset size\n        endog = pd.Series(np.random.randn(size))  # Normally distributed values\n        exog = pd.Series(np.random.uniform(-10, 10, size))  # Uniformly distributed values\n        group = np.random.randint(2, 20)  # Random number of quantile groups\n        title = f\"Test Case {i + 1}\"  # Unique title for each test case\n\n        test_cases.append((endog, exog, title, group))\n    return test_cases"}
{"problem_id": "seaborn_0", "library": "seaborn", "code_problem": "You are tasked with analyzing latent dimensions from a dataset and visualizing the distribution of different cell types across these dimensions. The goal is to compute the percentage of specific cell types that exhibit variability in their latent dimension values and create a bar plot to represent this information.\n\nFunction Signature:\n```python\ndef compute_diff_capacity_latent_dim(latent_dim_data, labels, palette, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant `6` is used to define the number of columns in the `latent_diff` array, which corresponds to the latent dimension index and the five cell types.\n\nInput Format:\n- `latent_dim_data`: A 2D NumPy array of shape (n_cells, n_latent_dims).\n- `labels`: A 1D array of length n_cells containing integer labels for cell types.\n- `palette`: A string or list specifying the color palette for the plot.\n- `output_file`: A string specifying the filename for the output plot (optional).\n\nOutput Format:\n- The function saves a bar plot as an image file to the specified `output_file`. The plot visualizes the percentage distribution of different cell types across the latent dimensions.\n\nInput:\n```python\nlatent_dim_data = np.array([[0.5, -1.2, 0.3, 0.8, -0.5],\n                            [1.0, 0.1, -0.2, 0.4, 0.6],\n                            [-0.3, 0.7, 1.5, -0.1, 0.2],\n                            [0.2, -0.4, 0.9, 1.1, -0.8],\n                            [0.6, 0.3, -0.5, 0.0, 0.4]])\nlabels = np.array([1, 2, 3, 4, 5])\npalette = ['#9b59b6', '#2ecc71', '#95a5a6', '#e74c3c', '#3498db']\n```\n\nOutput:\n```python\n# The output will be a bar plot saved as 'output.png' with the following characteristics:\n# - 5 latent dimensions (0 to 4)\n# - Each latent dimension will show the percentage of each cell type (Monocytes, Neutrophils, HSPCs, Erythrocytes, Thrombocytes)\n# - The percentages will be calculated based on the mean and standard deviation of the latent dimensions.\n# - The plot will be styled according to the specified palette and will have a dark grid style.\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be represented in text format. The description provides an overview of what the output will contain.)", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\n\n# main code\ndef compute_diff_capacity_latent_dim(latent_dim_data, labels, palette, output_file='output.png'):\n    num_latent_dims = latent_dim_data.shape[1]\n    latent_diff = np.zeros(shape=(num_latent_dims, 6))\n    for latent_dim in range(num_latent_dims):\n        latent_dim_across_cells = latent_dim_data[:, latent_dim]\n        latent_dim_mean = np.mean(latent_dim_across_cells)\n        latent_dim_std = np.std(latent_dim_across_cells)\n        variable_cells = np.where(latent_dim_across_cells > latent_dim_mean + latent_dim_std)\n        variable_labels = labels[variable_cells]\n        variable_cells = variable_labels.tolist()\n        counter_dict = {x: variable_cells.count(x) for x in range(1, 6)}\n        counter = np.array(list(counter_dict.values())) / float(len(variable_cells))\n        counter = np.around(counter * 100.0, decimals=2)\n        latent_diff[latent_dim][1:] = counter\n        latent_diff[latent_dim][0] = int(latent_dim)\n    latent_diff = pd.DataFrame(latent_diff, columns=['Latent dimension', 'Monocytes', 'Neutrophils', 'HSPCs', 'Erythrocytes', 'Thrombocytes'])\n    latent_diff['Latent dimension'] = latent_diff['Latent dimension'].astype(int)\n    latent_diff = latent_diff.melt(id_vars=['Latent dimension'], value_vars=['Monocytes', 'Neutrophils', 'HSPCs', 'Erythrocytes', 'Thrombocytes'], var_name='Cell type', value_name='Percentage')\n    sns.set(font_scale=2.5)\n    sns.set_palette(sns.color_palette(palette))\n    sns.set_style('darkgrid')\n    g = sns.catplot(x='Cell type', y='Percentage', col='Latent dimension', data=latent_diff, saturation=0.5, col_wrap=5, kind='bar', errorbar=None, aspect=1.3, legend_out=True)\n    g.set_xticklabels(rotation=70)\n    g.savefig(output_file)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    palette = ['#9b59b6', '#2ecc71', '#95a5a6', '#e74c3c', '#3498db', '#34495e']\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_latent_dims = np.random.randint(5, 10)\n        latent_dim_data = np.random.randn(num_samples, num_latent_dims)\n        labels = np.random.randint(1, 6, size=num_samples)\n        test_cases.append((latent_dim_data, labels, palette))\n    return test_cases"}
{"problem_id": "seaborn_1", "library": "seaborn", "code_problem": "You are tasked with analyzing latent dimensions of data associated with different clusters. The goal is to compute the percentage of variable cells in each cluster for each latent dimension and visualize the results using a bar plot. \n\nThe main function to implement is as follows:\n\n```python\ndef compute_dif_capacity_clusters_latent_dim(latent_dim_data, labels, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `100.0`, which is used to convert the proportion of variable cells into a percentage.\n\n### Input Format:\n- `latent_dim_data`: A 2D numpy array where each column represents a latent dimension and each row represents a cell.\n- `labels`: A 1D numpy array containing the cluster labels corresponding to each cell.\n- `output_file`: A string representing the filename to save the output plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value but saves a bar plot as an image file to the specified `output_file`. The plot visualizes the percentage of variable cells in each cluster for each latent dimension.\n\nInput:\n```python\nlatent_dim_data = np.array([[ 0.5, -1.2, 0.3, 0.8, -0.5],\n                            [ 1.0,  0.1, -0.4, 0.2,  0.7],\n                            [-0.3,  0.4, 0.9, -0.1,  1.2],\n                            [ 0.2, -0.5, 0.6, 0.4, -0.8],\n                            [ 1.5,  0.3, -0.2, 0.1,  0.0]])\nlabels = np.array([0, 1, 0, 1, 0])\n```\n\nOutput:\n```python\n# The output will be a bar plot saved as 'output.png' showing the percentage of variable cells in each cluster for each latent dimension.\n# The actual content of the plot cannot be represented in text format, but it will display the computed percentages based on the input data.\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef compute_dif_capacity_clusters_latent_dim(latent_dim_data, labels, output_file='output.png'):\n    labels = labels + 1\n    unique_clusters = np.unique(labels)\n    num_clusters = len(unique_clusters)\n    latent_diff = np.zeros(shape=(latent_dim_data.shape[1], num_clusters + 1))\n    for latent_dim in range(latent_dim_data.shape[1]):\n        latent_dim_across_cells = latent_dim_data[:, latent_dim]\n        latent_dim_mean = np.mean(latent_dim_across_cells)\n        latent_dim_std = np.std(latent_dim_across_cells)\n        variable_cells = np.where(latent_dim_across_cells > latent_dim_mean + latent_dim_std)\n        variable_labels = labels[variable_cells].tolist()\n        counter_dict = {x: variable_labels.count(x) for x in unique_clusters}\n        counter = np.array([counter_dict.get(i, 0) for i in unique_clusters]) / float(len(variable_labels))\n        counter = np.around(counter * 100.0, decimals=2)\n        latent_diff[latent_dim, 1:num_clusters + 1] = counter\n        latent_diff[latent_dim, 0] = int(latent_dim)\n    cluster_label = ['Cluster ' + str(i) for i in unique_clusters]\n    latent_diff = pd.DataFrame(latent_diff, columns=['Latent dimension'] + cluster_label)\n    latent_diff['Latent dimension'] = latent_diff['Latent dimension'].astype(int)\n    latent_diff = latent_diff.melt(id_vars=['Latent dimension'], value_vars=cluster_label, var_name='Cluster', value_name='Percentage')\n    sns.set(font_scale=2.5)\n    sns.set_palette(sns.color_palette('husl'))\n    sns.set_style('darkgrid')\n    g = sns.catplot(x='Cluster', y='Percentage', col='Latent dimension', data=latent_diff, saturation=0.5, col_wrap=5, kind='bar', errorbar=None, aspect=1.3, legend_out=True)\n    g.set_xticklabels(rotation=70)\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        latent_dims = np.random.randint(5, 10)\n        latent_dim_data = np.random.randn(num_samples, latent_dims)\n        num_clusters = np.random.randint(2, 10)\n        labels = np.random.randint(0, num_clusters, size=num_samples)\n        test_cases.append((latent_dim_data, labels))\n    return test_cases"}
{"problem_id": "seaborn_2", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a correlation heatmap from a given dataset. The function will analyze categorical data and visualize the relationships between different categories using a heatmap. The heatmap will display the correlation coefficients, allowing users to easily identify the strength and direction of relationships between categories.\n\nFunction signature:\n```python\ndef pl_cor_plot(data, group1, per_cat, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `data`: A pandas DataFrame containing the dataset.\n- `group1`: A string representing the column name to group the data by.\n- `per_cat`: A string representing the column name for which the value counts will be calculated.\n- `output_file`: An optional string representing the filename to save the output heatmap image.\n\nOutput format:\n- The function saves a heatmap image to the specified output file, but does not return any value.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame({\n    'group1': np.random.choice(['G0', 'G1', 'G2'], 100),\n    'per_cat': np.random.choice(['C0', 'C1', 'C2', 'C3'], 100)\n})\ngroup1 = 'group1'\nper_cat = 'per_cat'\n```\n\nOutput:\n```python\n# The output will be a heatmap saved as 'output.png' showing the correlation matrix of the normalized value counts of 'per_cat' within each 'group1'.\n``` \n\n(Note: The actual output file 'output.png' will be generated by the function when executed, and it will contain a visual representation of the correlation matrix.)", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef pl_cor_plot(data, group1, per_cat, output_file='output.png'):\n    plt.rcParams['legend.markerscale'] = 1\n    tf = data.groupby([group1])[per_cat].value_counts(normalize=True).unstack().fillna(0) * 100\n    cor_mat = tf.corr()\n    mask = np.triu(np.ones_like(cor_mat, dtype=bool))\n    plt.figure(figsize=(len(cor_mat), len(cor_mat.columns) * 0.8))\n    sns.heatmap(cor_mat, cmap='coolwarm', center=0, vmin=-1, vmax=1, mask=mask)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(50, 500)\n        num_group1 = random.randint(2, 10)\n        num_per_cat = random.randint(2, 10)\n        group1_values = [f'G{i}' for i in range(num_group1)]\n        per_cat_values = [f'C{i}' for i in range(num_per_cat)]\n        data = pd.DataFrame({'group1': np.random.choice(group1_values, num_samples), 'per_cat': np.random.choice(per_cat_values, num_samples)})\n        test_cases.append((data, 'group1', 'per_cat'))\n    return test_cases"}
{"problem_id": "seaborn_3", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of XGBoost models based on specific hyperparameters. The function will generate a scatter plot that displays the relationship between the learning rate and a specified performance metric, with points colored according to another hyperparameter.\n\nFunction signature:\n```python\ndef plot_xg_perf(df, scoretype, subset, output_path='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the default output file name, which is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**: The function takes a DataFrame `df` and two strings `scoretype` and `subset`, along with an optional string `output_path`.\n- **Output**: The function does not return any value but saves a scatter plot image to the specified output path.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'xgb_learning_rate': [0.1, 0.05, 0.2, 0.15, 0.1],\n    'xgb_gamma': [1.0, 2.0, 1.5, 0.5, 2.5],\n    'model_type': ['xgboost', 'xgboost', 'xgboost', 'xgboost', 'xgboost'],\n    'best_train_auc': [0.85, 0.90, 0.88, 0.92, 0.87]\n}\n\ndf = pd.DataFrame(data)\nscoretype = 'auc'\nsubset = 'train'\noutput_path = 'output.png'\n```\n\n**Output:**\nThe function `plot_xg_perf(df, scoretype, subset, output_path)` will generate a scatter plot saved as 'output.png' showing the performance of the XGBoost model based on the learning rate and gamma values, with the AUC score for the training subset. The plot will have the x-axis labeled as 'xgb_learning_rate', the y-axis labeled as 'best_train_auc', and points colored based on 'xgb_gamma'.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_xg_perf(df, scoretype, subset, output_path='output.png'):\n    sns.set_context('poster')\n    perf_track_df = df.copy().reset_index(drop=True)\n    plot_df = perf_track_df[perf_track_df.model_type == 'xgboost'].copy()\n\n    winnertype = f'best_{subset}_{scoretype}'\n\n    feat1, feat2 = 'xgb_learning_rate', 'xgb_gamma'\n    plot_df[feat1] = plot_df[feat1].round(3)\n    plot_df[feat2] = plot_df[feat2].round(3)\n\n    hue = feat2\n    plot_df = plot_df.sort_values([feat1, feat2])\n\n    with sns.axes_style('whitegrid'):\n        fig, ax = plt.subplots(figsize=(40, 15))\n\n        unique_hue_values = plot_df[hue].nunique()\n        palette = sns.cubehelix_palette(unique_hue_values) if unique_hue_values < 13 else sns.cubehelix_palette(\n            as_cmap=True)\n\n        sns.scatterplot(x=feat1, y=winnertype, hue=hue, palette=palette, data=plot_df, ax=ax)\n        sns.move_legend(ax, 'upper left', bbox_to_anchor=(1, 1))\n        plt.xticks(rotation=30, ha='right')\n        ax.set_title('XGBoost Model Performance')\n\n        plt.savefig(output_path, bbox_inches='tight')\n        plt.close(fig)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = random.randint(50, 500)\n        xgb_learning_rate = np.round(np.random.uniform(0.001, 0.3, num_rows), 3)\n        xgb_gamma = np.round(np.random.uniform(0, 10, num_rows), 3)\n        model_type = ['xgboost'] * num_rows\n        best_score = np.random.uniform(0.5, 1.0, num_rows)\n\n        scoretype = random.choice(['auc', 'logloss', 'rmse'])\n        subset = random.choice(['train', 'val', 'test'])\n        winnertype = f'best_{subset}_{scoretype}'\n\n        df = pd.DataFrame({\n            'xgb_learning_rate': xgb_learning_rate,\n            'xgb_gamma': xgb_gamma,\n            'model_type': model_type,\n            winnertype: best_score\n        })\n\n        test_cases.append((df, scoretype, subset))\n\n    return test_cases"}
{"problem_id": "seaborn_4", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a Partial Dependence Plot (PDP) for a given feature based on model predictions. The function should visualize how the predicted outcome varies with changes in the feature of interest.\n\nFunction signature:\n```python\ndef plot_pdp(grid, ys, feature_name, feature_role, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `grid`: A list of arrays, where each array contains values of the feature for which the PDP is being plotted.\n- `ys`: A list of 2D arrays, where each array contains the model predictions corresponding to the values in `grid`.\n- `feature_name`: A string representing the name of the feature being analyzed.\n- `feature_role`: A string indicating the role of the feature (e.g., 'Numeric' or 'Categorical').\n- `output_file`: A string specifying the filename to save the plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a plot as a PNG file to the specified `output_file`.\n\n**Input:**\n```python\ngrid = [np.array([0.1, 0.3, 0.5, 0.7, 0.9])]\nys = [np.array([[0.2], [0.4], [0.6], [0.8], [1.0]])]\nfeature_name = 'feature_42'\nfeature_role = 'Numeric'\n```\n\n**Output:**\n```python\n# The output will be a plot saved as 'output.png' showing a line plot of the predicted values (y_pred) against the feature values (feature value).\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# main code\ndef plot_pdp(grid, ys, feature_name, feature_role, output_file='output.png'):\n    sns.set(style='whitegrid', font_scale=1.5)\n    plt.figure(figsize=(16, 8))\n    plt.title(f'PDP: {feature_name}')\n\n    n_classes = ys[0].shape[1]\n\n    if n_classes == 1:\n        data = pd.concat([pd.DataFrame({'x': grid[i], 'y': ys[i].ravel()}) for i in range(len(grid))])\n        sns.lineplot(data=data, x='x', y='y', color='b')\n    else:\n        classes = np.arange(n_classes)\n        data = pd.concat(\n            [pd.DataFrame({'x': grid[i], 'y': ys[i][:, k], 'class': k}) for i in range(len(grid)) for k in classes])\n        sns.lineplot(data=data, x='x', y='y', hue='class')\n\n    plt.ylabel('y_pred')\n    plt.xlabel('feature value' if feature_role == 'Numeric' else feature_name)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        grid = [np.sort(np.random.rand(random.randint(5, 20))) for _ in range(num_samples)]\n        n_classes = random.choice([1, random.randint(2, 5)])\n        if n_classes == 1:\n            ys = [np.random.rand(len(grid[i]), 1) for i in range(num_samples)]\n        else:\n            ys = [np.random.rand(len(grid[i]), n_classes) for i in range(num_samples)]\n        feature_name = f'feature_{random.randint(1, 100)}'\n        feature_role = random.choice(['Numeric', 'Categorical'])\n\n        test_cases.append((grid, ys, feature_name, feature_role))\n\n    return test_cases"}
{"problem_id": "seaborn_5", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of different machine learning models based on their parameters and results. The function will take a DataFrame containing various metrics and generate a bar plot to compare the models' performance.\n\nFunction signature:\n```python\ndef boosting_rf_plot(df, output_file='output.png'):\n```\n\nIn this function, a constant `output_file` is used, which defaults to 'output.png'. This constant specifies the name of the file where the generated plot will be saved.\n\nInput format:\n- The input to the function is a DataFrame `df` that contains the following columns: 'dataset', 'dp_method', 'training_method', 'batch_perc', 'epsilon', and 'test_auc'.\n\nOutput format:\n- The output of the function is a saved image file (PNG format) containing the generated bar plot, which visually represents the performance of the models based on the provided data.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'dataset': ['Credit_1', 'Credit_1', 'Health_2', 'Health_1'],\n    'dp_method': ['DP', 'NonDP', 'DP', 'NonDP'],\n    'split_method': ['holdout', 'kfold', 'holdout', 'kfold'],\n    'training_method': ['rf', 'boosting', 'rf', 'boosting'],\n    'batch_perc': [0.1, 0.25, 0.5, 0.75],\n    'ebm': [True, False, True, False],\n    'weight_update': ['static', 'dynamic', 'static', 'dynamic'],\n    'max_depth': ['4', '6', '8', '4'],\n    'num_trees': ['50', '100', '200', '50'],\n    'epsilon': ['0.1', '0.5', '1.0', '2.0'],\n    'test_auc': [0.75, 0.85, 0.65, 0.90]\n}\n\ndf_test = pd.DataFrame(data)\nboosting_rf_plot(df_test, output_file='test_output.png')\n```\n\n**Output:**\n- A bar plot saved as `test_output.png` showing the test AUC values for different epsilon values, with bars colored according to the `args` derived from the `dp_method`, `training_method`, and `batch_perc`. The legend will indicate the corresponding methods used.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef boosting_rf_plot(df, output_file='output.png'):\n    df['dataset'] = df['dataset'].str.split('_').str[0]\n    df['args'] = df['dp_method'] + df['training_method'] + df['batch_perc'].astype(str)\n\n    arg_map = {\n        'DPboosting1.0': 'DP-TR XGBoost',\n        'DPrf1.0': 'DP-TR RF',\n        'DPrf_boosting0.05': 'DP-TR Boosting Averages- 5%',\n        'DPrf_boosting0.1': 'DP-TR Boosting Averages- 10%',\n        'DPrf_boosting0.25': 'DP-TR Boosting Averages- 25%',\n        'DPrf_boosting0.5': 'DP-TR Boosting Averages- 50%',\n        'DPrf_boosting0.75': 'DP-TR Boosting Averages- 75%'\n    }\n    df['args'] = df['args'].replace(arg_map)\n    plt.figure(figsize=(8, 6))\n    ax = sns.barplot(data=df, x='epsilon', y='test_auc', hue='args', palette='tab10', ci='sd')\n    ax.legend(bbox_to_anchor=(1.1, 1.05))\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    datasets = ['Credit 1', 'Credit_2', 'Health_1', 'Health_2']\n    dp_methods = ['DP', 'NonDP']\n    split_methods = ['holdout', 'kfold']\n    training_methods = ['rf', 'boosting']\n    batch_percs = [0.05, 0.1, 0.25, 0.5, 0.75, 1.0]\n    ebms = [True, False]\n    weight_updates = ['static', 'dynamic']\n    max_depths = ['4', '6', '8']\n    num_trees = ['50', '100', '200']\n    epsilons = ['0.1', '0.5', '1.0', '2.0']\n\n    for _ in range(n):\n        df = pd.DataFrame({\n            'dataset': [random.choice(datasets) for _ in range(50)],\n            'dp_method': [random.choice(dp_methods) for _ in range(50)],\n            'split_method': [random.choice(split_methods) for _ in range(50)],\n            'training_method': [random.choice(training_methods) for _ in range(50)],\n            'batch_perc': [random.choice(batch_percs) for _ in range(50)],\n            'ebm': [random.choice(ebms) for _ in range(50)],\n            'weight_update': [random.choice(weight_updates) for _ in range(50)],\n            'max_depth': [random.choice(max_depths) for _ in range(50)],\n            'num_trees': [random.choice(num_trees) for _ in range(50)],\n            'epsilon': [random.choice(epsilons) for _ in range(50)],\n            'test_auc': [random.uniform(0.5, 1.0) for _ in range(50)]\n        })\n\n        test_cases.append(df)\n\n    return test_cases\n"}
{"problem_id": "seaborn_6", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of Random Forest (RF) models based on various hyperparameters. The function will take a DataFrame containing model performance metrics and generate a scatter plot to illustrate the relationship between the number of estimators and the maximum features used in the RF models, colored by the maximum depth of the trees.\n\nFunction signature:\n```python\ndef plot_rf_perf(df, scoretype, subset, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `df`: A pandas DataFrame containing model performance metrics, including columns for `model_type`, `rf_estimators`, `rf_max_features`, `rf_max_depth`, and performance metrics formatted as `best_{subset}_{scoretype}`.\n- `scoretype`: A string indicating the type of score to be plotted (e.g., 'accuracy', 'f1').\n- `subset`: A string indicating the subset of data to be used in the performance metric (e.g., 'train', 'test').\n- `output_file`: An optional string specifying the filename for the output plot image (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a scatter plot image to the specified output file.\n\nInput:\n```python\nimport pandas as pd\n\ndata = {\n    'model_type': ['RF'] * 20,\n    'rf_estimators': [50, 100, 150, 200, 50, 100, 150, 200, 50, 100, 150, 200, 50, 100, 150, 200, 50, 100, 150, 200],\n    'rf_max_features': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.1, 0.2],\n    'rf_max_depth': [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20],\n    'best_valid_r2_score': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.1, 0.2],\n    'best_train_r2_score': [0.5, 0.6, 0.7, 0.8, 0.9, 0.5, 0.6, 0.7, 0.8, 0.9, 0.5, 0.6, 0.7, 0.8, 0.9, 0.5, 0.6, 0.7, 0.8, 0.9]\n}\n\ndf = pd.DataFrame(data)\nscoretype = 'r2_score'\nsubset = 'valid'\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' showing the RF Model Performance.\n# The plot will display a scatter plot with 'rf_estimators/max_features' on the x-axis and 'best_valid_r2_score' on the y-axis,\n# colored by 'rf_max_depth'.\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be displayed in this text format.)", "ground_truth_code": "import seaborn as sns\nimport pandas as pd\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_rf_perf(df, scoretype, subset, output_file='output.png'):\n    plot_df = df[df.model_type == 'RF'].copy()\n\n    plot_df['rf_estimators_cut'] = pd.qcut(plot_df['rf_estimators'], 5)\n    plot_df['rf_max_features_cut'] = pd.qcut(plot_df['rf_max_features'], 5)\n    plot_df['rf_estimators/max_features'] = plot_df['rf_estimators_cut'].astype(str) + ' / ' + plot_df[\n        'rf_max_features_cut'].astype(str)\n\n    fig, ax = plt.subplots(figsize=(15, 6))\n    sns.scatterplot(\n        x='rf_estimators/max_features', y=f'best_{subset}_{scoretype}', hue='rf_max_depth',\n        palette='viridis', data=plot_df, ax=ax\n    )\n    plt.xticks(rotation=30, ha='right')\n    ax.set_title('RF Model Performance')\n    plt.legend(title='Max Depth', bbox_to_anchor=(1, 1))\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = random.randint(10, 100)\n\n        data = {\n            'model_type': ['RF'] * num_rows,\n            'rf_estimators': np.random.randint(10, 200, size=num_rows),\n            'rf_max_features': np.random.uniform(0.1, 1.0, size=num_rows),\n            'rf_max_depth': np.random.randint(1, 20, size=num_rows),\n            'best_valid_r2_score': np.random.uniform(-1, 1, size=num_rows),\n            'best_train_r2_score': np.random.uniform(0.5, 1, size=num_rows)\n        }\n        df = pd.DataFrame(data)\n\n        subset = random.choice(['train', 'valid'])\n        scoretype = random.choice(['r2_score'])\n\n        test_cases.append((df, scoretype, subset))\n\n    return test_cases"}
{"problem_id": "seaborn_7", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a confusion matrix using a heatmap. The function should allow customization of the color bar and axis labels, and it should save the generated plot to a specified output file. \n\nThe function signature is as follows:\n```python\ndef confusion_matrix_helper(data, plot_cbar, plot_labels, output_filename='output.png'):\n```\n\n### Constants:\n- `N = 256`: This constant defines the number of color levels in the custom colormap used for the heatmap.\n\n### Input and Output Format:\n- **Input**:\n  - `data`: A DataFrame representing the confusion matrix.\n  - `plot_cbar`: A boolean indicating whether to plot the color bar.\n  - `plot_labels`: A boolean indicating whether to display axis labels.\n  - `output_filename`: A string specifying the filename for saving the output plot (default is 'output.png').\n\n- **Output**:\n  - The function does not return any value. Instead, it saves a heatmap visualization of the confusion matrix to the specified output file.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\ndata = pd.DataFrame(np.array([[5, 2], [1, 3]]), index=['Class 0', 'Class 1'], columns=['Class 0', 'Class 1'])\nplot_cbar = True\nplot_labels = True\n```\n\n**Output:**\n```plaintext\nA heatmap is generated and saved as 'output.png' with the following properties:\n- Colorbar is displayed.\n- X and Y axis labels are 'Presented category' and 'Decision', respectively.\n- The heatmap represents the confusion matrix with values:\n  [[5, 2],\n   [1, 3]]\n``` \n\nThis test case uses a small 2x2 confusion matrix and specifies that both the color bar and labels should be plotted. The output describes the expected result of running the `confusion_matrix_helper` function with the given input.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom matplotlib.colors import ListedColormap\n\n# main code\ndef confusion_matrix_helper(data, plot_cbar, plot_labels, output_filename='output.png'):\n    sns.set(color_codes=True)\n    plt.figure(figsize=(9, 6))\n    sns.set(font_scale=1.4)\n\n    N = 256\n    vals = np.ones((N, 4))\n    vals[:, 0] = np.linspace(165 / 256, 1, N)\n    vals[:, 1] = np.linspace(30 / 256, 1, N)\n    vals[:, 2] = np.linspace(55 / 256, 1, N)\n    newcmp = ListedColormap(vals)\n\n    ax = sns.heatmap(\n        data,\n        cmap=newcmp.reversed(),\n        vmin=np.min(data),\n        vmax=np.max(data),\n        linecolor='black',\n        linewidths=1.0,\n        square=True,\n        cbar=plot_cbar,\n        xticklabels=plot_labels,\n        yticklabels=plot_labels\n    )\n\n    if plot_labels:\n        colnames = list(data.columns)\n        rownames = list(data.index.values)\n        ax.set_xticklabels(colnames)\n        ax.set_yticklabels(rownames)\n        ax.set(xlabel='Presented category', ylabel='Decision')\n    else:\n        ax.set(xlabel='', ylabel='')\n\n    plt.savefig(output_filename, bbox_inches='tight', dpi=300)\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size = random.randint(2, 20)\n        data = np.random.randint(0, 100, (size, size))\n        labels = [f'Class {i}' for i in range(size)]\n        data_df = pd.DataFrame(data, index=labels, columns=labels)\n        plot_cbar = random.choice([True, False])\n        plot_labels = random.choice([True, False])\n\n        test_cases.append((data_df, plot_cbar, plot_labels))\n\n    return test_cases\n"}
{"problem_id": "seaborn_8", "library": "seaborn", "code_problem": "You are tasked with implementing a function that visualizes clusters of data points in a two-dimensional space using t-distributed Stochastic Neighbor Embedding (t-SNE). The function will take in a set of high-dimensional data points and their corresponding cluster labels, randomly select a subset of these points, and generate a scatter plot to represent the clusters.\n\nFunction signature:\n```python\ndef plot_embedding_clusters(output, targets, max_datapoints, font_scale, perplexity, n_iter, output_file='output.png'):\n```\n\n### Constants:\n- The function uses a default value for the `output_file` parameter, which is set to `'output.png'`.\n\n### Input Format:\n- `output`: A 2D NumPy array of shape (n_samples, n_features) representing the high-dimensional data points.\n- `targets`: A 2D NumPy array of shape (n_samples, n_classes) representing the one-hot encoded cluster labels for each data point.\n- `max_datapoints`: An integer specifying the maximum number of data points to randomly select for visualization.\n- `font_scale`: A float that determines the scaling of the font in the plot.\n- `perplexity`: A float parameter for the t-SNE algorithm that affects the balance between local and global aspects of the data.\n- `n_iter`: An integer specifying the number of iterations for the t-SNE optimization.\n- `output_file`: A string representing the filename to save the output plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a scatter plot image to the specified output file.\n\nInput:\n```python\noutput = np.array([[ 0.49671415, -0.1382643 ,  0.64768854,  1.52302986, -0.23415337],\n                   [-0.23413696,  1.57921282,  0.76743473, -0.46947439,  0.54256004],\n                   [ 0.24196227, -1.91328024, -1.72491783, -0.56228753, -1.01283112],\n                   [ 0.31424733, -0.90802408, -1.4123037 ,  1.46564877, -0.2257763 ],\n                   [ 0.0675282 , -1.42474819, -0.54438272,  0.11092259, -1.15099358],\n                   [ 0.37569802, -0.60063869, -0.29169375, -0.60170661,  1.85227818],\n                   [-0.01349722, -1.05771093,  0.82254491, -1.22084365,  0.2088636 ],\n                   [ 0.3869025 , -0.51080514, -1.18063218, -0.02818223,  0.42833187],\n                   [ 0.06651722,  0.3024719 , -0.63432209, -0.36274117, -0.67246045],\n                   [-0.35955316, -0.81314628, -1.7262826 ,  0.17742614, -0.40178094]])\n                   \ntargets = np.array([[1, 0, 0],\n                    [0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0],\n                    [0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0],\n                    [0, 1, 0],\n                    [0, 0, 1],\n                    [1, 0, 0]])\n\nmax_datapoints = 5\nfont_scale = 1.0\nperplexity = 5\nn_iter = 250\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' showing the t-SNE visualization of the selected data points.\n# The actual output cannot be displayed here as it is a graphical output.\n``` \n\nNote: The output is a graphical file and cannot be represented in text format. The saved file 'output.png' will contain the visualization of the clusters based on the provided input data.", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.manifold import TSNE\n\n# main code\ndef plot_embedding_clusters(output, targets, max_datapoints, font_scale, perplexity, n_iter, output_file='output.png'):\n    targets = np.argmax(targets, axis=1)\n    indices = np.random.permutation(len(targets))[:max_datapoints]\n    output_selected, model_targets = output[indices], targets[indices]\n    output_tsne = TSNE(n_components=2, perplexity=perplexity, n_iter=n_iter, verbose=1).fit_transform(output_selected)\n    pc_df = pd.DataFrame(output_tsne, columns=['tsne-one', 'tsne-two'])\n    pc_df['Cluster'] = model_targets\n    sns.set_context('poster', font_scale=font_scale)\n    plt.figure(figsize=(12, 8))\n    scatter = sns.scatterplot(x='tsne-one', y='tsne-two', hue='Cluster', data=pc_df, palette='tab10', s=100,\n                              edgecolor='k', alpha=0.75)\n    plt.legend(title=\"Cluster\", bbox_to_anchor=(1.05, 1), loc='upper left', borderaxespad=0.)\n    plt.tight_layout()\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        feature_dim = np.random.randint(5, 20)\n        num_classes = np.random.randint(5, 20)\n\n        output = np.random.randn(num_samples, feature_dim)\n        targets = np.eye(num_classes)[np.random.choice(num_classes, num_samples)]\n\n        max_datapoints = np.random.randint(10, num_samples)\n        font_scale = np.random.uniform(0.5, 2.0)\n        perplexity = np.random.randint(5, min(10, max_datapoints))\n        n_iter = np.random.randint(250, 300)\n\n        test_cases.append((output, targets, max_datapoints, font_scale, perplexity, n_iter))\n\n    return test_cases"}
{"problem_id": "seaborn_9", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the average \"Raw Pitch Accuracy\" of a dataset based on specified attributes. The function will generate a heatmap using the Seaborn library, which will help in understanding the relationship between the attributes and the accuracy values.\n\nFunction signature:\n```python\ndef plot_grid(data, attr_names, split, vminRPA, vmaxRPA, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the default output file name, which is set to `'output.png'`.\n\n### Input Format:\n- `data`: A Pandas DataFrame containing the dataset with at least the columns 'Dataset' and 'Raw Pitch Accuracy'.\n- `attr_names`: A list of two strings representing the names of the attributes to group by.\n- `split`: A string indicating the specific dataset to filter on.\n- `vminRPA`: A float representing the minimum value for the color scale of the heatmap.\n- `vmaxRPA`: A float representing the maximum value for the color scale of the heatmap.\n- `output_file`: A string representing the name of the output file where the heatmap will be saved (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a heatmap image to the specified output file.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'Dataset': ['train', 'train', 'train', 'test', 'test', 'validation', 'validation'],\n    'Category1': ['catA_0', 'catA_1', 'catA_0', 'catA_1', 'catA_0', 'catA_1', 'catA_0'],\n    'Category2': ['catB_0', 'catB_1', 'catB_0', 'catB_1', 'catB_0', 'catB_1', 'catB_0'],\n    'Raw Pitch Accuracy': [0.8, 0.9, 0.85, 0.7, 0.75, 0.95, 0.9]\n})\n\nattr_names = ['Category1', 'Category2']\nsplit = 'test'\nvminRPA = 0.7\nvmaxRPA = 0.75\n```\n\n**Output:**\nThe output will be a heatmap saved as 'output.png' showing the average 'Raw Pitch Accuracy' for the 'test' dataset, with 'Category1' on one axis and 'Category2' on the other. The heatmap will display the value 0.70 for the combination of 'catA_1' and 'catB_1', and 0.75 for 'catA_0' and 'catB_0'. The visual representation will be saved in the specified output file.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n\n# main code\ndef plot_grid(data, attr_names, split, vminRPA, vmaxRPA, output_file='output.png'):\n    sns.set(rc={'figure.figsize': (6, 5)})\n    sns.set(style='whitegrid')\n\n    fig, ax = plt.subplots()\n    cmap = sns.cubehelix_palette(100, reverse=True, as_cmap=True)\n    filtered_data = data[data['Dataset'] == split]\n    filtered_data['Raw Pitch Accuracy'] = pd.to_numeric(filtered_data['Raw Pitch Accuracy'], errors='coerce')\n    grouped_data = filtered_data.groupby(attr_names).mean(numeric_only=True).reset_index()\n    pivot = grouped_data.pivot(index=attr_names[0], columns=attr_names[1], values='Raw Pitch Accuracy')\n    sns.heatmap(pivot, annot=True, fmt='.3f', cmap=cmap, ax=ax, vmin=vminRPA, vmax=vmaxRPA)\n\n    plt.tight_layout()\n    fig.savefig(output_file, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        attr_names = random.sample(['Category1', 'Category2', 'Category3', 'Category4'], 2)\n        split = random.choice(['train', 'test', 'validation'])\n        num_samples = random.randint(10, 50)\n        categories1 = [f'catA_{i}' for i in range(random.randint(3, 7))]\n        categories2 = [f'catB_{i}' for i in range(random.randint(3, 7))]\n\n        data_dict = {\n            'Dataset': np.random.choice(['train', 'test', 'validation'], num_samples),\n            attr_names[0]: np.random.choice(categories1, num_samples),\n            attr_names[1]: np.random.choice(categories2, num_samples),\n            'Raw Pitch Accuracy': np.random.uniform(0.5, 1.0, num_samples)\n        }\n        data = pd.DataFrame(data_dict)\n        data['Raw Pitch Accuracy'] = pd.to_numeric(data['Raw Pitch Accuracy'], errors='coerce')\n        vminRPA = data['Raw Pitch Accuracy'].min()\n        vmaxRPA = data['Raw Pitch Accuracy'].max()\n\n        test_cases.append((data, attr_names, split, vminRPA, vmaxRPA))\n\n    return test_cases"}
{"problem_id": "seaborn_10", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a line plot from a given DataFrame containing experimental results. The DataFrame includes a column with arguments in string format, which need to be parsed to extract specific parameters for visualization. The function should save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef generate_plot(df, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- A DataFrame `df` with at least the following columns:\n  - `args`: a string column containing parameters in a specific format.\n  - `n`: a numeric column representing the number of clients.\n  - `test_auc`: a numeric column representing the test AUC values.\n\nOutput format:\n- The function saves a line plot as an image file (default is 'output.png') that visualizes the relationship between the number of clients and the test AUC for different methods.\n\n**Input:**\n```python\nimport pandas as pd\n\ntest_case = pd.DataFrame([\n    {'args': \"'dp_method': 'DP-TR Newton', 'split_method': '', 'num_trees': '100'\", 'test_auc': 0.85, 'n': 50},\n    {'args': \"'dp_method': 'XGBoost', 'split_method': 'IH', 'num_trees': '100'\", 'test_auc': 0.90, 'n': 100},\n    {'args': \"'dp_method': 'DP-TR Newton IH', 'split_method': '', 'num_trees': '100'\", 'test_auc': 0.75, 'n': 200},\n    {'args': \"'dp_method': 'XGBoost', 'split_method': '', 'num_trees': '100'\", 'test_auc': 0.95, 'n': 300},\n])\n```\n\n**Output:**\n```python\n# The output will be a saved plot file named 'output.png' with the following characteristics:\n# - X-axis labeled 'Number of Clients ($n$)'\n# - Y-axis labeled 'Test AUC'\n# - A line plot showing the test_auc values for different methods based on the number of clients.\n# - The legend will display the different methods used (e.g., 'DP-TR Newton', 'XGBoost', etc.).\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be displayed in text format.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef generate_plot(df, output_file='output.png'):\n    df['dp_method'] = df['args'].str.extract(\"'dp_method':\\\\s*'([^']+)'\")\n    df['split_method'] = df['args'].str.extract(\"'split_method':\\\\s*'([^']+)'\")\n    df['num_trees'] = df['args'].str.extract(\"'num_trees':\\\\s*'([^']+)'\")\n    df['args'] = df['dp_method'] + df['split_method'].apply(lambda x: f' {x}' if x else '')\n    df['args'] = df['args'].str.strip()\n    df = df.sort_values(['args', 'n'])\n    unique_args = df['args'].nunique()\n    palette = sns.color_palette('Reds', unique_args)\n    plt.figure(figsize=(10, 6))\n    ax = sns.lineplot(data=df, x='n', y='test_auc', hue='args', palette=palette, marker='o')\n    plt.ylabel('Test AUC')\n    plt.xlabel('Number of Clients ($n$)')\n    plt.legend(title='Method')\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.clf()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    all_test_cases = []\n    dp_methods = ['DP-TR Newton', 'DP-TR Newton IH', 'XGBoost']\n    split_methods = ['', 'IH']\n    for _ in range(n):\n        test_cases = []\n        sample_num = random.randint(20, 100)\n        for _ in range(sample_num):\n            dp_method = random.choice(dp_methods)\n            split_method = random.choice(split_methods)\n            num_trees = '100'\n            test_auc = np.random.uniform(0.5, 1.0)\n            num_clients = random.randint(10, 500)\n            args = f\"'dp_method': '{dp_method}', 'split_method': '{split_method}', 'num_trees': '{num_trees}'\"\n            test_cases.append({'args': args, 'test_auc': test_auc, 'n': num_clients})\n        all_test_cases.append(pd.DataFrame(test_cases))\n    return all_test_cases"}
{"problem_id": "seaborn_11", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the distribution of categorical data using a combination of swarm and box plots. The function will take in a dataset and several parameters to customize the plot. The function signature is as follows:\n\n```python\ndef plot_swarm_box(adata, grouping, per_cat, replicate, sub_col, sub_list, norm, figure_sizing, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `adata`: A structured dataset containing observational data.\n- `grouping`: A string representing the column name used for grouping the data.\n- `per_cat`: A string representing the column name for the categorical variable to be analyzed.\n- `replicate`: A string representing the column name for the replicate variable.\n- `sub_col`: A string representing the column name used for filtering the data.\n- `sub_list`: A list of values used to filter the data based on `sub_col`.\n- `norm`: A boolean indicating whether to normalize the data.\n- `figure_sizing`: A tuple representing the size of the figure (width, height).\n- `output_file`: A string representing the name of the output file where the plot will be saved (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\n**Input:**\n```python\nadata = {\n    'obs': pd.DataFrame({\n        'grouping': ['group_1', 'group_1', 'group_2', 'group_2', 'group_3', 'group_3', 'group_1', 'group_2'],\n        'replicate': ['rep_1', 'rep_1', 'rep_1', 'rep_2', 'rep_1', 'rep_2', 'rep_2', 'rep_1'],\n        'per_cat': ['cat_1', 'cat_2', 'cat_1', 'cat_2', 'cat_1', 'cat_2', 'cat_1', 'cat_2'],\n        'sub_col': ['sub_1', 'sub_1', 'sub_2', 'sub_2', 'sub_1', 'sub_2', 'sub_1', 'sub_1']\n    })\n}\n\ngrouping = 'grouping'\nper_cat = 'per_cat'\nreplicate = 'replicate'\nsub_col = 'sub_col'\nsub_list = ['sub_1']\nnorm = True\nfigure_sizing = (10, 6)\noutput_file = 'output.png'\n```\n\n**Output:**\nThe output will be a saved figure file named `output.png` that contains a boxplot visualizing the percentage distribution of `per_cat` across the different `grouping` categories, filtered by `sub_col` values in `sub_list`. The exact visual output cannot be represented in text format, but it will show the boxplot with the specified configurations.\n\n### Note:\nThe actual visual output (the boxplot) cannot be displayed in this format, but it will be generated and saved as an image file when the `plot_swarm_box` function is executed with the provided input.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef plot_swarm_box(adata, grouping, per_cat, replicate, sub_col, sub_list, norm, figure_sizing, output_file='output.png'):\n    data = adata['obs']\n    test1 = data.loc[data[sub_col].isin(sub_list)] if norm else data.copy()\n\n    test1 = test1.copy()\n    test1.loc[:, per_cat] = test1[per_cat].astype('category')\n\n    test_freq = test1.groupby([grouping, replicate])[per_cat].value_counts(normalize=True).mul(100).reset_index(\n        name='percentage')\n\n    plt.figure(figsize=figure_sizing)\n    ax = sns.boxplot(data=test_freq, x=grouping, y='percentage', order=test_freq[grouping].unique())\n\n    for patch in ax.artists:\n        r, g, b, _ = patch.get_facecolor()\n        patch.set_facecolor((r, g, b, 0.3))\n\n    plt.xlabel('')\n    plt.xticks(rotation=90)\n    ax.set_ylim(0, test_freq['percentage'].max() + 1)\n    sns.despine()\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(50, 200)\n        grouping_values = [f'group_{i}' for i in range(random.randint(2, 6))]\n        replicate_values = [f'rep_{i}' for i in range(random.randint(1, 4))]\n        per_cat_values = [f'cat_{i}' for i in range(random.randint(2, 5))]\n        sub_col_values = [f'sub_{i}' for i in range(random.randint(1, 5))]\n\n        data = {\n            'grouping': np.random.choice(grouping_values, num_rows),\n            'replicate': np.random.choice(replicate_values, num_rows),\n            'per_cat': np.random.choice(per_cat_values, num_rows),\n            'sub_col': np.random.choice(sub_col_values, num_rows)\n        }\n        adata = {'obs': pd.DataFrame(data)}\n\n        grouping = 'grouping'\n        per_cat = 'per_cat'\n        replicate = 'replicate'\n        sub_col = 'sub_col'\n        sub_list = np.random.choice(sub_col_values, random.randint(1, len(sub_col_values)), replace=False).tolist()\n        norm = random.choice([True, False])\n        figure_sizing = (random.uniform(5, 15), random.uniform(5, 15))\n\n        test_cases.append(\n            (adata, grouping, per_cat, replicate, sub_col, sub_list, norm, figure_sizing))\n\n    return test_cases"}
{"problem_id": "seaborn_12", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a bivariate plot based on the provided dataset and specified variables. The function should determine the types of the variables (categorical or numerical) and create an appropriate visualization using the Seaborn and Matplotlib libraries.\n\nFunction signature:\n```python\ndef bivariate_plot(dtf, x, y, max_cat, figsize, output_path='output.png'):\n```\n\n### Constants:\n- `max_cat`: This constant is used to determine the threshold for categorizing a variable as categorical based on the number of unique values it contains.\n\n### Input Format:\n- A DataFrame `dtf` containing the data.\n- Two strings `x` and `y` representing the column names for the variables to be plotted.\n- An integer `max_cat` indicating the maximum number of unique values for a variable to be considered categorical.\n- A tuple `figsize` specifying the dimensions of the plot.\n- An optional string `output_path` for the file name where the plot will be saved.\n\n### Output Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file at the specified `output_path`.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    'x_col_0': ['cat_0', 'cat_1', 'cat_0', 'cat_1', 'cat_0', 'cat_1', 'cat_0', 'cat_1'],\n    'y_col_0': [1.2, 2.3, 1.5, 2.1, 1.8, 2.5, 1.0, 2.0]\n}\ndf = pd.DataFrame(data)\n\n# Parameters\nx = 'x_col_0'\ny = 'y_col_0'\nmax_cat = 5\nfigsize = (6, 4)\noutput_path = 'output.png'\n```\n\n**Output:**\n- A boxplot saved as `output.png` showing the distribution of `y_col_0` values for each category in `x_col_0`. The plot will have `x_col_0` on the x-axis and `y_col_0` on the y-axis, with appropriate labels and title. \n\n(Note: The actual image file `output.png` cannot be displayed here, but it will be generated when the `bivariate_plot` function is called with the above parameters.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\ndef bivariate_plot(dtf, x, y, max_cat, figsize, output_path='output.png'):\n    x_type = 'cat' if dtf[x].dtype == 'O' or dtf[x].nunique() < max_cat else 'num'\n    y_type = 'cat' if dtf[y].dtype == 'O' or dtf[y].nunique() < max_cat else 'num'\n    (fig, ax) = plt.subplots(figsize=figsize)\n    fig.suptitle(f'{x} vs {y}', fontsize=16)\n    if x_type == 'num' and y_type == 'num':\n        sns.scatterplot(x=dtf[x], y=dtf[y], alpha=0.5, ax=ax)\n        ax.set_xlabel(x)\n        ax.set_ylabel(y)\n    elif x_type == 'cat' and y_type == 'cat':\n        sns.countplot(x=x, hue=y, data=dtf, ax=ax)\n        ax.set_xlabel(x)\n        ax.set_ylabel('Count')\n    else:\n        (cat, num) = (x, y) if x_type == 'cat' else (y, x)\n        sns.boxplot(x=dtf[cat], y=dtf[num], ax=ax)\n        ax.set_xlabel(cat)\n        ax.set_ylabel(num)\n    plt.savefig(output_path, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(50, 500)\n        num_cat_values = random.randint(2, 10)\n        max_cat = random.randint(5, 15)\n        figsize = (random.uniform(4, 10), random.uniform(4, 10))\n        x_col = f'x_col_{_}'\n        y_col = f'y_col_{_}'\n        x_is_cat = random.choice([True, False])\n        y_is_cat = random.choice([True, False])\n        data = {}\n        if x_is_cat:\n            data[x_col] = np.random.choice([f'cat_{i}' for i in range(num_cat_values)], num_rows)\n        else:\n            data[x_col] = np.random.randn(num_rows) * 10\n        if y_is_cat:\n            data[y_col] = np.random.choice([f'cat_{i}' for i in range(num_cat_values)], num_rows)\n        else:\n            data[y_col] = np.random.randn(num_rows) * 10\n        df = pd.DataFrame(data)\n        test_cases.append((df, x_col, y_col, max_cat, figsize))\n    return test_cases"}
{"problem_id": "seaborn_13", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a bivariate plot based on the types of two specified columns from a given DataFrame. The function should handle different types of data (categorical and numerical) and produce appropriate visualizations using the Seaborn and Matplotlib libraries.\n\nFunction Signature:\n```python\ndef bivariate_plot(dtf, x, y, max_cat, figsize, output_path=\"output.png\"):\n```\n\nConstants:\n- `max_cat`: This constant is used to determine the threshold for categorizing a column as categorical based on the number of unique values it contains.\n\n\nInput Format:\n- The function takes a pandas DataFrame and the names of two columns as strings, along with an integer, a tuple for figure size, and an optional string for the output file path.\n\nOutput Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file at the specified output path.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    'x_col_0': ['cat_0', 'cat_1', 'cat_0', 'cat_1', 'cat_2', 'cat_0', 'cat_1', 'cat_2', 'cat_0', 'cat_1'],\n    'y_col_0': [1.2, 2.3, 1.5, 2.1, 3.0, 1.8, 2.5, 2.0, 1.1, 2.2]\n}\ndf = pd.DataFrame(data)\n\n# Parameters\nx = 'x_col_0'\ny = 'y_col_0'\nmax_cat = 3\nfigsize = (6, 4)\noutput_path = \"output.png\"\n\n# Call to the function\nbivariate_plot(df, x, y, max_cat, figsize, output_path)\n```\n\n**Output:**\n- A boxplot saved as \"output.png\" showing the distribution of `y_col_0` values for each category in `x_col_0`. The plot will have `x_col_0` on the x-axis and `y_col_0` on the y-axis, with appropriate labels and a title \"x_col_0 vs y_col_0\". \n\n(Note: The actual image file \"output.png\" will be generated and saved in the working directory, but it cannot be displayed here.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# main code\ndef bivariate_plot(dtf, x, y, max_cat, figsize, output_path=\"output.png\"):\n    x_type = 'cat' if dtf[x].dtype == 'O' or dtf[x].nunique() < max_cat else 'num'\n    y_type = 'cat' if dtf[y].dtype == 'O' or dtf[y].nunique() < max_cat else 'num'\n\n    fig, ax = plt.subplots(figsize=figsize)\n    fig.suptitle(f\"{x} vs {y}\", fontsize=16)\n\n    if x_type == 'num' and y_type == 'num':\n        sns.scatterplot(x=dtf[x], y=dtf[y], alpha=0.5, ax=ax)\n        ax.set_xlabel(x)\n        ax.set_ylabel(y)\n\n    elif x_type == 'cat' and y_type == 'cat':\n        sns.countplot(x=x, hue=y, data=dtf, ax=ax)\n        ax.set_xlabel(x)\n        ax.set_ylabel(\"Count\")\n\n    else:\n        cat, num = (x, y) if x_type == 'cat' else (y, x)\n        sns.boxplot(x=dtf[cat], y=dtf[num], ax=ax)\n        ax.set_xlabel(cat)\n        ax.set_ylabel(num)\n\n    plt.savefig(output_path, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = random.randint(50, 500)\n        num_cat_values = random.randint(2, 10)\n        max_cat = random.randint(5, 15)\n        figsize = (random.uniform(4, 10), random.uniform(4, 10))\n\n\n        x_col = f\"x_col_{_}\"\n        y_col = f\"y_col_{_}\"\n\n        x_is_cat = random.choice([True, False])\n        y_is_cat = random.choice([True, False])\n\n        data = {}\n        if x_is_cat:\n            data[x_col] = np.random.choice([f\"cat_{i}\" for i in range(num_cat_values)], num_rows)\n        else:\n            data[x_col] = np.random.randn(num_rows) * 10\n        if y_is_cat:\n            data[y_col] = np.random.choice([f\"cat_{i}\" for i in range(num_cat_values)], num_rows)\n        else:\n            data[y_col] = np.random.randn(num_rows) * 10\n\n        df = pd.DataFrame(data)\n        test_cases.append((df, x_col, y_col, max_cat, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_14", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of neural network (NN) models based on various parameters. The function will take a DataFrame containing model information and generate a scatter plot that illustrates the relationship between the number of weights, learning rate, and a specified performance score.\n\nFunction signature:\n```python\ndef plot_nn_perf(df, scoretype, subset, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the string `'output.png'`, which serves as the default filename for saving the generated plot.\n\n### Input Format:\n- `df`: A pandas DataFrame containing columns such as 'model_type', 'dropouts', 'layer_sizes', 'learning_rate', and performance scores.\n- `scoretype`: A string indicating the type of score to be plotted on the y-axis.\n- `subset`: A string used to specify the subset of data for the performance score.\n- `output_file`: An optional string specifying the filename for the output plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a scatter plot as a PNG file to the specified output file.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ndata = {\n    'model_type': ['NN', 'NN', 'SVM', 'NN', 'RandomForest'],\n    'dropouts': [[0.1, 0.2], [0.3], [0.1], [0.4, 0.5], [0.2]],\n    'layer_sizes': [[50, 100], [200], [150], [100, 300], [250]],\n    'learning_rate': [0.01, 0.001, 0.05, 0.005, 0.02],\n    'best_train_accuracy': [0.85, 0.90, 0.75, 0.88, 0.80]\n}\n\ndf = pd.DataFrame(data)\n\n# Parameters\nscoretype = 'accuracy'\nsubset = 'train'\n```\n\n**Output:**\n```python\n# The output will be a plot saved as 'output.png'\n# The plot will show a scatter plot of 'num_weights/learning_rate' vs 'best_train_accuracy'\n# with points colored by 'avg_dropout'.\n# The actual output is a visual plot and cannot be represented in text format.\n```\n\n### Explanation:\n- The input consists of a DataFrame `df` with various model types, dropout rates, layer sizes, learning rates, and a score for the best training accuracy.\n- The parameters `scoretype` and `subset` are set to 'accuracy' and 'train', respectively.\n- The output is a plot saved as 'output.png', which visualizes the performance of the neural network models based on the specified parameters. The actual plot cannot be displayed in text format, but it will be generated when the `plot_nn_perf` function is called with the provided input.", "ground_truth_code": "import pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_nn_perf(df, scoretype, subset, output_file='output.png'):\n    sns.set_context('poster')\n\n    if 'NN' not in df.model_type.unique():\n        return\n\n    df = df.copy()\n    df['avg_dropout'] = df.dropouts.astype(str).str.strip('[]').str.split(',', expand=True).astype(float).mean(axis=1)\n    df['num_weights'] = df.layer_sizes.astype(str).str.strip('[]').str.split(',', expand=True).astype(float).prod(\n        axis=1)\n\n    plot_df = df[df.model_type == 'NN'].copy()\n    winnertype = f'best_{subset}_{scoretype}'\n    plot_df['num_weights_cut'] = pd.qcut(plot_df['num_weights'], 5)\n    plot_df['learning_rate_cut'] = pd.qcut(plot_df['learning_rate'], 5)\n\n    plot_df['num_weights/learning_rate'] = plot_df['num_weights_cut'].astype(str) + ' / ' + plot_df[\n        'learning_rate_cut'].astype(str)\n\n    with sns.axes_style('whitegrid'):\n        fig, ax = plt.subplots(figsize=(12, 6))\n        sns.scatterplot(x='num_weights/learning_rate', y=winnertype, hue='avg_dropout', data=plot_df, ax=ax)\n        sns.move_legend(ax, 'upper left', bbox_to_anchor=(1, 1))\n        plt.xticks(rotation=30, ha='right')\n        ax.set_title('NN Model Performance')\n        plt.savefig(output_file, bbox_inches='tight')\n        plt.close(fig)", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n\n        model_types = ['NN', 'SVM', 'RandomForest']\n        model_type = np.random.choice(model_types, num_samples, p=[0.7, 0.15, 0.15])\n\n        dropouts = [np.random.uniform(0, 0.5, size=random.randint(1, 5)).tolist() for _ in range(num_samples)]\n        layer_sizes = [np.random.randint(10, 500, size=random.randint(1, 5)).tolist() for _ in range(num_samples)]\n        learning_rates = np.random.uniform(0.0001, 0.1, num_samples)\n\n        subset = random.choice(['train', 'test', 'val'])\n        scoretype = random.choice(['accuracy', 'loss'])\n\n        winnertype = f'best_{subset}_{scoretype}'\n        scores = np.random.uniform(0.5, 1.0, num_samples)\n\n        df = pd.DataFrame({\n            'model_type': model_type,\n            'dropouts': dropouts,\n            'layer_sizes': layer_sizes,\n            'learning_rate': learning_rates,\n            winnertype: scores\n        })\n\n        df['num_weights'] = df.layer_sizes.apply(lambda x: np.prod(x))\n        df['learning_rate_bin'] = pd.cut(df['learning_rate'], bins=5, labels=False)\n        df['num_weights_bin'] = pd.qcut(df['num_weights'], 5, labels=False, duplicates='drop')\n        df['num_weights/learning_rate'] = df['num_weights_bin'].astype(int) * 10 + df['learning_rate_bin'].astype(int)\n\n\n        test_cases.append((df, scoretype, subset))\n\n    return test_cases"}
{"problem_id": "seaborn_15", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates and saves a heatmap from a given matrix. The heatmap should be customizable in terms of color mapping and value ranges, and it should optionally include a legend based on provided color and name mappings.\n\nFunction signature:\n```python\ndef save_heatmap(matrix, vmin, vmax, cmap, legend, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- A 2D array-like structure for `matrix`.\n- Two numerical values for `vmin` and `vmax`.\n- A string for `cmap`.\n- A dictionary for `legend` or a boolean value.\n\nOutput format:\n- The function saves a heatmap image to the specified output file.\n\n**Input:**\n```python\nmatrix = np.array([[0.1, 0.2, 0.3],\n                   [0.4, 0.5, 0.6],\n                   [0.7, 0.8, 0.9]])\nvmin = 0.0\nvmax = 1.0\ncmap = 'viridis'\nlegend = {'colors': ['low', 'high'], 'names': ['low', 'high']}\noutput_file = 'test_output.png'\n```\n\n**Output:**\n```python\n# The function save_heatmap will generate a heatmap and save it as 'test_output.png'.\n# The output file will contain a heatmap visualizing the input matrix with the specified colormap and legend.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport matplotlib.patches as mpatches\n\n# main code\ndef save_heatmap(matrix, vmin, vmax, cmap, legend, output_file='output.png'):\n\n    plt.figure(figsize=(8, 6))\n\n    ax = sns.heatmap(matrix, linewidth=0, cmap=cmap, vmin=vmin, vmax=vmax, yticklabels=False, xticklabels=False,\n                     cbar=legend is not False)\n\n    if isinstance(legend, dict) and 'colors' in legend and 'names' in legend:\n        patches = [mpatches.Patch(color=color, label=name) for color, name in zip(legend['colors'], legend['names'])]\n        ax.legend(handles=patches, bbox_to_anchor=(-0.09, 0.8), loc=2, borderaxespad=0, frameon=False)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    colormaps = ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'bwr', 'seismic']\n    legend_options = [False, {'colors': ['red', 'blue'], 'names': ['low', 'high']}]\n\n    for _ in range(n):\n        rows = random.randint(5, 50)\n        cols = random.randint(5, 50)\n        matrix = np.random.rand(rows, cols)\n\n        vmin = round(random.uniform(0, 0.5), 2)\n        vmax = round(random.uniform(0.5, 1), 2)\n\n        if vmin >= vmax:\n            vmin, vmax = 0, 1\n        cmap = random.choice(colormaps)\n        legend = random.choice(legend_options)\n\n        test_cases.append((matrix, vmin, vmax, cmap, legend))\n\n    return test_cases"}
{"problem_id": "seaborn_16", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the relationship between categorical and continuous variables in a dataset using various types of plots. The function should allow the user to specify the type of plot they want to generate, as well as customize the appearance of the plot.\n\nFunction Signature:\n```python\ndef plot_categorical_and_continuous(df, xlabel, ylabel, x_keys, y_keys, cmap, n_cat, plottype, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the default value for the `output_file` parameter, which is set to `'output.png'`.\n\nInput Format:\n- `df`: A pandas DataFrame containing the data to be plotted.\n- `xlabel`: A string representing the name of the categorical variable to be plotted on the x-axis.\n- `ylabel`: A string representing the name of the continuous variable to be plotted on the y-axis.\n- `x_keys`: A list of keys corresponding to the categories in the x-axis.\n- `y_keys`: A list of keys corresponding to the categories in the y-axis.\n- `cmap`: A string representing the color map to be used for the plot.\n- `n_cat`: An integer representing the number of categories for the color palette.\n- `plottype`: A string indicating the type of plot to generate ('box', 'strip', 'swarm', or 'violin').\n- `output_file`: A string representing the name of the output file where the plot will be saved (default is 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file specified by `output_file`.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'category': ['cat_0', 'cat_1', 'cat_0', 'cat_2', 'cat_1', 'cat_2', 'cat_0', 'cat_1', 'cat_2', 'cat_0'],\n    'value': [23.5, 45.2, 30.1, 50.3, 40.0, 55.1, 22.0, 48.5, 60.0, 25.5]\n}\ndf = pd.DataFrame(data)\n\n# Parameters\nxlabel = 'category'\nylabel = 'value'\nx_keys = ['cat_0', 'cat_1', 'cat_2']\ny_keys = ['cat_0', 'cat_1', 'cat_2']\ncmap = 'deep'\nn_cat = 3\nplottype = 'box'\noutput_file = 'output.png'\n```\n\n**Output:**\n- A box plot saved as `output.png` showing the distribution of `value` for each `category` ('cat_0', 'cat_1', 'cat_2'). The plot will have a color palette defined by the 'deep' colormap, with three distinct categories represented.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_categorical_and_continuous(df, xlabel, ylabel, x_keys, y_keys, cmap, n_cat, plottype, output_file='output.png'):\n    fig, ax = plt.subplots(figsize=(8, 6))\n\n    keys = y_keys if x_keys is xlabel else x_keys\n    current_palette = sns.color_palette(cmap, n_cat)\n\n    plot_functions = {\n        'box': sns.boxplot,\n        'strip': sns.stripplot,\n        'swarm': sns.swarmplot,\n        'violin': sns.violinplot\n    }\n\n    if plottype in plot_functions:\n        plot_functions[plottype](x=xlabel, y=ylabel, hue=xlabel, data=df, order=keys, palette=current_palette, legend=False, ax=ax)\n\n\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_cat = random.randint(2, 10)\n        categories = [f'cat_{i}' for i in range(n_cat)]\n        n_samples = random.randint(10, 100)\n        categorical_data = np.random.choice(categories, n_samples)\n        continuous_data = np.random.randn(n_samples) * random.uniform(1, 10) + random.uniform(0, 50)\n\n        df = pd.DataFrame({\n            'category': categorical_data,\n            'value': continuous_data\n        })\n\n        cmap = random.choice(['deep', 'muted', 'bright', 'pastel', 'dark', 'colorblind'])\n        plottype = random.choice(['box', 'strip', 'swarm', 'violin'])\n        test_case = (df, 'category', 'value', categories, categories, cmap, n_cat, plottype)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "seaborn_17", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a visual plot using the Seaborn library based on specified parameters. The function will create either a scatter plot or a line plot, depending on the user's choice. The data for the plot will be generated randomly, grouped by specified labels, and will be saved to a file.\n\nFunction signature:\n```python\ndef generate_sns_plot(num_groups, num_points_per_group, saturation_level, palette_type, plot_kind, output_file='output.png'):\n```\n\n### Constants:\n- `output_file`: This is a string that specifies the name of the output file where the plot will be saved. The default value is 'output.png'.\n\n### Input Format:\n- `num_groups`: An integer representing the number of groups to be plotted.\n- `num_points_per_group`: An integer representing the number of data points for each group.\n- `saturation_level`: A float representing the saturation level for the color palette.\n- `palette_type`: A string representing the type of color palette to use (e.g., \"deep\", \"muted\").\n- `plot_kind`: A string indicating the type of plot to create (\"scatter\" or \"line\").\n- `output_file`: An optional string specifying the name of the output file (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file in the specified format.\n\nInput:\n```python\n(3, 50, 0.75, 'muted', 'line')\n```\n\nOutput:\n```python\n'output.png'\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\n\n# main code\ndef generate_sns_plot(num_groups, num_points_per_group, saturation_level, palette_type, plot_kind, output_file='output.png'):\n    group_labels = [f'Group {i+1}' for i in range(num_groups)]\n    data = {\n        'x': np.tile(np.linspace(0, 10, num_points_per_group), num_groups),\n        'y': np.concatenate([np.random.rand(num_points_per_group) + i for i in range(num_groups)]),\n        'group': np.repeat(group_labels, num_points_per_group)\n    }\n    df = pd.DataFrame(data)\n\n    palette = sns.color_palette(palette_type, num_groups)\n    palette = sns.color_palette(palette, desat=saturation_level)\n\n    plt.figure(figsize=(8, 6))\n    if plot_kind == 'scatter':\n        sns.scatterplot(data=df, x='x', y='y', hue='group', palette=palette)\n    elif plot_kind == 'line':\n        sns.lineplot(data=df, x='x', y='y', hue='group', palette=palette)\n    else:\n        sns.scatterplot(data=df, x='x', y='y', hue='group', palette=palette)\n\n    plt.title(\"Group-wise Plot\")\n    plt.legend(title='Group')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    palette_types = [\n        'deep', 'muted', 'pastel', 'bright', 'dark', 'colorblind',\n        'tab10', 'tab20', 'Set1', 'Set2', 'Set3', 'Paired', 'hls', 'husl'\n    ]\n    plot_kinds = ['scatter', 'line']\n    max_colors_per_palette = {\n        'deep': 10, 'muted': 10, 'pastel': 10, 'bright': 10, 'dark': 10, 'colorblind': 10,\n        'tab10': 10, 'tab20': 20, 'Set1': 9, 'Set2': 8, 'Set3': 12,\n        'Paired': 12, 'hls': 12, 'husl': 12\n    }\n\n    for _ in range(n):\n        palette_type = random.choice(palette_types)\n        max_groups = max_colors_per_palette.get(palette_type, 10)\n        num_groups = random.randint(1, max_groups)\n        num_points_per_group = random.randint(10, 200)\n        saturation_level = round(random.uniform(0.1, 1.0), 2)\n        plot_kind = random.choice(plot_kinds)\n\n        test_cases.append((\n            num_groups,\n            num_points_per_group,\n            saturation_level,\n            palette_type,\n            plot_kind\n        ))\n    return test_cases\n"}
{"problem_id": "seaborn_18", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a box plot from a given DataFrame. The box plot will visualize the distribution of a specified numerical column grouped by a categorical column. The function should save the generated plot as an image file.\n\nFunction signature:\n```python\ndef plot_ss(df, y_column, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_path` parameter is set to `'output.png'`.\n\nInput format:\n- The function expects a pandas DataFrame `df`, a string `y_column` representing the name of the numerical column, and an optional string `output_path` for the file name.\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated box plot as an image file at the specified `output_path`.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'gen_type': ['A', 'B', 'A', 'C', 'B', 'D', 'E', 'C', 'D', 'E'],\n    'y_column': [5.1, 3.2, 4.8, 6.0, 2.9, 7.5, 1.2, 3.3, 4.1, 2.5]\n}\ndf = pd.DataFrame(data)\n\n# y_column to plot\ny_column = 'y_column'\n```\n\nOutput:\n```python\n# The output will be a boxplot saved as 'output.png' in the current directory.\n# The boxplot will show the distribution of 'y_column' values for each 'gen_type'.\n``` \n\n(Note: The actual output is a visual plot saved as a file, so it cannot be represented in text format.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef plot_ss(df, y_column, output_path='output.png'):\n    plt.figure()\n    sns.boxplot(x='gen_type', y=y_column, data=df, linewidth=1.5)\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    categories = ['A', 'B', 'C', 'D', 'E']\n\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        df = pd.DataFrame({\n            'gen_type': np.random.choice(categories, size=num_samples),\n            'y_column': np.random.randn(num_samples) * 10\n        })\n\n        test_cases.append((df, 'y_column'))\n\n    return test_cases"}
{"problem_id": "seaborn_19", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a heatmap from a given dataset using the Seaborn library. The function should allow customization of various parameters such as color map, axis labels, and title. The heatmap should be saved as an image file.\n\nFunction signature:\n```python\ndef heatmaps(data, cmap, label, title, vmax, vmin, center, xlabel, rot, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `data`: A 2D array-like structure (e.g., a list of lists or a NumPy array).\n- `cmap`: A string representing the color map name.\n- `label`: A string for the color bar label.\n- `title`: A string for the heatmap title (can be None).\n- `vmax`: A float representing the maximum value for the color scale.\n- `vmin`: A float representing the minimum value for the color scale.\n- `center`: A float value to center the colormap.\n- `xlabel`: A string for the x-axis label (can be None).\n- `rot`: An integer representing the rotation angle for x-axis tick labels.\n- `output_file`: A string for the output file name (default is 'output.png').\n\n### Output Format:\n- The function saves a heatmap image to the specified output file. The function does not return any value.\n\n**Input:**\n```python\ndata = np.array([[12.3, 45.6, 78.9],\n                 [23.4, 56.7, 89.0],\n                 [34.5, 67.8, 90.1]])\ncmap = 'viridis'\nlabel = 'Intensity'\ntitle = 'Test Heatmap'\nvmax = 100.0\nvmin = 0.0\ncenter = None\nxlabel = 'X Axis Label'\nrot = 45\noutput_file = 'test_output.png'\n```\n\n**Output:**\n```python\n# A heatmap is generated and saved as 'test_output.png' with the specified parameters.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef heatmaps(data, cmap, label, title, vmax, vmin, center, xlabel, rot, output_file='output.png'):\n    fig, ax = plt.subplots(figsize=(10, 7))\n\n    sns.heatmap(\n        data=data, ax=ax, cmap=cmap, vmax=vmax, vmin=vmin, center=center,\n        square=True, cbar=True, cbar_kws={'label': label, 'shrink': 0.8, 'extend': 'both'},\n        linewidth=0.3, linecolor='black'\n    )\n\n    if title:\n        ax.set_title(title, fontsize=14, fontweight='bold', loc='left')\n    if xlabel:\n        ax.set_xlabel(xlabel, fontweight='bold', fontsize=14)\n        plt.setp(ax.get_xticklabels(), rotation=rot, ha='right', rotation_mode='anchor')\n    else:\n        ax.set_xticklabels([])\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = random.randint(5, 20)\n        data = np.random.rand(m, m) * 100\n\n        cmap = random.choice(['viridis', 'coolwarm', 'magma', 'cividis', 'Blues', 'Reds', 'Greens'])\n\n        label = random.choice([\"Intensity\", \"Frequency\", \"Magnitude\", \"Score\"])\n        title = random.choice([None, \"Heatmap Visualization\", \"Test Heatmap\"])\n        vmax = np.max(data) if random.random() > 0.3 else random.uniform(50, 150)\n        vmin = np.min(data) if random.random() > 0.3 else random.uniform(-50, 0)\n        center = random.uniform(vmin, vmax) if random.random() > 0.5 else None\n        xlabel = random.choice([None, \"X Axis Label\"])\n        rot = random.choice([0, 30, 45, 90])\n\n        test_cases.append((data, cmap, label, title, vmax, vmin, center, xlabel, rot))\n\n    return test_cases"}
{"problem_id": "seaborn_20", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the relationship between a privacy budget and the test area under the curve (AUC) for different configurations of arguments. The function will take a DataFrame containing the relevant data, process it to compute summary statistics, and generate a bar plot with error bars representing the confidence intervals.\n\nFunction signature:\n```python\ndef plot_advanced(df, figure_size, output_file='output.png'):\n```\n\nConstant used in the main code:\n- A small constant `1e-6` is added to the 'epsilon' values to avoid taking the logarithm of zero.\n\nInput format:\n- A pandas DataFrame `df` containing the following columns:\n  - 'epsilon': A numeric column representing the privacy budget.\n  - 'args_combined': A categorical column representing different configurations.\n  - 'test_auc': A numeric column representing the test area under the curve.\n\nOutput format:\n- The function saves a plot as a PNG file to the specified `output_file` path. The plot visually represents the relationship between the log of the privacy budget and the test AUC, with error bars indicating confidence intervals.\n\nInput:\n```python\nimport pandas as pd\n\ndata = {\n    'epsilon': [0.5, 1.2, 0.8, 1.5, 0.3, 0.9, 1.1, 0.7],\n    'args_combined': ['A', 'A', 'B', 'B', 'C', 'C', 'D', 'D'],\n    'test_auc': [0.75, 0.85, 0.65, 0.70, 0.90, 0.95, 0.60, 0.80]\n}\ndf = pd.DataFrame(data)\nfigure_size = (8, 5)\noutput_file = 'test_output.png'\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'test_output.png' \n# showing the bar plot of mean test AUC against log_epsilon with error bars.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\n# main code\ndef plot_advanced(df, figure_size, output_file='output.png'):\n    df['log_epsilon'] = np.log10(df['epsilon'] + 1e-6)\n    summary = df.groupby(['log_epsilon', 'args_combined'])['test_auc'].agg(['mean', 'std', 'count']).reset_index()\n    summary['ci95'] = 1.96 * summary['std'] / np.sqrt(summary['count'])\n    cm = sns.color_palette('coolwarm', df['args_combined'].nunique())\n    plt.figure(figsize=figure_size)\n    ax = sns.barplot(data=summary, x='log_epsilon', y='mean', hue='args_combined', palette=cm, errorbar=None,\n                     edgecolor='black', linewidth=1.2)\n    for _, row in summary.iterrows():\n        plt.errorbar(row['log_epsilon'], row['mean'], yerr=row['ci95'], fmt='none', capsize=5, capthick=1.2, color='black', alpha=0.7)\n\n    plt.xlabel('Log Privacy Budget ($\\\\log_{10}\\\\epsilon$)')\n    plt.ylabel('Test AUC')\n    plt.title('Impact of Privacy Budget on Test AUC')\n    ax.legend(title=\"Args Combined\", loc='lower right', fontsize=10, frameon=True)\n\n    plt.xticks(rotation=45, ha='right')\n    plt.grid(True, linestyle='--', alpha=0.5)\n    plt.tight_layout()\n    plt.savefig(output_file, dpi=300)\n    plt.clf()\n\n", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(5, 20)\n        epsilon_values = np.abs(np.random.normal(loc=1.0, scale=0.5, size=num_samples))\n        args_combined_values = np.random.choice(['A', 'B', 'C', 'D'], size=num_samples)\n        test_auc_values = np.random.uniform(0.5, 1.0, size=num_samples)\n\n        df = pd.DataFrame({\n            'epsilon': epsilon_values,\n            'args_combined': args_combined_values,\n            'test_auc': test_auc_values\n        })\n\n        figure_size = (random.uniform(4, 10), random.uniform(3, 8))\n\n        test_cases.append((df, figure_size))\n\n    return test_cases\n\n"}
{"problem_id": "seaborn_21", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the relationship between the number of embeddings and the best hit rate (HR@10) for different models using a line plot. The function should take a DataFrame as input and generate a line plot that distinguishes between different models using color and style. The plot should be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_emb(df, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- A DataFrame `df` containing at least three columns: `n_emb`, `best_hr`, and `model`.\n\nOutput format:\n- A line plot saved as an image file, with the filename specified by the `output_file` parameter.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'n_emb': [10, 50, 100, 200, 10, 50, 100, 200],\n    'best_hr': [0.2, 0.5, 0.7, 0.9, 0.3, 0.6, 0.8, 0.4],\n    'model': ['Model_A', 'Model_A', 'Model_A', 'Model_A', \n              'Model_B', 'Model_B', 'Model_B', 'Model_B']\n}\n\ndf = pd.DataFrame(data)\n```\n\n**Output:**\nThe output will be a saved plot file named `output.png` that visualizes the data in `df`. The plot will show the line graph of `best_hr` against `n_emb` for `Model_A` and `Model_B`, with different colors and markers for each model. The x-axis will have ticks for the unique values of `n_emb` (10, 50, 100, 200), and the y-axis will be labeled 'HR@10'.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_emb(df, output_file='output.png'):\n    sns.set(color_codes=True)\n    sns.set_context('notebook', font_scale=1.0)\n\n    plt.figure(figsize=(10, 6))\n\n    fig = sns.lineplot(\n        x='n_emb',\n        y='best_hr',\n        hue='model',\n        style='model',\n        markers=True,\n        markersize=10,\n        linewidth=2,\n        data=df\n    )\n\n    fig.set(ylabel='HR@10', xlabel='Number of Embeddings')\n    plt.xticks(sorted(df['n_emb'].unique()))\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    models = ['Model_A', 'Model_B', 'Model_C', 'Model_D']\n    n_emb_values = [10, 50, 100, 200, 500, 1000]\n\n    for _ in range(n):\n        num_entries = random.randint(5, 20)\n\n        df = pd.DataFrame({\n            'n_emb': np.random.choice(n_emb_values, size=num_entries),\n            'best_hr': np.random.uniform(0.1, 1.0, size=num_entries),\n            'model': np.random.choice(models, size=num_entries)\n        })\n\n        test_cases.append(df)\n\n    return test_cases\n"}
{"problem_id": "seaborn_22", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes data using either a heatmap or a line plot, depending on the input parameters. The function should save the generated plot to a specified output file.\n\nFunction signature:\n```python\ndef plot(item, exp, figsize, heatmap, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_file` is set to `'output.png'`.\n\nInput format:\n- `item`: A 1D or 2D array-like structure containing the data to be plotted.\n- `exp`: A 2D array-like structure containing the data to be visualized as a heatmap if `heatmap` is `True`.\n- `figsize`: A tuple specifying the size of the figure (width, height).\n- `heatmap`: A boolean indicating whether to create a heatmap (`True`) or a line plot (`False`).\n- `output_file`: A string specifying the name of the file to save the plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It saves the generated plot to the specified output file.\n\n**Input:**\n```python\nitem = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\nexp = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\nfigsize = (8, 5)\nheatmap = True\n```\n\n**Output:**\n```plaintext\nA heatmap is generated and saved as 'output.png'.\n```\n\n---\n\n**Input:**\n```python\nitem = np.array([0.1, 0.2, 0.3, 0.4, 0.5])\nexp = np.zeros((1, 1))\nfigsize = (6, 4)\nheatmap = False\n```\n\n**Output:**\n```plaintext\nA line plot is generated and saved as 'output.png'.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef plot(item, exp, figsize, heatmap, output_file='output.png'):\n    plt.style.use('classic')\n\n    if heatmap:\n        fig, ax = plt.subplots(figsize=figsize)\n        sns.heatmap(exp, fmt='g', cmap='viridis', cbar=True, ax=ax, yticklabels=False)\n    else:\n        fig, ax = plt.subplots(figsize=figsize)\n        sns.lineplot(x=range(len(item.flatten())), y=item.flatten(), ax=ax, color='blue')\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        heatmap = random.choice([True, False])\n        if heatmap:\n            rows = random.randint(2, 50)\n            cols = random.randint(2, 50)\n            item = np.random.rand(rows, cols)\n            exp = np.random.rand(rows, cols)\n        else:\n            size = random.randint(5, 500)\n            item = np.random.rand(size)\n            exp = np.zeros((1, 1))\n        figsize = (random.uniform(4, 12), random.uniform(3, 10))\n\n        test_cases.append((item, exp, figsize, heatmap))\n\n    return test_cases"}
{"problem_id": "seaborn_23", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the Shannon Diversity Index using box plots and swarm plots. The function will take in a dataset and various parameters to customize the plot's appearance and save it to a file.\n\nFunction signature:\n```python\ndef pl_Shan_div(res, figsize, grouping, color_dic, plot_order, output_file='output.png'):\n```\n\n### Constants:\n- The default value for `output_file` is set to `'output.png'`.\n\n### Input Format:\n- `res`: A DataFrame containing the data to be plotted, including a column for 'Shannon Diversity'.\n- `figsize`: A tuple specifying the size of the figure (width, height).\n- `grouping`: A string representing the column name in `res` used for grouping the data.\n- `color_dic`: A dictionary mapping group names to colors for the box plots.\n- `plot_order`: A list specifying the order in which the groups should be displayed in the plot.\n- `output_file`: A string specifying the filename to save the plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves the generated plot as an image file to the specified `output_file`.\n\n**Input:**\n```python\nres = pd.DataFrame({\n    'Shannon Diversity': [2.5, 3.1, 4.0, 1.2, 5.5, 3.3, 2.8, 4.2, 3.9, 1.8],\n    'grouping': ['Group A', 'Group B', 'Group A', 'Group C', 'Group B', \n                 'Group D', 'Group C', 'Group A', 'Group D', 'Group B']\n})\nfigsize = (10, 6)\ngrouping = 'grouping'\ncolor_dic = {\n    'Group A': (0.1, 0.2, 0.5),\n    'Group B': (0.3, 0.4, 0.6),\n    'Group C': (0.5, 0.1, 0.2),\n    'Group D': (0.7, 0.8, 0.9)\n}\nplot_order = ['Group A', 'Group B', 'Group C', 'Group D']\noutput_file = 'test_output.png'\n```\n\n**Output:**\n```python\n# A boxplot and swarmplot will be generated and saved as 'test_output.png'.\n# The plot will display the Shannon Diversity values for each group with the specified colors and order.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# main code\ndef pl_Shan_div(res, figsize, grouping, color_dic, plot_order, output_file='output.png'):\n    plt.figure(figsize=figsize)\n    ax = sns.boxplot(data=res, x=grouping, y='Shannon Diversity', hue=grouping,\n                     dodge=False, order=plot_order, palette=color_dic, legend=False)\n\n    sns.swarmplot(data=res, x=grouping, y='Shannon Diversity', dodge=False, order=plot_order,\n                  edgecolor='black', linewidth=1, color='white')\n\n    # Adjust transparency of box colors\n    for patch in ax.artists:\n        r, g, b, a = patch.get_facecolor()\n        patch.set_facecolor((r, g, b, 0.3))\n\n    plt.xticks(rotation=90)\n    plt.xlabel('')\n    plt.ylabel('Shannon Diversity')\n    plt.title('')\n    sns.despine()\n\n    plt.savefig(output_file, bbox_inches='tight')\n    plt.clf()", "test_script": "import random\nimport pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        res = pd.DataFrame({\n            'Shannon Diversity': np.random.rand(num_samples) * 10,\n            'grouping': np.random.choice(['Group A', 'Group B', 'Group C', 'Group D'], num_samples)\n        })\n        figsize = (random.uniform(5, 15), random.uniform(5, 15))\n        unique_groups = res['grouping'].unique()\n        color_dic = {group: np.random.rand(3, ) for group in unique_groups}\n        plot_order = list(np.random.permutation(unique_groups))\n\n        test_cases.append((res, figsize, 'grouping', color_dic, plot_order))\n\n    return test_cases\n"}
{"problem_id": "seaborn_24", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a heatmap plot from a 3D NumPy array. The function should allow customization of the color scheme and the display mode (dark or light). The heatmap will visualize the data in the array while handling specific cases where the data may contain zeros.\n\nFunction signature:\n```python\ndef generate_plot(x_arr: np.ndarray, mode: str, color_list: list, x_max: float, vmin: float, vmax: float, output_path: str = 'output.png') -> None:\n```\n\nConstants used in the main code:\n- The constant `c` is derived from the length of `color_list`, which determines how many color maps will be used for the heatmap.\n\nInput format:\n- `x_arr`: A 3D NumPy array of shape (width, height, channels).\n- `mode`: A string indicating the display mode ('dark' or 'light').\n- `color_list`: A list of color strings to be used for the heatmaps.\n- `x_max`: A float representing the maximum value for normalization.\n- `vmin`: A float representing the minimum value for the color scale.\n- `vmax`: A float representing the maximum value for the color scale.\n- `output_path`: A string representing the file path where the output image will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It saves the generated heatmap plot as an image file at the specified output path.\n\nInput:\n```python\nx_arr = np.array([[[  0.,  50., 100.],\n                   [  0., 150., 200.],\n                   [  0.,  75., 250.]],\n\n                  [[  0.,  25.,  50.],\n                   [  0., 100., 150.],\n                   [  0.,  50., 200.]],\n\n                  [[  0.,  10.,  20.],\n                   [  0.,  30.,  40.],\n                   [  0.,  50.,  60.]]], dtype=np.float32)\n\nmode = 'light'\ncolor_list = ['#FF5733', '#33FF57', '#3357FF']\nx_max = 250.0\nvmin = 0.0\nvmax = 100.0\n```\n\nOutput:\n```python\n# The output will be a saved heatmap image at 'output.png' with the specified parameters.\n# The actual image cannot be represented in text format.\n```", "ground_truth_code": "import seaborn as sns\nimport numpy as np\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef generate_plot(x_arr, mode, color_list, x_max, vmin, vmax, output_path='output.png'):\n    (w, h, c) = x_arr.shape\n    x = x_arr.copy()\n\n    x_masked = np.where(x == 0, np.nan, x)\n\n    xxx = np.all(x == 0, axis=-1).astype(float)\n    xxx[xxx == 0] = np.nan\n\n    cmaps = [\n        sns.dark_palette(color, n_colors=50, reverse=False) if mode == 'dark'\n        else sns.light_palette(color, n_colors=50, reverse=False)\n        for color in color_list\n    ]\n\n    fig, ax = plt.subplots(figsize=(8, 8))\n\n    for i in range(min(c, len(color_list))):\n        data = x_masked[:, :, i] / x_max\n        sns.heatmap(\n            data, cmap=cmaps[i], vmin=vmin, vmax=vmax,\n            yticklabels=False, xticklabels=False, cbar=False,\n            ax=ax, alpha=0.8\n        )\n    grey_cmap = 'Greys'\n    grey_vmin, grey_vmax = (-10000, 1) if mode == 'dark' else (0, 1)\n    sns.heatmap(\n        xxx, vmin=grey_vmin, vmax=grey_vmax, cmap=grey_cmap,\n        yticklabels=False, xticklabels=False, cbar=False, ax=ax, alpha=0.6\n    )\n\n    if mode != 'dark':\n        ax.axhline(y=0, color='grey', lw=2, ls='--')\n        ax.axhline(y=w, color='grey', lw=2, ls='--')\n        ax.axvline(x=0, color='grey', lw=2, ls='--')\n        ax.axvline(x=h, color='grey', lw=2, ls='--')\n\n    plt.savefig(output_path, bbox_inches='tight')\n    plt.close(fig)\n", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        w = random.randint(10, 100)\n        h = random.randint(10, 100)\n        c = random.randint(1, 5)\n        x_arr = np.random.randint(0, 256, size=(w, h, c)).astype(np.float32)\n        mode = random.choice(['dark', 'light'])\n        color_list = [\"#\" + ''.join(random.choices('0123456789ABCDEF', k=6)) for _ in range(c)]\n        x_max = random.uniform(1, 255)\n        vmin = random.uniform(-10000, 0) if mode == 'dark' else random.uniform(0, 50)\n        vmax = random.uniform(vmin + 1, 100)\n\n\n        test_cases.append((x_arr, mode, color_list, x_max, vmin, vmax))\n\n    return test_cases"}
{"problem_id": "seaborn_25", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates and saves a plot based on provided data and styling options. The function should allow customization of colors, palettes, and other visual aspects of the plot. \n\nFunction Signature:\n```python\ndef generate_and_save_plot(plot_data, figure_size, color, palette, saturation, hue_names, default_palette, group_names, output_file='output.png'):\n```\n\n### Constants Used:\n- The default output file name is set to `'output.png'`.\n\n### Input Format:\n- `plot_data`: A list or array of numerical values to be plotted.\n- `figure_size`: A tuple representing the size of the figure (width, height).\n- `color`: A string representing a color name or hex code.\n- `palette`: A dictionary or list representing a color palette.\n- `saturation`: A float value representing the saturation level (0 to 1).\n- `hue_names`: A list of names corresponding to different hues.\n- `default_palette`: A string indicating the type of default palette ('light' or 'dark').\n- `group_names`: A list of group names corresponding to the data.\n- `output_file`: A string representing the name of the output file (default is 'output.png').\n\n### Output Format:\n- The function saves a plot as an image file in the specified format (PNG by default) to the location defined by `output_file`.\n\nInput:\n```python\nplot_data = np.array([0.1, 0.4, 0.3, 0.8, 0.6])\nfigure_size = (8, 6)\ncolor = None\npalette = \"deep\"\nsaturation = 0.8\nhue_names = None\ndefault_palette = \"light\"\ngroup_names = None\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with the specified parameters.\n# The plot will display a line graph with the data points from plot_data, using the 'deep' color palette.\n```", "ground_truth_code": "from seaborn.palettes import color_palette\nfrom seaborn import utils\nfrom seaborn.palettes import husl_palette, light_palette, dark_palette\nimport matplotlib.pyplot as plt\n\n# main code\ndef generate_and_save_plot(plot_data, figure_size, color, palette, saturation, hue_names, default_palette, group_names, output_file='output.png'):\n    n_colors = len(hue_names) if hue_names is not None else len(plot_data) if plot_data is not None else 1\n\n    if color is None and palette is None:\n        current_palette = utils.get_color_cycle()\n        colors = color_palette(n_colors=n_colors) if n_colors <= len(current_palette) else husl_palette(n_colors, l=0.7)\n    elif palette is None:\n        colors = [color] * n_colors if hue_names is None else (\n            light_palette(color, n_colors) if default_palette == 'light' else dark_palette(color, n_colors)\n        )\n    else:\n        if isinstance(palette, dict):\n            levels = hue_names if hue_names is not None else group_names\n            palette = [palette[l] for l in levels]\n        colors = color_palette(palette, n_colors)\n\n    if saturation < 1:\n        colors = color_palette(colors, desat=saturation)\n\n    rgb_colors = color_palette(colors)\n\n    plt.figure(figsize=figure_size)\n    plt.plot(plot_data, color=rgb_colors[0], label='Example Line')\n    plt.legend()\n    plt.savefig(output_file)", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        plot_data = np.random.rand(random.randint(10, 100))\n        figure_size = (random.uniform(4, 12), random.uniform(4, 12))\n        color = random.choice(\n            [None, (random.random(), random.random(), random.random()), f'#{random.randint(0, 0xFFFFFF):06x}'])\n        palette_options = [None, \"deep\", \"muted\", \"bright\", \"dark\", \"colorblind\"]\n        palette = random.choice(palette_options)\n        saturation = random.uniform(0, 1)\n        hue_names = random.choice([None, [\"A\", \"B\", \"C\"], [\"X\", \"Y\", \"Z\", \"W\"]])\n        default_palette = random.choice([\"light\", \"dark\"])\n        group_names = random.choice([None, [\"Group1\", \"Group2\"], [\"Set1\", \"Set2\", \"Set3\"]])\n        test_cases.append(\n            (plot_data, figure_size, color, palette, saturation, hue_names, default_palette, group_names))\n\n    return test_cases"}
{"problem_id": "seaborn_26", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the accuracy of predictions made by different algorithms over time. The function will take in several parameters, process the data, and generate a bar plot that displays the accuracy of each algorithm at various time intervals. The plot will be saved as an image file.\n\nFunction signature:\n```python\ndef plot_accuracy(ground_truths, figsize, predictions, legend_labels, time_offsets, max_sessions, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `100.0`, which is used to convert the accuracy from a fraction to a percentage.\n\nInput format:\n- `ground_truths`: A list of lists containing ground truth values for each participant across different algorithms.\n- `figsize`: A tuple specifying the size of the figure for the plot.\n- `predictions`: A list of lists containing predicted values for each participant across different algorithms.\n- `legend_labels`: A list of strings representing the labels for each algorithm in the legend.\n- `time_offsets`: A list of lists containing time offsets for each participant across different algorithms.\n- `max_sessions`: An integer specifying the maximum number of sessions to consider for accuracy calculation.\n- `output_file`: A string specifying the filename to save the output plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a bar plot as an image file at the specified output location.\n\n**Input:**\n```python\nground_truths = [\n    [\n        [np.array([1, 0, 1]), np.array([0, 1, 1])],\n        [np.array([1, 1, 0]), np.array([0, 0, 1])]\n    ],\n    [\n        [np.array([0, 1, 1]), np.array([1, 0, 0])],\n        [np.array([1, 1, 1]), np.array([0, 1, 0])]\n    ]\n]\nfigsize = (8, 5)\npredictions = [\n    [\n        [np.array([1, 0, 0]), np.array([0, 1, 1])],\n        [np.array([1, 0, 1]), np.array([0, 0, 1])]\n    ],\n    [\n        [np.array([0, 1, 0]), np.array([1, 0, 1])],\n        [np.array([1, 0, 1]), np.array([0, 1, 1])]\n    ]\n]\nlegend_labels = ['Algorithm 0', 'Algorithm 1']\ntime_offsets = [\n    [5.0, 10.0],\n    [15.0, 20.0]\n]\nmax_sessions = 3\noutput_file = 'output.png'\n```\n\n**Output:**\n```python\n# The function will generate a bar plot saved as 'output.png' with the following characteristics:\n# - X-axis: Time (days) with values [5.0, 10.0, 15.0, 20.0]\n# - Y-axis: Accuracy with calculated values based on the ground truths and predictions\n# - Legend: 'Algorithm 0', 'Algorithm 1'\n# - The plot will show the accuracy percentages for each algorithm over the specified time offsets.\n``` \n\n(Note: The actual output image file 'output.png' will be generated by the function, and the accuracy values will depend on the specific ground truth and prediction arrays provided in the input.)", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_accuracy(ground_truths, figsize, predictions, legend_labels, time_offsets, max_sessions,\n                  output_file='output.png'):\n    accuracies, times, algorithms, participants = [], [], [], []\n    for algo_idx, (gt_participants, pred_participants, times_participants) in enumerate(\n            zip(ground_truths, predictions, time_offsets)):\n        for part_idx, (gt_sessions, pred_sessions, times_sessions) in enumerate(\n                zip(gt_participants, pred_participants, times_participants)):\n            for sess_idx, (gt, pred, time) in enumerate(zip(gt_sessions, pred_sessions, times_sessions)):\n                if sess_idx > max_sessions:\n                    break\n                accuracies.append(np.mean(np.array(gt) == np.array(pred)) * 100.0)\n                times.append(time)\n                participants.append(part_idx)\n                algorithms.append(algo_idx)\n\n    df = pd.DataFrame(\n        {'Time (days)': times, 'Accuracy': accuracies, 'Participant': participants, 'Algorithm': algorithms})\n\n    plt.figure(figsize=figsize)\n    g = sns.barplot(x='Time (days)', y='Accuracy', hue='Algorithm', data=df, capsize=0.05, errorbar='sd')\n    for text, label in zip(g.get_legend().texts, legend_labels):\n        text.set_text(label)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_algorithms = random.randint(2, 5)\n        num_participants = random.randint(5, 20)\n        max_sessions = random.randint(3, 10)\n\n        ground_truths, predictions, time_offsets = [], [], []\n\n        for _ in range(num_algorithms):\n            gt_participants, pred_participants, time_participants = [], [], []\n            for _ in range(num_participants):\n                num_sessions = random.randint(1, max_sessions)\n                gt_sessions, pred_sessions, times_sessions = [], [], []\n                for _ in range(num_sessions):\n                    seq_len = random.randint(5, 15)\n                    gt = np.random.randint(0, 2, size=seq_len)\n                    pred = np.random.randint(0, 2, size=seq_len)\n                    time = random.uniform(0, 30)\n                    gt_sessions.append(gt)\n                    pred_sessions.append(pred)\n                    times_sessions.append(time)\n\n                gt_participants.append(gt_sessions)\n                pred_participants.append(pred_sessions)\n                time_participants.append(times_sessions)\n\n            ground_truths.append(gt_participants)\n            predictions.append(pred_participants)\n            time_offsets.append(time_participants)\n\n        figsize = (random.uniform(6, 12), random.uniform(4, 8))\n        legend_labels = [f'Algorithm {i}' for i in range(num_algorithms)]\n\n        test_cases.append((ground_truths, figsize, predictions, legend_labels, time_offsets, max_sessions))\n\n    return test_cases"}
{"problem_id": "seaborn_27", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a combined box plot and swarm plot from a given dataset. The function will visualize the distribution of a categorical variable across different groups, allowing for a clear comparison of proportions.\n\nFunction Signature:\n```python\ndef pl_swarm_box(test1, grouping, per_cat, replicate, figure_sizing, plot_order, col_in, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `test1`: A pandas DataFrame containing the data to be visualized.\n- `grouping`: A string representing the column name used for grouping the data.\n- `per_cat`: A string representing the column name of the categorical variable to be analyzed.\n- `replicate`: A string representing the column name used for replicates in the data.\n- `figure_sizing`: A tuple specifying the size of the figure (width, height).\n- `plot_order`: A list of strings specifying the order of the groups to be plotted.\n- `col_in`: A list of strings specifying which categories to include in the plot.\n- `output_file`: A string specifying the filename for saving the output plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value but saves a plot as an image file to the specified `output_file`.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame\ntest1 = pd.DataFrame({\n    'Group': ['Group_1', 'Group_1', 'Group_2', 'Group_2', 'Group_3', 'Group_3', 'Group_1', 'Group_2'],\n    'Replicate': [1, 1, 1, 1, 1, 1, 2, 2],\n    'Category': ['Cat_1', 'Cat_2', 'Cat_1', 'Cat_3', 'Cat_2', 'Cat_3', 'Cat_1', 'Cat_2']\n})\n\ngrouping = 'Group'\nper_cat = 'Category'\nreplicate = 'Replicate'\nfigure_sizing = (10, 6)\nplot_order = ['Group_1', 'Group_2', 'Group_3']\ncol_in = ['Cat_1', 'Cat_2']\n\n# Call the function\npl_swarm_box(test1, grouping, per_cat, replicate, figure_sizing, plot_order, col_in, output_file='output.png')\n```\n\n**Output:**\n- The function generates a boxplot and swarmplot visualizing the percentage distribution of 'Cat_1' and 'Cat_2' across the groups 'Group_1', 'Group_2', and 'Group_3'. The output is saved as 'output.png'.\n\n(Note: The actual visual output cannot be displayed in this format, but the function will create a file named 'output.png' containing the plot.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef pl_swarm_box(test1, grouping, per_cat, replicate, figure_sizing, plot_order, col_in, output_file='output.png'):\n\n    test1[per_cat] = test1[per_cat].astype('category')\n    test_freq = test1.groupby([grouping, replicate])[per_cat].value_counts(normalize=True).mul(\n        100).unstack().reset_index()\n\n    melt_per_plot = test_freq.melt(id_vars=[grouping, replicate], var_name=per_cat, value_name='percentage')\n\n    if col_in:\n        melt_per_plot = melt_per_plot[melt_per_plot[per_cat].isin(col_in)]\n\n    plot_order = plot_order or list(melt_per_plot[grouping].unique())\n\n    plt.figure(figsize=figure_sizing)\n    ax = sns.boxplot(data=melt_per_plot, x=grouping, y='percentage', order=plot_order)\n    sns.swarmplot(data=melt_per_plot, x=grouping, y='percentage', order=plot_order,\n                  edgecolor='black', linewidth=1, size=1)\n\n    for patch in ax.artists:\n        (r, g, b, a) = patch.get_facecolor()\n        patch.set_facecolor((r, g, b, 0.3))\n\n    plt.xticks(rotation=90)\n    plt.xlabel('')\n    plt.ylabel('')\n    sns.despine()\n    plt.savefig(output_file, bbox_inches='tight')", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_groups = random.randint(2, 10)\n        num_replicates = random.randint(2, 5)\n        num_categories = random.randint(3, 7)\n        grouping_col = 'Group'\n        replicate_col = 'Replicate'\n        category_col = 'Category'\n        groups = np.random.choice([f'Group_{i}' for i in range(num_groups)], num_groups * num_replicates)\n        replicates = np.tile(np.arange(1, num_replicates + 1), num_groups)\n        categories = np.random.choice([f'Cat_{i}' for i in range(num_categories)], num_groups * num_replicates)\n        test1 = pd.DataFrame({grouping_col: groups, replicate_col: replicates, category_col: categories})\n        figure_sizing = (random.randint(5, 15), random.randint(5, 15))\n        plot_order = random.sample(list(set(groups)), k=min(len(set(groups)), 5)) if random.random() > 0.5 else None\n        col_in = random.sample(list(set(categories)), k=min(len(set(categories)), 3)) if random.random() > 0.5 else None\n        test_cases.append(\n            (test1, grouping_col, category_col, replicate_col, figure_sizing, plot_order, col_in))\n\n    return test_cases\n"}
{"problem_id": "seaborn_28", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the activations of neurons in a clustered format. The function should generate a heatmap representation of the activations, highlighting different clusters of neurons with distinct colors. The function will also allow for customization of the output file path for saving the generated plot.\n\nFunction Signature:\n```python\ndef plot_clustered_activations(tokens, activations, clusters, output_path='output.png'):\n```\n\nConstant used in the main code:\n- `masking_threshold = 0.01`: This constant is used to determine the threshold below which activations are masked (i.e., not displayed in the heatmap).\n\nInput Format:\n- `tokens`: A list of strings representing the labels for the x-axis.\n- `activations`: A 2D NumPy array where each row corresponds to a neuron and each column corresponds to an activation value.\n- `clusters`: A dictionary where keys are cluster identifiers and values are lists of neuron indices belonging to each cluster.\n- `output_path`: A string representing the file path where the output image will be saved (default is 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a heatmap image to the specified output path.\n\n**Input:**\n```python\ntokens = ['A1B2C', 'D3E4F', 'G5H6I', 'J7K8L', 'M9N0O']\nactivations = np.array([[0.1, 0.5, 1.2, 0.3, 0.0],\n                        [0.0, 0.2, 1.5, 0.8, 0.0],\n                        [0.0, 0.0, 0.0, 0.0, 0.0],\n                        [0.4, 1.0, 0.6, 0.9, 0.0]])\nclusters = {\n    'cluster_0': [0, 1],\n    'cluster_1': [2],\n    'cluster_2': [3]\n}\n```\n\n**Output:**\nThe function `plot_clustered_activations(tokens, activations, clusters, output_path='output.png')` will generate a heatmap saved as `output.png` with the following characteristics:\n- The heatmap will display activations for the tokens with masked values below the threshold of 0.01.\n- Clusters will be visually distinguished by colored rectangles around the corresponding neurons.\n- The x-axis will be labeled with the provided tokens, rotated for better visibility.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport copy\nimport seaborn as sns\nfrom matplotlib.patches import Rectangle\nimport numpy as np\n\n# main code\ndef plot_clustered_activations(tokens, activations, clusters, output_path='output.png'):\n    masking_threshold = 0.01\n    masked = np.ma.masked_less(activations, masking_threshold)\n\n    fig = plt.figure(figsize=(activations.shape[1], 60))\n    ax = plt.gca()\n\n    v = copy.copy(plt.colormaps['viridis_r'])\n    v.set_bad('white')\n\n    g = sns.heatmap(activations, mask=masked.mask, cmap=v, ax=ax, vmax=2, vmin=0, cbar=False)\n\n    colors = plt.colormaps['prism'].resampled(len(clusters.keys()))\n\n    row = 0\n    for idx, (cluster_id, neurons) in enumerate(clusters.items()):\n        n_neurons = len(neurons)\n        edge_color = colors(idx, 0.5)\n        fill_color = edge_color\n\n        g.add_patch(Rectangle((-1, row), 1, n_neurons, fill=True, facecolor=edge_color, edgecolor=edge_color, lw=5, label=f'Cluster {cluster_id}'))\n        g.add_patch(Rectangle((-1, row), activations.shape[1] + 1, n_neurons, fill=False, facecolor=fill_color, edgecolor=edge_color, lw=5))\n\n        row += n_neurons\n\n    left, right = plt.xlim()\n    plt.xlim(max(0, left - 0.5), right)\n\n    if tokens:\n        ax.set_xticks(np.arange(activations.shape[1]))\n        ax.set_xticklabels(tokens[-activations.shape[1]:], rotation=-45)\n\n    ax.tick_params(axis='x', which='major', labelsize=28)\n    plt.tick_params(axis='x', which='both', left=False, bottom=True, top=True, labeltop=True, labelbottom=True)\n\n    fig.set_facecolor('w')\n    plt.legend(loc='lower left', bbox_to_anchor=(1.05, 0))\n\n    plt.savefig(output_path, bbox_inches='tight')\n    plt.close(fig)", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    def random_tokens(length):\n        return [\"\".join(random.choices(string.ascii_uppercase + string.digits, k=5)) for _ in range(length)]\n\n    def random_activations(rows, cols):\n        return np.random.uniform(0, 2, (rows, cols))\n\n    def random_clusters(rows):\n        cluster_dict = {}\n        assigned = 0\n        while assigned < rows:\n            cluster_size = random.randint(1, 10)\n            cluster_dict[f\"cluster_{len(cluster_dict)}\"] = list(range(assigned, min(assigned + cluster_size, rows)))\n            assigned += cluster_size\n        return cluster_dict\n\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(10, 50)\n        cols = random.randint(10, 50)\n\n        tokens = random_tokens(cols)\n        activations = random_activations(rows, cols)\n        clusters = random_clusters(rows)\n\n        test_cases.append((tokens, activations, clusters))\n    return test_cases"}
{"problem_id": "seaborn_29", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the distribution of a specified variable from a given dataset. The function will generate a histogram with a kernel density estimate (KDE) overlay, highlighting specific quantiles and values of interest.\n\nFunction signature:\n```python\ndef draw_var_dist(adata, var_name, quantile, find_value, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `50`, which represents the number of bins in the histogram.\n\n### Input Format:\n- `adata`: A data structure containing variable data.\n- `var_name`: A string representing the variable name.\n- `quantile`: A float between 0 and 1.\n- `find_value`: A float value or `None`.\n- `figsize`: A tuple of two integers representing the figure size.\n- `output_file`: A string for the output filename (optional).\n\n### Output Format:\n- The function saves a plot as an image file with the specified filename, showing the distribution of the variable along with quantile and value annotations.\n\n**Input:**\n```python\nimport numpy as np\nimport pandas as pd\n\n# Mock data generation\nnum_vars = 200\nvar_name = 'feature_42'\nvar_data = pd.DataFrame({\n    var_name: np.random.normal(loc=50, scale=10, size=num_vars)\n})\nadata = type('MockAdata', (object,), {'var': var_data})()\nquantile = 0.75\nfind_value = 60.00\nfigsize = (8, 5)\n\n# Call the function\ndraw_var_dist(adata, var_name, quantile, find_value, figsize)\n```\n\n**Output:**\n- A histogram plot saved as 'output.png' showing the distribution of 'feature_42', with a red vertical line at the 75th percentile and a green dashed line at the value 60.00, along with corresponding text annotations on the plot.", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef draw_var_dist(adata, var_name, quantile, find_value, figsize, output_file='output.png'):\n    fig = plt.figure(figsize=figsize)\n    sns.histplot(adata.var[var_name], bins=50, kde=True, stat='density')\n\n    quantile_value = adata.var[var_name].quantile(quantile)\n    plt.axvline(quantile_value, color='red')\n    plt.text(quantile_value, 1.0, f'{quantile_value:.2f} at {quantile * 100}%', color='red')\n\n    if find_value is not None:\n        find_quantile = (adata.var[var_name] < find_value).sum() / adata.var.shape[0]\n        plt.axvline(find_value, color='green', linestyle='--')\n        plt.text(find_value, 0.7, f'{find_value:.2f} at {find_quantile * 100:.2f}%', color='green')\n\n    plt.title(f'{var_name} distribution')\n    plt.savefig(output_file)\n    plt.close(fig)\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_vars = random.randint(50, 500)\n        var_name = 'feature_' + str(random.randint(1, 100))\n        var_data = pd.DataFrame({\n            var_name: np.random.normal(loc=random.uniform(0, 100), scale=random.uniform(1, 30), size=num_vars)\n        })\n        adata = type('MockAdata', (object,), {'var': var_data})()\n        quantile = round(random.uniform(0.01, 0.99), 2)\n\n        if random.random() > 0.5:\n            find_value = round(random.uniform(var_data[var_name].min(), var_data[var_name].max()), 2)\n        else:\n            find_value = None\n        figsize = (random.randint(4, 12), random.randint(3, 8))\n        test_cases.append((adata, var_name, quantile, find_value, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_30", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a time series data along with specific events that occur during that time. The function will plot a given signal and mark the occurrences of two types of events: those that belong to \"us\" and those that belong to \"others\". \n\nThe function signature is as follows:\n\n```python\ndef plot_u(times, u, t_deltas, is_own_event, figsize, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- `times`: A list or array of time points corresponding to the signal `u`.\n- `u`: A list or array of signal values at the given time points.\n- `t_deltas`: A list or array of time intervals between events.\n- `is_own_event`: A list or array of boolean values indicating whether each event belongs to \"us\" (True) or \"others\" (False).\n- `figsize`: A tuple specifying the size of the figure (width, height).\n- `output_file`: A string specifying the name of the output file where the plot will be saved (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\nInput:\n```python\ntimes = np.array([0.1, 0.3, 0.5, 0.7, 1.0])\nu = np.array([0.2, 0.4, 0.6, 0.8, 1.0])\nt_deltas = np.array([0.1, 0.2, 0.2, 0.1, 0])\nis_own_event = np.array([1, 0, 1, 0, 1])\nfigsize = (6, 4)\n```\n\nOutput:\n```python\n# The function will generate a plot saved as 'output.png' with the following characteristics:\n# - The plot will show the curve of u(t) over time.\n# - Vertical lines will indicate the times of own events (in one color) and other events (in another color).\n# - The figure size will be 6 inches by 4 inches.\n```", "ground_truth_code": "import numpy as np\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef plot_u(times, u, t_deltas, is_own_event, figsize, output_file='output.png'):\n    t_deltas = np.asarray(t_deltas)\n    is_own_event = np.asarray(is_own_event)\n    seq_len = np.nonzero(t_deltas == 0)[0][0] if np.any(t_deltas == 0) else len(t_deltas)\n\n    abs_t = np.cumsum(t_deltas[:seq_len])\n    abs_own = is_own_event[:seq_len]\n\n    our_events = [t for t, o in zip(abs_t, abs_own) if o]\n    other_events = [t for t, o in zip(abs_t, abs_own) if not o]\n\n    u_max = np.max(u)\n\n    plt.figure(figsize=figsize)\n    c1, c2, c3 = sns.color_palette(n_colors=3)\n\n    plt.plot(times, u, label='$u(t)$', color=c1)\n    plt.vlines(our_events, 0, 0.75 * u_max, label='Us', alpha=0.5, color=c2)\n    plt.vlines(other_events, 0, 0.75 * u_max, label='Others', alpha=0.5, color=c3)\n\n    plt.xlabel('Time')\n    plt.ylabel('$u(t)$')\n    plt.legend()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        seq_len = random.randint(10, 500)\n        times = np.cumsum(np.random.rand(seq_len))\n        u = np.random.rand(seq_len)\n        t_deltas = np.abs(np.random.randn(seq_len))\n        if random.random() < 0.3:\n            t_deltas[-1] = 0\n        is_own_event = np.random.choice([0, 1], size=seq_len)\n        figsize = (random.uniform(4, 12), random.uniform(4, 12))\n        test_cases.append((times, u, t_deltas, is_own_event, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_31", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the growth of COVID-19 cases in specified provinces of South Africa over time. The function will take in a DataFrame containing COVID-19 data, filter it by province, and plot the number of new and cumulative cases. The function will also include a reference line indicating a 33% daily growth rate.\n\nFunction signature:\n```python\ndef plot_covid19za_growth(df, provinces, ls, figsize, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant used for the reference line is `1.33`, which represents a 33% daily growth rate.\n\nInput format:\n- `df`: A pandas DataFrame containing COVID-19 data with at least the columns 'date', 'province', and 'country'.\n- `provinces`: A list of strings representing the names of the provinces to be plotted.\n- `ls`: A string representing the line style for the plot.\n- `figsize`: A tuple representing the size of the figure (width, height).\n- `output_file`: A string representing the filename to save the plot (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified `output_file`.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'date': pd.date_range(start='2020-03-01', periods=30, freq='D'),\n    'province': ['Gauteng'] * 15 + ['Western Cape'] * 15,\n    'country': ['South Africa'] * 30\n}\ndf = pd.DataFrame(data)\n\nprovinces = ['Gauteng', 'Western Cape']\nls = '-'\nfigsize = (10, 6)\n```\n\n**Output:**\n```python\n# The output will be a saved plot file named 'output.png' in the current directory.\n# The plot will show the growth of confirmed COVID-19 cases in Gauteng and Western Cape over 30 days.\n``` \n\n(Note: The actual output is a visual plot saved as 'output.png', which cannot be displayed in this text format.)", "ground_truth_code": "import matplotlib.pyplot as plt\nimport pandas as pd\nimport numpy as np\nimport seaborn as sns\nfrom matplotlib import ticker\n\n# main code\ndef plot_covid19za_growth(df, provinces, ls, figsize, output_file='output.png'):\n    fig, ax = plt.subplots(figsize=figsize)\n    df = df.set_index('date')\n    df.index = pd.to_datetime(df.index, dayfirst=True)\n\n    for province in provinces:\n        df1 = df[df.province == province].groupby('date').agg({'country': 'count'})\n        df1.columns = ['new cases']\n        df1['cumulative'] = df1['new cases'].cumsum()\n        df1.reset_index()['cumulative'].plot(label=province, ls=ls)\n\n    x = np.linspace(0, plt.xlim()[1])\n    plt.plot(x, x + 1.33, ls='--', color='k', label='33% daily growth')\n    plt.title(f'Data up to {df.index.max().strftime(\"%B %d, %Y\")}')\n    plt.xlabel('Days from first confirmed case')\n    plt.ylabel('Confirmed cases')\n\n    ax.get_yaxis().set_major_formatter(ticker.ScalarFormatter())\n    ax.set_xticks(range(0, int(plt.xlim()[1]) + 1))\n\n    plt.legend(bbox_to_anchor=(1.0, 1.0))\n    sns.despine()\n\n    plt.savefig(output_file)\n    plt.close(fig)", "test_script": "import pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    possible_provinces = ['Gauteng', 'Western Cape', 'KwaZulu-Natal', 'Eastern Cape', 'Free State', 'Limpopo']\n    possible_ls = ['-', '--', '-.', ':']\n\n    for _ in range(n):\n        num_days = random.randint(30, 365)\n        start_date = pd.to_datetime('2020-03-01')\n        date_range = pd.date_range(start=start_date, periods=num_days, freq='D')\n\n        province_data = random.choices(possible_provinces, k=num_days)\n        df = pd.DataFrame({\n            'date': date_range,\n            'province': province_data,\n            'country': ['South Africa'] * num_days\n        })\n        provinces = random.sample(possible_provinces, k=random.randint(1, len(possible_provinces)))\n        ls = random.choice(possible_ls)\n        figsize = (random.uniform(5, 15), random.uniform(4, 10))\n\n        test_cases.append((df, provinces, ls, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_32", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the relationship between age, income, and sex using a box plot. The function will categorize ages into specific ranges and display the income distribution for each age range, separated by sex.\n\nFunction signature:\n```python\ndef plot_data(age, income, sex, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `bins=[0, 20, 30, 40, 50]`: This constant defines the age ranges for categorization.\n\nInput format:\n- `age`: A list or array of integers representing the ages of individuals.\n- `income`: A list or array of floats or integers representing the income of individuals.\n- `sex`: A list or array of integers where 2 represents female and any other value represents male.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a box plot as an image file to the specified output file.\n\nInput:\n```python\nage = np.array([22, 35, 45, 28, 19, 50, 33, 40, 29, 15])\nincome = np.array([3000, 7000, 8000, 4000, 2000, 9000, 6000, 7500, 5000, 1500])\nsex = np.array([1, 2, 1, 1, 2, 2, 1, 2, 1, 1])\n```\n\nOutput:\n```plaintext\nA boxplot saved as 'output.png' showing income distribution across age ranges (0-20, 20-30, 30-40, 40-50, 50+) with male and female categories.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\nimport numpy as np\n\n\n# main code\ndef plot_data(age, income, sex, output_file='output.png'):\n    plt.figure(figsize=(7.5, 2.5))\n    sns.set_theme(style='white', palette='pastel', font_scale=1.5, font='DejaVu Sans')\n    ageranges = np.digitize(age, bins=[0, 20, 30, 40, 50])\n    sex = np.where(np.array(sex) == 2, 'female', 'male')\n    sns.boxplot(x=ageranges, y=income, hue=sex, showfliers=False)\n    plt.gca().set_xticklabels(['0-20', '20-30', '30-40', '40-50', '50+'])\n    plt.ylabel('Income ($)')\n    sns.despine(top=True, right=True)\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_size = random.randint(10, 100)\n        age = np.random.randint(0, 60, size=data_size)\n        income = np.random.uniform(1000, 10000, size=data_size)\n        sex = np.random.choice([1, 2], size=data_size)\n\n        test_cases.append((age, income, sex))\n\n    return test_cases"}
{"problem_id": "seaborn_33", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of a classification model using a confusion matrix. The function will take in the actual labels and the predicted labels of a dataset, compute the confusion matrix, normalize it, and then plot it using a heatmap. The resulting plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_confusion_matrix(total_actual, total_predicted, classes, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `total_actual`: A list or array of actual class labels.\n- `total_predicted`: A list or array of predicted class labels (can be probabilities or class indices).\n- `classes`: A list of class names corresponding to the labels.\n- `output_file`: A string representing the filename to save the output plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a confusion matrix plot as an image file to the specified output location.\n\nInput:\n```python\ntotal_actual = np.array([0, 1, 0, 1, 2, 2, 1, 0, 1, 2])\ntotal_predicted = np.array([0.1, 1.9, 0.4, 1.2, 2.5, 1.8, 0.7, 0.2, 1.5, 2.0])\nclasses = ['Class_0', 'Class_1', 'Class_2']\n```\n\nOutput:\n```python\n# Confusion Matrix (as a DataFrame)\n#               Class_0  Class_1  Class_2\n# Class_0        0.50     0.25     0.25\n# Class_1        0.00     0.50     0.50\n# Class_2        0.00     0.00     1.00\n```\n\n(Note: The actual output will be a confusion matrix visualized as a heatmap saved to 'output.png', but the numerical representation is provided here for clarity.)", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\nfrom sklearn.metrics import confusion_matrix\n\n# main code\ndef plot_confusion_matrix(total_actual, total_predicted, classes, output_file='output.png'):\n    total_predicted_int = np.rint(total_predicted).astype(int)\n    num_classes = len(classes)\n\n    cm = confusion_matrix(total_actual, total_predicted_int, labels=np.arange(num_classes))\n\n    row_sums = cm.sum(axis=1, keepdims=True)\n    cm = np.where(row_sums == 0, 0, cm / row_sums)\n\n    cm_df = pd.DataFrame(cm, index=classes, columns=classes)\n\n    plt.figure(figsize=(5, 5))\n    ax = sns.heatmap(\n        cm_df, vmin=0, vmax=1, annot=True, fmt='.2f',\n        cmap='Blues', square=True, annot_kws={'size': 10}\n    )\n\n    bottom, top = ax.get_ylim()\n    ax.set_ylim(bottom + 0.5, top - 0.5)\n\n    plt.title('Confusion Matrix', fontsize=20)\n    plt.ylabel('True label', fontsize=12)\n    plt.xlabel('Predicted label', fontsize=12)\n    plt.tight_layout()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_classes = random.randint(2, 10)\n        num_samples = random.randint(10, 100)\n\n        classes = [f'Class_{i}' for i in range(num_classes)]\n        total_actual = np.random.randint(0, num_classes, size=num_samples)\n        total_predicted = np.random.uniform(0, num_classes, size=num_samples)\n\n        test_cases.append((total_actual, total_predicted, classes))\n\n    return test_cases"}
{"problem_id": "seaborn_34", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a heatmap visualization based on predicted probabilities from a set of input files. Each input file is named in a specific format that encodes its position in a grid. The function will read these files, extract their positions, and plot a heatmap where the color intensity represents the predicted probabilities.\n\nFunction signature:\n```python\ndef prediction_heatmap(filenames, total_predicted, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `-1`, which is used to initialize the DataFrame to indicate unassigned values.\n\nInput format:\n- `filenames`: A list of strings representing the names of the input files, formatted as `prefix_x_y.extension`.\n- `total_predicted`: A list of floats representing the predicted probabilities corresponding to each file.\n\nOutput format:\n- The function saves a heatmap image to the specified `output_file`. The image file will be in PNG format.\n\nInput:\n```python\nfilenames = ['tile_0_0.ext', 'tile_1_2.ext', 'tile_3_1.ext']\ntotal_predicted = [0.75, 0.60, 0.90]\n```\n\nOutput:\n```python\n# The output will be a heatmap saved as 'output.png' with the following values:\n# df = \n#      0    1    2\n# 0  0.75 -1.0 -1.0\n# 1 -1.0 -1.0  0.60\n# 2 -1.0 -1.0 -1.0\n# 3 -1.0  0.90 -1.0\n``` \n\n(Note: The actual heatmap image will be saved as 'output.png', and the DataFrame `df` represents the values that will be visualized in the heatmap.)", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport matplotlib.pyplot as plt\nimport seaborn as sns\n\n\n# main code\ndef prediction_heatmap(filenames, total_predicted, output_file='output.png'):\n    def find_max_x_y(filenames):\n        x_max = y_max = 0\n        for file in filenames:\n            x, y = file.split('.')[0].split('_')[-2:]\n            x_max = max(x_max, int(x))\n            y_max = max(y_max, int(y))\n        return x_max, y_max\n\n    x_max, y_max = find_max_x_y(filenames)\n\n    df = pd.DataFrame(-1 * np.ones((x_max + 1, y_max + 1)),\n                      columns=np.arange(y_max + 1),\n                      index=np.arange(x_max + 1))\n\n    for i, file in enumerate(filenames):\n        x, y = file.split('.')[0].split('_')[-2:]\n        df.iloc[int(x), int(y)] = float(total_predicted[i])\n\n    mask = df < 0\n    plt.figure(figsize=(15, 15), dpi=300)\n    ax = sns.heatmap(df, vmin=0, vmax=1, annot=False, fmt='.2f', cmap='RdYlBu',\n                     square=True, mask=mask, cbar_kws={'shrink': 0.5})\n\n    bottom, top = ax.get_ylim()\n    ax.set_ylim(bottom + 0.5, top - 0.5)\n\n    plt.title('Predicted Probability Heatmap', fontsize=20)\n    plt.ylabel('Tile Position Y', fontsize=20)\n    plt.xlabel('Tile Position X', fontsize=20)\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        x_max = random.randint(5, 20)\n        y_max = random.randint(5, 20)\n\n        num_files = random.randint(1, (x_max + 1) * (y_max + 1))\n        coordinates = random.sample([(x, y) for x in range(x_max + 1) for y in range(y_max + 1)], num_files)\n        filenames = [f\"tile_{x}_{y}.ext\" for x, y in coordinates]\n        total_predicted = np.random.rand(num_files).tolist()\n\n        test_cases.append((filenames, total_predicted))\n\n    return test_cases"}
{"problem_id": "seaborn_35", "library": "seaborn", "code_problem": "You are tasked with creating a function that inspects the predictions made by a classification model. The function will evaluate the model's performance by calculating various metrics and visualizing the results in a confusion matrix. \n\nFunction signature:\n```python\ndef inspect_predictions(predictions, labels, classes, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the default value for `output_file`, which is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**:\n  - `predictions`: A 2D NumPy array of shape (n_samples, n_classes).\n  - `labels`: A 2D NumPy array of shape (n_samples, n_classes) in one-hot encoded format.\n  - `classes`: A list of strings representing the class names.\n  - `output_file`: A string representing the filename for saving the confusion matrix plot.\n\n- **Output**:\n  - The function does not return any value. Instead, it saves a confusion matrix plot to the specified output file and generates DataFrames containing the calculated metrics.\n\nInput:\n```python\npredictions = np.array([[0.1, 0.7, 0.2],\n                        [0.3, 0.4, 0.3],\n                        [0.6, 0.2, 0.2],\n                        [0.2, 0.5, 0.3],\n                        [0.4, 0.4, 0.2]])\nlabels = np.array([[0, 1, 0],\n                   [0, 1, 0],\n                   [1, 0, 0],\n                   [0, 1, 0],\n                   [1, 0, 0]])\nclasses = ['class_0', 'class_1', 'class_2']\n```\n\nOutput:\n```python\n# The output will be a confusion matrix saved as 'output.png' and the following metrics:\n# Assuming the predictions and labels yield the following metrics:\n\nresults = [\n    pd.DataFrame({'classes': [None], 'average': ['micro'], 'precision': [0.6], 'recall': [0.6], 'support': [5]}),\n    pd.DataFrame({'classes': [None], 'average': ['macro'], 'precision': [0.6], 'recall': [0.6], 'support': [5]}),\n    pd.DataFrame({'classes': [None], 'average': ['weighted'], 'precision': [0.6], 'recall': [0.6], 'support': [5]}),\n    pd.DataFrame({'classes': ['class_0', 'class_1', 'class_2'], 'precision': [0.5, 0.75, 0.0], 'recall': [0.5, 0.75, 0.0], 'support': [2, 3, 0]})\n]\n\n# Confusion Matrix:\n# [[1 1 0]\n#  [1 2 0]\n#  [1 0 0]]\n# Balanced Accuracy: 0.5\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import precision_recall_fscore_support, confusion_matrix, balanced_accuracy_score\n\n# main code\ndef inspect_predictions(predictions, labels, classes, output_file='output.png'):\n    test_predictions = np.argmax(predictions, axis=1)\n    test_predictions = [classes[p] for p in test_predictions]\n    y_test = np.argmax(labels, axis=1)\n    y_test = [classes[p] for p in y_test]\n\n    metrics = ['micro', 'macro', 'weighted']\n    results = []\n    for avg in metrics:\n        precision, recall, _, support = precision_recall_fscore_support(y_test, test_predictions, average=avg,\n                                                                        labels=classes)\n        results.append(pd.DataFrame(\n            {'classes': [None], 'average': [avg], 'precision': [precision], 'recall': [recall], 'support': [support]}))\n\n    precision, recall, _, support = precision_recall_fscore_support(y_test, test_predictions, average=None,\n                                                                    labels=classes)\n    per_class_results = pd.DataFrame({'classes': classes, 'precision': precision, 'recall': recall, 'support': support})\n    results.append(per_class_results)\n\n\n    cm = confusion_matrix(y_test, test_predictions)\n    balanced_accuracy = balanced_accuracy_score(y_test, test_predictions)\n\n    plt.figure(figsize=(10, 6))\n    sns.heatmap(cm, annot=True, fmt='d', cmap='Blues', xticklabels=classes, yticklabels=classes)\n    plt.xlabel('Predicted Label')\n    plt.ylabel('True Label')\n    plt.title(f'Confusion Matrix (Balanced Accuracy: {balanced_accuracy:.2f})')\n    plt.xticks(rotation=45, ha='right')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_classes = random.randint(3, 10)\n        num_samples = random.randint(50, 500)\n        predictions = np.random.rand(num_samples, num_classes)\n        predictions /= predictions.sum(axis=1, keepdims=True)\n        labels = np.zeros((num_samples, num_classes))\n        label_indices = np.random.randint(0, num_classes, size=num_samples)\n        labels[np.arange(num_samples), label_indices] = 1\n        classes = [f'class_{i}' for i in range(num_classes)]\n\n        test_cases.append((predictions, labels, classes))\n\n    return test_cases"}
{"problem_id": "seaborn_36", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a line plot for two sets of frequency data over time. The function should utilize the Seaborn and Matplotlib libraries to create visually appealing plots. The function signature is as follows:\n\n```python\ndef generate_plot(x, y1, y2, output_file=\"output.png\"):\n```\n\nIn this function, the following constant is used:\n- `output_file`: A string that specifies the name of the output file where the plot will be saved. The default value is \"output.png\".\n\nInput format:\n- `x`: A list or array-like structure containing the time values.\n- `y1`: A list or array-like structure containing the frequency values for the first dataset (PMU1).\n- `y2`: A list or array-like structure containing the frequency values for the second dataset (PMU2).\n- `output_file`: An optional string specifying the name of the output file (default is \"output.png\").\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated plots to the specified output file.\n\nInput:\n```python\nx = np.linspace(0, 99, 100)\ny1 = np.sin(2 * np.pi * x / 100) + np.random.normal(0, 0.1, 100)\ny2 = np.cos(2 * np.pi * x / 100) + np.random.normal(0, 0.1, 100)\n```\n\nOutput:\n```plaintext\nA plot saved as \"output.png\" with two subplots:\n1. PMU1 Frequency Plot showing a sine wave with noise.\n2. PMU2 Frequency Plot showing a cosine wave with noise.\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport seaborn as sns\n\n# main code\ndef generate_plot(x, y1, y2, output_file=\"output.png\"):\n\n    sns.set_theme(style=\"whitegrid\")\n\n    fig, axes = plt.subplots(2, 1, figsize=(8, 6), sharex=True)\n\n    sns.lineplot(x=x, y=y1, ax=axes[0])\n    axes[0].set_title(\"PMU1 Frequency Plot\")\n    axes[0].set_ylabel(\"Freq (Hz)\")\n\n    sns.lineplot(x=x, y=y2, ax=axes[1])\n    axes[1].set_title(\"PMU2 Frequency Plot\")\n    axes[1].set_xlabel(\"Time (s)\")\n    axes[1].set_ylabel(\"Freq (Hz)\")\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(50, 501)\n        x = np.linspace(0, length - 1, length)\n        y1 = np.sin(2 * np.pi * x / 100) + np.random.normal(0, 0.1, length)\n        y2 = np.cos(2 * np.pi * x / 100) + np.random.normal(0, 0.1, length)\n        test_cases.append((x, y1, y2))\n\n    return test_cases"}
{"problem_id": "seaborn_37", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a complex matrix by plotting its real and imaginary parts as heatmaps. The function should allow customization of the title and color map used for the plots, and it should save the resulting visualizations to a specified output file.\n\nFunction signature:\n```python\ndef plot_mat(rho, title, cmap, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the default output file name, which is set to `'output.png'`.\n\nInput format:\n- The function takes the following inputs:\n  - `rho`: A 2D numpy array representing a complex matrix.\n  - `title`: A string representing the title of the plot.\n  - `cmap`: A string representing the name of the color map to be used for the heatmaps.\n  - `output_file`: An optional string representing the name of the output file where the plot will be saved.\n\nOutput format:\n- The function does not return any value. Instead, it saves a visual representation of the real and imaginary parts of the complex matrix as a PNG file to the specified output file.\n\nInput:\n```python\nrho = np.array([[0.1 + 0.2j, 0.3 + 0.4j], [0.5 + 0.6j, 0.7 + 0.8j]])\ntitle = \"Test Case 1\"\ncmap = \"viridis\"\n```\n\nOutput:\n```plaintext\nA heatmap plot saved as 'output.png' with the following characteristics:\n- Real part heatmap displayed on the left\n- Imaginary part heatmap displayed on the right\n- Color map used: viridis\n- Title: Test Case 1\n```", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_mat(rho, title, cmap, output_file='output.png'):\n    lim = np.abs(rho).max()\n    fig, axes = plt.subplots(1, 2, figsize=(8, 4))\n    fig.suptitle(title)\n\n    sns.heatmap(rho.real, vmin=-lim, vmax=lim, cmap=cmap, ax=axes[0], cbar=False)\n    axes[0].set_title('Re')\n\n    sns.heatmap(rho.imag, vmin=-lim, vmax=lim, cmap=cmap, ax=axes[1], cbar=True, cbar_kws={'orientation': 'horizontal'})\n    axes[1].set_title('Im')\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    colormaps = ['viridis', 'plasma', 'inferno', 'magma', 'cividis',\n                 'coolwarm', 'bwr', 'seismic', 'cubehelix', 'Spectral']\n\n    for _ in range(n):\n        shape = random.choice([(5, 5), (10, 10), (8, 8), (6, 6), (4, 4)])\n        rho = np.random.randn(*shape) + 1j * np.random.randn(*shape)\n        title = f\"Test Case {_ + 1}\"\n        cmap = random.choice(colormaps)\n\n        test_cases.append((rho, title, cmap))\n\n    return test_cases"}
{"problem_id": "seaborn_38", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the correlation between two sets of data points, while also incorporating their respective standard error margins. The function should generate a scatter plot with a regression line, and it should display error bars representing the standard error of the mean (SEM) for both datasets. The plot should be saved as an image file.\n\nFunction Signature:\n```python\ndef plot_correlation_with_SEM(x_lab, y_lab, x_err_lab, y_err_lab, data, color, output_file=\"output.png\"):\n```\n\nConstants Used:\n- The default value for the `output_file` parameter is set to `\"output.png\"`.\n\nInput Format:\n- The function expects a DataFrame containing the data points and their errors, along with string labels for the x and y data, and their respective errors.\n\nOutput Format:\n- The function saves a plot as an image file in the specified format (default is PNG) to the location defined by `output_file`.\n\nInput:\n```python\nx_lab = \"X_AAA\"\ny_lab = \"Y_BBB\"\nx_err_lab = \"X_AAA_ERR\"\ny_err_lab = \"Y_BBB_ERR\"\ndata = pd.DataFrame({\n    \"X_AAA\": np.array([-5.0, -3.0, 0.0, 2.0, 4.0]),\n    \"Y_BBB\": np.array([-4.0, -2.0, 1.0, 3.0, 5.0]),\n    \"X_AAA_ERR\": np.array([0.2, 0.3, 0.1, 0.4, 0.2]),\n    \"Y_BBB_ERR\": np.array([0.3, 0.2, 0.4, 0.1, 0.3])\n})\ncolor = \"blue\"\n```\n\nOutput:\n```python\n# The function will generate a plot saved as \"output.png\" with the specified parameters.\n# The plot will show a regression line with error bars representing the standard error of the mean (SEM).\n```", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef plot_correlation_with_SEM(x_lab, y_lab, x_err_lab, y_err_lab, data, color, output_file=\"output.png\"):\n    x_error = data[x_err_lab]\n    y_error = data[y_err_lab]\n    x_values = data[x_lab]\n    y_values = data[y_lab]\n\n    min_limit = np.ceil(min(x_values.min(), y_values.min()) - 1)\n    max_limit = np.floor(max(x_values.max(), y_values.max()) + 1)\n    axes_limits = np.array([min_limit, max_limit])\n\n    sns.set_style(\"whitegrid\")\n    plt.figure(figsize=(6, 6))\n\n    grid = sns.regplot(x=x_values, y=y_values, color=color, ci=None)\n    plt.errorbar(x_values, y_values, xerr=x_error, yerr=y_error, fmt='o',\n                 ecolor=sns.color_palette()[0], capthick=2, label='SEM', alpha=0.75)\n\n    plt.axis('equal')\n    grid.plot(axes_limits, axes_limits, ls='--', c='black', alpha=0.8, lw=0.7)\n\n    palette = sns.color_palette('BuGn_r')\n    grid.fill_between(axes_limits, axes_limits - 0.5, axes_limits + 0.5, alpha=0.2, color=palette[2])\n    grid.fill_between(axes_limits, axes_limits - 1, axes_limits + 1, alpha=0.2, color=palette[3])\n\n    plt.xlim(axes_limits)\n    plt.ylim(axes_limits)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        x_lab = \"X_\" + ''.join(random.choices(string.ascii_uppercase, k=3))\n        y_lab = \"Y_\" + ''.join(random.choices(string.ascii_uppercase, k=3))\n        x_err_lab = x_lab + \"_ERR\"\n        y_err_lab = y_lab + \"_ERR\"\n\n        num_points = random.randint(10, 100)\n        x_values = np.random.uniform(-10, 10, num_points)\n        y_values = np.random.uniform(-10, 10, num_points)\n        x_error = np.random.uniform(0.1, 1.0, num_points)\n        y_error = np.random.uniform(0.1, 1.0, num_points)\n        data = pd.DataFrame({\n            x_lab: x_values,\n            y_lab: y_values,\n            x_err_lab: x_error,\n            y_err_lab: y_error\n        })\n        color = random.choice([\"blue\", \"red\", \"green\", \"purple\", \"orange\", \"black\"])\n        test_cases.append((x_lab, y_lab, x_err_lab, y_err_lab, data, color))\n\n    return test_cases"}
{"problem_id": "seaborn_39", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the predictions of a Gaussian Process (GP) model alongside the ground truth values. The function will generate heatmaps for the true values, predicted means, and predicted standard deviations, and save the resulting visualizations to a file.\n\nFunction signature:\n```python\ndef plot(y_true, gp, grid_size, output_file='output.png'):\n```\n\n### Constants:\n- The default value for `output_file` is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**: \n  - `y_true`: A 1D numpy array of true values.\n  - `gp`: A Gaussian Process model instance.\n  - `grid_size`: An integer representing the size of the grid.\n  - `output_file`: A string for the output file name (optional).\n\n- **Output**: \n  - A PNG file saved to the specified `output_file` containing three heatmaps: ground truth, predicted means, and predicted standard deviations.\n\n**Input:**\n```python\ny_true = np.array([[0.1, 0.2, 0.3], \n                   [0.4, 0.5, 0.6], \n                   [0.7, 0.8, 0.9]])\ngp = GaussianProcessRegressor(kernel=RBF(length_scale=1.0))\nx_train = np.array([[0.1, 0.1], [0.2, 0.2], [0.3, 0.3], \n                    [0.4, 0.4], [0.5, 0.5], [0.6, 0.6], \n                    [0.7, 0.7], [0.8, 0.8], [0.9, 0.9]])\ny_train = np.array([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\ngp.fit(x_train, y_train)\ngrid_size = 3\n```\n\n**Output:**\n```python\n# The output will be saved as 'output.png' and will contain three heatmaps:\n# 1. Ground truth heatmap of y_true\n# 2. Predicted mean heatmap from gp.predict\n# 3. Standard deviation heatmap from gp.predict with return_std=True\n``` \n\nNote: The actual visual output (heatmaps) cannot be represented in text format, but the output file 'output.png' will contain the generated plots.", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot(y_true, gp, grid_size, output_file='output.png'):\n    x1 = np.linspace(0, 1, grid_size)\n    x2 = np.linspace(0, 1, grid_size)\n    x1x2 = np.array([[a, b] for a in x1 for b in x2])\n    (y_pred, std) = gp.predict(x1x2, return_std=True)\n    y_pred = y_pred.reshape(grid_size, grid_size)\n    std = std.reshape(grid_size, grid_size)\n    (true_min, true_max) = (y_true.min(), y_true.max())\n    (pred_min, pred_max) = (y_pred.min(), y_pred.max())\n    (std_min, std_max) = (std.min(), std.max())\n    (fig, axes) = plt.subplots(1, 3, figsize=(15, 5))\n    sns.heatmap(y_true.reshape(grid_size, grid_size), ax=axes[0], cmap='viridis', cbar=True, vmin=true_min, vmax=true_max)\n    axes[0].set_title('Ground truth')\n    sns.heatmap(y_pred, ax=axes[1], cmap='viridis', cbar=True, vmin=pred_min, vmax=pred_max)\n    axes[1].set_title('Predict mean')\n    sns.heatmap(std, ax=axes[2], cmap='viridis', cbar=True, vmin=std_min, vmax=std_max)\n    axes[2].set_title('Predict std')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nfrom sklearn.gaussian_process import GaussianProcessRegressor\nfrom sklearn.gaussian_process.kernels import RBF\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        grid_size = np.random.randint(5, 50)\n        y_true = np.random.rand(grid_size, grid_size)\n        gp = GaussianProcessRegressor(kernel=RBF(length_scale=np.random.rand() * 2))\n        x_train = np.random.rand(20, 2)\n        y_train = np.random.rand(20)\n        gp.fit(x_train, y_train)\n        test_cases.append((y_true, gp, grid_size))\n    return test_cases"}
{"problem_id": "seaborn_40", "library": "seaborn", "code_problem": "You are tasked with implementing a function that visualizes the calibration of probabilistic predictions against actual outcomes. The function will generate a calibration plot, which helps in assessing how well the predicted probabilities align with the actual outcomes.\n\nFunction Signature:\n```python\ndef plotCalib(truth, pred, bins, min_samples, label, width, height, output_file='output.png'):\n```\n\n### Constants Used:\n- The constant used in the main code is `0.0001` and `0.9999`, which are used to clip the predicted probabilities to avoid taking the logarithm of zero.\n\n### Input Format:\n- `truth`: A list or array of actual binary outcomes (0 or 1).\n- `pred`: A list or array of predicted probabilities (values between 0 and 1).\n- `bins`: An integer representing the number of bins to use for grouping predicted probabilities.\n- `min_samples`: An integer specifying the minimum number of samples required in each bin to be included in the plot.\n- `label`: A string used as the title label for the plot.\n- `width`: An integer specifying the width of the plot in inches.\n- `height`: An integer specifying the height of the plot in inches.\n- `output_file`: A string specifying the filename to save the plot (default is 'output.png').\n\n### Output Format:\n- The function does not return any value. Instead, it generates and saves a calibration plot as an image file.\n\nInput:\n```python\ntruth = np.array([0, 1, 0, 1, 1, 0, 1, 0, 1, 0])\npred = np.array([0.1, 0.9, 0.2, 0.8, 0.7, 0.3, 0.6, 0.4, 0.5, 0.2])\nbins = 10\nmin_samples = 2\nlabel = 'Test Case 1'\nwidth = 6.0\nheight = 4.5\n```\n\nOutput:\n```python\nMAE = 0.3\nLL = -0.693\n``` \n\n(Note: The actual values for MAE and LL may vary slightly based on the implementation and numerical precision.)", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n\ndef getMAE(pred, truth):\n    return np.abs(truth - pred).mean()\n\n\ndef getLL(pred, truth):\n    ll_sum = 0\n    for i in range(len(pred)):\n        p = np.clip(pred[i], 0.0001, 0.9999)\n        ll_sum += truth[i] * np.log(p) + (1 - truth[i]) * np.log(1 - p)\n    return ll_sum / len(pred)\n\n\n# main code\ndef plotCalib(truth, pred, bins, min_samples, label, width, height, output_file='output.png'):\n    mae = np.round(getMAE(pred, truth), 3)\n    ll = np.round(getLL(pred, truth), 3)\n\n    d = pd.DataFrame({'p': pred, 'y': truth})\n    d['p_bin'] = np.floor(d['p'] * bins) / bins\n    d_bin = d.groupby(['p_bin']).agg(['mean', 'count'])\n\n    filt = d_bin['p']['count'] > min_samples\n\n    x = d_bin['p']['mean'][filt]\n    y = d_bin['y']['mean'][filt]\n    n = d_bin['y']['count'][filt]\n    stderr = np.sqrt(y * (1 - y) / n)\n\n    plt.figure(figsize=(width, height))\n    sns.scatterplot(x=x, y=y, label='Calibration Curve')\n    plt.plot([0.0, 1.0], [0.0, 1.0], 'k-', label='Perfect Calibration')\n    plt.errorbar(x, y, yerr=1.96 * stderr, fmt='o', color='blue', alpha=0.5)\n\n    plt.title(f'{label}: MAE = {mae}, LL = {ll}')\n    plt.xlim([0.0, 1.0])\n    plt.ylim([0.0, 1.0])\n    plt.xlabel('Prediction P(Y|X)')\n    plt.ylabel('Actual P(Y|X)')\n    plt.legend()\n    plt.tight_layout()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(50, 1000)\n        pred = np.clip(np.random.rand(length), 0.0, 1.0)\n        truth = np.random.choice([0, 1], size=length)\n\n        bins = np.random.randint(5, 50)\n        min_samples = np.random.randint(1, 20)\n        label = f'Test Case {_ + 1}'\n        width = np.random.uniform(4, 10)\n        height = np.random.uniform(4, 10)\n\n        test_cases.append((truth, pred, bins, min_samples, label, width, height))\n    return test_cases\n"}
{"problem_id": "seaborn_41", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes two sets of data points on a 2D plane, representing two different trajectories or paths. The function will also display directional arrows indicating the orientation of each point based on given angles.\n\nFunction Signature:\n```python\ndef draw_two(X1, Y1, THETA1, X2, Y2, THETA2, output_file='output.png'):\n```\n\nConstants:\n- The constant `0.25` is used to determine the length of the directional arrows that represent the orientation of each point.\n\nInput Format:\n- `X1`: A list of x-coordinates for the first set of points.\n- `Y1`: A list of y-coordinates for the first set of points.\n- `THETA1`: A list of angles (in radians) corresponding to each point in the first set.\n- `X2`: A list of x-coordinates for the second set of points.\n- `Y2`: A list of y-coordinates for the second set of points.\n- `THETA2`: A list of angles (in radians) corresponding to each point in the second set.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a visual representation of the data points and their orientations to the specified output file.\n\nInput:\n```python\nX1 = [1.5, -3.2, 4.0]\nY1 = [2.1, -1.5, 3.3]\nTHETA1 = [0.5, -1.0, 1.5]\nX2 = [2.0, -2.5, 3.5]\nY2 = [1.0, -2.0, 2.5]\nTHETA2 = [0.0, -0.5, 1.0]\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing two sets of points with arrows indicating their respective angles.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport math\n\n# main code\ndef draw_two(X1, Y1, THETA1, X2, Y2, THETA2, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(8, 6))\n\n    sns.lineplot(x=X1, y=Y1, marker='o', color='red', label='Ground Truth')\n    for x, y, theta in zip(X1, Y1, THETA1):\n        x2 = 0.25 * math.cos(theta) + x\n        y2 = 0.25 * math.sin(theta) + y\n        plt.arrow(x, y, x2 - x, y2 - y, head_width=0.05, color='red')\n\n\n    sns.lineplot(x=X2, y=Y2, marker='o', color='blue', label='Optimized')\n    for x, y, theta in zip(X2, Y2, THETA2):\n        x2 = 0.25 * math.cos(theta) + x\n        y2 = 0.25 * math.sin(theta) + y\n        plt.arrow(x, y, x2 - x, y2 - y, head_width=0.05, color='blue')\n\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = random.randint(5, 20)\n        X1 = np.random.uniform(-10, 10, num_points).tolist()\n        Y1 = np.random.uniform(-10, 10, num_points).tolist()\n        THETA1 = np.random.uniform(-np.pi, np.pi, num_points).tolist()\n\n        X2 = np.random.uniform(-10, 10, num_points).tolist()\n        Y2 = np.random.uniform(-10, 10, num_points).tolist()\n        THETA2 = np.random.uniform(-np.pi, np.pi, num_points).tolist()\n        test_cases.append((X1, Y1, THETA1, X2, Y2, THETA2))\n\n    return test_cases"}
{"problem_id": "seaborn_42", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a scatter plot to visualize the relationship between two normalized datasets, T and TMV, while categorizing the data points based on their associated event types. The function should also save the generated plot to a specified output file.\n\nFunction Signature:\n```python\ndef generate_indicator_space_plot(title, T_list, colors, TMV_list, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input Format:\n- The function accepts a string for the title, two lists of numerical values for T and TMV, a list of colors for event categorization, and an optional string for the output filename.\n\n### Output Format:\n- The function does not return any value but saves a scatter plot as an image file to the specified output path.\n\n**Input:**\n```python\ntitle = \"Test Plot 1\"\nT_list = [23.5, -12.3, 45.6, 78.9, -34.2]\ncolors = ['green', 'lime', 'red', 'lightcoral', 'green']\nTMV_list = [10.1, 20.5, 15.3, 30.0, 25.4]\n```\n\n**Output:**\n```python\n# The function generates a scatter plot saved as 'output.png' with the following characteristics:\n# - X-axis: Normalized T values\n# - Y-axis: Normalized TMV values\n# - Points colored according to the specified colors\n# - Legend indicating the meaning of each color\n# - Title: \"Test Plot 1\"\n```", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef generate_indicator_space_plot(title, T_list, colors, TMV_list, output_file='output.png'):\n\n    TMV_array = np.array(TMV_list)\n    T_array = np.array(T_list)\n\n    norm_TMV = (TMV_array - np.min(TMV_array)) / (np.max(TMV_array) - np.min(TMV_array))\n    norm_T = (T_array - np.min(T_array)) / (np.max(T_array) - np.min(T_array))\n\n    plt.figure(figsize=(8, 6))\n    sns.scatterplot(x=norm_T, y=norm_TMV, hue=colors, palette='husl', edgecolor='k')\n\n    legend_elements = [\n        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='green', markersize=5, label='Upward DCC Event'),\n        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='lime', markersize=5, label='Upward Overshoot Event'),\n        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='red', markersize=5, label='Downward DCC Event'),\n        plt.Line2D([0], [0], marker='o', color='w', markerfacecolor='lightcoral', markersize=5, label='Downward Overshoot Event')\n    ]\n    plt.legend(handles=legend_elements, loc='upper right', fontsize='small')\n\n    plt.xlim(np.min(norm_T) - 0.1, np.max(norm_T) + 0.1)\n    plt.ylim(np.min(norm_TMV) - 0.1, np.max(norm_TMV) + 0.1)\n    plt.title(title)\n    plt.xlabel('Normalized T')\n    plt.ylabel('Normalized TMV')\n\n    plt.savefig(output_file)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        list_size = random.randint(10, 100)\n\n        T_list = np.random.uniform(-100, 100, list_size).tolist()\n        TMV_list = np.random.uniform(-50, 150, list_size).tolist()\n\n        color_choices = ['green', 'lime', 'red', 'lightcoral']\n        colors = random.choices(color_choices, k=list_size)\n\n        title = f\"Test Plot {_ + 1}\"\n\n        test_cases.append((title, T_list, colors, TMV_list))\n\n    return test_cases\n"}
{"problem_id": "seaborn_43", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the training and validation accuracy and loss over a series of epochs. The function will generate a line plot that displays the performance metrics of a machine learning model during its training process.\n\nFunction signature:\n```python\ndef plot_curve(epoch_accuracy, epoch_losses, total_epoch, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `epoch_accuracy`: A 2D numpy array where each row corresponds to an epoch and each column corresponds to either training or validation accuracy.\n- `epoch_losses`: A 2D numpy array where each row corresponds to an epoch and each column corresponds to either training or validation loss.\n- `total_epoch`: An integer representing the total number of epochs.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output file path.\n\nInput:\n```python\nepoch_accuracy = np.array([[90.5, 85.0], [92.0, 87.5], [93.5, 88.0], [94.0, 89.0], [95.0, 90.0]])\nepoch_losses = np.array([[0.5, 0.6], [0.4, 0.5], [0.3, 0.4], [0.2, 0.3], [0.1, 0.2]])\ntotal_epoch = 5\n```\n\nOutput:\nThe function `plot_curve(epoch_accuracy, epoch_losses, total_epoch, output_file='output.png')` will generate a plot saved as 'output.png' showing the training and validation accuracy and loss over 5 epochs. The plot will have:\n- Train Accuracy line peaking at 95.0\n- Validation Accuracy line peaking at 90.0\n- Train Loss line decreasing to 0.1\n- Validation Loss line decreasing to 0.2", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_curve(epoch_accuracy, epoch_losses, total_epoch, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    x_axis = np.arange(total_epoch)\n\n    plt.figure(figsize=(12, 6))\n\n    sns.lineplot(x=x_axis, y=epoch_accuracy[:, 0], label='Train Accuracy', linewidth=2)\n    sns.lineplot(x=x_axis, y=epoch_accuracy[:, 1], label='Validation Accuracy', linewidth=2)\n    sns.lineplot(x=x_axis, y=epoch_losses[:, 0], label='Train Loss x30', linewidth=2, linestyle=':')\n    sns.lineplot(x=x_axis, y=epoch_losses[:, 1], label='Validation Loss x30', linewidth=2, linestyle=':')\n\n    plt.xlim(0, total_epoch)\n    plt.ylim(0, 100)\n\n    plt.xticks(np.arange(0, total_epoch + 5, 5))\n    plt.yticks(np.arange(0, 101, 5))\n\n    plt.title('Accuracy/Loss Curve of Train/Validation', fontsize=20)\n    plt.xlabel('Training Epoch', fontsize=16)\n    plt.ylabel('Accuracy', fontsize=16)\n\n    plt.legend(loc='lower right', fontsize=10)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        total_epoch = np.random.randint(10, 101)\n        epoch_accuracy = np.random.uniform(0, 100, size=(total_epoch, 2)).astype(np.float32)\n        epoch_losses = np.random.uniform(0, 3.33, size=(total_epoch, 2)).astype(np.float32)\n\n        test_cases.append((epoch_accuracy, epoch_losses, total_epoch))\n\n    return test_cases"}
{"problem_id": "seaborn_44", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a network geometry involving a Macro Base Station (MBS), Small Base Stations (SBS), and User Equipment (UE). The function will plot the locations of these entities on a 2D scatter plot and save the resulting plot as an image file.\n\nFunction signature:\n```python\ndef plot_network(yUE, xUE, ySBS, xSBS, rMBS, margin, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The constant `output_file` is set to 'output.png' by default, which specifies the name of the file where the plot will be saved.\n\nInput format:\n- The function takes in lists of coordinates for UEs and SBSs, along with two numerical values for the MBS radius and margin, and an optional output file name.\n\nOutput format:\n- The function saves a plot as an image file with the specified name, showing the network geometry with the MBS, SBS, and UE locations annotated.\n\nInput:\n```python\nyUE = [10.5, -20.3, 15.0]\nxUE = [30.2, -40.1, 25.5]\nySBS = [5.0, -15.0]\nxSBS = [20.0, -10.0]\nrMBS = 100.0\nmargin = 10.0\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' showing:\n- A red circle at (0, 0) representing the MBS.\n- Two green diamonds at (20.0, 5.0) and (-10.0, -15.0) representing the SBS.\n- Three blue stars at (30.2, 10.5), (-40.1, -20.3), and (25.5, 15.0) representing the UE.\n- Annotations for each point indicating their respective indices.\n- Axes limits set to (-110.0, 110.0) for both x and y axes.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_network(yUE, xUE, ySBS, xSBS, rMBS, margin, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(figsize=(5, 5))\n\n    sns.scatterplot(x=[0], y=[0], s=80, color='red', marker='o', alpha=0.5, label='MBS')\n    sns.scatterplot(x=xSBS, y=ySBS, s=50, color='green', marker='D', alpha=0.5, label='SBS')\n    sns.scatterplot(x=xUE, y=yUE, s=50, color='blue', marker='*', alpha=0.5, label='UE')\n\n    plt.annotate('0', xy=(0, 0), xytext=(0, 0))\n    for cnt, (x, y) in enumerate(zip(xSBS, ySBS), start=1):\n        plt.annotate(str(cnt), xy=(x, y), xytext=(x, y))\n    for cnt, (x, y) in enumerate(zip(xUE, yUE), start=1):\n        plt.annotate(str(cnt), xy=(x, y), xytext=(x, y))\n\n    plt.xlim((-rMBS - margin, rMBS + margin))\n    plt.ylim((-rMBS - margin, rMBS + margin))\n    plt.title('Network Geometry')\n    plt.xlabel('Distance (m)')\n    plt.ylabel('Distance (m)')\n    plt.legend(loc='upper right')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_UE = random.randint(1, 20)\n        num_SBS = random.randint(1, 10)\n        rMBS = random.uniform(50, 500)\n        margin = random.uniform(5, 50)\n        xUE = np.random.uniform(-rMBS, rMBS, num_UE)\n        yUE = np.random.uniform(-rMBS, rMBS, num_UE)\n        xSBS = np.random.uniform(-rMBS, rMBS, num_SBS)\n        ySBS = np.random.uniform(-rMBS, rMBS, num_SBS)\n        test_cases.append((yUE, xUE, ySBS, xSBS, rMBS, margin))\n\n    return test_cases"}
{"problem_id": "seaborn_45", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the training and validation loss over a specified number of recent epochs from a given dataset. The function should generate a line plot using the Seaborn and Matplotlib libraries, and save the plot as an image file.\n\nFunction signature:\n```python\ndef plot_losses_recent(data, num_points, figsize, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `data`: A dictionary with two keys, 'train' and 'val', each containing a list of loss values corresponding to each epoch.\n- `num_points`: An integer representing the number of recent epochs to visualize.\n- `figsize`: A tuple of two integers representing the width and height of the figure in inches.\n- `output_file`: A string representing the filename for saving the plot (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot image to the specified output file.\n\nInput:\n```python\ndata = {\n    'train': [0.5, 1.2, 0.8, 1.5, 0.3, 1.0, 0.7, 1.3, 0.4, 1.1],\n    'val': [0.6, 1.0, 0.9, 1.4, 0.5, 1.2, 0.8, 1.3, 0.2, 1.1]\n}\nnum_points = 5\nfigsize = (8, 6)\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with the following characteristics:\n# - A line plot showing the last 5 training losses in red and validation losses in blue.\n# - X-axis labeled 'Epoch' and Y-axis labeled 'Loss'.\n# - A legend indicating 'Train' and 'Validation'.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef plot_losses_recent(data, num_points, figsize, output_file='output.png'):\n    sns.set(style='whitegrid')\n\n    plt.figure(figsize=figsize)\n    sns.lineplot(data=data['train'][-num_points:], label='Train', color='r')\n    sns.lineplot(data=data['val'][-num_points:], label='Validation', color='b')\n\n    plt.xlabel('Epoch')\n    plt.ylabel('Loss')\n    plt.legend()\n    plt.savefig(output_file, dpi=300, bbox_inches='tight')\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_train_points = random.randint(50, 500)\n        num_val_points = random.randint(50, 500)\n        num_points = random.randint(1, min(num_train_points, num_val_points))\n        train_data = list(np.random.uniform(0, 2, num_train_points))\n        val_data = list(np.random.uniform(0, 2, num_val_points))\n        figsize = (random.uniform(4, 12), random.uniform(4, 12))\n        data =  {'train': train_data, 'val': val_data}\n        test_cases.append((data, num_points, figsize))\n    return test_cases\n"}
{"problem_id": "seaborn_46", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a given dataset as a heatmap and saves the resulting image to a file. The function should allow the user to specify the size of the figure and the name of the output file.\n\nFunction signature:\n```python\ndef easy_show(data, figsize, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a default parameter set to the string `'output.png'`, which specifies the name of the file where the heatmap will be saved if no other name is provided.\n\nInput format:\n- `data`: A 2D array-like structure (e.g., a list of lists, a NumPy array, or a Pandas DataFrame) containing the values to be visualized.\n- `figsize`: A tuple of two integers (width, height) representing the size of the figure in inches.\n- `output_file`: A string representing the name of the output file (optional).\n\nOutput format:\n- The function does not return any value. Instead, it saves the heatmap as an image file with the specified name.\n\nInput:\n```python\ndata = np.array([[0.1, 0.2, 0.3], \n                 [0.4, 0.5, 0.6], \n                 [0.7, 0.8, 0.9]])\nfigsize = (8, 6)\n```\n\nOutput:\n```plaintext\nA heatmap is generated and saved as 'output.png'.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef easy_show(data, figsize, output_file='output.png'):\n\n    plt.figure(figsize=figsize)\n    sns.heatmap(data)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(5, 100)\n        cols = random.randint(5, 100)\n        data = np.random.rand(rows, cols)\n        figsize = (random.uniform(4, 15), random.uniform(4, 15))\n        test_cases.append((data, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_47", "library": "seaborn", "code_problem": "You are tasked with visualizing high-dimensional data using Principal Component Analysis (PCA) and creating a scatter plot representation of the data points. The goal is to reduce the dimensionality of the data to two dimensions and plot the results, coloring the points based on their class labels.\n\nThe main function you need to implement is as follows:\n\n```python\ndef PlotRepresentation(y_test, encode_images, output_file='output.png'):\n```\n\n### Constants:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input**:\n  - `y_test`: A 1D array or list of class labels.\n  - `encode_images`: A multi-dimensional array representing the data to be visualized.\n  - `output_file`: A string representing the filename for saving the output plot (optional).\n\n- **Output**:\n  - The function does not return any value. Instead, it saves a scatter plot image to the specified output file.\n\nInput:\n```python\ny_test = np.array([0, 1, 0, 1, 2, 2, 1, 0])\nencode_images = np.random.rand(8, 16, 16, 3).astype(np.float32)\n```\n\nOutput:\n```python\n# The output will be a saved plot file 'output.png' showing a 2D scatter plot of the PCA-reduced images.\n# The colors of the points will correspond to the classes in y_test.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom sklearn.decomposition import PCA\n\n\ndef PCAdecomposition(data, n_components):\n    estimator = PCA(n_components=n_components)\n    return estimator.fit_transform(data)\n\n\n# main code\ndef PlotRepresentation(y_test, encode_images, output_file='output.png'):\n    if len(encode_images.shape) > 3:\n        encode_images_liner = encode_images.reshape((-1, np.prod(encode_images.shape[1:])))\n        encode_images = PCAdecomposition(encode_images_liner, 2)\n\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(8, 6))\n    scatter = sns.scatterplot(x=encode_images[:, 0],\n                              y=encode_images[:, 1],\n                              hue=y_test,\n                              s=10,\n                              palette='viridis')\n    plt.legend(title='Class', bbox_to_anchor=(1.05, 1), loc='upper left')\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(10, 100)\n        height = random.randint(8, 32)\n        width = random.randint(8, 32)\n        channels = random.choice([1, 3])\n\n        encode_images = np.random.rand(batch_size, height, width, channels).astype(np.float32)\n        num_classes = random.randint(2, 10)\n        y_test = np.random.choice(num_classes, size=batch_size)\n\n        test_cases.append((y_test, encode_images))\n\n    return test_cases\n"}
{"problem_id": "seaborn_48", "library": "seaborn", "code_problem": "You are tasked with visualizing the relationship between original data and its PCA (Principal Component Analysis) transformed data using scatter plots. The goal is to create a function that can handle both 2D and 3D data visualizations and save the resulting plot to a specified output file.\n\nFunction Signature:\n```python\ndef plot(origin_data, pca_data, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `origin_data`: A 2D array-like structure (e.g., a NumPy array) with shape (n_samples, n_features) where n_features can be either 2 or 3.\n- `pca_data`: A 2D array-like structure (e.g., a NumPy array) with the same shape as `origin_data`.\n- `output_file`: A string representing the filename to save the plot (optional).\n\nOutput Format:\n- The function does not return any value. Instead, it saves a plot as an image file in the specified format (default is PNG) to the location defined by `output_file`.\n\nInput:\n```python\norigin_data = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0]])\npca_data = np.array([[0.12, 0.22], [0.28, 0.38], [0.52, 0.58], [0.68, 0.78], [0.91, 1.02]])\n```\n\nOutput:\n```python\n# The function plot will save a file named 'output.png' with a scatter plot of the original and PCA data.\n# The output file will contain:\n# - Red points representing the original data\n# - Blue points representing the PCA data\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot(origin_data, pca_data, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n    fig = plt.figure()\n\n    dim = origin_data.shape[1]\n    if dim == 3:\n        ax = fig.add_subplot(111, projection='3d')\n        ax.scatter(origin_data[:, 0], origin_data[:, 1], origin_data[:, 2], c='r', label='Original Data')\n        ax.scatter(pca_data[:, 0], pca_data[:, 1], pca_data[:, 2], c='b', label='PCA Data')\n    elif dim == 2:\n        plt.axis('equal')\n        sns.scatterplot(x=origin_data[:, 0], y=origin_data[:, 1], color='r', label='Original Data')\n        sns.scatterplot(x=pca_data[:, 0], y=pca_data[:, 1], color='b', label='PCA Data')\n\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dim = random.choice([2, 3])\n        num_points = random.randint(5, 500)\n        origin_data = np.random.rand(num_points, dim)\n        pca_data = origin_data + np.random.normal(0, 0.05, size=origin_data.shape)\n        test_cases.append((origin_data, pca_data))\n\n    return test_cases"}
{"problem_id": "seaborn_49", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a dual-axis line plot using the Seaborn and Matplotlib libraries in Python. The function will allow users to visualize two different datasets on the same graph, each with its own y-axis, while sharing a common x-axis.\n\nFunction signature:\n```python\ndef dual_axis_plot(xaxis, data1, data2, fst_color, sec_color, fig_size, x_label, y_label1, y_label2, legend1, legend2, grid, title):\n```\n\n### Constants:\n- The function saves the generated plot as \"output.png\".\n\n### Input Format:\n- `xaxis`: A list or array of x-axis values.\n- `data1`: A list or array of y-axis values for the first dataset.\n- `data2`: A list or array of y-axis values for the second dataset.\n- `fst_color`: A string representing the color for the first dataset's line.\n- `sec_color`: A string representing the color for the second dataset's line.\n- `fig_size`: A tuple representing the size of the figure (width, height).\n- `x_label`: A string for the x-axis label.\n- `y_label1`: A string for the y-axis label of the first dataset.\n- `y_label2`: A string for the y-axis label of the second dataset.\n- `legend1`: A string for the legend label of the first dataset.\n- `legend2`: A string for the legend label of the second dataset.\n- `grid`: A boolean indicating whether to display the grid.\n- `title`: A string for the title of the plot.\n\n### Output Format:\n- The function does not return any value. Instead, it saves the generated plot as \"output.png\".\n\n**Input:**\n```python\nxaxis = np.linspace(0, 100, 50)\ndata1 = np.random.normal(loc=50, scale=5, size=50)\ndata2 = np.random.normal(loc=30, scale=3, size=50)\nfst_color = 'b'\nsec_color = 'r'\nfig_size = (8, 6)\nx_label = \"X-axis 42\"\ny_label1 = \"Y-axis1 15\"\ny_label2 = \"Y-axis2 27\"\nlegend1 = \"Legend1 88\"\nlegend2 = \"Legend2 34\"\ngrid = True\ntitle = \"Title 12\"\n```\n\n**Output:**\n```python\n# This will generate a dual-axis plot saved as \"output.png\"\n# The plot will have:\n# - X-axis labeled \"X-axis 42\"\n# - Left Y-axis labeled \"Y-axis1 15\" in blue\n# - Right Y-axis labeled \"Y-axis2 27\" in red\n# - Title \"Title 12\"\n# - Grid enabled\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef dual_axis_plot(xaxis, data1, data2, fst_color, sec_color, fig_size, x_label, y_label1, y_label2, legend1, legend2, grid, title):\n    sns.set(style=\"whitegrid\")\n    fig, ax = plt.subplots(figsize=fig_size)\n\n    sns.lineplot(x=xaxis, y=data1, ax=ax, color=fst_color, label=legend1)\n    ax.set_xlabel(x_label)\n    ax.set_ylabel(y_label1, color=fst_color)\n    ax.tick_params(axis='y', labelcolor=fst_color)\n\n    ax2 = ax.twinx()\n    sns.lineplot(x=xaxis, y=data2, ax=ax2, color=sec_color, label=legend2)\n    ax2.set_ylabel(y_label2, color=sec_color)\n    ax2.tick_params(axis='y', labelcolor=sec_color)\n\n    ax.set_title(title)\n    ax.grid(grid)\n\n    plt.tight_layout()\n    plt.savefig(\"output.png\")\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = random.randint(10, 500)\n\n        xaxis = np.linspace(0, 100, length)\n\n        data1 = np.random.normal(loc=random.uniform(0, 100), scale=random.uniform(1, 10), size=length)\n        data2 = np.random.normal(loc=random.uniform(0, 100), scale=random.uniform(1, 10), size=length)\n\n        fst_color = random.choice(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n        sec_color = random.choice(['b', 'g', 'r', 'c', 'm', 'y', 'k'])\n\n        fig_size = (random.uniform(4, 12), random.uniform(4, 8))\n\n        x_label = f\"X-axis {random.randint(1, 100)}\"\n        y_label1 = f\"Y-axis1 {random.randint(1, 100)}\"\n        y_label2 = f\"Y-axis2 {random.randint(1, 100)}\"\n        legend1 = f\"Legend1 {random.randint(1, 100)}\"\n        legend2 = f\"Legend2 {random.randint(1, 100)}\"\n        grid = random.choice([True, False])\n        title = f\"Title {random.randint(1, 100)}\"\n\n        test_cases.append((xaxis, data1, data2, fst_color, sec_color, fig_size, x_label, y_label1, y_label2, legend1, legend2, grid, title))\n\n    return test_cases"}
{"problem_id": "seaborn_50", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the predictions of a model against actual data points from a training and test dataset. The function will generate a scatter plot for both the training and test data, along with a line plot for the predictions and a shaded area representing the confidence interval around those predictions.\n\nFunction Signature:\n```python\ndef plot_predictions(train_df, test_df, predictions, confidence_interval, r2, output_path='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_path` parameter is set to `'output.png'`.\n\nInput Format:\n- `train_df`: A DataFrame containing the training data with columns 'MJD' and 'PT_TT'.\n- `test_df`: A DataFrame containing the test data with columns 'MJD' and 'PT_TT'.\n- `predictions`: A list or array of predicted PT-TT values corresponding to the test dataset.\n- `confidence_interval`: A numeric value representing the width of the confidence interval around the predictions.\n- `r2`: A numeric value representing the R\u00b2 score of the predictions.\n- `output_path`: A string representing the file path where the plot will be saved (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a plot as an image file at the specified output path.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Training Data\ntrain_df = pd.DataFrame({\n    'MJD': [50000.0, 50050.0, 50100.0, 50150.0, 50200.0],\n    'PT_TT': [0.5, -0.2, 0.3, 0.1, -0.4]\n})\n\n# Test Data\ntest_df = pd.DataFrame({\n    'MJD': [60000.0, 60050.0, 60100.0, 60150.0],\n    'PT_TT': [0.6, -0.1, 0.2, 0.0]\n})\n\n# Predictions\npredictions = np.array([0.4, 0.0, 0.3, -0.1])\n\n# Confidence Interval\nconfidence_interval = np.array([0.2, 0.3, 0.1, 0.2])\n\n# R\u00b2 Value\nr2 = 0.85\n\n# Output Path\noutput_path = 'output.png'\n```\n\n**Output:**\n```python\n# The function plot_predictions will generate a plot and save it to 'output.png'.\n# The plot will show:\n# - Blue scatter points for training data\n# - Green scatter points for test data\n# - A red line for predictions\n# - A shaded red area representing the 95% confidence interval\n# - The title \"Pulsar Timing Noise: Predictions vs Actual\"\n# - A legend indicating the data types and R\u00b2 value\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_predictions(train_df, test_df, predictions, confidence_interval, r2, output_path='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(figsize=(12, 8))\n\n    sns.scatterplot(x='MJD', y='PT_TT', data=train_df, color='blue', alpha=0.6, s=10, label='Training Data')\n    sns.scatterplot(x='MJD', y='PT_TT', data=test_df, color='green', alpha=0.6, s=10, label='Test Data')\n\n    sns.lineplot(x='MJD', y=predictions, data=test_df, color='red', linewidth=1.5, label=f'Predictions (R\u00b2 = {r2:.4f})')\n    plt.fill_between(test_df['MJD'],\n                     predictions - confidence_interval,\n                     predictions + confidence_interval,\n                     color='red', alpha=0.2, label='95% Confidence Interval')\n\n    plt.xlabel('Modified Julian Date (days)')\n    plt.ylabel('PT-TT (s)')\n    plt.title('Pulsar Timing Noise: Predictions vs Actual')\n    plt.legend()\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        train_size = random.randint(50, 500)\n        test_size = random.randint(20, 300)\n\n        train_df = pd.DataFrame({\n            'MJD': np.linspace(50000, 60000, train_size),\n            'PT_TT': np.random.normal(0, 1, train_size)\n        })\n\n        test_df = pd.DataFrame({\n            'MJD': np.linspace(60000, 70000, test_size),\n            'PT_TT': np.random.normal(0, 1, test_size)\n        })\n\n        predictions = np.random.normal(0, 1, test_size)\n        confidence_interval = np.random.uniform(0.1, 0.5, test_size)\n\n        r2 = round(random.uniform(0.5, 1.0), 4)\n        test_cases.append((train_df, test_df, predictions, confidence_interval, r2))\n\n    return test_cases"}
{"problem_id": "seaborn_51", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes time series data, including training and test datasets, predictions, and a confidence interval. The function will generate a plot that displays these elements clearly and saves the output as an image file.\n\nFunction Signature:\n```python\ndef plot_time_series(train_df, test_df, predictions, confidence_interval, r2, output_file='output.png'):\n```\n\nConstant Used:\n- The constant used in the main code is the default value for the `output_file` parameter, which is set to `'output.png'`.\n\nInput Format:\n- `train_df`: A DataFrame containing the training data with columns 'MJD' and 'PT_TT'.\n- `test_df`: A DataFrame containing the test data with columns 'MJD' and 'PT_TT'.\n- `predictions`: A list or array of predicted PT-TT values corresponding to the test data.\n- `confidence_interval`: A list or array representing the confidence interval for the predictions.\n- `r2`: A float representing the R\u00b2 value of the predictions.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output file path.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Training Data\ntrain_mjd = np.array([58001.0, 58002.0, 58003.0, 58004.0, 58005.0])\ntrain_pt_tt = np.array([0.01, 0.02, 0.03, 0.01, 0.00])\ntrain_df = pd.DataFrame({'MJD': train_mjd, 'PT_TT': train_pt_tt})\n\n# Test Data\ntest_mjd = np.array([59001.0, 59002.0, 59003.0])\ntest_pt_tt = np.array([0.02, 0.01, 0.03])\ntest_df = pd.DataFrame({'MJD': test_mjd, 'PT_TT': test_pt_tt})\n\n# Predictions\npredictions = np.array([0.015, 0.012, 0.028])\nconfidence_interval = np.array([0.1, 0.1, 0.1])\nr2 = 0.85\n\n# Call the function\nplot_time_series(train_df, test_df, predictions, confidence_interval, r2, output_file='test_output.png')\n```\n\n**Output:**\n- A plot saved as `test_output.png` showing:\n  - Blue dots for training data points.\n  - Green dots for test data points.\n  - A red line for predictions.\n  - A shaded red area representing the 95% confidence interval around the predictions.\n  - The title \"Complete Time Series Analysis\" and a legend indicating the data types and R\u00b2 value.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_time_series(train_df, test_df, predictions, confidence_interval, r2, output_file='output.png'):\n    sns.set_theme(style=\"whitegrid\")\n\n    plt.figure(figsize=(15, 8))\n    plt.plot(train_df['MJD'], train_df['PT_TT'], 'b.', label='Training Data', alpha=0.6, markersize=2)\n    plt.plot(test_df['MJD'], test_df['PT_TT'], 'g.', label='Test Data', alpha=0.6, markersize=2)\n    plt.plot(test_df['MJD'], predictions, 'r-', label=f'Predictions (R\u00b2 = {r2:.4f})', linewidth=1.5)\n    plt.fill_between(\n        test_df['MJD'],\n        predictions - confidence_interval,\n        predictions + confidence_interval,\n        color='r',\n        alpha=0.2,\n        label='95% Confidence Interval'\n    )\n\n    plt.xlabel('Modified Julian Date (days)')\n    plt.ylabel('PT-TT (s)')\n    plt.title('Complete Time Series Analysis')\n    plt.legend()\n    plt.tight_layout()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_train_points = random.randint(50, 500)\n        num_test_points = random.randint(30, 400)\n\n        train_mjd = np.sort(np.random.uniform(58000, 59000, num_train_points))\n        test_mjd = np.sort(np.random.uniform(59000, 60000, num_test_points))\n\n        train_pt_tt = np.sin(train_mjd / 200) + np.random.normal(0, 0.1, num_train_points)\n        test_pt_tt = np.sin(test_mjd / 200) + np.random.normal(0, 0.1, num_test_points)\n\n        predictions = np.sin(test_mjd / 200) + np.random.normal(0, 0.05, num_test_points)\n        confidence_interval = np.random.uniform(0.05, 0.2, num_test_points)\n\n        r2 = round(random.uniform(0.5, 1.0), 4)\n\n        train_df = pd.DataFrame({'MJD': train_mjd, 'PT_TT': train_pt_tt})\n        test_df = pd.DataFrame({'MJD': test_mjd, 'PT_TT': test_pt_tt})\n\n        test_cases.append((train_df, test_df, predictions, confidence_interval, r2))\n\n    return test_cases"}
{"problem_id": "seaborn_52", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the distribution of residuals from a set of predictions compared to actual values. The function will generate a histogram of the residuals and overlay a normal distribution curve based on the mean and standard deviation of the residuals.\n\nFunction Signature:\n```python\ndef plot_residuals_distribution(test_df, predictions, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_path` is set to `'output.png'`.\n\nInput Format:\n- `test_df`: A pandas DataFrame containing the actual values in a column named 'PT_TT'.\n- `predictions`: A list or array of predicted values corresponding to the actual values in `test_df`.\n- `output_path`: A string representing the file path where the output image will be saved (optional, defaults to 'output.png').\n\nOutput Format:\n- The function saves a plot as an image file at the specified `output_path`. The image will contain a histogram of the residuals and a normal distribution curve overlay.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test DataFrame\ntest_df = pd.DataFrame({'PT_TT': [48.5, 52.3, 47.8, 55.1, 49.9]})\n\n# Predictions\npredictions = np.array([50.0, 51.0, 46.0, 54.0, 50.0])\n```\n\nOutput:\n```python\n# Residuals\n# Residuals = test_df['PT_TT'].values - predictions\n# Residuals = [ -1.5,  1.3,  1.8,  1.1, -0.1]\n# Mean = 0.12\n# Standard Deviation = 1.25\n``` \n\nThis output represents the calculated residuals, mean, and standard deviation based on the provided input data.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nfrom scipy import stats\n\n# main code\ndef plot_residuals_distribution(test_df, predictions, output_path='output.png'):\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(12, 8))\n\n    residuals = test_df['PT_TT'].values - predictions\n    sns.histplot(residuals, bins=50, kde=True, color='blue', label='Residuals', stat='density')\n\n    mean, std = np.mean(residuals), np.std(residuals)\n    xmin, xmax = plt.xlim()\n    x = np.linspace(xmin, xmax, 100)\n    p = stats.norm.pdf(x, mean, std)\n    plt.plot(x, p, 'r-', lw=2, label=f'Normal Distribution')\n\n    plt.xlabel('Residuals (s)')\n    plt.ylabel('Density')\n    plt.title('Residuals Distribution Analysis')\n    plt.legend()\n\n    plt.tight_layout()\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_samples = random.randint(50, 500)\n        pt_tt_values = np.random.normal(loc=50, scale=10, size=num_samples)\n        test_df = pd.DataFrame({'PT_TT': pt_tt_values})\n\n        noise = np.random.normal(loc=0, scale=5, size=num_samples)\n        predictions = pt_tt_values + noise\n\n\n        test_cases.append((test_df, predictions))\n\n    return test_cases"}
{"problem_id": "seaborn_53", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the components of a mathematical model based on time-series data. The function will take in a DataFrame containing time data and model parameters, and it will generate a plot that displays the main periodic component, harmonics, a trend component, and a modulation component. The plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_model_components(test_df, model_params, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the default value for `output_path`, which is set to `'output.png'`.\n\nInput format:\n- `test_df`: A DataFrame containing at least two columns: 'Time' (for time data) and 'MJD' (for Modified Julian Date).\n- `model_params`: A list or array of model parameters used for calculating the components.\n- `output_path`: A string representing the file path where the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file at the specified `output_path`.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\ntest_df = pd.DataFrame({\n    'MJD': np.linspace(50000, 60000, 100),\n    'Time': np.random.uniform(0, 100, 100)\n})\nmodel_params = np.array([5, 0.1, 0, 3, 0.2, np.pi/4, 1, 0.05, np.pi/2, 0, 0.01, 0, 0, 0.5, 0.1])\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' containing the model components.\n# The actual output cannot be displayed here as it is a graphical output.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_model_components(test_df, model_params, output_path='output.png'):\n    sns.set_theme(style=\"darkgrid\")\n\n    plt.figure(figsize=(15, 8))\n    t = test_df['Time'].values\n    t_norm = (t - np.mean(t)) / np.std(t)\n\n    A1, w1, phi1 = model_params[0:3]\n    A2, w2, phi2 = model_params[3:6]\n    A3, w3, phi3 = model_params[6:9]\n\n    main_component = A1 * np.sin(w1 * t + phi1)\n    harmonic1 = A2 * np.sin(w2 * t + phi2)\n    harmonic2 = A3 * np.sin(w3 * t + phi3)\n\n    trend = (\n        model_params[9] + model_params[10] * t_norm +\n        model_params[11] * t_norm ** 2 + model_params[12] * t_norm ** 3\n    )\n    modulation = model_params[13] * np.exp(-model_params[14] * t_norm)\n\n    sns.lineplot(x=test_df['MJD'], y=main_component, label='Main Periodic Component', alpha=0.7)\n    sns.lineplot(x=test_df['MJD'], y=harmonic1, label='First Harmonic', alpha=0.7)\n    sns.lineplot(x=test_df['MJD'], y=harmonic2, label='Second Harmonic', alpha=0.7)\n    sns.lineplot(x=test_df['MJD'], y=trend, label='Trend Component', alpha=0.7)\n    sns.lineplot(x=test_df['MJD'], y=modulation, label='Modulation Component', alpha=0.7)\n\n    plt.xlabel('Modified Julian Date (days)')\n    plt.ylabel('Component Value (s)')\n    plt.title('Model Component Decomposition')\n    plt.legend()\n    plt.tight_layout()\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_points = np.random.randint(50, 500)\n        t_values = np.linspace(50000, 60000, num_points)\n        time_values = np.random.uniform(0, 100, num_points)\n\n        test_df = pd.DataFrame({\n            'MJD': t_values,\n            'Time': time_values\n        })\n\n        model_params = np.random.uniform(-10, 10, 15)\n        test_cases.append((test_df, model_params))\n\n    return test_cases\n\n"}
{"problem_id": "seaborn_54", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the prediction errors of a dataset over time. The function will compute the absolute errors between actual values and predicted values, and then plot these errors along with a moving average to help identify trends.\n\nFunction signature:\n```python\ndef plot_prediction_error(test_df, predictions, window, output_file='output.png'):\n```\n\n### Constants:\n- The default value for `output_file` is set to `'output.png'`.\n\n### Input Format:\n- `test_df`: A pandas DataFrame with at least two columns: 'PT_TT' (actual values) and 'MJD' (Modified Julian Dates).\n- `predictions`: A numpy array or list of predicted values corresponding to the actual values in `test_df`.\n- `window`: An integer for the moving average window size.\n- `output_file`: (Optional) A string for the output filename.\n\n### Output Format:\n- The function saves a plot as an image file (default is 'output.png') showing the absolute prediction errors and their moving average over time.\n\nInput:\n```python\ntest_df = pd.DataFrame({\n    'MJD': [50001.0, 50002.0, 50003.0, 50004.0, 50005.0],\n    'PT_TT': [150.0, 200.0, 250.0, 300.0, 350.0]\n})\npredictions = np.array([160.0, 190.0, 240.0, 310.0, 340.0])\nwindow = 2\n```\n\nOutput:\n```python\n# The output will be a plot saved as 'output.png' showing the absolute errors and the moving average of the absolute errors.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport pandas as pd\n\n# main code\ndef plot_prediction_error(test_df, predictions, window, output_file='output.png'):\n    residuals = test_df['PT_TT'].values - predictions\n    abs_errors = np.abs(residuals)\n\n    plt.figure(figsize=(12, 6))\n    sns.lineplot(x=test_df['MJD'], y=abs_errors, label='Absolute Error', alpha=0.6)\n\n    moving_avg = pd.Series(abs_errors).rolling(window=window).mean()\n    sns.lineplot(x=test_df['MJD'], y=moving_avg, label=f'{window}-point Moving Average', color='red')\n\n    plt.xlabel('Modified Julian Date (days)')\n    plt.ylabel('Absolute Error (s)')\n    plt.title('Prediction Error Over Time')\n    plt.legend()\n    plt.tight_layout()\n\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(50, 1000)\n        mjd_values = np.sort(np.random.uniform(50000, 60000, num_samples))\n        pt_tt_values = np.random.uniform(100, 500, num_samples)\n        test_df = pd.DataFrame({'MJD': mjd_values, 'PT_TT': pt_tt_values})\n        predictions = pt_tt_values + np.random.normal(0, 20, num_samples)\n        window = random.randint(1, max(1, num_samples // 10))\n        test_cases.append((test_df, predictions, window))\n\n    return test_cases"}
{"problem_id": "seaborn_55", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a site frequency spectrum (SFS) using a bar plot. The function will take in a list of frequencies and generate a plot that represents the distribution of alternate alleles across a set of sites. The plot will be saved as an image file.\n\nFunction signature:\n```python\ndef plot_sfs(sfs, plot_title, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- The function accepts a list or array of integers for `sfs`, a string for `plot_title`, and an optional string for `output_file`.\n\nOutput format:\n- The function saves a bar plot as an image file in the specified format (default is PNG) and does not return any value.\n\nInput:\n```python\nsfs = [10, 20, 30, 40, 50]\nplot_title = \"Test Case 1: Random SFS Plot\"\n```\n\nOutput:\n```plaintext\nA bar plot saved as 'output.png' with the title \"Test Case 1: Random SFS Plot\", showing the distribution of alternate alleles across 5 sites.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_sfs(sfs, plot_title, output_file='output.png'):\n    sns.set(style='whitegrid')\n    plt.figure(figsize=(8, 5))\n    sns.barplot(x=np.arange(1, len(sfs) + 1), y=sfs)\n    plt.title(plot_title)\n    plt.xlabel('# of alternate alleles')\n    plt.ylabel('# sites')\n    plt.xticks(np.arange(1, len(sfs) + 1, 1.0))\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sfs_length = random.randint(5, 100)\n        sfs = np.random.randint(0, 1000, size=sfs_length).tolist()\n        plot_title = f\"Test Case {_ + 1}: Random SFS Plot\"\n\n        test_cases.append((sfs, plot_title))\n\n    return test_cases"}
{"problem_id": "seaborn_56", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a violin plot to visualize the distribution of estimated values based on different methods across varying sample sizes. The function will also overlay median values for each method on the plot.\n\nFunction signature:\n```python\ndef make_plot(dat):\n```\n\nIn the main code, the constant used is the figure size, which is set to `(10, 6)`.\n\n\nInput format:\n- The function takes a single argument `dat`, which is a pandas DataFrame containing at least the columns 'sampSize', 'FP', 'RAVK1', 'RAVK2', and 'Proposed'.\n\nOutput format:\n- The function does not return any value. Instead, it saves a visual representation of the data as a PNG file named 'output.png'.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = {\n    'sampSize': [10, 20, 30, 40, 50, 60, 70, 80, 90],\n    'FP': [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3],\n    'RAVK1': [0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2],\n    'RAVK2': [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1],\n    'Proposed': [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]\n}\n\ndat = pd.DataFrame(data)\n```\n\n**Output:**\nThe output will be a saved file named `output.png` which contains a violin plot visualizing the distribution of the values for each method across different sample sizes. The plot will include median lines for each method, represented by 'x' markers, and a horizontal dashed line at y=0. \n\n(Note: The actual visual output cannot be displayed in this format, but the description provides an understanding of what the output will be.)", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef make_plot(dat):\n    sns.set(style=\"whitegrid\")\n\n    melted_dat = dat.melt(id_vars=['sampSize'], value_vars=['FP', 'RAVK1', 'RAVK2', 'Proposed'],\n                          var_name='Method', value_name='Value')\n\n    plt.figure(figsize=(10, 6))\n    sns.violinplot(data=melted_dat, x='sampSize', y='Value', hue='Method', split=True)\n\n    for method in ['FP', 'RAVK1', 'RAVK2', 'Proposed']:\n        median_values = dat.groupby('sampSize').median()[method].values\n        plt.plot(dat['sampSize'].unique(), median_values, marker='x', label=f'Median {method}')\n\n    plt.axhline(y=0, color='black', linestyle='--')\n    plt.legend()\n    plt.xlabel('Sample Size')\n    plt.ylabel('Estimated I(X;Y|Z)')\n    plt.tight_layout()\n    plt.savefig('output.png')\n    plt.close()", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samp_sizes = random.randint(3, 15)\n        samp_sizes = np.sort(np.random.randint(10, 1000, num_samp_sizes))\n\n        repeat_count = random.randint(5, 20)\n        total_length = len(samp_sizes) * repeat_count\n\n        data = {\n            'sampSize': np.repeat(samp_sizes, repeat_count),\n            'FP': np.random.normal(0, 1, total_length),\n            'RAVK1': np.random.normal(0, 1.5, total_length),\n            'RAVK2': np.random.normal(0, 1.2, total_length),\n            'Proposed': np.random.normal(0, 0.8, total_length)\n        }\n\n        dat = pd.DataFrame(data)\n\n        test_cases.append(dat)\n\n    return test_cases\n"}
{"problem_id": "seaborn_57", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes spectral data using line plots. The function will take in multiple sets of spectral data and plot them on a single graph, allowing for easy comparison. The function should also handle both single-dimensional and multi-dimensional input for the spectral data.\n\nFunction signature:\n```python\ndef plot_spectra(spectra_x, spectra_y, labels, title, size):\n```\n\n### Constants:\n- The constant used in the main code is the filename for saving the plot, which is set to `'output.png'`.\n\n### Input Format:\n- `spectra_x`: A 1D or 2D array-like structure representing the x-coordinates of the spectral data.\n- `spectra_y`: A 1D or 2D array-like structure representing the y-coordinates (flux values) of the spectral data.\n- `labels`: A list of strings representing the labels for each spectral line (optional).\n- `title`: A string representing the title of the plot.\n- `size`: A tuple representing the size of the figure (width, height).\n\n### Output Format:\n- The function does not return any value. Instead, it saves a plot as an image file named 'output.png' in the current working directory.\n\nInput:\n```python\nspectra_x = np.linspace(0, 100, 100)\nspectra_y = np.random.rand(100)\nlabels = \"Sample Spectrum\"\ntitle = \"Test Spectrum Plot\"\nsize = (8, 6)\n```\n\nOutput:\n```python\n# A plot saved as 'output.png' with the specified parameters.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef plot_spectra(spectra_x, spectra_y, labels, title, size):\n    sns.set(style=\"whitegrid\")\n\n\n    fig, ax = plt.subplots(figsize=size)\n\n    if len(spectra_x.shape) == 1:\n        sns.lineplot(x=spectra_x, y=spectra_y, label=labels, ax=ax)\n    else:\n        for i in range(len(spectra_x)):\n            sns.lineplot(x=spectra_x[i], y=spectra_y[i], label=labels[i] if labels else None, ax=ax)\n\n    ax.set_xlabel('x [px]', fontsize=14)\n    ax.set_ylabel('flux [ADU]', fontsize=14)\n    ax.set_title(title, fontsize=16)\n\n    if labels:\n        ax.legend(loc='upper left')\n\n    plt.savefig('output.png', bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\ndef random_string(length=10):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        if random.choice([True, False]):\n            length = random.randint(50, 500)\n            spectra_x = np.linspace(0, 100, length)\n            spectra_y = np.random.rand(length)\n            labels = random_string() if random.choice([True, False]) else None\n        else:\n            n_spectra = random.randint(2, 10)\n            length = random.randint(50, 500)\n            spectra_x = np.array([np.linspace(0, 100, length) for _ in range(n_spectra)])\n            spectra_y = np.random.rand(n_spectra, length)\n            labels = [random_string() for _ in range(n_spectra)] if random.choice([True, False]) else None\n\n        title = random_string(15)\n        size = (random.uniform(4, 12), random.uniform(4, 12))\n        test_cases.append((spectra_x, spectra_y, labels, title, size))\n\n    return test_cases"}
{"problem_id": "seaborn_58", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates and saves a plot using Matplotlib. The function should allow customization of the plot's appearance through various parameters, including line style, marker type, marker size, and color. The plot will display multiple sine waves, each offset by a different phase.\n\nFunction signature:\n```python\ndef create_and_save_plot(length: int, linestyle: str, marker: str, markersize: int, color: str, output_path: str = 'output.png') -> None:\n```\n\nConstant used in the main code:\n- The constant `1` is used to ensure that the `length` parameter is at least `1`.\n\nInput format:\n- `length`: An integer representing the number of repetitions for the styles.\n- `linestyle`: A string representing the line style for the plot.\n- `marker`: A string or list of strings representing the marker type(s) for the plot.\n- `markersize`: An integer representing the size of the markers.\n- `color`: A string representing the color of the plot lines.\n- `output_path`: A string representing the file path where the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. It saves the generated plot as an image file at the specified `output_path`.\n\nInput:\n```python\n(5, '--', 'o', 7.5, 'g')\n```\n\nOutput:\n```plaintext\nA plot saved as 'output.png' with 5 lines, using dashed lines ('--'), circle markers ('o'), a marker size of 7.5, and green color ('g').\n```", "ground_truth_code": "import matplotlib.pyplot as plt\nimport numpy as np\n\ndef create_and_save_plot(length, linestyle, marker, markersize, color, output_path='output.png'):\n    length = max(1, length)\n    cycler_ori = plt.rcParams['axes.prop_cycle']\n\n    linestyle = [linestyle]\n    marker = [marker] if isinstance(marker, str) else marker\n    color = [color]\n    markersize = [markersize]\n\n    linestyle = ['' if x is None else x for x in linestyle]\n    marker = ['' if x is None else x for x in marker]\n\n    cycler_plt = plt.cycler(color=color * length) if color else plt.cycler(color=cycler_ori.by_key().get('color', []))\n\n    if isinstance(marker, list):\n        cycler_plt += plt.cycler(marker=marker * length)\n    if isinstance(linestyle, list):\n        cycler_plt += plt.cycler(linestyle=linestyle * length)\n    if isinstance(markersize, list):\n        cycler_plt += plt.cycler(markersize=markersize * length)\n\n    plt.figure()\n    plt.gca().set_prop_cycle(cycler_plt)\n\n    x = np.linspace(0, 10, 100)\n    for i in range(5):\n        plt.plot(x, np.sin(x + i), label=f'Line {i+1}')\n\n    plt.legend()\n    plt.savefig(output_path)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    linestyles = ['-', '--', '-.', ':', '']\n    markers = ['o', 's', '^', 'D', 'x', '*']\n    colors = ['b', 'g', 'r', 'c', 'm', 'y', 'k', 'w']\n    markersizes = [random.uniform(1, 10) for _ in range(n)]\n\n    for _ in range(n):\n        length = random.randint(1, 10)\n        linestyle = random.choice(linestyles)\n        marker = random.choice(markers)\n        color = random.choice(colors)\n        markersize = random.choice(markersizes)\n        test_cases.append((length, linestyle, marker, markersize, color))\n\n    return test_cases"}
{"problem_id": "seaborn_59", "library": "seaborn", "code_problem": "```python\ndef plot_points(data_x, data_y, labels, title, x_title, y_title, linestyle, size, output_file='output.png'):\n```\n\nIn this code, the function `plot_points` is designed to create a line plot using the Seaborn and Matplotlib libraries. The function takes several parameters to customize the plot, including data points, labels, titles, line styles, and output file specifications.\n\n### Constant Used:\n- The constant used in the main code is the default output file name, which is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input Format**: The function takes in lists for `data_x`, `data_y`, and `labels`, along with strings for `title`, `x_title`, `y_title`, and a list for `linestyle`, a tuple for `size`, and an optional string for `output_file`.\n- **Output Format**: The function does not return any value but saves a plot as an image file in the specified format.\n\n**Input:**\n```python\ndata_x = [np.sort(np.random.rand(15)), np.sort(np.random.rand(15))]\ndata_y = [np.random.rand(15), np.random.rand(15)]\nlabels = [\"Series 1\", \"Series 2\"]\ntitle = \"Sample Plot\"\nx_title = \"X Axis\"\ny_title = \"Y Axis\"\nlinestyle = ['-', '--']\nsize = (6, 4)\n```\n\n**Output:**\n```python\n# The function will create a plot and save it as 'output.png'.\n# The output file will contain a line plot with two series, each with different line styles.\n``` \n\n(Note: The actual plot cannot be displayed here, but it will be saved as 'output.png' in the working directory when the `plot_points` function is executed with the provided input.)", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef create_plot_linestyle_marker_markersize_color(length, linestyle):\n    length = max(1, length)\n    linestyles = linestyle or ['-', '--', '-.', ':']\n    return plt.cycler(linestyle=linestyles * length)\n\n# main code\ndef plot_points(data_x, data_y, labels, title, x_title, y_title, linestyle, size, output_file='output.png'):\n    labels = labels or [''] * len(data_x)\n    plt.figure(figsize=size)\n    sns.set_theme(style=\"whitegrid\")\n\n    cycler_plt = create_plot_linestyle_marker_markersize_color(len(data_x), linestyle)\n    plt.gca().set_prop_cycle(cycler_plt)\n\n    for i, (x, y) in enumerate(zip(data_x, data_y)):\n        label = labels[i] if i < len(labels) else None\n        sns.lineplot(x=x, y=y, label=label, linestyle=cycler_plt.by_key().get('linestyle')[i % len(cycler_plt)])\n\n    plt.xlabel(x_title)\n    plt.ylabel(y_title)\n    plt.title(title)\n    plt.legend()\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_series = random.randint(1, 10)\n        series_length = random.randint(10, 200)\n\n        data_x = [np.sort(np.random.rand(series_length)) for _ in range(num_series)]\n        data_y = [np.random.rand(series_length) for _ in range(num_series)]\n\n        labels = [f\"Series {i}\" if random.random() > 0.5 else \"\" for i in range(num_series)]\n\n        size = (random.uniform(4, 10), random.uniform(4, 10))\n\n        linestyles = ['-', '--', '-.', ':']\n        chosen_linestyle = random.choice(linestyles)\n        title = \"Plot\"\n        x_title = \"X Axis\"\n        y_title = \"Y Axis\"\n\n        test_cases.append((data_x, data_y, labels, title, x_title, y_title, [chosen_linestyle], size))\n\n    return test_cases\n"}
{"problem_id": "seaborn_60", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the distribution of null hypothesis samples and highlights specific statistical values on a histogram. The function should be able to plot the null samples, mark the 2.5th and 97.5th percentiles, and optionally display a test statistic if provided. The output of the plot should be saved to a specified file path.\n\nFunction signature:\n```python\ndef plot_permutation_samples(null_samples, statistic=None, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The constant values used for the percentiles are 2.5 and 97.5.\n\nInput format:\n- `null_samples`: A list or array of numerical values (e.g., [1.2, 2.3, 3.1, ...]).\n- `statistic`: An optional numerical value (e.g., 2.5).\n- `output_path`: A string representing the file path for saving the plot (e.g., 'my_plot.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a histogram plot as an image file at the specified `output_path`.\n\nInput:\n```python\nnull_samples = np.array([-0.123, 0.456, 0.789, -1.234, 2.345, 0.678, -0.567, 1.234, 0.123, -0.456])\nstatistic = 0.678\n```\n\nOutput:\n```python\n# The output will be a saved histogram plot at 'output.png' with:\n# - A histogram of the null_samples\n# - A blue dashed line at the 2.5th percentile\n# - A blue dashed line at the 97.5th percentile\n# - A red solid line at the test statistic value (0.678)\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_permutation_samples(null_samples, statistic=None, output_path='output.png'):\n    plt.figure(figsize=(8, 6))\n    sns.histplot(null_samples, kde=True, bins=30)\n\n    plt.axvline(x=np.percentile(null_samples, 2.5), color='blue', linestyle='--', label='2.5th percentile')\n    plt.axvline(x=np.percentile(null_samples, 97.5), color='blue', linestyle='--', label='97.5th percentile')\n\n    if statistic is not None:\n        plt.axvline(x=statistic, color='red', linestyle='-', label='Test statistic')\n\n    plt.xlabel('Test Statistic Value')\n    plt.ylabel('Counts')\n    plt.legend()\n    plt.tight_layout()\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sample_size = random.randint(50, 5000)\n\n        distribution_type = random.choice(['normal', 'uniform', 'poisson', 'exponential'])\n\n        if distribution_type == 'normal':\n            null_samples = np.random.normal(loc=0, scale=random.uniform(0.5, 5), size=sample_size)\n        elif distribution_type == 'uniform':\n            null_samples = np.random.uniform(low=-10, high=10, size=sample_size)\n        elif distribution_type == 'poisson':\n            null_samples = np.random.poisson(lam=random.randint(1, 20), size=sample_size)\n        elif distribution_type == 'exponential':\n            null_samples = np.random.exponential(scale=random.uniform(1, 5), size=sample_size)\n\n        include_statistic = random.choice([True, False])\n        statistic = np.random.choice(null_samples) if include_statistic else None\n\n\n        test_cases.append((null_samples, statistic))\n\n    return test_cases"}
{"problem_id": "seaborn_61", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a bar plot from a given dataset and saves it as an image file. The function should utilize the Seaborn and Matplotlib libraries to create the plot.\n\nFunction signature:\n```python\ndef draw_figs(fig_data, output_file=\"output.png\"):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the output file where the generated plot will be saved. It defaults to \"output.png\" if no other name is provided.\n\nInput format:\n- `fig_data`: A dictionary where keys are strings representing figure names and values are numerical values to be plotted.\n- `output_file`: An optional string representing the name of the output file (default is \"output.png\").\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated bar plot as an image file in the specified format.\n\nInput:\n```python\n{\n    \"A\": 23.5,\n    \"B\": 45.0,\n    \"C\": 12.3,\n    \"D\": 67.8\n}\n```\n\nOutput:\nA bar plot saved as \"output.png\" with the following characteristics:\n- X-axis labels: \"A\", \"B\", \"C\", \"D\"\n- Y-axis values: 23.5, 45.0, 12.3, 67.8\n- Title: \"Generated Plot\"", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef draw_figs(fig_data, output_file=\"output.png\"):\n    sns.set_theme(style=\"whitegrid\")\n\n    plt.figure(figsize=(8, 6))\n    sns.barplot(x=list(fig_data.keys()), y=list(fig_data.values()))\n\n    plt.xlabel(\"Figure Names\")\n    plt.ylabel(\"Values\")\n    plt.title(\"Generated Plot\")\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport string\n\ndef random_string(length=5):\n    return ''.join(random.choices(string.ascii_letters, k=length))\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_entries = random.randint(3, 15)\n        fig_data = {random_string(): random.uniform(0, 100) for _ in range(num_entries)}\n        test_cases.append(fig_data)\n    return test_cases"}
{"problem_id": "seaborn_62", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a Quantile-Quantile (QQ) plot to assess the uniformity of a given dataset. The function should also provide a statistical measure (Mu) to indicate whether the data is uniform or non-uniform based on the QQ plot.\n\nFunction Signature:\n```python\ndef plot_qq_unf(data, title, degrees, output_path='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is `360`, which is used to normalize the data if the `degrees` parameter is set to `True`.\n\n### Input Format:\n- The function accepts a list or array of numerical values for `data`, a string for `title`, a boolean for `degrees`, and an optional string for `output_path`.\n\n### Output Format:\n- The function generates and saves a QQ plot as an image file at the specified `output_path`. The plot visually represents the uniformity of the input data based on the calculated quantiles.\n\nInput:\n```python\ndata = np.array([12.5, 15.3, 14.8, 10.1, 13.7])\ntitle = \"Normal_5_Degrees_True\"\ndegrees = True\n```\n\nOutput:\n```python\n# The output will be a saved plot file named 'output.png' with the following characteristics:\n# - N: 5\n# - Mu: (calculated value based on the input data)\n# - The plot will indicate whether the data is 'Non-uniform (99%)', 'Uniform (95%)', or 'Uniform (99%)' based on the value of Mu.\n```", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_qq_unf(data, title, degrees, output_path='output.png'):\n    if degrees:\n        data = np.array(data) % 360\n\n    X = np.sort(data / np.max(data))\n    n = float(len(data))\n    i = np.arange(0, len(data))\n    Y = (i - 0.5) / n\n\n    ds = i / n - X\n    ds_neg = X - (i - 1) / n\n    dpos = ds.max()\n    dneg = ds_neg.max()\n\n    v = dneg + dpos\n    Mu = v * (np.sqrt(n) - 0.567 + 1.623 / np.sqrt(n))\n\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(6, 6))\n    sns.scatterplot(x=Y, y=X, color='red')\n\n    plt.axis([0, 1.0, 0.0, 1.0])\n    plt.text(0.1, 0.9, f'N: {int(n)}')\n    plt.text(0.1, 0.8, f'Mu: {Mu:.3f}')\n\n    if Mu > 1.347:\n        plt.text(0.1, 0.7, 'Non-uniform (99%)')\n    elif Mu < 1.207:\n        plt.text(0.1, 0.7, 'Uniform (95%)')\n    else:\n        plt.text(0.1, 0.7, 'Uniform (99%)')\n\n    plt.title(title)\n    plt.xlabel('Uniform Quantile')\n    plt.ylabel('Data Quantile')\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = np.random.randint(10, 1000)\n        distribution_type = np.random.choice(['uniform', 'normal', 'exponential'])\n        if distribution_type == 'uniform':\n            data = np.random.uniform(0, 1000, size=data_length)\n        elif distribution_type == 'normal':\n            data = np.random.normal(500, 100, size=data_length)\n        else:\n            data = np.random.exponential(scale=100, size=data_length)\n        degrees = np.random.choice([True, False])\n        title = f\"{distribution_type.capitalize()}_{data_length}_Degrees_{degrees}\"\n        test_cases.append((data, title, degrees))\n\n    return test_cases\n"}
{"problem_id": "seaborn_63", "library": "seaborn", "code_problem": "You are tasked with implementing a function that generates a Quantile-Quantile (QQ) plot to assess whether a given dataset follows an exponential distribution. The function will take a list of angles in degrees, compute the necessary transformations, and visualize the results using a scatter plot. The QQ plot will compare the quantiles of the transformed data against the theoretical quantiles of an exponential distribution.\n\nFunction signature:\n```python\ndef plot_qq_exp(I, title, output_path='output.png'):\n```\n\n### Constants:\n- `rad`: This constant is defined as `np.pi / 180.0`, which is used to convert degrees to radians.\n\n### Input and Output Format:\n- **Input**: \n  - `I`: A list of angles in degrees (float or int).\n  - `title`: A string representing the title of the plot.\n  - `output_path`: A string representing the file path where the plot will be saved (default is 'output.png').\n\n- **Output**: \n  - The function does not return any value. It generates and saves a QQ plot as an image file at the specified output path.\n\nInput:\n```python\nI = [45.0, 30.0, 60.0, 15.0, 75.0]\ntitle = \"Test Case 1\"\n```\n\nOutput:\n```plaintext\nN: 5\nMe: 0.872\nExponential (95%)\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_qq_exp(I, title, output_path='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    X, Y, dpos, dneg = [], [], 0.0, 0.0\n    rad = np.pi / 180.0\n    xsum = 0\n\n    for i in I:\n        theta = (90.0 - i) * rad\n        X.append(1.0 - np.cos(theta))\n        xsum += X[-1]\n\n    X.sort()\n    n = float(len(X))\n    kappa = (n - 1.0) / xsum\n\n    for i in range(len(X)):\n        p = (float(i) - 0.5) / n\n        Y.append(-np.log(1.0 - p))\n        f = 1.0 - np.exp(-kappa * X[i])\n        ds = float(i) / n - f\n        dpos = max(dpos, ds)\n        ds = f - (float(i) - 1.0) / n\n        dneg = max(dneg, ds)\n\n    ds = max(dpos, dneg)\n    Me = (ds - 0.2 / n) * (np.sqrt(n) + 0.26 + 0.5 / np.sqrt(n))\n\n    plt.figure(figsize=(8, 6))\n    sns.scatterplot(x=Y, y=X, color='red')\n\n    plt.text(0.1 * max(Y), 0.9 * max(X), f'N: {int(n)}')\n    plt.text(0.1 * max(Y), 0.8 * max(X), f'Me: {Me:.3f}')\n    plt.text(0.1 * max(Y), 0.7 * max(X), 'Not Exponential' if Me > 1.094 else 'Exponential (95%)')\n\n    plt.title(title)\n    plt.xlabel('Exponential Quantile')\n    plt.ylabel('Data Quantile')\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_points = np.random.randint(10, 1000)\n        I = np.random.uniform(0, 180, size=num_points).tolist()\n        title = f\"Test Case {_ + 1}\"\n\n        test_cases.append((I, title))\n    return test_cases"}
{"problem_id": "seaborn_64", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a line plot from a given dataset and saves it as an image file. The function should utilize the Seaborn and Matplotlib libraries for visualization.\n\nFunction Signature:\n```python\ndef plot_strat(data, labels, figsize, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `data`: A list of tuples, where each tuple contains two numerical values (x, y).\n- `labels`: A list of three strings representing the x-axis label, y-axis label, and plot title.\n- `figsize`: A tuple of two integers representing the width and height of the figure.\n- `output_file`: A string representing the name of the output file (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. It saves the generated plot as an image file with the specified name.\n\nInput:\n```python\ndata = [\n    (0.0, 0.04967141530112327),\n    (1.1111111111111112, 0.9786407451920524),\n    (2.2222222222222223, 0.2051582631652024),\n    (3.3333333333333335, 0.3876681632020523),\n    (4.444444444444445, -0.1032188517935573),\n    (5.555555555555555, 0.9008550951570743),\n    (6.666666666666667, 0.1585147930520523),\n    (7.777777777777778, 0.8225450521234567),\n    (8.88888888888889, 0.9786407451920524),\n    (10.0, 0.04967141530112327)\n]\nlabels = ['X-axis', 'Y-axis', 'Sine Wave with Noise']\nfigsize = (8.0, 5.0)\n```\n\nOutput:\n```python\n# This will generate a plot saved as 'output.png' with the specified data, labels, and figure size.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_strat(data, labels, figsize, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    X, Y = zip(*data)\n\n    plt.figure(figsize=figsize)\n    sns.lineplot(x=X, y=Y, marker='o')\n\n    plt.xlabel(labels[0])\n    plt.ylabel(labels[1])\n    plt.title(labels[2])\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\nimport string\n\n\ndef random_string(length=8):\n    return ''.join(random.choices(string.ascii_letters + string.digits, k=length))\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_length = random.randint(10, 100)\n        X = np.linspace(0, 10, data_length).tolist()\n        Y = (np.sin(X) + np.random.normal(0, 0.1, data_length)).tolist()\n        data = list(zip(X, Y))\n        labels = [random_string(5) for _ in range(3)]\n        figsize = (random.uniform(4, 10), random.uniform(3, 8))\n\n\n        test_cases.append((data, labels, figsize))\n\n    return test_cases"}
{"problem_id": "seaborn_65", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a scatter plot to visualize the relationship between two variables, Bc and S, which represent coercivity and squareness, respectively. The function should allow customization of the plot's appearance, including the figure number and marker style. The plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_s_bc(fignum, Bc, S, sym, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to 'output.png'.\n\nInput format:\n- The function takes in a figure number (integer), two lists or arrays (for Bc and S), a list or tuple (for sym), and an optional output file name (string).\n\nOutput format:\n- The function saves a scatter plot as an image file to the specified output file location.\n\nInput:\n```python\n(42, \n np.array([0.5, 1.2, 0.3, 0.8, 0.6]), \n np.array([0.1, 0.4, 0.9, 0.2, 0.5]), \n ('g', 's'))\n```\n\nOutput:\n```plaintext\nA scatter plot is generated and saved as 'output.png' with the following characteristics:\n- Figure number: 42\n- Bc values: [0.5, 1.2, 0.3, 0.8, 0.6]\n- S values: [0.1, 0.4, 0.9, 0.2, 0.5]\n- Symbol: green square ('g', 's')\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_s_bc(fignum, Bc, S, sym, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(num=fignum)\n    sns.scatterplot(x=Bc, y=S, marker=sym[1], color=sym[0])\n\n    plt.xlabel('Bc')\n    plt.ylabel('Mr/Ms')\n    plt.title('Squareness-Coercivity Plot')\n    plt.xlim(left=0)\n    plt.ylim(0, 1)\n    plt.savefig(output_file)\n    plt.close()\n", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    symbols = [\n        ('b', 'o'), ('r', 'x'), ('g', 's'), ('k', '^'), ('m', 'v'),\n        ('y', 'd'), ('c', '<'), ('#FF5733', '>'), ('#33FFCE', '*'), ('#AABBCC', 'p')\n    ]\n\n    for _ in range(n):\n        fignum = random.randint(1, 1000)\n\n        size = random.randint(10, 500)\n        Bc = np.abs(np.random.randn(size))\n        S = np.clip(np.random.rand(size), 0, 1)\n\n        sym = random.choice(symbols)\n        test_cases.append((fignum, Bc, S, sym))\n\n    return test_cases"}
{"problem_id": "seaborn_66", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the relationship between temperature and susceptibility for different frequencies using a line plot. The function will utilize the Seaborn and Matplotlib libraries to generate the plot and save it as an image file.\n\nFunction signature:\n```python\ndef plot_xtf(fignum, XTF, Fs, e, b, output_file='output.png'):\n```\n\nConstants used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `fignum`: An integer.\n- `XTF`: A list of lists, where each inner list contains tuples of (temperature, susceptibility).\n- `Fs`: A list of floats representing frequencies.\n- `e`: A string for the plot title.\n- `b`: A float for the magnetic field value.\n- `output_file`: An optional string for the output file name (default is 'output.png').\n\nOutput format:\n- The function saves a plot as an image file with the specified name and does not return any value.\n\n**Input:**\n```python\nfignum = 1\nXTF = [\n    [(10.0, 0.00001), (20.0, -0.00002), (30.0, 0.00003)],\n    [(15.0, 0.00001), (25.0, -0.00001), (35.0, 0.00002)]\n]\nFs = [50.0, 100.0]\ne = 'Sample A'\nb = 0.5\noutput_file = 'output.png'\n```\n\n**Output:**\n```python\n# The function will generate a plot saved as 'output.png' with the following characteristics:\n# - X-axis labeled 'Temperature (K)'\n# - Y-axis labeled 'Susceptibility (m\u00b3/kg)'\n# - Two lines representing the frequencies 50 Hz and 100 Hz\n# - Title: 'Sample A: B = 5.0e-01 T'\n``` \n\n(Note: The actual output is a visual plot saved as an image file, which cannot be represented in text format.)", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_xtf(fignum, XTF, Fs, e, b, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n    plt.figure(num=fignum)\n    plt.xlabel('Temperature (K)')\n    plt.ylabel('Susceptibility (m\u00b3/kg)')\n\n    for k, freq in enumerate(XTF):\n        T, X = zip(*freq)\n        sns.lineplot(x=T, y=X, label=f'{int(Fs[k])} Hz')\n\n    plt.title(f'{e}: B = {b:.1e} T')\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for index in range(n):\n        num_frequencies = random.randint(1, 10)\n        XTF = []\n        for freq_index in range(num_frequencies):\n            num_points = random.randint(5, 50)\n            T = np.sort(np.random.uniform(1, 300, num_points))\n            X = np.random.uniform(-1e-5, 1e-5, num_points)\n            XTF.append(list(zip(T, X)))\n        Fs = np.random.uniform(10, 10000, num_frequencies)\n        e = random.choice(['Sample A', 'Sample B', 'Sample C'])\n        b = random.uniform(0.1, 2.0)\n        test_cases.append((index, XTF, Fs, e, b))\n\n    return test_cases\n"}
{"problem_id": "seaborn_67", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a scree plot to visualize the explained variance of principal components obtained from a Principal Component Analysis (PCA). The function will take in a PCA object and a specific number of components, and it will save the resulting plot to a specified output file.\n\nFunction signature:\n```python\ndef make_scree_plot(pca, x, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- `output_file`: This is a string that specifies the name of the file where the plot will be saved. The default value is 'output.png'.\n\nInput format:\n- `pca`: A PCA object that contains the `explained_variance_ratio_` attribute.\n- `x`: An integer representing the number of components to highlight in the plot.\n- `output_file`: A string representing the name of the output file (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a scree plot as an image file to the specified output location.\n\nInput:\n```python\nimport numpy as np\nfrom sklearn.decomposition import PCA\n\n# Generate a test case\nn_samples = 100\nn_features = 10\ndata = np.random.rand(n_samples, n_features)\n\npca = PCA(n_components=5)\npca.fit(data)\n\nx = 3  # Choosing the 4th component (index 3)\n```\n\nOutput:\n```python\n# The output will be a scree plot saved as 'output.png'\n# The plot will show the explained variance ratio for the first 5 components,\n# with a vertical red dashed line at x=3 indicating the 4th component.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n\n# main code\ndef make_scree_plot(pca, x, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    n_components = len(pca.explained_variance_ratio_)\n\n    plt.figure(figsize=(12, 8))\n    sns.lineplot(x=range(n_components),\n                 y=pca.explained_variance_ratio_,\n                 marker='o')\n\n    plt.xlabel('Number of Components')\n    plt.ylabel('% Explained Variance')\n    plt.title('Scree Plot')\n\n    plt.axvline(x=x, color='r', linestyle='--')\n\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nfrom sklearn.decomposition import PCA\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(50, 500)\n        n_features = np.random.randint(2, 100)\n        data = np.random.rand(n_samples, n_features)\n\n        pca = PCA(n_components=np.random.randint(1, min(n_samples, n_features)))\n        pca.fit(data)\n\n        x = np.random.randint(0, len(pca.explained_variance_ratio_))\n        test_cases.append((pca, x))\n\n    return test_cases"}
{"problem_id": "seaborn_68", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a heatmap visualization from a given 2D array of values. The function should allow customization of the color map, figure size, and whether to annotate the heatmap with the data values. Additionally, the function should save the generated heatmap to a specified output file.\n\nFunction signature:\n```python\ndef plot_pxy(pxy, cmap, figsize, annotate, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- The function expects a 2D array-like structure for `pxy`, a string for `cmap`, a tuple for `figsize`, a boolean for `annotate`, and an optional string for `output_path`.\n\nOutput format:\n- The function does not return any value but saves the heatmap visualization as an image file at the specified `output_path`.\n\nInput:\n```python\npxy = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ncmap = 'Blues'\nfigsize = (6, 6)\nannotate = True\n```\n\nOutput:\n```plaintext\nA heatmap is generated and saved as 'output.png' with the following properties:\n- Shape of pxy: (3, 3)\n- Color map: Blues\n- Figure size: (6, 6)\n- Annotations: True\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n\n# main code\ndef plot_pxy(pxy, cmap, figsize, annotate, output_path='output.png'):\n    pxy = np.array(pxy)\n    plt.figure(figsize=figsize)\n\n    plt.xlabel('Y-axis', fontsize=14, fontweight='bold')\n    plt.ylabel('X-axis', fontsize=14, fontweight='bold')\n\n    ax = sns.heatmap(pxy, cmap=cmap, annot=annotate, fmt='.2f', cbar=True, linewidths=0.5)\n    plt.title(f'Heatmap Visualization (Shape: {pxy.shape})', fontsize=16, fontweight='bold')\n    plt.savefig(output_path)", "test_script": "import random\nimport numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    possible_shapes = [\n        (5, 5), (10, 10), (20, 20), (3, 3), (8, 12), (12, 8),\n        (15, 15), (4, 6), (6, 4), (7, 7)\n    ]\n\n    cmap_options = ['viridis', 'plasma', 'inferno', 'magma', 'cividis',\n                    'Blues', 'Greens', 'Reds', 'coolwarm', 'hot']\n\n    figsize_options = [\n        (4, 4), (6, 6), (8, 6), (10, 10), (12, 8),\n        (5, 5), (7, 7), (9, 5), (11, 6), (6, 8)\n    ]\n\n    annotate_options = [True, False]\n\n    for _ in range(n):\n        pxy = np.random.rand(*random.choice(possible_shapes))\n        cmap = random.choice(cmap_options)\n        figsize = random.choice(figsize_options)\n        annotate = random.choice(annotate_options)\n\n        test_cases.append((pxy, cmap, figsize, annotate))\n\n    return test_cases\n"}
{"problem_id": "seaborn_69", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a heatmap visualization from a given 2D array of values. The function should allow customization of the color map, whether to annotate the heatmap with the data values, and the option to save the generated heatmap to a specified file path.\n\nFunction signature:\n```python\ndef plot_pxy(pxy, cmap, annotate, save_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `save_path` is set to `'output.png'`.\n\n\nInput format:\n- `pxy`: A 2D array of numerical values (e.g., a list of lists or a NumPy array).\n- `cmap`: A string representing the desired color map (e.g., 'viridis', 'plasma', etc.).\n- `annotate`: A boolean value (True or False) indicating whether to display the values on the heatmap.\n- `save_path`: A string representing the file path where the heatmap image will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves the generated heatmap as an image file at the specified `save_path`.\n\nInput:\n```python\npxy = np.array([[0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9]])\ncmap = 'viridis'\nannotate = True\n```\n\nOutput:\n```plaintext\nA heatmap is generated and saved as 'output.png' with the specified parameters.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_pxy(pxy, cmap, annotate, save_path='output.png'):\n    plt.figure(figsize=(8, 6))\n\n    sns.heatmap(pxy, cmap=cmap, annot=annotate, fmt='.2f', linewidths=0.5)\n\n    plt.xlabel('Y', fontsize=12)\n    plt.ylabel('X', fontsize=12)\n    plt.title('Heatmap Visualization', fontsize=14)\n\n    plt.savefig(save_path, bbox_inches='tight')\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    cmap_options = ['viridis', 'plasma', 'inferno', 'magma', 'cividis', 'coolwarm', 'YlGnBu']\n\n    for _ in range(n):\n        rows, cols = random.randint(2, 20), random.randint(2, 20)\n        pxy = np.random.rand(rows, cols)\n        cmap = random.choice(cmap_options)\n\n        if random.choice([True, False]):\n            annotate = np.round(pxy, 2)\n        else:\n            annotate = False\n\n        test_cases.append((pxy, cmap, annotate))\n\n    return test_cases"}
{"problem_id": "seaborn_70", "library": "seaborn", "code_problem": "You are tasked with creating a function that plots a Gaussian (normal) distribution based on specified parameters. The function should allow customization of the mean, variance, axis labels, and the output file name for the generated plot.\n\nFunction signature:\n```python\ndef plot_gaussian(mean, variance, xlim, xlabel, ylabel, output_file='output.png'):\n```\n\nIn this function, the following constant is used:\n- The default output file name is set to `'output.png'`.\n\nInput format:\n- `mean`: A float representing the mean of the Gaussian distribution.\n- `variance`: A float representing the variance of the Gaussian distribution.\n- `xlim`: A tuple of two floats representing the limits of the x-axis, or `None` to automatically calculate limits.\n- `xlabel`: A string representing the label for the x-axis.\n- `ylabel`: A string representing the label for the y-axis.\n- `output_file`: A string representing the name of the output file where the plot will be saved (default is `'output.png'`).\n\nOutput format:\n- The function does not return any value. It generates and saves a plot of the Gaussian distribution to the specified output file.\n\nInput:\n```python\n(10.5, 25.0, None, \"X-axis 42\", \"Y-axis 88\")\n```\n\nOutput:\n```python\n# A Gaussian plot is generated with:\n# - Mean: 10.5\n# - Variance: 25.0\n# - X-axis limits: Automatically determined\n# - X-axis label: \"X-axis 42\"\n# - Y-axis label: \"Y-axis 88\"\n# The plot is saved as 'output.png'.\n```", "ground_truth_code": "import math\nimport numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\nfrom scipy.stats import norm\n\n# main code\ndef plot_gaussian(mean, variance, xlim, xlabel, ylabel, output_file='output.png'):\n    sigma = math.sqrt(variance)\n    n = norm(mean, sigma)\n\n    min_x, max_x = (n.ppf(0.001), n.ppf(0.999)) if xlim is None else xlim\n\n    xs = np.linspace(min_x, max_x, 1000)\n    ys = n.pdf(xs)\n\n    sns.set(style=\"whitegrid\")\n    sns.lineplot(x=xs, y=ys)\n\n    plt.axvline(mean, color='red', linestyle='--')\n    plt.xlabel(xlabel)\n    plt.ylabel(ylabel)\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        mean = random.uniform(-50, 50)\n        variance = random.uniform(0.1, 100)\n        if random.random() < 0.5:\n            xlim = None\n        else:\n            lower_bound = mean - random.uniform(1, 30)\n            upper_bound = mean + random.uniform(1, 30)\n            xlim = (min(lower_bound, upper_bound), max(lower_bound, upper_bound))\n        xlabel = f\"X-axis {random.randint(1, 100)}\"\n        ylabel = f\"Y-axis {random.randint(1, 100)}\"\n        test_cases.append((mean, variance, xlim, xlabel, ylabel))\n\n    return test_cases"}
{"problem_id": "seaborn_71", "library": "seaborn", "code_problem": "You are required to implement a function that visualizes the performance of a classification model using a confusion matrix. The function will take the true labels and predicted labels as input and generate a heatmap representation of the confusion matrix, saving it to a specified output file.\n\nFunction signature:\n```python\ndef plot_confusion_matrix(y_true, y_pred, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for `output_path` is set to `'output.png'`.\n\nInput format:\n- `y_true`: A list or array-like structure containing the true labels of the data points.\n- `y_pred`: A list or array-like structure containing the predicted labels from the classification model.\n- `output_path`: A string representing the file path where the confusion matrix image will be saved (optional).\n\nOutput format:\n- The function does not return any value. Instead, it saves a heatmap image of the confusion matrix to the specified output path.\n\n```python\n# Input\ny_true = np.array([0, 1, 0, 1, 2, 2, 1, 0, 2, 1])\ny_pred = np.array([0, 0, 1, 1, 2, 2, 1, 0, 1, 2])\n\n# Output\n# The confusion matrix will be saved as 'output.png' and will look like this:\n# [[3 1 0]\n#  [1 2 1]\n#  [0 1 2]]\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nfrom sklearn import metrics\nimport numpy as np\n\n# main code\ndef plot_confusion_matrix(y_true, y_pred, output_path='output.png'):\n    conf_mat = metrics.confusion_matrix(y_true, y_pred)\n\n    plt.figure(figsize=(8, 6))\n    sns.heatmap(conf_mat, annot=True, fmt='d', cmap='coolwarm', cbar=False,\n                xticklabels=np.unique(y_pred),\n                yticklabels=np.unique(y_true))\n\n    plt.xlabel('Predicted label')\n    plt.ylabel('True label')\n    plt.tight_layout()\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_classes = random.randint(2, 10)\n        num_samples = random.randint(10, 100)\n        y_true = np.random.randint(0, num_classes, size=num_samples)\n        y_pred = np.random.randint(0, num_classes, size=num_samples)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "seaborn_72", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the cost values over a series of iterations. The function will generate a line plot using the Seaborn and Matplotlib libraries, which will help in analyzing the performance of a model during training.\n\nFunction Signature:\n```python\ndef draw_costs(costs_: List[float], steps_: float, output_file: str = 'output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `costs_`: A list of floating-point numbers representing the cost values at each iteration.\n- `steps_`: A floating-point number representing the step size for the x-axis.\n- `output_file`: A string representing the filename to save the plot (optional, defaults to 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a plot as an image file to the specified output file path.\n\nInput:\n```python\ncosts_ = np.array([5.67, 4.89, 3.45, 2.78, 1.23])\nsteps_ = 2\n```\n\nOutput:\n```plaintext\nA line plot saved as 'output.png' showing the cost values J(w) over iterations with the following characteristics:\n- X-axis labeled 'Iterations' ranging from 2 to 10 (2, 4, 6, 8, 10).\n- Y-axis labeled 'Cost values J(w)' ranging from 0 to 6.67.\n- A grey line with black markers at each data point.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef draw_costs(costs_, steps_, output_file='output.png'):\n\n    sns.set(style=\"whitegrid\")\n\n    x = np.arange(1, 1 + len(costs_)) * steps_\n\n    plt.figure(figsize=(8, 5))\n    sns.lineplot(x=x, y=costs_, color='grey', marker='o', markerfacecolor='black')\n\n    plt.title('Cost values J(w) state')\n    plt.xlabel('Iterations')\n    plt.ylabel('Cost values J(w)')\n\n    plt.xlim(min(x), max(x))\n    plt.ylim(0, max(costs_) + 1)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_values = random.randint(5, 100)\n        costs_ = np.round(np.abs(np.random.randn(num_values) * 10), 2)\n        steps_ = random.randint(1, 10)\n        test_cases.append((costs_, steps_))\n\n    return test_cases"}
{"problem_id": "seaborn_73", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes data points in a scatter plot using the Seaborn and Matplotlib libraries. The function should take in a set of data points and their corresponding values, annotate each point with its coordinates, and save the resulting plot to a specified file.\n\nFunction signature:\n```python\ndef draw_points(X, y, title, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_path` parameter is set to `'output.png'`.\n\nInput format:\n- `X`: A 2D NumPy array where each row represents a data point and the first column contains the x-coordinates (BMI values).\n- `y`: A 1D NumPy array containing the corresponding y-coordinates (Fat% values) for each data point.\n- `title`: A string representing the title of the plot.\n- `output_path`: A string representing the file path where the plot will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it generates and saves a scatter plot as an image file at the specified output path.\n\nInput:\n```python\nX = np.array([[20.5], [25.3], [30.1], [35.7], [22.8]])\ny = np.array([15.2, 20.5, 25.1, 30.0, 18.3])\ntitle = 'Test Case 1: 5 Points'\n```\n\nOutput:\n```plaintext\nA scatter plot is generated and saved as 'output.png' with the following annotations:\n(20.50,15.20), (25.30,20.50), (30.10,25.10), (35.70,30.00), (22.80,18.30)\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef draw_points(X, y, title, output_path='output.png'):\n    plt.figure()\n    sns.scatterplot(x=X[:, 0], y=y, color='black', marker='o')\n    plt.title(title)\n    plt.xlabel('BMI')\n    plt.ylabel('Fat%')\n\n    for x, y in zip(X[:, 0], y):\n        plt.annotate(f'({x:.2f},{y:.2f})', xy=(x, y), xytext=(-20, -20),\n                     textcoords='offset pixels', ha='left', va='bottom')\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 100)\n        X = np.random.uniform(15, 40, size=(num_samples, 1))\n        y = np.random.uniform(5, 50, size=(num_samples,))\n        title = f'Test Case {_ + 1}: {num_samples} Points'\n        test_cases.append((X, y, title))\n\n    return test_cases"}
{"problem_id": "seaborn_74", "library": "seaborn", "code_problem": "You are tasked with visualizing the results of a clustering algorithm using Python. The goal is to create a function that generates a scatter plot of the clustered data points along with their corresponding centroids. The function should allow for customization of the output file name where the plot will be saved.\n\nFunction Signature:\n```python\ndef plot_cluster_result(list_cluster_members, centroid, iteration, output_file='output.png'):\n```\n\n### Constants Used:\n- The default output file name is set to `'output.png'`.\n\n### Input Format:\n- `list_cluster_members`: A list of numpy arrays, where each array contains the coordinates of the data points belonging to a specific cluster.\n- `centroid`: A numpy array containing the coordinates of the centroids for each cluster.\n- `iteration`: An integer representing the current iteration number.\n- `output_file`: (Optional) A string representing the name of the output file.\n\n### Output Format:\n- The function does not return any value. Instead, it saves a scatter plot image to the specified output file.\n\nInput:\n```python\nlist_cluster_members = [\n    np.array([[10, 20], [12, 22], [14, 18]]),  # Cluster 1\n    np.array([[50, 60], [52, 62], [54, 58]]),  # Cluster 2\n    np.array([[80, 90], [82, 92], [84, 88]])   # Cluster 3\n]\ncentroid = np.array([[12, 20], [52, 60], [82, 90]])\niteration = 5\n```\n\nOutput:\n```plaintext\nA plot is generated and saved as 'output.png' showing:\n- 3 clusters represented by different markers.\n- Centroids marked distinctly.\n- Title indicating 'Iteration - 5'.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\nimport itertools\n\n# main code\ndef plot_cluster_result(list_cluster_members, centroid, iteration, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(figsize=(8, 6))\n    plt.title(f'Iteration - {iteration}')\n\n    marker = itertools.cycle(('.', '*', '^', 'x', '+'))\n\n    for i, member_cluster in enumerate(list_cluster_members):\n        sns.scatterplot(\n            x=np.ravel(member_cluster[:, 0]),\n            y=np.ravel(member_cluster[:, 1]),\n            marker=next(marker),\n            s=100,\n            label=f'Cluster {i + 1}'\n        )\n\n    for i in range(len(centroid)):\n        sns.scatterplot(\n            x=[centroid[i, 0]],\n            y=[centroid[i, 1]],\n            marker=next(marker),\n            s=200,\n            label=f'Centroid {i + 1}'\n        )\n\n    plt.legend()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_clusters = random.randint(2, 5)\n        list_cluster_members = [\n            np.random.rand(random.randint(5, 20), 2) * 100\n            for _ in range(num_clusters)\n        ]\n        centroid = np.array([np.mean(cluster, axis=0) for cluster in list_cluster_members])\n        iteration = random.randint(1, 100)\n\n        test_cases.append((list_cluster_members, centroid, iteration))\n\n    return test_cases"}
{"problem_id": "seaborn_75", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the results of a spectral clustering algorithm. The function will generate a scatter plot of clustered data points, where each cluster is represented by a different color. The function will save the plot to a specified output file.\n\nFunction signature:\n```python\ndef draw(k, data, classification, iteration, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the figure size, which is set to (8, 6) for the plot.\n\nInput format:\n- The function takes the following inputs:\n  - An integer `k` (number of clusters).\n  - A 2D numpy array `data` of shape (n_samples, 2) containing the x and y coordinates of the data points.\n  - A 1D numpy array `classification` of length n_samples indicating the cluster assignment for each data point.\n  - An integer `iteration` representing the current iteration of the clustering process.\n  - An optional string `output_file` specifying the name of the output file (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a scatter plot image to the specified output file.\n\nInput:\n```python\nk = 5\ndata = np.array([[12.5, 30.1], [45.2, 60.3], [22.1, 15.5], [78.9, 90.0], [55.5, 45.5], \n                 [10.0, 20.0], [30.0, 40.0], [50.0, 60.0], [70.0, 80.0], [90.0, 100.0]])\nclassification = np.array([0, 1, 0, 2, 1, 3, 4, 3, 2, 4])\niteration = 10\noutput_file = 'test_output.png'\n```\n\nOutput:\n```python\n# The function draw will create a scatter plot saved as 'test_output.png' \n# with the title 'Spectral-Clustering Iteration-10' showing points colored \n# according to their classification.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef draw(k, data, classification, iteration, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(8, 6))\n\n    palette = sns.color_palette(\"hsv\", k)\n    for i in range(k):\n        mask = (classification == i)\n        sns.scatterplot(x=data[mask, 0], y=data[mask, 1], s=8, color=palette[i])\n\n    title = f'Spectral-Clustering Iteration-{iteration}'\n    plt.title(title)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        k = random.randint(2, 10)\n        num_points = random.randint(50, 500)\n        data = np.random.rand(num_points, 2) * 100\n        classification = np.random.randint(0, k, size=num_points)\n        iteration = random.randint(1, 100)\n        test_cases.append((k, data, classification, iteration))\n\n    return test_cases"}
{"problem_id": "seaborn_76", "library": "seaborn", "code_problem": "You are tasked with visualizing spike train data from a leaky integrate-and-fire (LIF) neuron model. The goal is to create a scatter plot of spike events and optionally overlay the membrane potential of the neurons over time. \n\nThe main function you will implement is defined by the following signature:\n\n```python\ndef plotLIF(U, S, Vplot, staggering, output_file='output.png'):\n```\n\n### Constants:\n- The constant used in the main code is the default value for `output_file`, which is set to `'output.png'`.\n\n### Input and Output Format:\n- **Input Format**:\n  - `U`: A 2D NumPy array of shape (T, N) where T is the number of time steps and N is the number of neurons.\n  - `S`: A 2D binary NumPy array of the same shape (T, N) indicating spike events.\n  - `Vplot`: Either a string ('all') or an integer indicating which neurons to plot.\n  - `staggering`: A float value for vertical spacing between neuron plots.\n  - `output_file`: A string for the output filename.\n\n- **Output Format**:\n  - The function saves a plot as an image file (PNG format) specified by `output_file`. The plot visually represents the spike events and the membrane potentials of the specified neurons over time.\n\nInput:\n```python\nU = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0]])\nS = np.array([[0, 1], [1, 0], [0, 0], [1, 1], [0, 0]])\nVplot = [0, 1]\nstaggering = 1.0\n```\n\nOutput:\n```python\n# The output will be a plot saved as 'output.png' with:\n# - Scatter plot of spikes at times [1, 3] for neuron 0 and [0, 1, 3] for neuron 1.\n# - Line plots for U[:, 0] and U[:, 1] staggered by 1.0.\n```", "ground_truth_code": "import numpy as np\nimport seaborn as sns\nimport matplotlib.pyplot as plt\n\ndef spikes_to_evlist(spikes):\n    t, n = np.where(spikes)\n    return t, n\n\n# main code\ndef plotLIF(U, S, Vplot, staggering, output_file='output.png'):\n    sns.set(style=\"whitegrid\")\n    t, n = spikes_to_evlist(S)\n\n    plt.figure(figsize=(10, 6))\n    sns.scatterplot(x=t, y=n, color='k', marker='|')\n    plt.ylim([-1, S.shape[1] + 1])\n    plt.xlim([0, S.shape[0]])\n\n    if U is not None:\n        if isinstance(Vplot, str) and Vplot == 'all':\n            Vplot = range(U.shape[1])\n        elif not hasattr(Vplot, '__iter__'):\n            Vplot = range(min(Vplot, U.shape[1]))\n\n        for i, idx in enumerate(Vplot):\n            sns.lineplot(x=np.arange(U.shape[0]), y=U[:, idx] + i * staggering)\n\n        plt.xlabel('Time [ms]')\n        plt.ylabel('u [au]')\n\n    plt.ylabel('Neuron')\n    plt.tight_layout()\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        time_steps = random.randint(50, 500)\n        neurons = random.randint(10, 200)\n        if random.random() < 0.5:\n            U = None\n        else:\n            U = np.random.rand(time_steps, random.randint(1, neurons))\n        S = np.random.choice([0, 1], size=(time_steps, neurons))\n        if U is not None:\n            if random.random() < 0.3:\n                Vplot = 'all'\n            elif random.random() < 0.5:\n                Vplot = random.randint(1, U.shape[1])\n            else:\n                Vplot = np.random.choice(U.shape[1], size=random.randint(1, U.shape[1]), replace=False)\n        else:\n            Vplot = 'all'\n        staggering = random.uniform(0.1, 5.0)\n        test_cases.append((U, S, Vplot, staggering))\n\n    return test_cases"}
{"problem_id": "seaborn_77", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a 2D matrix as a heatmap using the Seaborn and Matplotlib libraries. The function should allow the user to specify the matrix data, a title for the plot, and an optional output filename for saving the generated heatmap image.\n\nFunction signature:\n```python\ndef plot_matrix(Sxx, title, output_file='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput format:\n- `Sxx`: A 2D array-like structure containing numerical data to be visualized.\n- `title`: A string representing the title of the heatmap.\n- `output_file`: (Optional) A string representing the filename to save the heatmap image.\n\nOutput format:\n- The function saves a heatmap image to the specified output file, with no return value.\n\nInput:\n```python\nSxx = np.array([[0.1, 0.2, 0.3], \n                 [0.4, 0.5, 0.6], \n                 [0.7, 0.8, 0.9]])\ntitle = \"Test Case 1: 3x3 Matrix\"\n```\n\nOutput:\nThe function `plot_matrix(Sxx, title)` will generate a heatmap and save it as 'output.png'. The heatmap will visually represent the values in the 3x3 matrix with a color gradient based on the 'jet' colormap.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_matrix(Sxx, title, output_file='output.png'):\n    plt.figure(figsize=(8, 6))\n    sns.heatmap(Sxx, cmap='jet', cbar=True)\n    plt.title(title, fontsize=12)\n    plt.ylabel('Frequency Bins')\n    plt.xlabel('Window Samples')\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(5, 100)\n        cols = random.randint(5, 100)\n\n        Sxx = np.random.rand(rows, cols)\n\n        title = f\"Test Case {_+1}: {rows}x{cols} Matrix\"\n\n        test_cases.append((Sxx, title))\n\n    return test_cases\n"}
{"problem_id": "seaborn_78", "library": "seaborn", "code_problem": "You are tasked with creating a function that generates a line plot to visualize the Mean Absolute Percentage Error (MAPE) for a given dataset. The function will take in several parameters, including the data to be plotted and the output file path for saving the plot.\n\nFunction signature:\n```python\ndef plot_mape_figure(i, x, y, name, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The default value for the `output_path` parameter is set to `'output.png'`.\n\nInput format:\n- The function accepts the following parameters:\n  - `i`: A string for the plot title.\n  - `x`: A list or array-like structure for the x-axis data.\n  - `y`: A list or array-like structure for the y-axis data.\n  - `name`: A string for the line label.\n  - `output_path`: An optional string for the output file path.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file at the specified output path.\n\nInput:\n```python\n('A1B2C3D4', array([ 0,  1,  2,  3,  4,  5,  6,  7,  8,  9]), array([23.45, 67.89, 12.34, 45.67, 89.01, 34.56, 78.90, 11.12, 22.33, 44.55]), 'Test_A1B2C3D4')\n```\n\nOutput:\n```python\n'output.png'  # The output file will be saved as 'output.png' containing the plot.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_mape_figure(i, x, y, name, output_path='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(figsize=(8, 6))\n    sns.lineplot(x=x, y=y, label=f'{name}_MAPE', linewidth=2.5)\n\n    plt.xlabel('Linkid')\n    plt.ylabel('MAPE')\n    plt.title(i)\n    plt.legend(loc='upper right')\n\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        data_points = random.randint(10, 100)\n        x = np.arange(data_points)\n        y = np.random.uniform(0, 100, data_points)\n        title = ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n\n        test_cases.append((title, x, y, f'Test_{title}'))\n\n    return test_cases"}
{"problem_id": "seaborn_79", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes traffic volume data over time for multiple files. The function will generate a line plot where each line represents the traffic volume from a different file, using a distinct color for each line. The plot will include labeled axes, a title, and a legend indicating which line corresponds to which file. The final plot will be saved to a specified output file.\n\nFunction signature:\n```python\ndef plot_in_one_figure(i, x, y, files, output_path='output.png'):\n```\n\nConstant used in the main code:\n- The color palette used for the lines is defined as `color_palette = sns.color_palette(\"tab10\", len(files))`, which generates a color palette with a maximum of 10 distinct colors.\n\nInput format:\n- `i`: A string representing the title of the plot.\n- `x`: A list of numerical values representing the x-axis data (time).\n- `y`: A list of lists, where each inner list contains numerical values representing the y-axis data (traffic volume) for each corresponding file.\n- `files`: A list of strings representing the filenames associated with each dataset.\n- `output_path`: A string representing the file path where the plot will be saved (optional, defaults to 'output.png').\n\nOutput format:\n- The function does not return any value. It saves a plot as an image file at the specified output path.\n\nInput:\n```python\ntitle = \"Plot A1B2C3D4\"\nx = np.linspace(0, 100, 75)\ny = np.array([\n    [12.5, 15.3, 14.8, 18.2, 20.1, 22.4, 19.8, 21.0, 23.5, 25.0, 27.1, 29.3, 30.0, 32.5, 34.1, 36.0, 38.2, 40.0, 42.5, 44.1, 46.0, 48.5, 50.0, 52.3, 54.1, 56.0, 58.5, 60.0, 62.1, 64.5, 66.0, 68.2, 70.0, 72.5, 74.1, 76.0, 78.5, 80.0, 82.1, 84.5, 86.0, 88.2, 90.0, 92.5, 94.1, 96.0, 98.5, 100.0, 102.1, 104.5, 106.0, 108.2, 110.0, 112.5, 114.1, 116.0, 118.5, 120.0, 122.1, 124.5, 126.0],\n    [10.0, 12.0, 14.0, 16.0, 18.0, 20.0, 22.0, 24.0, 26.0, 28.0, 30.0, 32.0, 34.0, 36.0, 38.0, 40.0, 42.0, 44.0, 46.0, 48.0, 50.0, 52.0, 54.0, 56.0, 58.0, 60.0, 62.0, 64.0, 66.0, 68.0, 70.0, 72.0, 74.0, 76.0, 78.0, 80.0, 82.0, 84.0, 86.0, 88.0, 90.0, 92.0, 94.0, 96.0, 98.0, 100.0, 102.0, 104.0, 106.0, 108.0, 110.0, 112.0, 114.0, 116.0, 118.0, 120.0, 122.0, 124.0, 126.0],\n])\nfiles = [\"file_A.txt\", \"file_B.txt\"]\n```\n\nOutput:\n```python\n# The output will be a saved plot image at 'output.png' with the title \"Plot A1B2C3D4\",\n# x-axis labeled as 'Time', y-axis labeled as 'Traffic Volume', and two lines representing\n# the data from 'file_A.txt' and 'file_B.txt' in different colors.\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\n\n# main code\ndef plot_in_one_figure(i, x, y, files, output_path='output.png'):\n    sns.set_theme(style=\"whitegrid\")\n\n    plt.figure()\n    color_palette = sns.color_palette(\"tab10\", len(files))\n\n    for idx, file in enumerate(files):\n        plt.plot(x, y[idx], color=color_palette[idx], linewidth=2.5, linestyle='-', label=file.split('.')[0])\n\n    plt.xlabel('Time')\n    plt.ylabel('Traffic Volume')\n    plt.title(i)\n    plt.legend(loc='upper right')\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\nimport string\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_files = random.randint(2, 10)\n        files = [\"file_\" + ''.join(random.choices(string.ascii_letters, k=5)) + \".txt\" for _ in range(num_files)]\n        x_length = random.randint(50, 200)\n        x = np.linspace(0, 100, x_length)\n        y = np.random.rand(num_files, x_length) * random.uniform(10, 100)\n        title = \"Plot \" + ''.join(random.choices(string.ascii_letters + string.digits, k=8))\n        test_cases.append((title, x, y, files))\n\n    return test_cases"}
{"problem_id": "seaborn_80", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes traffic volume data over time using a line plot. The function will take in a title for the plot, a list of time points, a list of traffic volume data series, and a list of filenames corresponding to each data series. The function will generate a line plot with the specified title, label the axes appropriately, and save the plot as an image file.\n\nFunction signature:\n```python\ndef plot_in_one_subfigure(title: str, x: list, y_data: list, files: list) -> None:\n```\n\nConstant used in the main code:\n- The figure size for the plot is set to (8, 6).\n\nInput format:\n- `title`: A string representing the title of the plot.\n- `x`: A list of time points (e.g., timestamps).\n- `y_data`: A list of lists, where each inner list contains traffic volume data corresponding to the time points.\n- `files`: A list of strings representing filenames, where each filename corresponds to a data series in `y_data`.\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file named 'output.png'.\n\nInput:\n```python\n(\n    \"Test Case 1\", \n    np.linspace(0, 99, 100), \n    [np.random.rand(100) * 50, np.random.rand(100) * 75], \n    ['file_0.csv', 'file_1.csv']\n)\n```\n\nOutput:\n```plaintext\nA line plot saved as 'output.png' showing two series of traffic volume over time with the title \"Test Case 1\".\n```", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport pandas as pd\n\n# main code\ndef plot_in_one_subfigure(title, x, y_data, files):\n    sns.set(style=\"whitegrid\")\n    plt.figure(figsize=(8, 6))\n\n\n    data = pd.DataFrame({'time': x})\n    for idx, series in enumerate(y_data):\n        data[files[idx].split('.')[0]] = series\n\n\n    sns.lineplot(data=data.set_index('time')).set(title=title)\n    plt.ylabel('Traffic Volume')\n    plt.xlabel('Time')\n\n    plt.savefig('output.png')\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        time_steps = random.randint(50, 200)\n        x = np.linspace(0, time_steps - 1, time_steps)\n        num_series = random.choice([2, 3])\n        y_data = [np.random.rand(time_steps) * random.uniform(10, 100) for _ in range(num_series)]\n        files = [f'file_{i}.csv' for i in range(num_series)]\n        title = f'Test Case {_ + 1}'\n\n        test_cases.append((title, x, y_data, files))\n\n    return test_cases"}
{"problem_id": "seaborn_81", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes a time series data using a line plot. The function will also highlight specific boundaries on the plot to indicate significant points in the data. \n\nFunction signature:\n```python\ndef plot_single_jingju(obs_i, i_boundary, hopsize_t, output_path='output.png'):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the default value for `output_path`, which is set to `'output.png'`.\n\nInput format:\n- `obs_i`: A list or array of observed data points (float or integer).\n- `i_boundary`: A list or array of indices indicating the boundaries (integer).\n- `hopsize_t`: A float representing the time interval between observations.\n- `output_path`: A string representing the file path where the plot will be saved (default is 'output.png').\n\nOutput format:\n- The function does not return any value. Instead, it saves a plot as an image file at the specified `output_path`.\n\nInput:\n```python\nobs_i = np.array([0.1, 0.5, 0.3, 0.7, 0.2, 0.9, 0.4, 0.6])\ni_boundary = [2, 5]\nhopsize_t = 0.1\n```\n\nOutput:\nThe function `plot_single_jingju(obs_i, i_boundary, hopsize_t, output_path='output.png')` will generate a plot saved as 'output.png' with the following characteristics:\n- The x-axis will represent time in seconds, ranging from 0 to 0.7 seconds (since the length of `obs_i` is 8 and `hopsize_t` is 0.1).\n- The y-axis will represent the values of `obs_i`.\n- Vertical red lines will be drawn at 0.2 seconds (2 * 0.1) and 0.5 seconds (5 * 0.1) to indicate the boundaries.", "ground_truth_code": "import seaborn as sns\nimport matplotlib.pyplot as plt\nimport numpy as np\n\n# main code\ndef plot_single_jingju(obs_i, i_boundary, hopsize_t, output_path='output.png'):\n    sns.set(style=\"whitegrid\")\n\n    plt.figure(figsize=(16, 4))\n\n    ax = plt.subplot(1, 1, 1)\n    sns.lineplot(x=np.arange(0, len(obs_i)) * hopsize_t, y=obs_i, ax=ax)\n\n    for i_ib in range(len(i_boundary) - 1):\n        ax.axvline(i_boundary[i_ib] * hopsize_t, color='r', linewidth=2)\n\n    ax.set_ylabel('ODF')\n    ax.set_xlabel('Time (s)')\n    ax.axis('tight')\n\n    plt.savefig(output_path)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for idx in range(n):\n        obs_length = random.randint(50, 1000)\n        obs_i = np.random.rand(obs_length)\n        num_boundaries = random.randint(2, 20)\n        i_boundary = sorted(random.sample(range(obs_length), num_boundaries))\n        hopsize_t = round(random.uniform(0.01, 1.0), 3)\n\n\n        test_cases.append((obs_i, i_boundary, hopsize_t))\n\n    return test_cases"}
{"problem_id": "seaborn_82", "library": "seaborn", "code_problem": "You are tasked with creating a function that visualizes the performance of a classification model by generating a confusion matrix. The function will take the true labels and predicted labels of a test dataset, along with the model's name, and save the resulting confusion matrix as an image file.\n\nFunction Signature:\n```python\ndef draw_confusion_matrix(y_test, y_pred, model_name, output_file='output.png'):\n```\n\nConstant Used:\n- The default value for the `output_file` parameter is set to `'output.png'`.\n\nInput Format:\n- `y_test`: A list or array-like structure containing the true labels of the test dataset.\n- `y_pred`: A list or array-like structure containing the predicted labels from the classification model.\n- `model_name`: A string representing the name of the classification model.\n- `output_file`: An optional string specifying the filename to save the output image (default is 'output.png').\n\nOutput Format:\n- The function does not return any value. Instead, it saves a confusion matrix heatmap as an image file to the specified output path.\n\nInput:\n```python\ny_test = np.array([0, 1, 0, 1, 2, 2, 1, 0, 2, 1])\ny_pred = np.array([0, 1, 0, 2, 2, 1, 1, 0, 2, 0])\nmodel_name = \"Model_42\"\n```\n\nOutput:\n```python\n# Confusion Matrix:\n# [[3 0 0]\n#  [1 3 1]\n#  [0 2 2]]\n\n# F1 Score (avg = micro): 0.60\n# F1 Score (avg = macro): 0.57\n```", "ground_truth_code": "import seaborn as sns\nimport pandas as pd\nimport numpy as np\nimport matplotlib.pyplot as plt\nfrom sklearn.metrics import confusion_matrix, f1_score\n\n# main code\ndef draw_confusion_matrix(y_test, y_pred, model_name, output_file='output.png'):\n    sns.set_style('darkgrid')\n\n    cm = confusion_matrix(y_test, y_pred)\n    unique_labels = np.unique(y_test).tolist()\n    cm_df = pd.DataFrame(cm, index=unique_labels, columns=unique_labels)\n\n    plt.figure(figsize=(8, 6))\n    ax = sns.heatmap(cm_df, center=0, cmap=sns.diverging_palette(220, 15, as_cmap=True), annot=True, fmt='g')\n    ax.set_title(f'{model_name} \\nF1 Score(avg = micro): {f1_score(y_test, y_pred, average=\"micro\"):.2f} \\n'\n                 f'F1 Score(avg = macro): {f1_score(y_test, y_pred, average=\"macro\"):.2f}', fontsize=13)\n    ax.set_ylabel('True label', fontsize=13)\n    ax.set_xlabel('Predicted label', fontsize=13)\n\n    plt.savefig(output_file)\n    plt.close()", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_classes = random.randint(2, 10)\n        labels = list(range(num_classes))\n        num_samples = random.randint(50, 500)\n        y_test = np.random.choice(labels, size=num_samples)\n        y_pred = np.random.choice(labels, size=num_samples)\n        model_name = f\"Model_{random.randint(1, 100)}\"\n\n        test_cases.append((y_test, y_pred, model_name))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_0", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the Intersection over Union (IoU) for pairs of bounding boxes. The function will take two sets of bounding boxes and return a matrix representing the IoU for each pair of boxes from the two sets.\n\nFunction signature:\n```python\ndef overlaps_graph(boxes1, boxes2):\n```\n\nConstants used in the main code:\n- The constant value `4` is used to represent the number of coordinates for each bounding box (y1, x1, y2, x2).\n\nInput format:\n- `boxes1`: A tensor of shape (N, 4) where N is the number of bounding boxes in the first set.\n- `boxes2`: A tensor of shape (M, 4) where M is the number of bounding boxes in the second set.\n\nOutput format:\n- A tensor of shape (N, M) where each element (i, j) represents the IoU between the i-th box in `boxes1` and the j-th box in `boxes2`.\n\nInput:\n```python\nboxes1 = np.array([[0.1, 0.1, 0.4, 0.4], \n                   [0.2, 0.2, 0.5, 0.5]], dtype=np.float32)\n\nboxes2 = np.array([[0.3, 0.3, 0.6, 0.6], \n                   [0.0, 0.0, 0.2, 0.2]], dtype=np.float32)\n```\n\nOutput:\n```python\n<tf.Tensor: shape=(2, 2), dtype=float32, numpy=\narray([[0.05882352, 0.08333333],\n       [0.2857142 , 0.        ]], dtype=float32)>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef overlaps_graph(boxes1, boxes2):\n    b1 = tf.reshape(tf.tile(tf.expand_dims(boxes1, 1), [1, 1, tf.shape(boxes2)[0]]), [-1, 4])\n    b2 = tf.tile(boxes2, [tf.shape(boxes1)[0], 1])\n    (b1_y1, b1_x1, b1_y2, b1_x2) = tf.split(b1, 4, axis=1)\n    (b2_y1, b2_x1, b2_y2, b2_x2) = tf.split(b2, 4, axis=1)\n    y1 = tf.maximum(b1_y1, b2_y1)\n    x1 = tf.maximum(b1_x1, b2_x1)\n    y2 = tf.minimum(b1_y2, b2_y2)\n    x2 = tf.minimum(b1_x2, b2_x2)\n    intersection = tf.maximum(x2 - x1, 0) * tf.maximum(y2 - y1, 0)\n    b1_area = (b1_y2 - b1_y1) * (b1_x2 - b1_x1)\n    b2_area = (b2_y2 - b2_y1) * (b2_x2 - b2_x1)\n    union = b1_area + b2_area - intersection\n    iou = intersection / union\n    overlaps = tf.reshape(iou, [tf.shape(boxes1)[0], tf.shape(boxes2)[0]])\n    return overlaps", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_boxes1 = np.random.randint(1, 50)\n        num_boxes2 = np.random.randint(1, 50)\n\n        boxes1 = np.random.rand(num_boxes1, 4).astype(np.float32)\n        boxes2 = np.random.rand(num_boxes2, 4).astype(np.float32)\n        boxes1[:, :2], boxes1[:, 2:] = np.minimum(boxes1[:, :2], boxes1[:, 2:]), np.maximum(boxes1[:, :2],\n                                                                                            boxes1[:, 2:])\n        boxes2[:, :2], boxes2[:, 2:] = np.minimum(boxes2[:, :2], boxes2[:, 2:]), np.maximum(boxes2[:, :2],\n                                                                                            boxes2[:, 2:])\n\n        test_cases.append((boxes1, boxes2))\n\n    return test_cases"}
{"problem_id": "tensorflow_1", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a tensor of bounding box coordinates by removing any boxes that are entirely composed of zeros. The function should return a tensor of the remaining boxes and a boolean tensor indicating which boxes were non-zero.\n\nFunction signature:\n```python\ndef trim_zeros_graph(boxes):\n```\n\nConstant used in the main code:\n- There are no constants explicitly defined in the main code.\n\nInput format:\n- The input to the function is a 2D tensor (matrix) where each row represents a bounding box with its coordinates.\n\nOutput format:\n- The output of the function is a tuple containing:\n  1. A 2D tensor of the remaining bounding boxes after trimming the zeros.\n  2. A 1D boolean tensor indicating which original boxes were non-zero.\n\nInput:\n```python\narray([[ 0. ,  0. ,  0. ,  0. ,  0. ],\n       [ 1.2, -0.5,  3.4,  0. ,  0. ],\n       [ 0. ,  0. ,  0. ,  0. ,  0. ],\n       [ 2.1,  0. , -1.3,  4.5,  0. ]], dtype=float32)\n```\n\nOutput:\n```python\n(tf.Tensor(\n[[ 1.2 -0.5  3.4  0.   0. ]\n [ 2.1  0.  -1.3  4.5  0. ]], shape=(2, 5), dtype=float32),\n\ntf.Tensor([False  True False  True], shape=(4,), dtype=bool))\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef trim_zeros_graph(boxes):\n    non_zeros = tf.cast(tf.reduce_sum(tf.abs(boxes), axis=1), tf.bool)\n    boxes = tf.boolean_mask(boxes, non_zeros, name='trim_zeros')\n    return (boxes, non_zeros)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 11)\n        num_features = np.random.randint(5, 16)\n        boxes = np.random.randn(batch_size, num_features).astype(np.float32)\n        if np.random.rand() > 0.5:\n            zero_indices = np.random.choice(batch_size * num_features, size=5, replace=False)\n            boxes.ravel()[zero_indices] = 0\n        test_cases.append(boxes)\n\n    return test_cases"}
{"problem_id": "tensorflow_2", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that expands the dimensions of a given tensor at specified axes using TensorFlow. The function should allow for multiple axes to be specified, and it should handle the axes in a sorted order to ensure that the dimensions are expanded correctly without affecting the positions of previously expanded dimensions.\n\nFunction signature:\n```python\ndef expand_multiple_dims(x, axes, name='expand_multiple_dims'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the string `'expand_multiple_dims'`, which serves as the default name for the operation within the TensorFlow name scope.\n\nInput format:\n- The input to the function consists of a tensor `x` and a list of integers `axes`.\n\nOutput format:\n- The output of the function is a tensor with additional dimensions added at the specified axes.\n\nInput:\n```python\ntensor = tf.constant([[1, 2], [3, 4]])  # Shape: (2, 2)\naxes = [0, 1]  # Expanding both dimensions\n```\n\nOutput:\n```python\n<tf.Tensor: shape=(1, 1, 2, 2), dtype=int32, numpy=\narray([[[[1, 2],\n         [3, 4]]]], dtype=int32)>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef expand_multiple_dims(x, axes, name='expand_multiple_dims'):\n    with tf.name_scope(name):\n        for i in sorted(axes):\n            x = tf.expand_dims(x, axis=i, name='expand_axis_%i' % i)\n        return x", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_dims = np.random.randint(1, 5)\n        shape = tuple(np.random.randint(1, 6, size=num_dims))\n        tensor = tf.random.normal(shape)\n\n        max_axes = num_dims\n        num_axes_to_expand = np.random.randint(1, max_axes + 1)\n        axes = np.random.choice(range(max_axes), num_axes_to_expand, replace=False)\n\n        test_cases.append((tensor, axes))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_3", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes angular symmetry features for a set of atoms based on their coordinates and types. The function will utilize TensorFlow to perform tensor operations efficiently.\n\nFunction Signature:\n```python\ndef angular_symmetry(atom_matrix, A_eta, A_thetas, A_zeta, angular_feature_size, max_atom_types, A_Rc, A_Rs):\n```\n\nConstants Used:\n- The constant `2.0` is used in the computation of the final result.\n\nInput Format:\n- `atom_matrix`: A 2D tensor where each row represents an atom with its type and coordinates.\n- `A_eta`: A scalar parameter for the exponential decay.\n- `A_thetas`: A 1D tensor of angles used in the cosine transformation.\n- `A_zeta`: A scalar parameter for the power transformation.\n- `angular_feature_size`: An integer representing the size of the output feature vector.\n- `max_atom_types`: An integer representing the maximum number of different atom types.\n- `A_Rc`: A scalar cutoff distance for the distance function.\n- `A_Rs`: A 1D tensor of reference distances.\n\nOutput Format:\n- The function returns a 2D tensor of shape (num_atoms, angular_feature_size) containing the computed angular symmetry features for each atom.\n\n**Input:**\n```python\n(array([[ 1.        , -8.54148085, -8.13974928,  7.15317689],\n       [ 2.        , -1.85668719,  2.6440549 ,  5.78874674],\n       [ 0.        ,  5.53973427,  6.47562589,  9.12491509],\n       [ 0.        , -3.29637551,  7.12998497, -2.95103838],\n       [ 2.        , -6.67187449,  5.89646775, -8.03600526],\n       [ 3.        , -6.13996209,  0.78025822,  5.97181298],\n       [ 3.        , -4.40866307, -2.64863083, -6.97771381],\n       [ 3.        , -6.39229521,  0.3689799 , -6.35571709],\n       [ 3.        , -0.84254419, -6.00627443,  5.26691325],\n       [ 1.        ,  2.35048021, -7.1287495 ,  5.62921059],\n       [ 3.        ,  5.2201718 , -6.21056943,  3.97644326],\n       [ 2.        , -7.08709899,  0.23295962,  7.18240385],\n       [ 0.        , -7.80640969,  0.20799318,  6.24189795],\n       [ 3.        , -3.29958431,  1.38323099, -9.36853841],\n       [ 0.        ,  8.08960867, -8.02100729,  8.43570342]]), 1.773675379169744, \n array([0.10071892, 0.56989155, 1.31138712, 0.24191923]), \n 3.067554119292594, \n 80, \n 4, \n 10.181561683297922, \n array([1.33275189, 1.87892951]))\n```\n\n**Output:**\n```python\n<tf.Tensor: shape=(15, 80), dtype=float32, numpy=\narray([[0.0000000e+00, 0.0000000e+00, 0.0000000e+00, ..., 1.7177648e-33,\n        5.3137267e-34, 2.1139212e-33],\n       [1.2914605e-21, 1.0111052e-21, 3.1277487e-22, ..., 4.7056767e-07,\n        1.4556521e-07, 5.7909148e-07],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, ..., 0.0000000e+00,\n        0.0000000e+00, 0.0000000e+00],\n       ...,\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, ..., 1.3112129e+00,\n        4.0561002e-01, 1.6136088e+00],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, ..., 7.2061157e-06,\n        3.2856431e-06, 8.0681457e-06],\n       [0.0000000e+00, 0.0000000e+00, 0.0000000e+00, ..., 2.3053449e-28,\n        1.6350232e-28, 2.0431156e-28]], dtype=float32)>\n```", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\n\n# main code\ndef angular_symmetry(atom_matrix, A_eta, A_thetas, A_zeta, angular_feature_size, max_atom_types, A_Rc, A_Rs):\n    num_atoms = tf.shape(atom_matrix)[0]\n    atom_idxs = tf.range(num_atoms)\n    atom_types = tf.cast(atom_matrix[:, 0], dtype=tf.int32)\n    atom_coords = atom_matrix[:, 1:]\n    type_groups_idxs = tf.dynamic_partition(atom_idxs, atom_types, max_atom_types)\n    angular_features = []\n    for type_a in range(max_atom_types):\n        j_idxs = type_groups_idxs[type_a]\n        for type_b in range(type_a, max_atom_types):\n            k_idxs = type_groups_idxs[type_b]\n            tile_a = tf.tile(tf.expand_dims(j_idxs, 1), [1, tf.shape(k_idxs)[0]])\n            tile_a = tf.expand_dims(tile_a, 2)\n            tile_b = tf.tile(tf.expand_dims(k_idxs, 0), [tf.shape(j_idxs)[0], 1])\n            tile_b = tf.expand_dims(tile_b, 2)\n            cartesian_product = tf.concat([tile_a, tile_b], axis=2)\n            group_coords = tf.nn.embedding_lookup(atom_coords, cartesian_product)\n            dist_vec = tf.reshape(atom_coords, (-1, 1, 1, 1, 3))\n            deltas = group_coords - dist_vec\n            delta_ij = deltas[:, :, :, 0, :]\n            delta_ik = deltas[:, :, :, 1, :]\n            denom = tf.multiply(tf.norm(delta_ij, axis=-1), tf.norm(delta_ik, axis=-1))\n            dot = tf.reduce_sum(tf.multiply(delta_ij, delta_ik), axis=-1)\n            theta_ijk = tf.acos(dot / denom)\n            lhs = tf.pow(1 + tf.cos(tf.expand_dims(theta_ijk, -1) - tf.reshape(A_thetas, (1, 1, 1, -1))), A_zeta)\n            lhs = tf.where(tf.math.is_nan(lhs) | tf.math.is_inf(lhs), tf.zeros_like(lhs), lhs)\n            R_ij_ik = tf.norm(deltas, axis=-1)\n            f_C_true = 0.5 * tf.cos(np.pi * R_ij_ik / A_Rc) + 0.5\n            f_C_flags = tf.nn.relu(tf.sign(A_Rc - R_ij_ik))\n            f_C_R_ij_ik = f_C_true * f_C_flags\n            fCRi_fCRj = tf.multiply(f_C_R_ij_ik[:, :, :, 0], f_C_R_ij_ik[:, :, :, 1])\n            R_ij = R_ij_ik[:, :, :, 0]\n            R_ik = R_ij_ik[:, :, :, 1]\n            inner = tf.expand_dims((R_ij + R_ik) / 2.0, -1) - tf.reshape(A_Rs, (1, 1, 1, -1))\n            rhs = tf.exp(-A_eta * tf.pow(inner, 2)) * tf.expand_dims(fCRi_fCRj, -1)\n            lhs = tf.expand_dims(lhs, axis=3)\n            rhs = tf.expand_dims(rhs, axis=4)\n            summand = tf.multiply(lhs, rhs)\n            summand = tf.cast(summand, dtype=tf.float32)\n            result = tf.multiply(\n                tf.pow(tf.constant(2.0, dtype=tf.float32), 1 - tf.cast(A_zeta, tf.float32)),\n                tf.reduce_sum(summand, axis=[1, 2])\n            )\n            result = tf.reshape(result, (num_atoms, len(A_thetas) * len(A_Rs)))\n            angular_features.append(result)\n    if angular_features:\n        angular_features = tf.concat(angular_features, axis=1)\n        angular_features = tf.reshape(angular_features, (num_atoms, angular_feature_size))\n    else:\n        angular_features = tf.zeros((num_atoms, angular_feature_size()))\n    return angular_features", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def angular_feature_size(A_Rs, max_atom_types, A_thetas):\n        return np.int32(len(A_Rs) * len(A_thetas) * max_atom_types * (max_atom_types + 1) / 2)\n\n    test_cases = []\n\n    for _ in range(n):\n        num_atoms = np.random.randint(5, 20)\n        max_atom_types = np.random.randint(2, 6)\n        atom_matrix = np.hstack([\n            np.random.randint(0, max_atom_types, size=(num_atoms, 1)),\n            np.random.uniform(-10, 10, size=(num_atoms, 3))\n        ])\n        A_eta = np.random.uniform(0.1, 5.0)\n        A_thetas = np.random.uniform(0, np.pi, size=np.random.randint(2, 5))\n        A_zeta = np.random.uniform(1, 10)\n        A_Rc = np.random.uniform(5, 15)\n        A_Rs = np.random.uniform(0, A_Rc, size=np.random.randint(2, 5))\n        feature_size = angular_feature_size(A_Rs, max_atom_types, A_thetas)\n        test_cases.append((atom_matrix, A_eta, A_thetas, A_zeta, feature_size, max_atom_types, A_Rc, A_Rs))\n\n    return test_cases"}
{"problem_id": "tensorflow_4", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the cosine similarity between vectors based on specified indices. The function will utilize TensorFlow to perform the necessary operations.\n\nFunction signature:\n```python\ndef _cosine_similarity_from_indices(vectors: tf.Tensor, indices: tf.Tensor) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `-1`, which is used to specify the last axis in various TensorFlow operations.\n\nInput format:\n- `vectors`: A TensorFlow tensor of shape (N, D), where N is the number of vectors and D is the dimensionality of each vector.\n- `indices`: A TensorFlow tensor of shape (M,), where M is the number of indices to gather from the `vectors`.\n\nOutput format:\n- The function returns a TensorFlow tensor of shape (M,), representing the cosine similarity values for the vectors specified by the indices.\n\n```python\n# Input\nvectors = tf.constant([[0.1, 0.2, 0.3], \n                       [0.4, 0.5, 0.6], \n                       [0.7, 0.8, 0.9]], dtype=tf.float32)\nindices = tf.constant([0, 2], dtype=tf.int32)\n\n# Output\n<tf.Tensor: shape=(), dtype=float32, numpy=0.3010616>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef _cosine_similarity_from_indices(vectors, indices):\n    vectors = tf.gather_nd(vectors, tf.expand_dims(indices, axis=-1))\n    vectors = tf.math.l2_normalize(vectors, axis=-1)\n    return tf.reduce_sum(tf.reduce_prod(vectors, axis=1), axis=-1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(2, 20)\n        feature_dim = np.random.randint(2, 50)\n        vectors = tf.random.normal((batch_size, feature_dim))\n        indices = tf.random.uniform(shape=(2,), minval=0, maxval=batch_size, dtype=tf.int32)\n\n        test_cases.append((vectors, indices))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_5", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the Cartesian product of two tensors. The function should take two input tensors and return a new tensor that represents the Cartesian product of the two input tensors.\n\nFunction Signature:\n```python\ndef cartesian_product(a: tf.Tensor, b: tf.Tensor) -> tf.Tensor:\n```\n\nConstant Used:\n- The constant used in the main code is `1`, which is used to specify the dimension along which to expand the tensors.\n\nInput Format:\n- The function accepts two tensors `a` and `b` as input parameters.\n\nOutput Format:\n- The function returns a tensor that represents the Cartesian product of the input tensors `a` and `b`.\n\nInput:\n```python\na = tf.constant([[1.0, 2.0], [3.0, 4.0]])\nb = tf.constant([[5.0, 6.0], [7.0, 8.0]])\n```\n\nOutput:\n```python\n<tf.Tensor: shape=(2, 2, 4), dtype=float32, numpy=\narray([[[1., 2., 5., 6.],\n        [1., 2., 7., 8.]],\n       [[3., 4., 5., 6.],\n        [3., 4., 7., 8.]]], dtype=float32)>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef cartesian_product(a, b):\n    tile_a = tf.tile(tf.expand_dims(a, 1), [1, tf.shape(b)[0], 1])\n    tile_b = tf.tile(tf.expand_dims(b, 0), [tf.shape(a)[0], 1, 1])\n    cartesian_product = tf.concat([tile_a, tile_b], axis=2)\n    return cartesian_product", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a_shape = (np.random.randint(1, 10), np.random.randint(1, 5))\n        b_shape = (np.random.randint(1, 10), np.random.randint(1, 5))\n        a = tf.random.uniform(a_shape, dtype=tf.float32)\n        b = tf.random.uniform(b_shape, dtype=tf.float32)\n        test_cases.append((a, b))\n    return test_cases"}
{"problem_id": "tensorflow_6", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the loss for a Region Proposal Network (RPN) in a deep learning model. The function will compare the predicted bounding boxes from the RPN with the target bounding boxes and compute a loss value based on the differences between them.\n\nFunction signature:\n```python\ndef rpn_bbox_loss_graph(config, target_bbox, rpn_match, rpn_bbox):\n```\n\nIn this function, the following constant is used:\n- `1.0`: This constant is used to determine the threshold for calculating the loss based on the differences between the predicted and target bounding boxes.\n\nInput format:\n- `config`: An object containing configuration parameters, including `IMAGES_PER_GPU`.\n- `target_bbox`: A tensor containing the target bounding boxes.\n- `rpn_match`: A tensor indicating the match status of the RPN predictions.\n- `rpn_bbox`: A tensor containing the predicted bounding boxes from the RPN.\n\nOutput format:\n- The function returns a scalar tensor representing the mean loss value calculated from the differences between the target and predicted bounding boxes.\n\nInput:\n```python\nclass Config:\n    IMAGES_PER_GPU = 3\n    RPN_TRAIN_ANCHORS_PER_IMAGE = 5\n\nconfig = Config()\ntarget_bbox = tf.constant([[[0.1, 0.2, 0.3, 0.4],\n                             [0.5, 0.6, 0.7, 0.8],\n                             [0.9, 1.0, 1.1, 1.2],\n                             [1.3, 1.4, 1.5, 1.6],\n                             [1.7, 1.8, 1.9, 2.0]],\n\n                            [[0.2, 0.3, 0.4, 0.5],\n                             [0.6, 0.7, 0.8, 0.9],\n                             [1.0, 1.1, 1.2, 1.3],\n                             [1.4, 1.5, 1.6, 1.7],\n                             [1.8, 1.9, 2.0, 2.1]],\n\n                            [[0.3, 0.4, 0.5, 0.6],\n                             [0.7, 0.8, 0.9, 1.0],\n                             [1.1, 1.2, 1.3, 1.4],\n                             [1.5, 1.6, 1.7, 1.8],\n                             [1.9, 2.0, 2.1, 2.2]]], dtype=tf.float32)\n\nrpn_match = tf.constant([[[1], [1], [0], [0], [0]],\n                          [[0], [1], [1], [0], [0]],\n                          [[0], [0], [1], [1], [1]]], dtype=tf.int32)\n\nrpn_bbox = tf.constant([[[0.0, 0.1, 0.2, 0.3],\n                          [0.4, 0.5, 0.6, 0.7],\n                          [0.8, 0.9, 1.0, 1.1],\n                          [1.2, 1.3, 1.4, 1.5],\n                          [1.6, 1.7, 1.8, 1.9]],\n\n                         [[0.1, 0.2, 0.3, 0.4],\n                          [0.5, 0.6, 0.7, 0.8],\n                          [0.9, 1.0, 1.1, 1.2],\n                          [1.3, 1.4, 1.5, 1.6],\n                          [1.7, 1.8, 1.9, 2.0]],\n\n                         [[0.2, 0.3, 0.4, 0.5],\n                          [0.6, 0.7, 0.8, 0.9],\n                          [1.0, 1.1, 1.2, 1.3],\n                          [1.4, 1.5, 1.6, 1.7],\n                          [1.8, 1.9, 2.0, 2.1]]], dtype=tf.float32)\n```\n\nOutput:\n```python\n<tf.Tensor: shape=(), dtype=float32, numpy=0.11928571>\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef batch_pack_graph(x, counts, num_rows):\n    outputs = [x[i, :counts[i]] for i in range(num_rows)]\n    return tf.concat(outputs, axis=0) if outputs else tf.constant([], dtype=x.dtype)\n\n# main code\ndef rpn_bbox_loss_graph(config, target_bbox, rpn_match, rpn_bbox):\n    K = tf.keras.backend\n    rpn_match = K.squeeze(rpn_match, -1)\n    indices = tf.where(K.equal(rpn_match, 1))\n    rpn_bbox = tf.gather_nd(rpn_bbox, indices)\n    batch_counts = K.sum(K.cast(K.equal(rpn_match, 1), tf.int32), axis=1)\n    target_bbox = batch_pack_graph(target_bbox, batch_counts, config.IMAGES_PER_GPU)\n\n    diff = K.abs(target_bbox - rpn_bbox)\n    less_than_one = K.cast(K.less(diff, 1.0), 'float32')\n    loss = less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)\n\n    return K.mean(loss) if tf.size(loss) > 0 else tf.constant(0.0)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        class Config:\n            IMAGES_PER_GPU = np.random.randint(1, 5)\n            RPN_TRAIN_ANCHORS_PER_IMAGE = np.random.randint(2, 10)\n        config = Config()\n        batch_size = config.IMAGES_PER_GPU\n        max_anchors = config.RPN_TRAIN_ANCHORS_PER_IMAGE\n        target_bbox = tf.random.normal((batch_size, max_anchors, 4))\n        rpn_match = tf.random.uniform((batch_size, max_anchors, 1), minval=-1, maxval=2,\n                                      dtype=tf.int32)\n        rpn_bbox = tf.random.normal((batch_size, max_anchors, 4))\n\n        test_cases.append((config, target_bbox, rpn_match, rpn_bbox))\n\n    return test_cases"}
{"problem_id": "tensorflow_7", "library": "tensorflow", "code_problem": "```python\ndef prepare_data_eval(data, is_target, source_num_modalities, target_num_modalities):\n```\n\nIn this code, the function `prepare_data_eval` is designed to process a dataset consisting of multiple modalities and prepare it for evaluation. The function takes in four parameters: `data`, `is_target`, `source_num_modalities`, and `target_num_modalities`. \n\n### Constant Used:\n- The constant used in the main code is the `axis` parameter in the `tf.concat` function, which is set to `0` to concatenate the tensors along the first dimension.\n\n### Input and Output Format:\n- **Input Format**: The input to the function is a tuple containing:\n  - A list of tensors for modalities (`xs`).\n  - A tensor for target values (`y`).\n  - A tensor for domain information (`domain`).\n  - A tensor for example identifiers (`example_ids`).\n  - A boolean indicating if the data is for the target (`is_target`).\n  - An integer for the number of source modalities (`source_num_modalities`).\n  - An integer for the number of target modalities (`target_num_modalities`).\n\n- **Output Format**: The output is a tuple containing:\n  - A list of concatenated tensors for each modality (`xs`).\n  - A concatenated tensor for target values (`y`).\n  - A concatenated tensor for domain information (`domain`).\n  - A value for auxiliary data (set to `None`).\n\n**Input:**\n```python\ndata = ([[<tf.Tensor: shape=(2, 5), dtype=float32, numpy=\narray([[0.36410916, 0.9389547 , 0.9813427 , 0.5490482 , 0.10906184],\n       [0.75810957, 0.9220686 , 0.30004656, 0.7241292 , 0.2295667 ]],\n      dtype=float32)>]], [<tf.Tensor: shape=(2, 4), dtype=float32, numpy=\narray([[0.63808846, 0.3541646 , 0.85782075, 0.04219902],\n       [0.23113751, 0.71441984, 0.7581872 , 0.76047456]], dtype=float32)>, <tf.Tensor: shape=(2, 4), dtype=float32, numpy=\narray([[0.0904696 , 0.4795314 , 0.7437464 , 0.7877804 ],\n       [0.09648693, 0.27351332, 0.89230037, 0.00858462]], dtype=float32)>], [<tf.Tensor: shape=(2, 1), dtype=float32, numpy=\narray([[0.98076737],\n       [0.97141576]], dtype=float32)>], <tf.Tensor: shape=(2,), dtype=string, numpy=array([b'id_0', b'id_1'], dtype=object)>)\nis_target = True\nsource_num_modalities = 2\ntarget_num_modalities = 1\n```\n\n**Output:**\n```python\n[<tf.Tensor: shape=(2, 5), dtype=float32, numpy=\narray([[0.36410916, 0.9389547 , 0.9813427 , 0.5490482 , 0.10906184],\n       [0.75810957, 0.9220686 , 0.30004656, 0.7241292 , 0.2295667 ]],\n      dtype=float32)>]\n\ntf.Tensor(\n[[0.63808846 0.3541646  0.85782075 0.04219902]\n [0.23113751 0.71441984 0.7581872  0.76047456]\n [0.0904696  0.4795314  0.7437464  0.7877804 ]\n [0.09648693 0.27351332 0.89230037 0.00858462]], shape=(4, 4), dtype=float32)\n\ntf.Tensor(\n[[0.98076737]\n [0.97141576]], shape=(2, 1), dtype=float32)\n\nNone\n```\n", "ground_truth_code": "import tensorflow as tf\n\n\ndef pad_tensor_to_max_dim(tensors):\n    max_dim = max(t.shape[1] for t in tensors)\n    return [tf.pad(t, [[0, 0], [0, max_dim - t.shape[1]]]) for t in tensors]\n\n# main code\ndef prepare_data_eval(data, is_target, source_num_modalities, target_num_modalities):\n    xs, y, domain, example_ids = data\n    num_modalities = target_num_modalities if is_target else source_num_modalities\n\n    xs = [\n        tf.concat(pad_tensor_to_max_dim([x[i] for x in xs]), axis=0)\n        for i in range(num_modalities)\n    ]\n\n    y = tf.concat(pad_tensor_to_max_dim(y), axis=0)\n\n    domain = tf.concat(pad_tensor_to_max_dim(domain), axis=0)\n\n    auxiliary_data = None\n    return xs, y, domain, auxiliary_data\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        source_num_modalities = np.random.randint(1, 5)\n        target_num_modalities = np.random.randint(1, 5)\n        is_target = np.random.choice([True, False])\n        num_modalities = target_num_modalities if is_target else source_num_modalities\n\n        feature_dim_xs = np.random.randint(5, 10)\n        feature_dim_y = np.random.randint(1, 5)\n        feature_dim_domain = 1\n\n        xs = [\n            [tf.random.uniform((batch_size, feature_dim_xs)) for _ in range(num_modalities)]\n            for _ in range(np.random.randint(1, 4))\n        ]\n\n        y = [tf.random.uniform((batch_size, feature_dim_y)) for _ in range(np.random.randint(1, 3))]\n        domain = [tf.random.uniform((batch_size, feature_dim_domain)) for _ in range(np.random.randint(1, 3))]\n        example_ids = tf.convert_to_tensor([f\"id_{i}\" for i in range(batch_size)], dtype=tf.string)\n\n        data = (xs, y, domain, example_ids)\n        test_cases.append((data, is_target, source_num_modalities, target_num_modalities))\n\n    return test_cases"}
{"problem_id": "tensorflow_8", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes a specific transformation of two input tensors using TensorFlow. The function signature is as follows:\n\n```python\ndef tf_product(a, b):\n```\n\nIn this function, the constant used is the shape of the tensor `b`, specifically `tf.shape(b)[0]`, which represents the number of rows in tensor `b`.\n\nInput format:\n- The function takes two input tensors `a` and `b`, where `a` is a 2D tensor and `b` is also a 2D tensor.\n\nOutput format:\n- The function returns a 2D tensor that is the result of the concatenation of the transformed tensors based on the logic described above.\n\nInput:\n```python\na = tf.convert_to_tensor([[1.0], [2.0]], dtype=tf.float32)  # Shape (2, 1)\nb = tf.convert_to_tensor([[3.0, 4.0], [5.0, 6.0]], dtype=tf.float32)  # Shape (2, 2)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[1. 3. 4.]\n [1. 5. 6.]\n [2. 3. 4.]\n [2. 5. 6.]], shape=(4, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tf_product(a, b):\n    tile_a = tf.tile(a, [1, tf.shape(b)[0]])\n    tile_a = tf.expand_dims(tile_a, 2)\n    tile_a = tf.reshape(tile_a, [-1, 1])\n    b = tf.tile(b, [tf.shape(a)[0], 1])\n    b = tf.concat([tile_a, b], axis=1)\n    return b", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a_rows = np.random.randint(1, 10)\n        b_rows = np.random.randint(1, 10)\n        a_cols = 1\n        b_cols = np.random.randint(1, 10)\n\n        a = tf.convert_to_tensor(np.random.randn(a_rows, a_cols), dtype=tf.float32)\n        b = tf.convert_to_tensor(np.random.randn(b_rows, b_cols), dtype=tf.float32)\n\n        test_cases.append((a, b))\n\n    return test_cases"}
{"problem_id": "tensorflow_9", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes input data through a series of transformations and manipulations, specifically designed for use in a machine learning context. The function signature is as follows:\n\n```python\ndef call(x, output_feature_transform, masked_coordinate_offset, feature_dropout, input_feature_transform,\n         collect_neighbours, also_coordinates, n_dimensions, input_spatial_transform):\n```\n\n### Constants Used:\n- `masked_coordinate_offset`: This constant is used to replace certain values in the coordinates when a mask is applied.\n\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `x`: Input data (can be a list).\n  - `output_feature_transform`: A function to transform the output features.\n  - `masked_coordinate_offset`: A constant used for masking.\n  - `feature_dropout`: A float representing the dropout rate.\n  - `input_feature_transform`: A function to transform the input features.\n  - `collect_neighbours`: A function to collect neighboring features.\n  - `also_coordinates`: A boolean indicating whether to return coordinates.\n  - `n_dimensions`: An integer representing the number of dimensions for coordinates.\n  - `input_spatial_transform`: A function to transform the spatial coordinates.\n\n- **Output**: The function returns either:\n  - The transformed output features, or\n  - A list containing the transformed output features and the coordinates, depending on the `also_coordinates` parameter.\n\n**Input:**\n```python\n# Test case input\nx = [tf.random.normal((3, 10, 5)), tf.random.uniform((3, 10, 1), minval=0, maxval=2, dtype=tf.int32)]\noutput_feature_transform = lambda x: keras.layers.Dense(5)(x)\nmasked_coordinate_offset = 0.5\nfeature_dropout = 0.3\ninput_feature_transform = lambda x: keras.layers.Dense(5)(x)\ndef collect_neighbours(coordinates, features):\n    return tf.reduce_mean(features, axis=1, keepdims=True)\nalso_coordinates = True\nn_dimensions = 3\ninput_spatial_transform = lambda x: x[:, :, :n_dimensions]\n```\n\n**Output:**\n```python\n# Expected output\noutput, coordinates = call(x, output_feature_transform, masked_coordinate_offset, feature_dropout,\n                           input_feature_transform, collect_neighbours, also_coordinates, n_dimensions,\n                           input_spatial_transform)\n```", "ground_truth_code": "import tensorflow as tf\nimport keras\n\n# main code\ndef call(x, output_feature_transform, masked_coordinate_offset, feature_dropout, input_feature_transform,\n         collect_neighbours, also_coordinates, n_dimensions, input_spatial_transform):\n    mask = None\n    if masked_coordinate_offset is not None and isinstance(x, list):\n        mask = x[1]\n        x = x[0]\n\n    features = input_feature_transform(x)\n    if 0 < feature_dropout < 1:\n        features = keras.layers.Dropout(feature_dropout)(features)\n\n    coordinates = input_spatial_transform(x) if input_spatial_transform else x[:, :, :n_dimensions]\n\n    if masked_coordinate_offset is not None and mask is not None:\n        sel_mask = tf.tile(mask, [1, 1, tf.shape(coordinates)[2]])\n        coordinates = tf.where(sel_mask > 0.0, coordinates, tf.zeros_like(coordinates) - masked_coordinate_offset)\n\n    collected_neighbours = collect_neighbours(coordinates, features)\n    collected_neighbours = tf.tile(collected_neighbours, [1, tf.shape(x)[1], 1])  # Broadcast along num_points\n    updated_features = tf.concat([x, collected_neighbours], axis=-1)\n\n    output = output_feature_transform(updated_features)\n\n    if masked_coordinate_offset is not None and mask is not None:\n        output *= mask\n\n    return [output, coordinates] if also_coordinates else output", "test_script": "import tensorflow as tf\nimport keras\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)  # Random batch size between 1 and 10\n        num_points = np.random.randint(5, 20)  # Random number of points between 5 and 20\n        n_dimensions = np.random.randint(2, 5)  # Random number of dimensions between 2 and 5\n        feature_dim = np.random.randint(3, 8)  # Random feature dimension between 3 and 8\n        feature_dropout = np.random.uniform(0, 1)  # Random dropout value between 0 and 1\n        masked_coordinate_offset = np.random.uniform(0, 1) if np.random.rand() > 0.5 else None\n        also_coordinates = np.random.choice([True, False])\n\n        x = tf.random.normal((batch_size, num_points, feature_dim))\n        mask = None\n        if masked_coordinate_offset is not None:\n            mask = tf.random.uniform((batch_size, num_points, 1), minval=0, maxval=2, dtype=tf.int32)\n            mask = tf.cast(mask, tf.float32)\n            x = [x, mask]\n\n        def input_feature_transform(x):\n            return keras.layers.Dense(feature_dim)(x)\n\n        def collect_neighbours(coordinates, features):\n            return tf.reduce_mean(features, axis=1, keepdims=True)\n\n        def output_feature_transform(x):\n            return keras.layers.Dense(feature_dim)(x)\n\n        def input_spatial_transform(x):\n            return x[:, :, :n_dimensions]\n\n        test_cases.append((x, output_feature_transform, masked_coordinate_offset, feature_dropout,\n                           input_feature_transform, collect_neighbours, also_coordinates, n_dimensions,\n                           input_spatial_transform))\n\n    return test_cases"}
{"problem_id": "tensorflow_10", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that retrieves the next element from a TensorFlow dataset. The function should handle both eager execution mode and graph execution mode. The function signature is as follows:\n\n```python\ndef next_dataset_element(test_case, dataset):\n```\n\nIn this function, the following constant is used:\n- `tf.executing_eagerly()`: This constant checks if TensorFlow is currently in eager execution mode.\n\nInput format:\n- The function takes two inputs: `test_case`, which is an object for evaluating the dataset element, and `dataset`, which is a TensorFlow dataset.\n\nOutput format:\n- The function returns the next element from the dataset, evaluated according to the provided `test_case`.\n\n```python\n# Input\ndata = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=np.float32)\ndataset = tf.data.Dataset.from_tensor_slices(data).batch(2)\n\n# Output\noutput = tf.Tensor(\n[[0.1 0.2 0.3]\n [0.4 0.5 0.6]], shape=(2, 3), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef next_dataset_element(test_case, dataset):\n    if tf.executing_eagerly():\n        itr = iter(dataset)\n        return next(itr)\n    get_next = tf.compat.v1.data.make_one_shot_iterator(dataset).get_next()\n    return test_case.evaluate(get_next)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        feature_dim = np.random.randint(2, 20)\n        data = np.random.rand(batch_size, feature_dim).astype(np.float32)\n        dataset = tf.data.Dataset.from_tensor_slices(data).batch(batch_size)\n        test_cases.append((data, dataset))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_11", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that expands the dimensions of a given tensor and optionally broadcasts it along a specified axis. The function should be able to handle both positive and negative axis values and should allow for the specification of how many times to replicate the tensor along the new dimension.\n\nFunction signature:\n```python\ndef expand_dims_unbroadcast(x, axis, dim, name='expand_dims_unbroadcast'):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the default name for the operation, which is `'expand_dims_unbroadcast'`.\n\nInput format:\n- The function accepts three parameters:\n  - `x`: A tensor (can be of any shape).\n  - `axis`: An integer indicating the axis along which to expand the dimensions.\n  - `dim`: An integer specifying how many times to replicate the tensor along the new dimension.\n\nOutput format:\n- The function returns a tensor that has been expanded and possibly broadcasted according to the specified parameters.\n\nInput:\n```python\nx = np.array([[1, 2], [3, 4]], dtype=np.float32)  # Shape (2, 2)\naxis = 1  # Expanding the second dimension\ndim = 3   # Tiling the expanded dimension 3 times\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[1. 2.]\n  [1. 2.]\n  [1. 2.]]\n [[3. 4.]\n  [3. 4.]\n  [3. 4.]]], shape=(2, 3, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef expand_dims_unbroadcast(x, axis, dim, name='expand_dims_unbroadcast'):\n    with tf.name_scope(name):\n        x = tf.convert_to_tensor(x)\n        x = tf.expand_dims(x, axis)\n        new_ndim = x.get_shape().ndims\n\n        if new_ndim is None or not isinstance(axis, int):\n            return x\n\n        if dim != 1:\n            if axis < 0:\n                axis = new_ndim + axis\n            x = tf.tile(x, [dim if axis == i else 1 for i in range(new_ndim)])\n\n        return x", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(1, 5, size=np.random.randint(1, 4)).tolist()\n        x = np.random.rand(*shape).astype(np.float32)\n        axis = np.random.randint(-len(shape) - 1, len(shape) + 1)\n        dim = np.random.randint(1, 5)\n\n        test_cases.append((x, axis, dim))\n\n    return test_cases"}
{"problem_id": "tensorflow_12", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a Region Proposal Network (RPN) in a deep learning model. The function will take two inputs: the ground truth labels for anchor matches and the predicted class logits from the RPN. The goal is to calculate the sparse categorical cross-entropy loss based on these inputs.\n\nFunction signature:\n```python\ndef rpn_class_loss_graph(rpn_match, rpn_class_logits):\n```\n\nConstant used in the main code:\n- The constant `0.0` is used to return a default loss value when there are no valid entries in the loss calculation.\n\n\nInput format:\n- `rpn_match`: A tensor of shape (N, 1) where N is the number of anchors, containing integer values indicating the match status of each anchor (0 for non-matching, 1 for positive matches).\n- `rpn_class_logits`: A tensor of shape (N, num_classes) where `num_classes` is the number of classes, containing the predicted logits for each anchor.\n\nOutput format:\n- The function returns a scalar tensor representing the computed loss value.\n\nInput:\n```python\nrpn_match_tensor = tf.constant([[[ 1], [ 0], [-1], [ 1], [ 0]], \n                                  [[-1], [ 1], [ 0], [-1], [ 1]]], dtype=tf.int32)\n\nrpn_class_logits_tensor = tf.constant([[[ 0.5, -0.2], [ 0.1, 0.3], [-0.5, 0.2], [ 0.4, -0.1], [ 0.2, 0.0]], \n                                        [[-0.3, 0.4], [ 0.6, -0.5], [ 0.1, 0.2], [-0.1, 0.3], [ 0.5, -0.4]]], dtype=tf.float32)\n```\n\nOutput:\n```python\n<tf.Tensor: shape=(), dtype=float32, numpy=1.1178771>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef rpn_class_loss_graph(rpn_match, rpn_class_logits):\n    K = tf.keras.backend\n    rpn_match = tf.squeeze(rpn_match, -1)\n    anchor_class = K.cast(K.equal(rpn_match, 1), tf.int32)\n    indices = tf.where(K.not_equal(rpn_match, 0))\n\n    rpn_class_logits = tf.gather_nd(rpn_class_logits, indices)\n    anchor_class = tf.gather_nd(anchor_class, indices)\n\n    loss = K.sparse_categorical_crossentropy(target=anchor_class, output=rpn_class_logits, from_logits=True)\n    loss = K.mean(loss) if tf.size(loss) > 0 else tf.constant(0.0)\n\n    return loss", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 9)\n        num_anchors = np.random.randint(100, 1001)\n        rpn_match = np.random.choice([-1, 0, 1], size=(batch_size, num_anchors, 1)).astype(np.int32)\n        rpn_class_logits = np.random.randn(batch_size, num_anchors, 2).astype(np.float32)\n        rpn_match_tensor = tf.convert_to_tensor(rpn_match, dtype=tf.int32)\n        rpn_class_logits_tensor = tf.convert_to_tensor(rpn_class_logits, dtype=tf.float32)\n\n        test_cases.append((rpn_match_tensor, rpn_class_logits_tensor))\n\n    return test_cases"}
{"problem_id": "tensorflow_13", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the Cartesian product of two matrices. The function should take two input matrices and return a new matrix that represents the Cartesian product of the two input matrices.\n\nFunction signature:\n```python\ndef cartesian_product_matrix(a, b):\n```\n\nIn this function, the following constant is used:\n- The constant `1` is used to specify the dimensions for expanding the input matrices.\n\nInput format:\n- The function takes two input tensors `a` and `b`, where `a` is of shape `(m, n)` and `b` is of shape `(p, q)`.\n\nOutput format:\n- The function returns a tensor of shape `(m, p, 1, n + q)`, representing the Cartesian product of the two input matrices.\n\nInput:\n```python\na = tf.constant([[0.1, 0.2], [0.3, 0.4]], dtype=tf.float32)\nb = tf.constant([[0.5, 0.6], [0.7, 0.8]], dtype=tf.float32)\n```\n\nOutput:\n```python\ncartesian_product = tf.Tensor(\n[[[[0.1 0.2 0.5 0.6]]\n  [[0.1 0.2 0.7 0.8]]]\n [[[0.3 0.4 0.5 0.6]]\n  [[0.3 0.4 0.7 0.8]]]], shape=(2, 2, 1, 4), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef cartesian_product_matrix(a, b):\n    tile_a = tf.tile(tf.expand_dims(a, 1), [1, tf.shape(b)[0], 1])\n    tile_a = tf.expand_dims(tile_a, 2)\n    tile_b = tf.tile(tf.expand_dims(b, 0), [tf.shape(a)[0], 1, 1])\n    tile_b = tf.expand_dims(tile_b, 2)\n    cartesian_product = tf.concat([tile_a, tile_b], axis=-1)\n    return cartesian_product", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        size_a = np.random.randint(1, 10)\n        size_b = np.random.randint(1, 10)\n        common_dim = np.random.randint(1, 10)\n        a = tf.constant(np.random.rand(size_a, common_dim), dtype=tf.float32)\n        b = tf.constant(np.random.rand(size_b, common_dim), dtype=tf.float32)\n\n        test_cases.append((a, b))\n\n    return test_cases"}
{"problem_id": "tensorflow_14", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that transforms a set of 2D coordinates into a multi-channel representation suitable for processing in a neural network. The function will take into account whether the coordinates are normalized and will apply a mask to the output if specified.\n\nFunction signature:\n```python\ndef coord2channel_simple(coords, keypoint_num, is_normalized, img_H, img_W, apply_mask):\n```\n\n### Constants:\n- The constant value `2.0` is used in the function to represent the update value for valid coordinates in the output channel.\n\n\n### Input Format:\n- `coords`: A tensor of shape `[batch_size, keypoint_num * 2]` representing the coordinates.\n- `keypoint_num`: An integer representing the number of keypoints.\n- `is_normalized`: A boolean indicating whether the coordinates are normalized.\n- `img_H`: An integer representing the height of the image.\n- `img_W`: An integer representing the width of the image.\n- `apply_mask`: A boolean indicating whether to apply a mask to the output.\n\n### Output Format:\n- The function returns a tensor of shape `[batch_size, img_H, img_W, keypoint_num]`, representing the multi-channel output with the specified transformations applied.\n\n**Input:**\n```python\nimport tensorflow as tf\n\ncoords_tensor = tf.convert_to_tensor([[[0.5, -0.5], [0.2, 0.3], [-0.8, 0.9]]], dtype=tf.float32)  # Batch size: 1, Keypoint num: 3\nkeypoint_num = 3\nis_normalized = True\nimg_H = 10\nimg_W = 10\napply_mask = True\n```\n\n**Output:**\n```python\n<tf.Tensor: shape=(1, 10, 10, 3), dtype=float32, numpy=\narray([[[[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1.,  1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1.,  1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [ 1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]],\n        [[-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.],\n         [-1., -1., -1.]]]], dtype=float32)>\n```", "ground_truth_code": "import tensorflow as tf\nimport numpy as np\n\n# main code\ndef coord2channel_simple(coords, keypoint_num, is_normalized, img_H, img_W, apply_mask):\n    batch_size = tf.shape(coords)[0]\n    coords = tf.reshape(coords, [batch_size, keypoint_num, 2])\n\n    R, C = tf.split(coords, num_or_size_splits=2, axis=-1)\n\n    if is_normalized:\n        R = (R + 1) / 2.0 * tf.cast(img_H, tf.float32)\n        R = tf.clip_by_value(R, 0, img_H - 1)\n        C = (C + 1) / 2.0 * tf.cast(img_W, tf.float32)\n        C = tf.clip_by_value(C, 0, img_W - 1)\n\n    coords = tf.cast(tf.concat([R, C], axis=-1), tf.int32)\n\n    R, C = tf.split(coords, num_or_size_splits=2, axis=-1)\n    R = tf.reshape(R, [-1])\n    C = tf.reshape(C, [-1])\n\n    batch_idx = tf.reshape(tf.range(batch_size), (batch_size, 1))\n    B = tf.reshape(tf.tile(batch_idx, (1, keypoint_num)), [-1])\n\n    kp_idx = tf.range(keypoint_num)\n    K = tf.tile(kp_idx, [batch_size])\n\n    indices = tf.stack([B, R, C, K], axis=1)\n    valid_mask = (R >= 0) & (R < img_H) & (C >= 0) & (C < img_W)\n    valid_mask = tf.reshape(valid_mask, [-1])\n\n    indices = tf.boolean_mask(indices, valid_mask)\n    updates = tf.fill([tf.shape(indices)[0]], 2.0)\n\n    shape = [batch_size, img_H, img_W, keypoint_num]\n    landChannel = tf.scatter_nd(indices=indices, updates=updates, shape=shape)\n\n    if apply_mask:\n        mask = np.ones(shape, dtype=np.float32)\n        mask[:, 0, 0, :] = 0\n        tf_mask = tf.constant(mask)\n        landChannel = landChannel * tf_mask\n    return landChannel - 1", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 11)\n        keypoint_num = np.random.randint(10, 21)\n        is_normalized = np.random.choice([True, False])\n        img_H = np.random.randint(1, 10)\n        img_W = np.random.randint(1, 10)\n        apply_mask = np.random.choice([True, False])\n\n        if is_normalized:\n            coords = np.random.uniform(-1, 1, size=(batch_size, keypoint_num, 2)).astype(np.float32)\n        else:\n            coords_R = np.random.uniform(0, img_H - 1, size=(batch_size, keypoint_num, 1)).astype(np.float32)\n            coords_C = np.random.uniform(0, img_W - 1, size=(batch_size, keypoint_num, 1)).astype(np.float32)\n            coords = np.concatenate([coords_R, coords_C], axis=-1)\n\n        coords_tensor = tf.convert_to_tensor(coords, dtype=tf.float32)\n        test_cases.append((coords_tensor, keypoint_num, is_normalized, img_H, img_W, apply_mask))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_15", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a tensor of bounding box coordinates by removing any boxes that are entirely composed of zeros. The function should also return a boolean tensor indicating which boxes were non-zero.\n\nFunction signature:\n```python\ndef trim_zeros_graph(boxes, name):\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\n\nInput format:\n- The input to the function is a tensor `boxes` of shape (N, M), where N is the number of boxes and M is the number of coordinates per box. The second parameter is a string `name`.\n\nOutput format:\n- The output of the function is a tuple containing:\n  1. A tensor of shape (K, M), where K is the number of non-zero boxes.\n  2. A boolean tensor of shape (N,) indicating which boxes were non-zero.\n\nInput:\n```python\nboxes_tensor = tf.convert_to_tensor([[0.0, 0.0, 0.0, 0.0],\n                                      [1.0, 2.0, 3.0, 4.0],\n                                      [0.0, 0.0, 0.0, 0.0],\n                                      [5.0, 6.0, 7.0, 8.0]], dtype=tf.float32)\ntest_case_name = \"test_0\"\n```\n\nOutput:\n```python\n(trimmed_boxes, non_zeros) = trim_zeros_graph(boxes_tensor, name=test_case_name)\n# trimmed_boxes: \ntf.Tensor(\n[[1. 2. 3. 4.]\n [5. 6. 7. 8.]], shape=(2, 4), dtype=float32)\n\n# non_zeros: \ntf.Tensor([False  True False  True], shape=(4,), dtype=bool)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef trim_zeros_graph(boxes, name):\n    non_zeros = tf.cast(tf.reduce_sum(tf.abs(boxes), axis=1), tf.bool)\n    boxes = tf.boolean_mask(boxes, non_zeros, name=name)\n    return (boxes, non_zeros)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for i in range(n):\n        num_boxes = np.random.randint(1, 51)\n        box_dim = 4\n\n        boxes = np.random.randn(num_boxes, box_dim).astype(np.float32)\n\n        if num_boxes > 1:\n            num_zero_rows = np.random.randint(0, num_boxes)\n            zero_indices = np.random.choice(num_boxes, num_zero_rows, replace=False)\n            boxes[zero_indices] = 0\n\n        boxes_tensor = tf.convert_to_tensor(boxes, dtype=tf.float32)\n        test_case_name = f\"test_{i}\"\n\n        test_cases.append((boxes_tensor, test_case_name))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_16", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs batch gathering of elements from a tensor based on specified indices. The function should allow for the option to keep the dimensions of the output tensor consistent with the input tensor.\n\nFunction Signature:\n```python\ndef batch_gather(x, indices, keepdims: bool) -> tf.Tensor:\n```\n\n### Constants Used:\n- There are no specific constants defined in the main code.\n\n\n### Input and Output Format:\n- **Input**:\n  - `x`: A tensor of any shape.\n  - `indices`: A tensor of integer indices with shape compatible for gathering from `x`.\n  - `keepdims`: A boolean value.\n\n- **Output**:\n  - A tensor containing the gathered elements from `x`, with dimensions adjusted based on the `keepdims` parameter.\n\nInput:\n```python\nx = tf.constant([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]], dtype=tf.float32)\nindices = tf.constant([2, 0, 1], dtype=tf.int32)\nkeepdims = False\n```\n\nOutput:\n```python\ntf.Tensor([0.3 0.4 0.8], shape=(3,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef expand_dims_unbroadcast(x, axis, dim):\n    x = tf.expand_dims(tf.convert_to_tensor(x), axis)\n    if dim != 1:\n        shape = x.shape.ndims\n        if shape is not None and isinstance(axis, int):\n            axis = shape + axis if axis < 0 else axis\n            x = tf.tile(x, [dim if i == axis else 1 for i in range(shape)])\n    return x\n\ndef nd_indices(indices, batch_axis=0):\n    batch_size = tf.shape(indices)[batch_axis]\n    batch_idx = tf.cast(tf.range(batch_size), dtype=indices.dtype)\n    for axis in range(indices.shape.ndims):\n        if axis != batch_axis:\n            batch_idx = expand_dims_unbroadcast(batch_idx, axis, tf.shape(indices)[axis])\n    return tf.stack([batch_idx, indices], axis=-1)\n\ndef to_int32_64(x):\n    return x if x.dtype in [tf.int32, tf.int64] else tf.cast(x, tf.int32)\n\n# main code\ndef batch_gather(x, indices, keepdims):\n    y = tf.gather_nd(x, nd_indices(to_int32_64(indices)))\n    return tf.expand_dims(y, axis=1) if keepdims else y", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        feature_dim = np.random.randint(2, 10)\n        x = tf.random.uniform(shape=(batch_size, feature_dim), dtype=tf.float32)\n        indices_shape = (batch_size,)\n        indices = tf.random.uniform(shape=indices_shape, minval=0, maxval=feature_dim, dtype=tf.int32)\n        keepdims = np.random.choice([True, False])\n\n        test_cases.append((x, indices, keepdims))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_17", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs 3D upsampling on a given tensor using bilinear interpolation. The function should take an input tensor and resize it to a specified new size while allowing for options to align corners and use half-pixel centers during the resizing process.\n\nFunction Signature:\n```python\ndef upsampling3d_bilinear(input_tensor, new_size, align_corners, half_pixel_centers):\n```\n\nConstants used in the main code:\n- There are no explicit constants defined in the code; however, the function relies on the parameters passed to it.\n\nInput Format:\n- `input_tensor`: A 5D tensor of shape [batch_size, depth, height, width, channels].\n- `new_size`: A list or tuple of three integers representing the new dimensions [new_depth, new_height, new_width].\n- `align_corners`: A boolean value (True or False).\n- `half_pixel_centers`: A boolean value (True or False).\n\nOutput Format:\n- The function returns a 5D tensor of shape [batch_size, new_depth, new_height, new_width, channels] containing the upsampled images.\n\n**Input:**\n```python\ninput_tensor = tf.constant([[[[[0.1, 0.2],\n                               [0.3, 0.4]],\n\n                              [[0.5, 0.6],\n                               [0.7, 0.8]]]]], dtype=tf.float32)\n\nnew_size = [2, 4, 4]  # New depth, height, width\nalign_corners = False\nhalf_pixel_centers = True\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[[[[0.1        0.2       ]\n    [0.15       0.25      ]\n    [0.25       0.35000002]\n    [0.3        0.4       ]]\n   [[0.2        0.3       ]\n    [0.25       0.35000002]\n    [0.35       0.45000002]\n    [0.4        0.5       ]]\n   [[0.4        0.5       ]\n    [0.45000002 0.55      ]\n    [0.54999995 0.65      ]\n    [0.6        0.70000005]]\n   [[0.5        0.6       ]\n    [0.55       0.65000004]\n    [0.65       0.75      ]\n    [0.7        0.8       ]]]\n  [[[0.1        0.2       ]\n    [0.15       0.25      ]\n    [0.25       0.35000002]\n    [0.3        0.4       ]]\n   [[0.2        0.3       ]\n    [0.25       0.35000002]\n    [0.35       0.45000002]\n    [0.4        0.5       ]]\n   [[0.4        0.5       ]\n    [0.45000002 0.55      ]\n    [0.54999995 0.65      ]\n    [0.6        0.70000005]]\n   [[0.5        0.6       ]\n    [0.55       0.65000004]\n    [0.65       0.75      ]\n    [0.7        0.8       ]]]]], shape=(1, 2, 4, 4, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef upsampling3d_bilinear(input_tensor, new_size, align_corners, half_pixel_centers):\n    resized_list = []\n    for img in tf.unstack(input_tensor, axis=1):\n        resized_list.append(tf.compat.v1.image.resize_bilinear(\n            images=img,\n            size=new_size[1:3],\n            align_corners=align_corners,\n            half_pixel_centers=half_pixel_centers,\n        ))\n\n    stack_img_hw = tf.stack(resized_list, axis=1)\n    resized_list.clear()\n    for img in tf.unstack(stack_img_hw, axis=3):\n        resized_list.append(tf.compat.v1.image.resize_bilinear(\n            images=img,\n            size=[new_size[0], new_size[1]],\n            align_corners=align_corners,\n            half_pixel_centers=half_pixel_centers,\n        ))\n\n    return tf.stack(resized_list, axis=3)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        batch_size = np.random.randint(1, 5)\n        depth = np.random.randint(2, 10)\n        height = np.random.randint(2, 20)\n        width = np.random.randint(2, 20)\n        channels = np.random.randint(1, 5)\n\n        input_tensor = tf.random.uniform(\n            shape=(batch_size, depth, height, width, channels),\n            minval=0.0, maxval=1.0, dtype=tf.float32\n        )\n\n        new_depth = np.random.randint(depth, depth * 2)\n        new_height = np.random.randint(height, height * 2)\n        new_width = np.random.randint(width, width * 2)\n        new_size = [new_depth, new_height, new_width]\n        half_pixel_centers = bool(np.random.choice([True, False]))\n        align_corners = False if half_pixel_centers else bool(np.random.choice([True, False]))\n\n        test_cases.append((input_tensor, new_size, align_corners, half_pixel_centers))\n\n    return test_cases"}
{"problem_id": "tensorflow_18", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the weighted loss for keypoint detection in a machine learning model. The function will compare the predicted class probabilities for keypoints against the target keypoint weights and class IDs. The goal is to compute a loss value that can be used to optimize the model during training.\n\nFunction signature:\n```python\ndef keypoint_weight_loss_graph(target_keypoint_weight, pred_class, target_class_ids):\n```\n\nConstant used in the main code:\n- The constant `17` is used to represent the number of keypoints in the reshaping of the predicted class probabilities.\n\n\nInput format:\n- `target_keypoint_weight`: A tensor representing the weights for each keypoint.\n- `pred_class`: A tensor containing the predicted class probabilities for each keypoint.\n- `target_class_ids`: A tensor containing the class IDs corresponding to the target keypoints.\n\nOutput format:\n- The function returns a single scalar tensor representing the computed mean loss value.\n\nInput:\n```python\ntarget_keypoint_weight = np.array([[1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1],\n                                   [0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0]]).astype(np.float32)\npred_class = np.array([[[0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6]],\n\n                        [[0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6],\n                         [0.7, 0.8, 0.9],\n                         [0.1, 0.2, 0.3],\n                         [0.4, 0.5, 0.6]]]).astype(np.float32)\ntarget_class_ids = np.array([[1], [0]]).astype(np.int32)\n```\n\nOutput:\n```python\ntf.Tensor(1.1490016, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef keypoint_weight_loss_graph(target_keypoint_weight, pred_class, target_class_ids):\n    K = tf.keras.backend\n    target_mask_class = tf.cast(target_keypoint_weight, tf.int64)\n    target_class_ids = K.reshape(target_class_ids, (-1,))\n    num_classes = tf.shape(pred_class)[-1]  # Get number of classes dynamically\n    pred_class = K.reshape(pred_class, (-1, 17, num_classes))  # Use dynamic shape\n    target_mask_class = tf.cast(K.reshape(target_mask_class, (-1, 17)), tf.int64)\n    positive_roi_ix = tf.where(target_class_ids > 0)[:, 0]\n    target_class = tf.gather(target_mask_class, positive_roi_ix)\n    pred_class = tf.gather(pred_class, positive_roi_ix)\n    loss = K.switch(tf.size(target_class) > 0,\n                    lambda: tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_class, logits=pred_class),\n                    lambda: tf.constant(0.0))\n    loss = tf.reduce_mean(loss)\n    return loss", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_keypoints = 17\n        num_classes = np.random.randint(2, 10)\n        target_keypoint_weight = np.random.randint(0, 2, size=(batch_size, num_keypoints)).astype(np.float32)\n        pred_class = np.random.randn(batch_size, num_keypoints, num_classes).astype(np.float32)\n        target_class_ids = np.random.randint(0, num_classes, size=(batch_size, 1)).astype(np.int32)\n\n        test_cases.append((target_keypoint_weight, pred_class, target_class_ids))\n\n    return test_cases"}
{"problem_id": "tensorflow_19", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that normalizes bounding box coordinates based on the dimensions of an image. The function will take in a set of bounding boxes and the shape of the image, and it will return the normalized bounding boxes.\n\nFunction signature:\n```python\ndef norm_boxes_graph(boxes, shape):\n```\n\nIn this function, the following constant is used:\n- `shift`: A constant tensor with values `[0.0, 0.0, 1.0, 1.0]`, which is used to adjust the bounding box coordinates.\n\nInput format:\n- `boxes`: A tensor of shape (N, 4) where N is the number of bounding boxes, and each bounding box is represented by four coordinates (x_min, y_min, x_max, y_max).\n- `shape`: A tensor of shape (2,) representing the height and width of the image.\n\nOutput format:\n- The function returns a tensor of the same shape as `boxes`, containing the normalized bounding box coordinates. Each coordinate will be in the range of [0, 1].\n\n```python\n# Input\nboxes = tf.constant([[100.0, 200.0, 300.0, 400.0]], dtype=tf.float32)\nshape = tf.constant([[800, 600]], dtype=tf.int32)\n\n# Output\ntf.Tensor([[0.12515645 0.3338898  0.37421778 0.66611016]], shape=(1, 4), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef norm_boxes_graph(boxes, shape):\n    (h, w) = tf.split(tf.cast(shape, tf.float32), num_or_size_splits=2, axis=-1)\n    scale = tf.concat([h, w, h, w], axis=-1) - tf.constant(1.0)\n    shift = tf.constant([0.0, 0.0, 1.0, 1.0])\n    return tf.divide(boxes - shift, scale)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        boxes = tf.constant(np.random.uniform(0, 1000, (batch_size, 4)), dtype=tf.float32)\n        shape = tf.constant(np.random.randint(1, 2000, (batch_size, 2)), dtype=tf.int32)\n\n        test_cases.append((boxes, shape))\n\n    return test_cases"}
{"problem_id": "tensorflow_20", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that collects the features of the nearest neighbors for a set of coordinates in a multi-dimensional space. The function should compute the distances between points, rank them, and then gather the features of the closest neighbors, applying a Gaussian weighting to these features. The final output should consist of the maximum and mean features of the neighbors.\n\nFunction signature:\n```python\ndef collect_neighbours(coordinates, features, n_neighbours):\n```\n\nConstant used in the main code:\n- The constant `10.0` is used in the Gaussian weighting function to scale the distances.\n\nInput format:\n- `coordinates`: A tensor of shape `(batch_size, n_vertices, n_dimensions)` representing the coordinates of the vertices.\n- `features`: A tensor of shape `(batch_size, n_vertices, n_feature_dimensions)` representing the features associated with each vertex.\n- `n_neighbours`: An integer specifying the number of nearest neighbors to consider.\n\nOutput format:\n- A tensor of shape `(batch_size, n_vertices, n_feature_dimensions * 2)` containing the concatenated maximum and mean features of the nearest neighbors for each vertex.\n\nInput:\n```python\ncoordinates = tf.constant([[[ 0.1,  0.2,  0.3],\n                             [ 0.4,  0.5,  0.6],\n                             [ 0.7,  0.8,  0.9],\n                             [ 1.0,  1.1,  1.2]]], dtype=tf.float32)\n\nfeatures = tf.constant([[[ 0.5,  0.6,  0.7],\n                          [ 0.8,  0.9,  1.0],\n                          [ 1.1,  1.2,  1.3],\n                          [ 1.4,  1.5,  1.6]]], dtype=tf.float32)\n\nn_neighbours = 3\n```\n\nOutput:\n```python\noutput = tf.Tensor(\n[[[0.0537644  0.06048495 0.0672055  0.02689342 0.03025471 0.03361601]\n  [0.07392617 0.08064673 0.08736729 0.05376446 0.06048502 0.06720557]\n  [0.09408773 0.10080829 0.10752884 0.07392609 0.08064665 0.0873672 ]\n  [0.07392617 0.08064673 0.08736729 0.03697124 0.04033254 0.04369384]]], shape=(1, 4, 6), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef euclidean_squared(A, B):\n    sub_factor = -2 * tf.matmul(A, tf.transpose(B, perm=[0, 2, 1]))\n    dotA = tf.expand_dims(tf.reduce_sum(A * A, axis=2), axis=2)\n    dotB = tf.expand_dims(tf.reduce_sum(B * B, axis=2), axis=1)\n    return tf.abs(sub_factor + dotA + dotB)\n\n\ndef gauss_of_lin(x):\n    return tf.exp(-tf.abs(x))\n\n# main code\ndef collect_neighbours(coordinates, features, n_neighbours):\n    distance_matrix = euclidean_squared(coordinates, coordinates)\n    ranked_distances, ranked_indices = tf.nn.top_k(-distance_matrix, k=n_neighbours)\n\n    neighbour_indices = ranked_indices[:, :, 1:]\n    n_batches = tf.shape(features)[0]\n    n_vertices = tf.shape(features)[1]\n\n    batch_indices = tf.tile(tf.range(n_batches)[:, None, None, None], [1, n_vertices, n_neighbours - 1, 1])\n    vertex_indices = tf.expand_dims(neighbour_indices, axis=3)\n    indices = tf.concat([batch_indices, vertex_indices], axis=-1)\n\n    neighbour_features = tf.gather_nd(features, indices)\n    weights = gauss_of_lin(-ranked_distances[:, :, 1:] * 10.0)\n    neighbour_features *= tf.expand_dims(weights, axis=-1)\n\n    neighbours_max = tf.reduce_max(neighbour_features, axis=2)\n    neighbours_mean = tf.reduce_mean(neighbour_features, axis=2)\n\n    return tf.concat([neighbours_max, neighbours_mean], axis=-1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_vertices = np.random.randint(5, 20)\n        feature_dim = np.random.randint(3, 10)\n        n_neighbours = np.random.randint(2, num_vertices)\n        coordinates = tf.random.normal((batch_size, num_vertices, 3))\n        features = tf.random.normal((batch_size, num_vertices, feature_dim))\n\n        test_cases.append((coordinates, features, n_neighbours))\n\n    return test_cases"}
{"problem_id": "tensorflow_21", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a Mask R-CNN model based on the predicted class logits and the target class IDs. The function should handle the computation of the sparse softmax cross-entropy loss while considering only the active classes.\n\nFunction signature:\n```python\ndef mrcnn_class_loss_graph(target_class_ids, pred_class_logits, active_class_ids):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the data type 'int64' for casting the target class IDs.\n\nInput format:\n- `target_class_ids`: A tensor of shape (N, C) where N is the number of instances and C is the number of classes, containing the target class IDs for each instance.\n- `pred_class_logits`: A tensor of shape (N, C) containing the predicted class logits for each instance.\n- `active_class_ids`: A tensor of shape (1, C) containing the active class IDs.\n\nOutput format:\n- The function returns a tensor of shape (1, 1) representing the computed loss value.\n\nInput:\n```python\ntarget_class_ids = np.array([[0, 1, 2], [1, 0, 2]])\npred_class_logits = np.array([[[0.1, 0.2, 0.7], [0.5, 0.3, 0.2], [0.2, 0.8, 0.0]], \n                               [[0.3, 0.4, 0.3], [0.6, 0.1, 0.3], [0.4, 0.4, 0.2]]]).astype(np.float32)\nactive_class_ids = np.array([[1, 1, 1]]).astype(np.float32)\n```\n\nOutput:\n```python\ntf.Tensor([[1.1871066]], shape=(1, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef mrcnn_class_loss_graph(target_class_ids, pred_class_logits, active_class_ids):\n    K = tf.keras.backend\n    target_class_ids = tf.cast(target_class_ids, 'int64')\n    pred_class_ids = tf.argmax(pred_class_logits, axis=2)\n    pred_active = tf.gather(active_class_ids[0], pred_class_ids)\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_class_ids, logits=pred_class_logits)\n    loss = loss * pred_active\n    loss = tf.reduce_sum(loss) / tf.reduce_sum(pred_active)\n    loss = K.reshape(loss, [1, 1])\n    return loss", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        num_rois = np.random.randint(5, 20)\n        num_classes = np.random.randint(3, 10)\n\n        target_class_ids = np.random.randint(0, num_classes, size=(batch_size, num_rois))\n        pred_class_logits = np.random.randn(batch_size, num_rois, num_classes).astype(np.float32)\n        active_class_ids = np.random.randint(0, 2, size=(1, num_classes)).astype(np.float32)\n\n        test_cases.append((target_class_ids, pred_class_logits, active_class_ids))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_22", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes a context-based similarity matching score between a set of input vectors and a reference vector using TensorFlow. The function will take in a 3D tensor representing multiple sets of vectors and a 2D tensor representing a reference vector. The goal is to calculate a weighted sum of the reference vector based on the maximum values of the input vectors.\n\nFunction signature:\n```python\ndef context_based_similarity_matching(A: tf.Tensor, r_p: tf.Tensor) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the axis parameter for the `reduce_max` and `softmax` functions, which is set to `2` and `1` respectively.\n\nInput format:\n- `A`: A 3D tensor of shape (batch_size, num_vectors, vector_dim).\n- `r_p`: A 2D tensor of shape (batch_size, vector_dim).\n\nOutput format:\n- Returns a 2D tensor of shape (batch_size, vector_dim) representing the context-based similarity matching scores.\n\nInput:\n```python\nA = tf.constant([[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], \n                  [[0.7, 0.8, 0.9], [1.0, 1.1, 1.2]]], dtype=tf.float32)\nr_p = tf.constant([[0.1, 0.2, 0.3], \n                   [0.4, 0.5, 0.6]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[0.1 0.2 0.3]\n [0.4 0.5 0.6]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef context_based_similarity_matching(A, r_p):\n    e = tf.reduce_max(A, axis=2)\n    d = tf.nn.softmax(e, axis=1)\n\n    d_expand = tf.expand_dims(d, axis=-1)\n    r_p_expand = tf.expand_dims(r_p, axis=1)\n\n    m_3 = tf.multiply(d_expand, r_p_expand)\n    m_3 = tf.reduce_sum(m_3, axis=1)\n\n    return m_3\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(5, 20)\n        seq_len = np.random.randint(10, 50)\n        feature_dim = np.random.randint(8, 32)\n\n        A = tf.random.uniform((batch_size, seq_len, feature_dim), dtype=tf.float32)\n        r_p = tf.random.uniform((batch_size, feature_dim), dtype=tf.float32)\n\n        test_cases.append((A, r_p))\n\n    return test_cases"}
{"problem_id": "tensorflow_23", "library": "tensorflow", "code_problem": "The task is to implement a function that calculates the total regularization loss for a convolutional neural network layer. The function should consider L1 and L2 regularization for both the filters and the bias of the layer, as well as any additional regularization loss from a specified nonlinearity function. The function signature is as follows:\n\n```python\ndef tf_regularization_loss(bias, l2_regularization, filters, nonlinearity, l1_regularization, Conv1d):\n```\n\n### Constants:\n- The constant used in the main code is `0.0`, which is used to represent a zero loss when no losses are calculated.\n\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `bias`: A tensor representing the bias of the layer (can be `None`).\n  - `l2_regularization`: A float representing the L2 regularization coefficient.\n  - `filters`: A tensor representing the filters of the convolutional layer.\n  - `nonlinearity`: An object that has a method `regularization_loss()` which returns a tensor or `None`.\n  - `l1_regularization`: A float representing the L1 regularization coefficient.\n  - `Conv1d`: A class that has a method `tf_regularization_loss()` which returns a tensor or `None`.\n\n- **Output**: The function returns a tensor representing the total regularization loss, which is the sum of all individual losses calculated based on the provided parameters.\n\nInput:\n```python\n(\n    tf.constant([-0.5, 0.3, 0.1]),  # bias\n    0.1,                            # l2_regularization\n    tf.random.normal((3, 4, 2)),    # filters\n    MockNonlinearity(),             # nonlinearity\n    0.2,                            # l1_regularization\n    MockConv1d()                    # Conv1d\n)\n```\n\nOutput:\n```python\ntf.Tensor(4.6108685, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tf_regularization_loss(bias, l2_regularization, filters, nonlinearity, l1_regularization, Conv1d):\n    losses = []\n\n    base_loss = Conv1d.tf_regularization_loss()\n    if base_loss is not None:\n        losses.append(base_loss)\n\n    if l2_regularization > 0.0:\n        losses.append(l2_regularization * tf.nn.l2_loss(filters))\n        if bias is not None:\n            losses.append(l2_regularization * tf.nn.l2_loss(bias))\n\n    if l1_regularization > 0.0:\n        losses.append(l1_regularization * tf.reduce_sum(tf.abs(filters)))\n        if bias is not None:\n            losses.append(l1_regularization * tf.reduce_sum(tf.abs(bias)))\n\n    nonlinearity_loss = nonlinearity.regularization_loss()\n    if nonlinearity_loss is not None:\n        losses.append(nonlinearity_loss)\n\n    return tf.add_n(losses) if losses else tf.constant(0.0)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        out_channels = np.random.randint(1, 10)\n        in_channels = np.random.randint(1, 10)\n        kernel_size = np.random.randint(1, 5)\n\n        filters = tf.random.normal((out_channels, in_channels, kernel_size))\n        use_bias = np.random.choice([True, False])\n        bias = tf.random.normal((out_channels,)) if use_bias else None\n\n        l1_regularization = np.random.uniform(0, 1)\n        l2_regularization = np.random.uniform(0, 1)\n\n        class MockNonlinearity:\n            def regularization_loss(self):\n                return tf.random.uniform(()) if np.random.choice([True, False]) else None\n\n        nonlinearity = MockNonlinearity()\n\n        class MockConv1d:\n            def tf_regularization_loss(self):\n                return tf.random.uniform(()) if np.random.choice([True, False]) else None\n\n        Conv1d = MockConv1d()\n\n        test_cases.append((bias, l2_regularization, filters, nonlinearity, l1_regularization, Conv1d))\n\n    return test_cases"}
{"problem_id": "tensorflow_24", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that identifies indices of anchor points in a dataset based on their similarity to other points. The function will utilize a contrastive learning approach to determine positive and negative pairs of indices based on specified conditions.\n\nFunction signature:\n```python\ndef _contrastive_get_indices(y: tf.Tensor, d: tf.Tensor, anchors: tf.Tensor, num_total: int, in_domain: bool, any_domain: bool) -> Tuple[tf.Tensor, tf.Tensor, tf.Tensor]:\n```\n\nConstants used in the main code:\n- `num_total`: This constant represents the total number of elements in the dataset.\n\nInput format:\n- `y`: A tensor representing the labels of the dataset.\n- `d`: A tensor representing the data points of the dataset.\n- `anchors`: A tensor containing the indices of the anchor points.\n- `num_total`: An integer representing the total number of elements in the dataset.\n- `in_domain`: A boolean flag indicating whether to consider in-domain conditions.\n- `any_domain`: A boolean flag indicating whether to consider any-domain conditions.\n\nOutput format:\n- A tuple containing three tensors:\n  - The first tensor contains the indices of the anchors with positive pairs.\n  - The second tensor contains the indices of the positive pairs.\n  - The third tensor contains the indices of the negative pairs.\n\n**Input:**\n```python\ny = tf.convert_to_tensor([0, 1, 2, 1, 0], dtype=tf.int32)  # Labels\nd = tf.convert_to_tensor([0, 1, 1, 0, 2], dtype=tf.int32)  # Domain identifiers\nanchors = tf.convert_to_tensor([0, 2], dtype=tf.int32)      # Anchor indices\nnum_total = 5                                               # Total number of elements\nin_domain = True                                          # In-domain flag\nany_domain = False                                        # Any-domain flag\n```\n\n**Output:**\n```python\nanchors_indices = tf.Tensor([], shape=(0,), dtype=int32) \npositives_similarity_indices = tf.Tensor([], shape=(0, 2), dtype=int32)\nnegatives_similarity_indices = tf.Tensor([[0 3] [2 1]], shape=(2, 2), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef _cartesian_product(a, b):\n    tile_a = tf.tile(tf.expand_dims(a, 1), [1, tf.shape(b)[0]])\n    tile_a = tf.expand_dims(tile_a, 2)\n    tile_b = tf.tile(tf.expand_dims(b, 0), [tf.shape(a)[0], 1])\n    tile_b = tf.expand_dims(tile_b, 2)\n    return tf.concat([tile_a, tile_b], axis=2)\n\n# main code\ndef _contrastive_get_indices(y, d, anchors, num_total, in_domain, any_domain):\n    prod_indices = _cartesian_product(anchors, tf.range(0, num_total))\n    anchor_d = tf.gather_nd(d, tf.expand_dims(prod_indices[:, :, 0], axis=-1))\n    all_d = tf.gather_nd(d, tf.expand_dims(prod_indices[:, :, 1], axis=-1))\n    anchor_y = tf.gather_nd(y, tf.expand_dims(prod_indices[:, :, 0], axis=-1))\n    all_y = tf.gather_nd(y, tf.expand_dims(prod_indices[:, :, 1], axis=-1))\n    is_not_anchor = tf.logical_not(\n        tf.cast(tf.gather_nd(tf.eye(num_total), tf.expand_dims(anchors, axis=-1)), dtype=tf.bool))\n\n    if in_domain:\n        positives = tf.logical_and(tf.logical_and(tf.equal(anchor_d, all_d), tf.equal(anchor_y, all_y)), is_not_anchor)\n        negatives = tf.logical_and(tf.equal(anchor_d, all_d), tf.not_equal(anchor_y, all_y))\n    elif any_domain:\n        positives = tf.logical_and(tf.equal(anchor_y, all_y), is_not_anchor)\n        negatives = tf.not_equal(anchor_y, all_y)\n    else:\n        positives = tf.logical_and(tf.not_equal(anchor_d, all_d), tf.equal(anchor_y, all_y))\n        negatives = tf.logical_and(tf.not_equal(anchor_d, all_d), tf.not_equal(anchor_y, all_y))\n\n    positives_similarity_indices = tf.gather_nd(prod_indices, tf.where(tf.not_equal(tf.cast(positives, tf.int32), 0)))\n    negatives_similarity_indices = tf.gather_nd(prod_indices, tf.where(tf.not_equal(tf.cast(negatives, tf.int32), 0)))\n    anchors_indices = positives_similarity_indices[:, 0] if tf.size(positives_similarity_indices) > 0 else tf.constant(\n        [], dtype=tf.int32)\n\n    return anchors_indices, positives_similarity_indices, negatives_similarity_indices\n", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_total = np.random.randint(5, 20)\n        num_anchors = np.random.randint(1, num_total)\n\n        y = tf.convert_to_tensor(np.random.randint(0, 3, size=(num_total,)), dtype=tf.int32)\n        d = tf.convert_to_tensor(np.random.randint(0, 3, size=(num_total,)), dtype=tf.int32)\n        anchors = tf.convert_to_tensor(np.random.choice(num_total, size=num_anchors, replace=False), dtype=tf.int32)\n        in_domain = bool(np.random.choice([True, False]))\n        any_domain = bool(np.random.choice([True, False]))\n\n        test_cases.append((y, d, anchors, num_total, in_domain, any_domain))\n\n    return test_cases"}
{"problem_id": "tensorflow_25", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that clips bounding boxes to a specified window. The function should ensure that the coordinates of the bounding boxes do not exceed the limits defined by the window. The function signature is as follows:\n\n```python\ndef clip_boxes_graph(boxes, window):\n```\n\nIn this function, the `boxes` parameter is a tensor containing the coordinates of the bounding boxes, where each box is represented by four values: (y1, x1, y2, x2). The `window` parameter is a tensor that defines the clipping region, also represented by four values: (wy1, wx1, wy2, wx2).\n\nThe constant used in the main code is `4`, which indicates the number of splits for both the `boxes` and `window` tensors.\n\nInput format:\n- The `boxes` parameter is a tensor of shape (N, 4), where N is the number of bounding boxes.\n- The `window` parameter is a tensor of shape (4,).\n\nOutput format:\n- The function returns a tensor of shape (N, 4) containing the clipped bounding box coordinates.\n\nInput:\n```python\nboxes_tensor = tf.convert_to_tensor([[1.0, 2.0, 6.0, 7.0], [-5.0, -3.0, 4.0, 8.0]], dtype=tf.float32)\nwindow_tensor = tf.convert_to_tensor([0.0, 0.0, 5.0, 5.0], dtype=tf.float32)\n```\n\nOutput:\n```python\nclipped_boxes = \n<tf.Tensor: shape=(2, 4), dtype=float32, numpy=\narray([[1., 2., 5., 5.],\n       [0., 0., 4., 5.]], dtype=float32)>\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef clip_boxes_graph(boxes, window):\n    wy1, wx1, wy2, wx2 = tf.split(window, num_or_size_splits=4)\n    y1, x1, y2, x2 = tf.split(boxes, num_or_size_splits=4, axis=1)\n\n    y1 = tf.clip_by_value(y1, wy1, wy2)\n    x1 = tf.clip_by_value(x1, wx1, wx2)\n    y2 = tf.clip_by_value(y2, wy1, wy2)\n    x2 = tf.clip_by_value(x2, wx1, wx2)\n\n    clipped = tf.concat([y1, x1, y2, x2], axis=1, name='clipped_boxes')\n    return clipped if clipped is not None else tf.zeros_like(boxes)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 101)\n        boxes = np.random.uniform(-10, 10, size=(batch_size, 4)).astype(np.float32)\n        wy1, wx1 = np.random.uniform(-10, 5, size=(2,)).astype(np.float32)\n        wy2, wx2 = np.random.uniform(5, 15, size=(2,)).astype(np.float32)\n        window = np.array([wy1, wx1, wy2, wx2], dtype=np.float32)\n        boxes_tensor = tf.convert_to_tensor(boxes, dtype=tf.float32)\n        window_tensor = tf.convert_to_tensor(window, dtype=tf.float32)\n\n        test_cases.append((boxes_tensor, window_tensor))\n\n    return test_cases"}
{"problem_id": "tensorflow_26", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the conditional probability distribution of source domains given class labels from multiple datasets. The function will aggregate data from various source domains and compute the probabilities based on the class labels present in the datasets.\n\nFunction signature:\n```python\ndef mle_for_p_d_given_y(domain_outputs: int, source_train_eval_datasets: list, num_source_domains: int, num_classes: int) -> tf.Tensor:\n```\n\nConstants used in the main code:\n- `p_d_given_y`: A 2D array initialized to store the conditional probabilities of each domain given each class label.\n\nInput format:\n- `domain_outputs`: An integer representing the number of output domains.\n- `source_train_eval_datasets`: A list of datasets, where each dataset contains tuples of data, with the second element being the class label.\n- `num_source_domains`: An integer representing the number of source domains.\n- `num_classes`: An integer representing the number of unique class labels.\n\nOutput format:\n- The function returns a TensorFlow tensor of shape `(num_classes, domain_outputs)` containing the conditional probabilities of each domain given each class label.\n\n**Input:**\n```python\ndomain_outputs = 3\nsource_train_eval_datasets = [\n    [(None, tf.convert_to_tensor([[0], [1], [0]]), None)],\n    [(None, tf.convert_to_tensor([[1], [2], [1]]), None)],\n    [(None, tf.convert_to_tensor([[0], [2], [2]]), None)]\n]\nnum_source_domains = 3\nnum_classes = 3\n```\n\n**Output:**\n```python\np_d_given_y = tf.Tensor(\n[[0.6666667  0.         0.33333334]\n [0.33333334 0.6666667  0.        ]\n [0.         0.33333334 0.6666667 ]], shape=(3, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\nimport numpy as np\n\n# main code\ndef mle_for_p_d_given_y(domain_outputs, source_train_eval_datasets, num_source_domains, num_classes):\n    ys, ds = [], []\n\n    for d, dataset in enumerate(source_train_eval_datasets):\n        for _, y, _ in dataset:\n            ys.append(y)\n            ds.append(tf.fill(y.shape, d))\n\n    y = tf.concat(ys, axis=0)\n    d = tf.concat(ds, axis=0)\n\n    y = tf.cast(tf.squeeze(y), dtype=tf.int32).numpy()\n    d = tf.cast(tf.squeeze(d), dtype=tf.int32).numpy()\n\n    p_d_given_y = np.zeros((num_classes, domain_outputs), dtype=np.float32)\n\n    for y_key in range(num_classes):\n        indices = np.where(y == y_key)\n        d_given_key = d[indices]\n        d_keys, d_counts = np.unique(d_given_key, return_counts=True)\n\n        p_d_given_key = np.zeros((num_source_domains,))\n        p_d_given_key[d_keys] = d_counts\n\n        p_d_given_y[y_key] = p_d_given_key\n\n    p_d_given_y = tf.constant(p_d_given_y, dtype=tf.float32)\n    p_d_given_y /= tf.reduce_sum(tf.math.abs(p_d_given_y), axis=1, keepdims=True)\n\n    return p_d_given_y", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_source_domains = np.random.randint(2, 10)\n        num_classes = np.random.randint(2, 10)\n        domain_outputs = num_source_domains\n\n        source_train_eval_datasets = []\n        for d in range(num_source_domains):\n            dataset_size = np.random.randint(5, 20)\n            y = tf.convert_to_tensor(np.random.randint(0, num_classes, size=(dataset_size, 1)), dtype=tf.int32)\n\n            dataset = [(None, y, None)]\n            source_train_eval_datasets.append(dataset)\n\n        test_cases.append((domain_outputs, source_train_eval_datasets, num_source_domains, num_classes))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_27", "library": "tensorflow", "code_problem": "The task is to implement a function that processes and transforms node features in a graph neural network context. The function takes in various inputs related to node features, message passing, and aggregation operations, and outputs updated node features after applying specified transformations.\n\nFunction signature:\n```python\ndef call(h_from, h_to, _to_ind, _g_node, _g_msg, _embed_mlp, _from_ind, _msg_mlp, _use_attributes, _gather_ind, _reduce_op):\n```\n\nConstant used in the main code:\n- The constant used in the main code is a dictionary named `reduce_ops`, which maps string keys ('sum', 'mean', 'max', 'min') to their corresponding TensorFlow reduction functions.\n\nInput format:\n- `h_from`: A tensor representing features of source nodes.\n- `h_to`: A tensor representing features of target nodes.\n- `_to_ind`: Indices for selecting target nodes.\n- `_g_node`: A tensor representing node attributes.\n- `_g_msg`: A tensor representing message attributes.\n- `_embed_mlp`: A multi-layer perceptron for embedding updates.\n- `_from_ind`: Indices for selecting source nodes.\n- `_msg_mlp`: A multi-layer perceptron for message transformations.\n- `_use_attributes`: A boolean flag indicating whether to use attributes.\n- `_gather_ind`: Indices for gathering messages.\n- `_reduce_op`: A string indicating the type of reduction operation to perform.\n\nOutput format:\n- The function returns a tensor representing the updated features of the target nodes after processing.\n\n**Input:**\n```python\nimport tensorflow as tf\n\n# Test case input\nbatch_size = 2\nnum_nodes = 5\nfeature_dim = 4\nmessage_dim = 3\n\nh_from = tf.random.normal((batch_size, num_nodes, feature_dim))\nh_to = tf.random.normal((batch_size, num_nodes, feature_dim))\n\n_from_ind = tf.constant([0, 1, 2, 3, 4])\n_to_ind = tf.constant([4, 3, 2, 1, 0])\n\n_g_msg = tf.random.normal((num_nodes, message_dim))\n_g_node = tf.random.normal((num_nodes, message_dim))\n\n_gather_ind = tf.constant([[0, 1, 2, 3, 4], [4, 3, 2, 1, 0]])\n\n_reduce_op = 'mean'\n_use_attributes = True\n\n_msg_mlp = tf.keras.Sequential([\n    tf.keras.layers.Dense(message_dim, activation='relu'),\n    tf.keras.layers.Dense(message_dim)\n])\n\n_embed_mlp = tf.keras.Sequential([\n    tf.keras.layers.Dense(feature_dim, activation='relu'),\n    tf.keras.layers.Dense(feature_dim)\n])\n```\n\n**Output:**\n```python\noutput = call(h_from, h_to, _to_ind, _g_node, _g_msg, _embed_mlp, _from_ind, _msg_mlp, _use_attributes, _gather_ind, _reduce_op)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(h_from, h_to, _to_ind, _g_node, _g_msg, _embed_mlp, _from_ind, _msg_mlp, _use_attributes, _gather_ind,\n         _reduce_op):\n    features = tf.concat([tf.gather(h_from, _from_ind, axis=1), tf.gather(h_to, _to_ind, axis=1)], axis=-1)\n\n    if _use_attributes:\n        attr = tf.tile(tf.expand_dims(_g_msg, axis=0), [tf.shape(features)[0], 1, 1])\n        features = tf.concat((features, attr), axis=-1)\n\n    messages = _msg_mlp(features)\n    messages = tf.transpose(messages, (1, 2, 0))\n    m_ragged = tf.gather(messages, _gather_ind, axis=0)\n\n    reduce_ops = {\n        'sum': tf.reduce_sum,\n        'mean': tf.reduce_mean,\n        'max': tf.reduce_max,\n        'min': tf.reduce_min\n    }\n\n    reduce_fn = reduce_ops.get(_reduce_op, tf.reduce_sum)\n    m = reduce_fn(m_ragged, axis=1)\n\n    m = tf.transpose(m, (2, 0, 1))\n\n    if _use_attributes:\n        attr = tf.tile(tf.expand_dims(_g_node, axis=0), [tf.shape(m)[0], 1, 1])\n        m = tf.concat((m, attr), axis=-1)\n\n    h_to_new = _embed_mlp(tf.concat([m, h_to], axis=-1))\n\n    return h_to_new", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_nodes = np.random.randint(5, 20)\n        feature_dim = np.random.randint(4, 16)\n        message_dim = np.random.randint(4, 16)\n\n        h_from = tf.random.normal((batch_size, num_nodes, feature_dim))\n        h_to = tf.random.normal((batch_size, num_nodes, feature_dim))\n\n        _from_ind = tf.random.uniform((num_nodes,), minval=0, maxval=num_nodes, dtype=tf.int32)\n        _to_ind = tf.random.uniform((num_nodes,), minval=0, maxval=num_nodes, dtype=tf.int32)\n\n        _g_msg = tf.random.normal((num_nodes, message_dim))\n        _g_node = tf.random.normal((num_nodes, message_dim))\n\n        _gather_ind = tf.random.uniform((num_nodes, num_nodes), minval=0, maxval=num_nodes, dtype=tf.int32)\n\n        _reduce_op = np.random.choice(['sum', 'mean', 'max', 'min'])\n\n        _use_attributes = np.random.choice([True, False])\n\n        _msg_mlp = tf.keras.Sequential([\n            tf.keras.layers.Dense(message_dim, activation='relu'),\n            tf.keras.layers.Dense(message_dim)\n        ])\n\n        _embed_mlp = tf.keras.Sequential([\n            tf.keras.layers.Dense(feature_dim, activation='relu'),\n            tf.keras.layers.Dense(feature_dim)\n        ])\n\n        test_cases.append((h_from, h_to, _to_ind, _g_node, _g_msg, _embed_mlp, _from_ind, _msg_mlp, _use_attributes, _gather_ind, _reduce_op))\n\n    return test_cases"}
{"problem_id": "tensorflow_28", "library": "tensorflow", "code_problem": "The task is to implement a function that processes and organizes data for a contrastive learning model in a machine learning context. The function will filter and reshape input tensors based on certain conditions related to domain generalization and pseudo-labeling.\n\nFunction signature:\n```python\ndef _contrastive_get_examples(task_y_true, domain_y_true, z_output, task_y_pred, domain_generalization, pseudo_label_target):\n```\n\n### Constants:\n- The constant used in the main code is `0`, which is used to identify the target domain in the `domain_y_true` tensor.\n\n### Input Format:\n- The function takes in five tensors and two boolean values as parameters.\n\n### Output Format:\n- The function returns a tuple containing four tensors and an integer. The tensors represent the processed task labels, domain labels, output features, and predicted task labels, while the integer represents the total number of samples.\n\nInput:\n```python\ntask_y_true = tf.constant([[1], [0], [2], [1], [0]])\ndomain_y_true = tf.constant([[0], [1], [0], [1], [0]])\nz_output = tf.random.normal(shape=(5, 20))  # Example shape\ntask_y_pred = tf.random.normal(shape=(5, 3))  # Example shape\ndomain_generalization = False\npseudo_label_target = True\n```\n\nOutput:\n```python\n(y, d, z, pred, num_total) = _contrastive_get_examples(task_y_true, domain_y_true, z_output, task_y_pred, domain_generalization, pseudo_label_target)\n\ny = tf.Tensor([0 1 1 1 1 1 0 1 2 1], shape=(10,), dtype=int32)\nd = tf.Tensor([1 0 1 0 0 0 0 0 0 0], shape=(10,), dtype=int32)\nz = tf.Tensor(\n[[-0.64321244  0.09058352 -0.999927   -1.2861035  -0.99874276  0.9117883\n   0.75010073 -0.38919875  0.30707216  1.4281328   0.0773479  -0.34002095\n   0.2088375  -0.20639348  0.7580024  -0.1415226  -0.6075441  -0.76190346\n   0.12732677 -0.15171547  0.59909433  0.759741   -0.04659576  0.19080366\n  -1.063112    0.6097067   0.1594699  -0.8159646   1.0228577  -0.03011172\n   0.00646799  1.2589688   0.44356945  0.25115746 -0.81815207  1.6016827\n   0.5401112  -0.50891143  0.6919001  -0.60184973]\n [-0.16548386  2.5535007  -0.80952257  1.4037191  -0.40621352 -0.16073997\n   0.83954525  0.6254922   0.796695    0.31617785  1.0131129  -1.240495\n  -0.09968698 -0.5565052  -0.09904107 -0.24390794 -0.7269316   0.65735847\n   0.07163426  0.2771094   0.59909433  0.759741   -0.04659576  0.19080366\n  -1.063112    0.6097067   0.1594699  -0.8159646   1.0228577  -0.03011172\n   0.00646799  1.2589688   0.44356945  0.25115746 -0.81815207  1.6016827\n   0.5401112  -0.50891143  0.6919001  -0.60184973]\n [ 0.59909433  0.759741   -0.04659576  0.19080366 -1.063112    0.6097067\n   0.1594699  -0.8159646   1.0228577  -0.03011172  0.00646799  1.2589688\n   0.44356945  0.25115746 -0.81815207  1.6016827   0.5401112  -0.50891143\n   0.6919001  -0.60184973  0.59909433  0.759741   -0.04659576  0.19080366\n  -1.063112    0.6097067   0.1594699  -0.8159646   1.0228577  -0.03011172\n   0.00646799  1.2589688   0.44356945  0.25115746 -0.81815207  1.6016827\n   0.5401112  -0.50891143  0.6919001  -0.60184973]\n [ 0.6797013  -0.6906337  -0.14045778 -0.14969699  0.11804987 -2.267864\n   1.2537538  -0.83749926 -0.5852041  -0.60486335  2.655696    1.5412024\n   0.8965038  -0.24063045 -0.23987213  0.70149547 -0.5504633  -0.5943038\n  -0.8510909  -0.65826774  0.59909433  0.759741   -0.04659576  0.19080366\n  -1.063112    0.6097067   0.1594699  -0.8159646   1.0228577  -0.03011172\n   0.00646799  1.2589688   0.44356945  0.25115746 -0.81815207  1.6016827\n   0.5401112  -0.50891143  0.6919001  -0.60184973]\n [-1.016046    0.87266475 -0.35631528 -0.8916494  -0.39071724 -0.61307806\n   1.5013754  -1.2091612   0.6934533  -0.7555616  -1.1759913   0.4282188\n   0.9819497  -0.45580125 -0.38392237 -1.5210693  -0.7199145   1.8353657\n   0.36534822  1.8947837   0.59909433  0.759741   -0.04659576  0.19080366\n  -1.063112    0.6097067   0.1594699  -0.8159646   1.0228577  -0.03011172\n   0.00646799  1.2589688   0.44356945  0.25115746 -0.81815207  1.6016827\n   0.5401112  -0.50891143  0.6919001  -0.60184973]], shape=(5, 40), dtype=float32)\npred = tf.Tensor(\n[[ 0.7109847  -1.1166623  -0.33448496 -1.1876948  -0.719858   -0.99993867]\n [-1.7454767   0.6041826   2.6396697  -1.1876948  -0.719858   -0.99993867]\n [-1.1876948  -0.719858   -0.99993867 -1.1876948  -0.719858   -0.99993867]\n [ 0.5971293  -0.45427606 -1.7764289  -1.1876948  -0.719858   -0.99993867]\n [ 0.07867169 -0.03141894  1.7049237  -1.1876948  -0.719858   -0.99993867]], shape=(5, 6), dtype=float32)\ntf.Tensor(10, shape=(), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef _contrastive_get_examples(task_y_true, domain_y_true, z_output, task_y_pred, domain_generalization,\n                              pseudo_label_target):\n    if domain_generalization:\n        nontarget = tf.range(0, tf.shape(domain_y_true)[0])[:, tf.newaxis]\n    else:\n        nontarget = tf.where(tf.not_equal(domain_y_true, 0))\n\n    y = tf.gather(task_y_true, nontarget, axis=0)\n    d = tf.gather(domain_y_true, nontarget, axis=0)\n    z = tf.gather(z_output, nontarget, axis=0)\n    pred = tf.gather(task_y_pred, nontarget, axis=0)\n\n    y = tf.reshape(y, [-1, 1])\n\n    if pseudo_label_target and not domain_generalization:\n        target = tf.where(tf.equal(domain_y_true, 0))\n        target_y = tf.gather(task_y_pred, target, axis=0)\n        target_y = tf.argmax(tf.nn.softmax(target_y), axis=-1, output_type=tf.int32)\n        target_y = tf.cast(target_y, dtype=task_y_true.dtype)\n        target_y = tf.reshape(target_y, [-1, 1])\n\n        target_d = tf.gather(domain_y_true, target, axis=0)\n        target_z = tf.gather(z_output, target, axis=0)\n        target_pred = tf.gather(task_y_pred, target, axis=0)\n\n        y = tf.concat([y, target_y], axis=0)\n        d = tf.concat([d, target_d], axis=0)\n        z = tf.concat([z, target_z], axis=0)\n        pred = tf.concat([pred, target_pred], axis=0)\n\n    y = tf.reshape(y, [-1])\n    d = tf.reshape(d, [-1])\n    z = tf.reshape(z, [tf.shape(z)[0], -1])\n    pred = tf.reshape(pred, [tf.shape(pred)[0], -1])\n    num_total = tf.shape(y)[0]\n\n    return (y, d, z, pred, num_total)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(5, 50)\n        feature_dim = np.random.randint(10, 100)\n        num_classes = np.random.randint(2, 10)\n        domain_classes = np.random.randint(2, 5)\n\n        # Generate random tensors\n        task_y_true = tf.random.uniform(shape=(batch_size, 1), minval=0, maxval=num_classes, dtype=tf.int32)\n        domain_y_true = tf.random.uniform(shape=(batch_size, 1), minval=0, maxval=domain_classes, dtype=tf.int32)\n        z_output = tf.random.normal(shape=(batch_size, feature_dim))\n        task_y_pred = tf.random.normal(shape=(batch_size, num_classes))\n\n        domain_generalization = np.random.choice([True, False])\n        pseudo_label_target = np.random.choice([True, False])\n\n        test_cases.append(\n            (task_y_true, domain_y_true, z_output, task_y_pred, domain_generalization, pseudo_label_target))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_29", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a keypoint detection model using Mask R-CNN. The function will take in various parameters related to the predicted and target keypoints, as well as their associated weights and class IDs. The goal is to calculate a loss value that can be used to train the model effectively.\n\nFunction signature:\n```python\ndef test_keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids,\n                                        pred_keypoint_logits, num_keypoints, mask_shape):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `0.0`, which is returned in cases where there are no positive keypoints.\n\nInput format:\n- `target_keypoints`: A tensor representing the target keypoints for each instance.\n- `target_keypoint_weights`: A tensor representing the weights for each target keypoint.\n- `target_class_ids`: A tensor representing the class IDs for each instance.\n- `pred_keypoint_logits`: A tensor representing the predicted keypoint logits from the model.\n- `num_keypoints`: An integer representing the number of keypoints.\n- `mask_shape`: A tuple representing the shape of the mask.\n\nOutput format:\n- The function returns a tensor representing the computed loss value for the keypoint detection model.\n\nInput:\n```python\ntarget_keypoints = np.array([[10, 15, 20], [5, 8, 12]], dtype=np.int32)\ntarget_keypoint_weights = np.array([[1, 0, 1], [1, 1, 0]], dtype=np.int32)\ntarget_class_ids = np.array([1, 0], dtype=np.int32)\npred_keypoint_logits = np.random.randn(2, 3, 64).astype(np.float32)\nnum_keypoints = 3\nmask_shape = (8, 8)\n```\n\nOutput:\n```python\ntf.Tensor(4.2732887, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef test_keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids,\n                                        pred_keypoint_logits, num_keypoints, mask_shape):\n    K = tf.keras.backend\n    KL = tf.keras.layers\n    pred_keypoint_logits = KL.Lambda(lambda x: x, name='pred_keypoint')(pred_keypoint_logits)\n    target_keypoints = KL.Lambda(lambda x: x, name='target_keypoint')(target_keypoints)\n\n    target_class_ids = KL.Lambda(lambda x: K.reshape(x, (-1,)), name='target_class_ids_reshape')(target_class_ids)\n    target_keypoints = KL.Lambda(lambda x: K.reshape(x, (-1, num_keypoints)), name='target_keypoint_reshape')(\n        target_keypoints)\n    target_keypoint_weights = KL.Lambda(lambda x: K.reshape(x, (-1, num_keypoints)),\n                                        name='target_keypoint_weights_reshape')(target_keypoint_weights)\n    pred_keypoints_logits = KL.Lambda(lambda x: K.reshape(x, (-1, num_keypoints, mask_shape[0] * mask_shape[1])),\n                                      name='pred_keypoint_reshape')(pred_keypoint_logits)\n\n    positive_people_ix = KL.Lambda(lambda x: tf.where(x > 0)[:, 0], name='positive_people_ix')(target_class_ids)\n    positive_target_keypoints = KL.Lambda(lambda x: tf.gather(x[0], tf.cast(x[1], tf.int64)),\n                                          name='positive_target_keypoints')([target_keypoints, positive_people_ix])\n    positive_keypoint_weights = KL.Lambda(lambda x: tf.cast(tf.gather(x[0], tf.cast(x[1], tf.int64)), tf.int64),\n                                          name='positive_keypoint_weights')(\n        [target_keypoint_weights, positive_people_ix])\n    positive_pred_keypoints_logits = KL.Lambda(lambda x: tf.gather(x[0], tf.cast(x[1], tf.int64)),\n                                               name='positive_pred_keypoint_masks')(\n        [pred_keypoints_logits, positive_people_ix])\n\n    positive_target_keypoints = tf.cast(positive_target_keypoints, tf.int32)\n    loss = KL.Lambda(lambda x: K.switch(tf.size(x[0]) > 0, lambda: tf.nn.sparse_softmax_cross_entropy_with_logits(\n        labels=tf.cast(x[0], tf.int32), logits=x[1]), lambda: tf.constant(0.0)), name='soft_loss')(\n        [positive_target_keypoints, positive_pred_keypoints_logits])\n\n    loss = KL.Lambda(lambda x: x * tf.cast(positive_keypoint_weights, tf.float32), name='positive_loss')(loss)\n    num_valid = KL.Lambda(lambda x: tf.reduce_sum(tf.cast(x, tf.float32)), name='num_valid')(positive_keypoint_weights)\n    loss = KL.Lambda(lambda x: K.switch(x[1] > 0, lambda: tf.reduce_sum(x[0]) / x[1], lambda: tf.constant(0.0)),\n                     name='keypoint_loss')([loss, num_valid])\n\n    return loss", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_keypoints = np.random.randint(5, 21)\n        mask_shape = (np.random.randint(28, 65), np.random.randint(28, 65))\n        batch_size = np.random.randint(1, 33)\n        target_keypoints = np.random.randint(0, mask_shape[0] * mask_shape[1],\n                                             size=(batch_size, num_keypoints)).astype(np.int32)\n        target_keypoint_weights = np.random.randint(0, 2, size=(batch_size, num_keypoints)).astype(np.int32)\n        target_class_ids = np.random.randint(0, 3, size=(batch_size,)).astype(np.int32)\n        pred_keypoint_logits = np.random.randn(batch_size, num_keypoints, mask_shape[0] * mask_shape[1]).astype(\n            np.float32)\n\n        test_cases.append((target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoint_logits,\n                           num_keypoints, mask_shape))\n\n    return test_cases"}
{"problem_id": "tensorflow_30", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that prepares data for a machine learning model by combining multiple data sources and a target dataset. The function will ensure that the data is structured correctly and that the modalities from the source datasets align with the target dataset.\n\nFunction signature:\n```python\ndef prepare_data(data_sources, data_target, shared_modalities):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0`, which is used in the context of accessing the first element of the `data_sources` and `data_target`.\n\n\nInput format:\n- `data_sources`: A list of tuples, where each tuple contains:\n  - A list of feature tensors (modalities).\n  - A tensor of labels.\n  - A tensor of domain labels.\n  - A list of example IDs.\n- `data_target`: A tuple containing:\n  - A list of feature tensors (modalities).\n  - A tensor of labels.\n  - A tensor of domain labels.\n  - A list of example IDs.\n- `shared_modalities`: A list of integers representing the indices of the modalities that are shared between the source and target datasets.\n\nOutput format:\n- The function returns a tuple containing:\n  - A list of concatenated feature tensors for the shared modalities.\n  - A tensor of task labels.\n  - A tensor of domain labels.\n\n**Input:**\n```python\ndata_sources = (\n    [\n        [tf.constant([[0.1, 0.2], [0.3, 0.4]]), tf.constant([[0.5, 0.6], [0.7, 0.8]])],  # Source 1\n        [tf.constant([[0.9, 1.0], [1.1, 1.2]]), tf.constant([[1.3, 1.4], [1.5, 1.6]])]   # Source 2\n    ],\n    [\n        tf.constant([[1], [0]]),  # Labels for Source 1\n        tf.constant([[1], [0]])   # Labels for Source 2\n    ],\n    [\n        tf.constant([[0], [0]]),  # Domains for Source 1\n        tf.constant([[1], [1]])   # Domains for Source 2\n    ],\n    [\n        tf.constant([0, 1]),  # Example IDs for Source 1\n        tf.constant([0, 1])   # Example IDs for Source 2\n    ]\n)\n\ndata_target = (\n    [tf.constant([[2.0, 2.1], [2.2, 2.3]])],  # Target data\n    tf.constant([[0], [1]]),  # Target labels\n    tf.constant([[0], [0]]),  # Target domains\n    tf.constant([0, 1])        # Target example IDs\n)\n\nshared_modalities = [0, 1]\n```\n\n**Output:**\n```python\nxs, task_y_true, domain_y_true = prepare_data(data_sources, data_target, shared_modalities)\n\n# xs\n[<tf.Tensor: shape=(6, 2), dtype=float32, numpy=\narray([[0.1, 0.2],\n       [0.3, 0.4],\n       [0.9, 1. ],\n       [1.1, 1.2],\n       [2. , 2.1],\n       [2.2, 2.3]], dtype=float32)>, <tf.Tensor: shape=(6, 2), dtype=float32, numpy=\narray([[0.5, 0.6],\n       [0.7, 0.8],\n       [1.3, 1.4],\n       [1.5, 1.6],\n       [3. , 3.1],\n       [3.2, 3.3]], dtype=float32)>]\n\n# task_y_true\ntf.Tensor(\n[[1]\n [0]\n [1]\n [0]\n [0]\n [0]], shape=(6, 1), dtype=int32)\n# domain_y_true\ntf.Tensor(\n[[0]\n [0]\n [1]\n [1]\n [0]\n [0]], shape=(6, 1), dtype=int32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\ndef get_num_modalities(target_dataset, source_datasets):\n    if not source_datasets:\n        return None, None\n\n    source_num_modalities = len(source_datasets[0])\n    for other_source in source_datasets[1:]:\n        if len(other_source) != source_num_modalities:\n            return None, None\n\n    target_num_modalities = len(target_dataset) if target_dataset else None\n    return source_num_modalities, target_num_modalities\n\n\n# main code\ndef prepare_data(data_sources, data_target, shared_modalities):\n\n    xs_a, y_a, domain_a, example_ids_a = data_sources\n    xs_b, y_b, domain_b, example_ids_b = data_target\n    source_num_modalities, target_num_modalities = get_num_modalities(data_target[0], data_sources[0])\n\n    xs_a = [tf.concat([x[i] for x in xs_a], axis=0) for i in range(source_num_modalities)]\n    y_a = tf.concat(y_a, axis=0)\n    domain_a = tf.concat(domain_a, axis=0)\n\n    xs = [tf.concat((xs_a[m], xs_b[m]), axis=0) for m in shared_modalities]\n    task_y_true = tf.concat((y_a, tf.zeros_like(y_b)), axis=0)\n    domain_y_true = tf.concat((domain_a, domain_b), axis=0)\n\n    return xs, task_y_true, domain_y_true", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    class MockDataset:\n        def __init__(self, num_modalities, batch_size, feature_shape):\n            self.num_modalities = num_modalities\n            self.data = [tf.random.uniform((batch_size, *feature_shape)) for _ in range(num_modalities)]\n            self.labels = tf.random.uniform((batch_size, 1))\n            self.domains = tf.random.uniform((batch_size, 1))\n            self.example_ids = tf.range(batch_size)\n\n\n    test_cases = []\n    for _ in range(n):\n        num_modalities = np.random.randint(1, 5)\n        batch_size_source = np.random.randint(5, 20)\n        batch_size_target = np.random.randint(5, 20)\n        feature_shape = (np.random.randint(4, 10), np.random.randint(4, 10))\n\n        num_sources = np.random.randint(1, 4)\n        source_datasets = [MockDataset(num_modalities, batch_size_source, feature_shape) for _ in range(num_sources)]\n        target_dataset = MockDataset(num_modalities, batch_size_target, feature_shape)\n\n        data_sources = (\n            [ds.data for ds in source_datasets],\n            [ds.labels for ds in source_datasets],\n            [ds.domains for ds in source_datasets],\n            [ds.example_ids for ds in source_datasets]\n        )\n\n        data_target = (\n            target_dataset.data,\n            target_dataset.labels,\n            target_dataset.domains,\n            target_dataset.example_ids\n        )\n\n        shared_modalities = list(range(num_modalities))\n        test_cases.append((data_sources, data_target, shared_modalities))\n\n    return test_cases"}
{"problem_id": "tensorflow_31", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs floor division in a way that is compatible with the ONNX (Open Neural Network Exchange) standard. The function should handle both positive and negative integers correctly, ensuring that the result follows the mathematical definition of floor division.\n\nFunction signature:\n```python\ndef onnx_compat_floor_div(a, b):\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the main code.\n\nInput format:\n- The function accepts two tensor inputs, `a` and `b`, which can be of any shape and must contain integer values.\n\nOutput format:\n- The function returns a tensor of the same shape as the inputs, containing the results of the floor division operation performed according to the ONNX compatibility rules.\n\nInput:\n```python\na = tf.convert_to_tensor([[3, -8], [7, -2]], dtype=tf.int32)\nb = tf.convert_to_tensor([[2, 3], [4, 5]], dtype=tf.int32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[ 1 -4]\n [ 1 -2]], shape=(2, 2), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef onnx_compat_floor_div(a, b):\n    (abs_a, abs_b) = (tf.abs(a), tf.abs(b))\n    return tf.where(a * b >= 0, a // b, -abs_a // abs_b - tf.cast(abs_a % abs_b != 0, dtype=a.dtype))", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = np.random.randint(0, 4)\n        shape = tuple(np.random.randint(1, 5, size=rank))\n\n\n        a = tf.convert_to_tensor(np.random.randint(-10, 10, size=shape, dtype=np.int32))\n        b = tf.convert_to_tensor(np.random.randint(1, 10, size=shape, dtype=np.int32))\n\n        test_cases.append((a, b))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_32", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that generates permutations of nodes in a graph based on a given number of nodes. The function should be able to handle multiple graphs and return the permutations of nodes for each graph in a structured format.\n\nFunction signature:\n```python\ndef senders_receivers(n_node):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `2`, which represents the default number of times permutations are generated.\n\nInput format:\n- The input to the function `senders_receivers` is a tensor `n_node`, which is a 1D tensor representing the number of nodes in each graph.\n\nOutput format:\n- The output of the function is a tuple of two tensors. The first tensor contains the first elements of the permutations, and the second tensor contains the second elements of the permutations. Both tensors are structured based on the permutations generated for the input graphs.\n\n**Input:**\n```python\ntf.constant([3, 2, 4], dtype=tf.int32)\n```\n\n**Output:**\n```python\n(\n    tf.Tensor([0 0 0 1 1 1 2 2 2 3 3 4 4 5 5 5 5 6 6 6 6 7 7 7 7 8 8 8 8], shape=(29,), dtype=int32),\n    tf.Tensor([0 1 2 0 1 2 0 1 2 3 4 3 4 5 6 7 8 5 6 7 8 5 6 7 8 5 6 7 8], shape=(29,), dtype=int32)\n)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef cartesian_graph(a):\n    tile_a = tf.expand_dims(tf.tile(tf.expand_dims(a[0], 1), [1, tf.shape(a[1])[0]]), 2)\n    tile_b = tf.expand_dims(tf.tile(tf.expand_dims(a[1], 0), [tf.shape(a[0])[0], 1]), 2)\n    cart = tf.concat([tile_a, tile_b], axis=2)\n    cart = tf.reshape(cart, [-1, 2])\n    for c in a[2:]:\n        tile_c = tf.tile(tf.expand_dims(c, 1), [1, tf.shape(cart)[0]])\n        tile_c = tf.expand_dims(tile_c, 2)\n        tile_c = tf.reshape(tile_c, [-1, 1])\n        cart = tf.tile(cart, [tf.shape(c)[0], 1])\n        cart = tf.concat([tile_c, cart], axis=1)\n    return cart\n\ndef permutations(a, times=2):\n    options = tf.range(tf.shape(a)[0])\n    indices = cartesian_graph([options for _ in range(times)])\n    return tf.gather(a, indices)\n\n# main code\ndef senders_receivers(n_node):\n    def body(i, n_node_lower, n_node_cum, output):\n        n_node_upper = n_node_cum[i]\n        output = output.write(i, permutations(tf.range(n_node_lower, n_node_upper)))\n        return (i + 1, n_node_cum[i], n_node_cum, output)\n\n    num_graphs = tf.shape(n_node)[0]\n    loop_condition = lambda i, *_: tf.less(i, num_graphs)\n    initial_loop_vars = [0, 0, tf.cumsum(n_node), tf.TensorArray(dtype=tf.int32, size=num_graphs, infer_shape=False)]\n    _, _, _, output = tf.while_loop(loop_condition, body, initial_loop_vars, back_prop=False)\n    output = output.concat()\n\n    return output[..., 0], output[..., 1]", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_graphs = np.random.randint(1, 11)\n        n_node = np.random.randint(1, 51, size=(num_graphs,)).astype(np.int32)\n        n_node_tensor = tf.convert_to_tensor(n_node, dtype=tf.int32)\n\n        test_cases.append(n_node_tensor)\n\n    return test_cases\n"}
{"problem_id": "tensorflow_33", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a Region Proposal Network (RPN) in a deep learning model. The function will evaluate the classification loss based on the predicted class logits and the ground truth labels for the anchors.\n\nFunction signature:\n```python\ndef rpn_class_loss_graph(rpn_match, rpn_class_logits):\n```\n\nConstant used in the main code:\n- `0.0`: This constant is used to return a loss of zero when there are no valid entries in the loss calculation.\n\nInput format:\n- `rpn_match`: A tensor of shape (N, 1) containing the ground truth labels for the anchors, where N is the number of anchors.\n- `rpn_class_logits`: A tensor of shape (N, num_classes) containing the predicted class logits for the anchors.\n\nOutput format:\n- A scalar tensor representing the computed classification loss for the RPN.\n\nInput:\n```python\nrpn_match = tf.constant([[[ 1], [ 0], [-1], [ 1], [ 0]], \n                          [[-1], [ 1], [ 0], [-1], [ 1]]], dtype=tf.int32)\n\nrpn_class_logits = tf.constant([[[ 0.5, -0.2], [ 0.1, 0.3], [-0.5, 0.2], [ 0.4, -0.1], [ 0.2, 0.1]], \n                                 [[-0.3, 0.4], [ 0.6, -0.5], [ 0.1, 0.2], [-0.1, 0.3], [ 0.5, -0.4]]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(1.1178771, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef rpn_class_loss_graph(rpn_match, rpn_class_logits):\n    K = tf.keras.backend\n    rpn_match = tf.squeeze(rpn_match, -1)\n    anchor_class = K.cast(K.equal(rpn_match, 1), tf.int32)\n    indices = tf.where(K.not_equal(rpn_match, 0))\n    rpn_class_logits = tf.gather_nd(rpn_class_logits, indices)\n    anchor_class = tf.gather_nd(anchor_class, indices)\n    loss = K.sparse_categorical_crossentropy(target=anchor_class, output=rpn_class_logits, from_logits=True)\n    loss = K.switch(tf.size(loss) > 0, K.mean(loss), tf.constant(0.0))\n    return loss", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        num_anchors = np.random.randint(10, 1000)\n        rpn_match = np.random.choice([-1, 0, 1], size=(batch_size, num_anchors, 1), p=[0.3, 0.4, 0.3])\n        rpn_class_logits = np.random.randn(batch_size, num_anchors, 2).astype(np.float32)\n        rpn_match_tensor = tf.convert_to_tensor(rpn_match, dtype=tf.int32)\n        rpn_class_logits_tensor = tf.convert_to_tensor(rpn_class_logits, dtype=tf.float32)\n\n        test_cases.append((rpn_match_tensor, rpn_class_logits_tensor))\n\n    return test_cases"}
{"problem_id": "tensorflow_34", "library": "tensorflow", "code_problem": "You are tasked with implementing a function to calculate the accuracy between two sets of predictions and their corresponding true values using TensorFlow. The function should be defined as follows:\n\n```python\ndef accuracy(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- The constant `1` is added to both the numerator and denominator to avoid division by zero.\n\nInput format:\n- The function takes two arguments:\n  - `y_true`: A tensor representing the true values.\n  - `y_pred`: A tensor representing the predicted values.\n\nOutput format:\n- The function returns a single scalar value representing the accuracy between the predicted and true values.\n\nInput:\n```python\ny_true = tf.convert_to_tensor([[0.5, 0.2, 0.1], [0.3, 0.4, 0.6]], dtype=tf.float32)\ny_pred = tf.convert_to_tensor([[0.4, 0.3, 0.2], [0.5, 0.1, 0.7]], dtype=tf.float32)\n```\n\nOutput:\n```python\naccuracy_value = accuracy(y_true, y_pred)\n# tf.Tensor(0.04198581, shape=(), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef accuracy(y_true, y_pred):\n    denom = tf.sqrt(tf.reduce_sum(tf.pow(y_pred, 2), axis=[0, 1]) * tf.reduce_sum(tf.pow(y_true, 2), axis=[0, 1]))\n    return 1 - (tf.reduce_sum(y_pred * y_true, axis=[0, 1]) + 1) / (denom + 1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(5, 101)\n        feature_dim = np.random.randint(5, 51)\n\n        y_true = tf.convert_to_tensor(np.random.randn(batch_size, feature_dim), dtype=tf.float32)\n        y_pred = tf.convert_to_tensor(np.random.randn(batch_size, feature_dim), dtype=tf.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_35", "library": "tensorflow", "code_problem": "The task is to implement a function that computes the loss for a keypoint detection model using Mask R-CNN. The function will take in the target keypoints, their weights, class IDs, predicted keypoints logits, a flag for weighted loss, the shape of the mask, and the number of keypoints. The function will return the computed loss value.\n\nFunction signature:\n```python\ndef keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoints_logit,\n                                   weight_loss, mask_shape, number_point):\n```\n\nConstant used in the main code:\n- The constant `0.0` is used to represent a zero loss when there are no positive keypoints.\n\nInput format:\n- `target_keypoints`: A tensor of shape (N, number_point, 2) representing the ground truth keypoints.\n- `target_keypoint_weights`: A tensor of shape (N, number_point) representing the weights for each keypoint.\n- `target_class_ids`: A tensor of shape (N,) representing the class IDs for each instance.\n- `pred_keypoints_logit`: A tensor of shape (N, number_point, mask_shape[0] * mask_shape[1]) representing the predicted logits for keypoints.\n- `weight_loss`: A boolean indicating whether to apply weighted loss.\n- `mask_shape`: A tuple representing the shape of the mask (height, width).\n- `number_point`: An integer representing the number of keypoints.\n\nOutput format:\n- The function returns a tensor of shape (1, 1) representing the computed loss value.\n\n**Input:**\n```python\ntarget_keypoints = np.array([[5, 10, 15], [2, 3, 4]])\ntarget_keypoint_weights = np.array([[1.0, 0.5, 0.0], [1.0, 1.0, 0.0]])\ntarget_class_ids = np.array([[1], [0]])\npred_keypoints_logit = np.array([[[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n                                   [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n                                   [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0]]])\nweight_loss = True\nmask_shape = (10, 10)\nnumber_point = 3\n```\n\n**Output:**\n```python\nloss = keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids,\n                                       pred_keypoints_logit, weight_loss, mask_shape, number_point)\n# The expected output will be a tensor with shape (1, 1) containing the computed loss value.\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoints_logit,\n                                   weight_loss, mask_shape, number_point):\n    K = tf.keras.backend\n    target_class_ids = K.reshape(target_class_ids, (-1,))\n    positive_people_ix = tf.where(target_class_ids > 0)[:, 0]\n    target_keypoint_weights = K.reshape(target_keypoint_weights, (-1, number_point))\n    target_keypoints = K.reshape(target_keypoints, (-1, number_point))\n    pred_keypoints_logit = K.reshape(pred_keypoints_logit, (-1, number_point, mask_shape[0] * mask_shape[1]))\n\n    positive_target_keypoints = tf.cast(tf.gather(target_keypoints, positive_people_ix), tf.int32)\n    positive_pred_keypoints_logit = tf.gather(pred_keypoints_logit, positive_people_ix)\n    positive_keypoint_weights = tf.cast(tf.gather(target_keypoint_weights, positive_people_ix), tf.float32)\n\n    loss = K.switch(\n        tf.size(positive_target_keypoints) > 0,\n        lambda: tf.nn.sparse_softmax_cross_entropy_with_logits(\n            logits=positive_pred_keypoints_logit, labels=positive_target_keypoints\n        ),\n        lambda: tf.constant(0.0)\n    )\n\n    loss *= positive_keypoint_weights\n\n    if weight_loss:\n        loss = K.switch(\n            tf.reduce_sum(positive_keypoint_weights) > 0,\n            lambda: tf.reduce_sum(loss) / tf.reduce_sum(positive_keypoint_weights),\n            lambda: tf.constant(0.0)\n        )\n    else:\n        loss = K.mean(loss)\n\n    return tf.reshape(loss, [1, 1])", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        number_point = np.random.randint(5, 20)\n        mask_shape = (np.random.randint(10, 30), np.random.randint(10, 30))\n        weight_loss = np.random.choice([True, False])\n        target_keypoints = np.random.randint(0, mask_shape[0] * mask_shape[1],\n                                             size=(batch_size, number_point))\n        target_keypoint_weights = np.random.rand(batch_size, number_point).astype(np.float32)\n        target_class_ids = np.random.randint(0, 2, size=(batch_size, 1))  # Binary class IDs\n        pred_keypoints_logit = np.random.randn(batch_size, number_point, mask_shape[0] * mask_shape[1]).astype(\n            np.float32)\n\n        test_cases.append((target_keypoints, target_keypoint_weights, target_class_ids,\n                           pred_keypoints_logit, weight_loss, mask_shape, number_point))\n\n    return test_cases"}
{"problem_id": "tensorflow_36", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes edge features for a set of vertices in a spatial context. The function will identify neighboring vertices and calculate the differences between each vertex and its neighbors, ultimately returning a tensor that represents these edge features.\n\nFunction Signature:\n```python\ndef edge_features(vertices_in, num_neighbors):\n```\n\nConstant Used:\n- The constant `k` is set to `10` in the `indexing_tensor` function, which defines the maximum number of neighbors to consider.\n\nInput Format:\n- The input `vertices_in` is a tensor of shape `[batch_size, num_vertices, feature_dimension]`.\n- The input `num_neighbors` is an integer.\n\nOutput Format:\n- The output is a tensor of shape `[batch_size, num_vertices, num_neighbors, feature_dimension * 2]`, where each entry contains the original vertex features and the differences to its neighbors.\n\n```python\n# Input\nspatial_features = tf.constant([[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]], \n                                 [[0.7, 0.8], [0.9, 1.0], [1.1, 1.2]]], dtype=tf.float32)\nk = 2\n\n# Output\nindexing_tensor_output, distance_matrix_output = indexing_tensor(spatial_features, k)\n# indexing_tensor_output: \ntf.Tensor(\n[[[[0 0]\n   [0 1]]\n  [[0 1]\n   [0 2]]\n  [[0 2]\n   [0 1]]]\n [[[1 0]\n   [1 1]]\n  [[1 1]\n   [1 0]]\n  [[1 2]\n   [1 1]]]], shape=(2, 3, 2, 2), dtype=int64)\n\n\n# distance_matrix_output: \n[[[7.4505806e-09 7.9999983e-02]\n  [0.0000000e+00 7.9999983e-02]\n  [0.0000000e+00 7.9999983e-02]]\n [[0.0000000e+00 7.9999804e-02]\n  [0.0000000e+00 7.9999804e-02]\n  [0.0000000e+00 7.9999924e-02]]], shape=(2, 3, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef indexing_tensor(spatial_features, k=10):\n    shape_spatial_features = tf.shape(spatial_features)\n    n_batch = shape_spatial_features[0]\n    n_max_entries = shape_spatial_features[1]\n\n    neighbor_matrix, distance_matrix = nearest_neighbor_matrix(spatial_features, k)\n    batch_range = tf.range(n_batch)\n    batch_range = tf.reshape(batch_range, [n_batch, 1, 1, 1])\n    batch_range = tf.tile(batch_range, [1, n_max_entries, k, 1])\n\n    expanded_neighbor_matrix = tf.expand_dims(neighbor_matrix, axis=3)\n    indexing_tensor = tf.concat([batch_range, expanded_neighbor_matrix], axis=3)\n\n    return tf.cast(indexing_tensor, tf.int64), distance_matrix\n\n\ndef euclidean_squared(A, B):\n    sub_factor = -2 * tf.matmul(A, tf.transpose(B, perm=[0, 2, 1]))\n    dotA = tf.expand_dims(tf.reduce_sum(A * A, axis=2), axis=2)\n    dotB = tf.expand_dims(tf.reduce_sum(B * B, axis=2), axis=1)\n\n    return tf.abs(sub_factor + dotA + dotB)\n\n\ndef nearest_neighbor_matrix(spatial_features, k=10):\n    D = euclidean_squared(spatial_features, spatial_features)\n    D, N = tf.nn.top_k(-D, k)\n\n    return N, -D\n\n# main code\ndef edge_features(vertices_in, num_neighbors):\n    indexing, _ = indexing_tensor(vertices_in, num_neighbors)\n    neighbour_space = tf.gather_nd(vertices_in, indexing)\n\n    expanded_trans_space = tf.expand_dims(vertices_in, axis=2)\n    expanded_trans_space = tf.tile(expanded_trans_space, [1, 1, num_neighbors, 1])\n\n    diff = expanded_trans_space - neighbour_space\n    edge = tf.concat([expanded_trans_space, diff], axis=-1)\n\n    return edge", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 17)\n        num_points = np.random.randint(5, 101)\n        feature_dim = np.random.randint(2, 17)\n        k = np.random.randint(1, min(11, num_points))\n        spatial_features = tf.random.normal([batch_size, num_points, feature_dim])\n        test_cases.append((spatial_features, k))\n\n    return test_cases"}
{"problem_id": "tensorflow_37", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that serves as a discriminator in a Generative Adversarial Network (GAN) using TensorFlow. The function will process input data through a series of convolutional layers, batch normalization, activation functions, and dropout layers, ultimately producing two outputs: a discriminator output and a latent variable output.\n\nFunction signature:\n```python\ndef discriminator(x, training, latent_dim, depth, dropout, kernel_size):\n```\n\nConstants used in the main code:\n- The constant `momentum` is set to `0.9` for the BatchNormalization layers.\n- The constant `alpha` is set to `0.2` for the LeakyReLU activation function.\n- The constant `-16` is used in the Lambda layer to ensure that the log standard deviation does not fall below this threshold.\n\nInput format:\n- `x`: A tensor of shape (batch_size, height, width, channels) representing the input data.\n- `training`: A boolean indicating whether the model is in training mode.\n- `latent_dim`: An integer representing the dimensionality of the latent space.\n- `depth`: An integer representing the base depth for the convolutional layers.\n- `dropout`: A float representing the dropout rate.\n- `kernel_size`: An integer representing the size of the convolutional kernels.\n\nOutput format:\n- Returns a tuple containing:\n  - `d`: A tensor representing the discriminator output.\n  - `q`: A tensor representing the predicted latent variables, which includes both the mean and log standard deviation.\n\n**Input:**\n```python\nx = tf.random.normal((8, 64, 16, 3))  # Batch size of 8, height 64, width 16, 3 channels\ntraining = True\nlatent_dim = 32\ndepth = 64\ndropout = 0.3\nkernel_size = 5\n```\n\n**Output:**\n```python\nd, q = discriminator(x, training, latent_dim, depth, dropout, kernel_size)\n# d \ntf.Tensor(\n[[ 1.7309359 ]\n [-0.7746494 ]\n [ 0.873041  ]\n [-0.00719783]\n [ 1.6690536 ]\n [ 0.01402417]\n [ 0.11991599]\n [-0.31427974]], shape=(8, 1), dtype=float32)\n# q\n\ntf.Tensor(\n[[[[-0.7229998   0.7133567   0.40767768 -0.99923325 -0.10503822\n     0.6110139  -0.28380486 -0.892045   -1.1800506   1.8943264\n    -1.3553518  -0.45364252 -0.24649093  0.44609755 -0.09261163\n     0.39926186 -0.7400095   0.0773894  -0.27078617  0.46897075\n    -0.14324614 -0.87581664  0.24754907  1.6248446   0.67200935\n     0.24621527  0.5027378  -0.11588173  0.54309547 -0.64081\n     0.5016864   0.72958994]]\n    ...\n  [[ 0.32030478  0.98663205  0.05851567 -1.1252775   0.5966284\n     0.7445272  -0.45449197 -0.92595977 -0.39968747 -0.21980119\n    -0.7447434  -0.37110317 -0.2852335   0.31117702  0.2231994\n    -0.97212493 -1.3585898  -0.59402627  0.90703255  0.22339018\n     0.29543826 -1.3209313  -0.39604554 -0.62549436  0.01212028\n    -1.572803   -0.5149586   0.8683696   1.0919335   0.5693767\n    -0.6463584   0.96706593]]]], shape=(8, 2, 1, 32), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef discriminator(x, training, latent_dim, depth, dropout, kernel_size):\n    kernel_size = (kernel_size, kernel_size)\n\n    for i in range(1, 7):\n        x = tf.keras.layers.Conv2D(depth * (2 ** (i - 1)), kernel_size, strides=(2, 1), padding='same')(x)\n        x = tf.keras.layers.BatchNormalization(momentum=0.9)(x, training=training)\n        x = tf.keras.layers.LeakyReLU(alpha=0.2)(x)\n        x = tf.keras.layers.Dropout(dropout)(x, training=training)\n\n    x = tf.keras.layers.Flatten()(x)\n    x = tf.keras.layers.Dense(1024)(x)\n    x = tf.keras.layers.BatchNormalization(momentum=0.9)(x, training=training)\n    x = tf.keras.layers.LeakyReLU(alpha=0.2)(x)\n\n    d = tf.keras.layers.Dense(1)(x)\n    q = tf.keras.layers.Dense(latent_dim)(x)\n    q = tf.keras.layers.BatchNormalization(momentum=0.9)(q, training=training)\n    q = tf.keras.layers.LeakyReLU(alpha=0.2)(q)\n\n    q_mean = tf.keras.layers.Dense(latent_dim)(q)\n    q_logstd = tf.keras.layers.Dense(latent_dim)(q)\n    q_logstd = tf.keras.layers.Lambda(lambda x: tf.maximum(x, -16))(q_logstd)\n\n    q_mean = tf.keras.layers.Reshape((-1, 1, latent_dim))(q_mean)\n    q_logstd = tf.keras.layers.Reshape((-1, 1, latent_dim))(q_logstd)\n    q = tf.keras.layers.Concatenate(axis=1, name='predicted_latent')([q_mean, q_logstd])\n\n    return d, q", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 33)\n        height = np.random.choice([32, 64])\n        width = np.random.choice([8, 16, 32])\n        channels = np.random.choice([1, 3])\n        x = tf.random.normal((batch_size, height, width, channels))\n        training = np.random.choice([True, False])\n        latent_dim = np.random.randint(4, 64)\n        depth = np.random.choice([32, 64])\n        dropout = np.random.uniform(0.1, 0.5)\n        kernel_size = np.random.choice([3, 5, 7])\n\n        test_cases.append((x, training, latent_dim, depth, dropout, kernel_size))\n\n    return test_cases"}
{"problem_id": "tensorflow_38", "library": "tensorflow", "code_problem": "The task is to implement a function that retrieves a TensorFlow variable from a given tensor. The function should be able to identify if the input is a TensorFlow variable or tensor and return the corresponding variable if applicable.\n\nFunction signature:\n```python\ndef get_variable_from_tensor(var):\n```\n\nConstant used in the main code:\n- The function utilizes the constant `tf.compat.v1.global_variables()` to access all global variables in the TensorFlow graph.\n\nInput format:\n- The input to the function is a single argument `var`, which can be either a TensorFlow variable or tensor.\n\nOutput format:\n- The output of the function is either a TensorFlow variable if found, or `None` if no variable can be retrieved from the input tensor.\n\nInput: \n```python\nvar = tf.Variable(tf.random.uniform((3, 3)))\noutput = get_variable_from_tensor(var)\n```\n\nOutput: \n```python\n<tf.Variable 'Variable:0' shape=(3, 3) dtype=float32, numpy=...>\n```\n\n---\n\nInput: \n```python\nvar = tf.Variable(tf.random.uniform((2, 2)))\ntensor = tf.identity(var)\noutput = get_variable_from_tensor(tensor)\n```\n\nOutput: \n```python\n<tf.Variable 'Variable:0' shape=(2, 2) dtype=float32, numpy=...>\n```\n\n---\n\nInput: \n```python\nvar = tf.Variable(tf.random.uniform((4, 4)))\ntensor = var.read_value()\noutput = get_variable_from_tensor(tensor)\n```\n\nOutput: \n```python\n<tf.Variable 'Variable:0' shape=(4, 4) dtype=float32, numpy=...>\n```\n\n---\n\nInput: \n```python\nvar = tf.Variable(tf.random.uniform((5, 5)))\nhandle = var.handle\noutput = get_variable_from_tensor(handle)\n```\n\nOutput: \n```python\n<tf.Variable 'Variable:0' shape=(5, 5) dtype=float32, numpy=\narray([[0.8453101 , 0.0128175 , 0.39718747, 0.49247825, 0.28131044],\n       [0.0317173 , 0.08889663, 0.9524964 , 0.9014764 , 0.72625613],\n       [0.59266233, 0.54809046, 0.09789586, 0.6316453 , 0.33101177],\n       [0.03958642, 0.13308501, 0.6347817 , 0.25848234, 0.42362309],\n       [0.30318546, 0.6872027 , 0.7508755 , 0.2932644 , 0.7846439 ]],\n      dtype=float32)>\n\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef get_variable_from_tensor(var):\n    if isinstance(var, tf.Variable):\n        return var\n    if isinstance(var, tf.Tensor):\n        if hasattr(var, 'op') and var.op.type == 'ReadVariableOp':\n            var = var.op.inputs[0]\n        if hasattr(var, 'op') and var.op.type in {'VarHandleOp', 'VariableV2'}:\n            for v in tf.compat.v1.global_variables():\n                if v.handle == var:\n                    return v\n        if hasattr(var, 'op') and var.op.type == 'Identity':\n            var = var.op.inputs[0]\n            return get_variable_from_tensor(var)\n\n    return None", "test_script": "import tensorflow as tf\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        choice = random.choice(['variable', 'identity', 'read_variable', 'var_handle'])\n\n        var = tf.Variable(tf.random.uniform((random.randint(1, 10), random.randint(1, 10))))\n\n        if choice == 'variable':\n            test_cases.append(var)\n\n        elif choice == 'identity':\n            tensor = tf.identity(var)\n            test_cases.append(tensor)\n\n        elif choice == 'read_variable':\n            tensor = var.read_value()\n            test_cases.append(tensor)\n\n        elif choice == 'var_handle':\n            handle = var.handle\n            test_cases.append(handle)\n\n    return test_cases"}
{"problem_id": "tensorflow_39", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the softmax values of a set of logits and evaluates the accuracy of predictions against the true labels. The function should be defined as follows:\n\n```python\ndef compute_softmax_and_accuracy(logits, labels):\n```\n\nIn this function, the constant used is the TensorFlow library, specifically the `tf` module.\n\nThe input format for the function is two tensors: `logits` and `labels`. The output format is a tuple consisting of the softmax probabilities tensor and a float representing the accuracy.\n\n```python\n# Input\nlogits = np.array([[1.0, 2.0, 3.0], \n                   [1.0, 2.0, 3.0], \n                   [1.0, 2.0, 3.0]], dtype=np.float32)\nlabels = np.array([2, 1, 0], dtype=np.int32)\n\n# Output\nsoftmax_op = tf.Tensor(\n[[0.09003057 0.24472848 0.6652409 ]\n [0.09003057 0.24472848 0.6652409 ]\n [0.09003057 0.24472848 0.6652409 ]], shape=(3, 3), dtype=float32)\n\naccuracy_op = tf.Tensor(0.33333334, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef compute_softmax_and_accuracy(logits, labels):\n    softmax_op = tf.nn.softmax(logits)\n    correct_prediction_op = tf.equal(tf.argmax(softmax_op, 1), labels)\n    accuracy_op = tf.reduce_mean(tf.cast(correct_prediction_op, tf.float32))\n    return (softmax_op, accuracy_op)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 50)\n        num_classes = np.random.randint(2, 20)\n        logits = np.random.randn(batch_size, num_classes).astype(np.float32)\n        labels = np.random.randint(0, num_classes, size=(batch_size,), dtype=np.int32)\n\n        test_cases.append((logits, labels))\n\n    return test_cases"}
{"problem_id": "tensorflow_40", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that generates a sampled ground truth matrix based on a given ground truth matrix, a set of sample indices, and a mask indicating which samples are valid. The function should handle multiple batches of data and ensure that the sampled indices do not exceed the maximum number of vertices.\n\nFunction signature:\n```python\ndef generate_sampled_gt_matrix(gt_matrix, samples, predicted_flags, samples_per_vertex, max_vertices, num_batch):\n```\n\nConstants used in the main code:\n- `max_vertices`: This constant represents the maximum number of vertices that can be sampled from the ground truth matrix.\n\nInput format:\n- `gt_matrix`: A tensor representing the ground truth matrix.\n- `samples`: A tensor containing the sample indices for each vertex.\n- `predicted_flags`: A tensor indicating which samples are valid.\n- `samples_per_vertex`: An integer representing the number of samples per vertex.\n- `max_vertices`: An integer representing the maximum number of vertices.\n- `num_batch`: An integer representing the number of batches.\n\nOutput format:\n- The function returns a tensor containing the sampled ground truth matrix, where each entry corresponds to the valid samples extracted from the `gt_matrix` based on the provided indices and mask.\n\n**Input:**\n```python\ngt_matrix = tf.convert_to_tensor(\n    [[[0.1, 0.2, 0.3, 0.4, 0.5],\n      [0.6, 0.7, 0.8, 0.9, 1.0],\n      [1.1, 1.2, 1.3, 1.4, 1.5],\n      [1.6, 1.7, 1.8, 1.9, 2.0],\n      [2.1, 2.2, 2.3, 2.4, 2.5]],\n\n     [[2.6, 2.7, 2.8, 2.9, 3.0],\n      [3.1, 3.2, 3.3, 3.4, 3.5],\n      [3.6, 3.7, 3.8, 3.9, 4.0],\n      [4.1, 4.2, 4.3, 4.4, 4.5],\n      [4.6, 4.7, 4.8, 4.9, 5.0]]], dtype=tf.float32)\n\nsamples = tf.convert_to_tensor(\n    [[[0, 1, 2],\n      [1, 2, 3],\n      [2, 3, 4],\n      [3, 4, 0],\n      [4, 0, 1]]], dtype=tf.int32)\n\npredicted_flags = tf.convert_to_tensor(\n    [[1, 1, 1, 0, 0]], dtype=tf.float32)\n\nsamples_per_vertex = 3\nmax_vertices = 5\nnum_batch = 1\n```\n\n**Output:**\n```python\ngathered_gt_matrix = tf.Tensor(\n      [[[0.1 0.2 0.3]\n        [0.7 0.8 0.9]\n        [1.3 1.4 1.5]\n        [0.  0.  0. ]\n        [0.  0.  0. ]]], shape=(1, 5, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef generate_sampled_gt_matrix(gt_matrix, samples, predicted_flags, samples_per_vertex, max_vertices, num_batch):\n    mask = tf.tile(tf.expand_dims(predicted_flags, -1), [1, 1, samples_per_vertex])\n    samples = tf.cast(samples, tf.int32)\n    samples = tf.where(samples == max_vertices, tf.zeros_like(samples), samples)\n\n    y = tf.range(num_batch)[..., tf.newaxis]\n    y = tf.tile(y, [1, max_vertices])\n\n    z = tf.range(max_vertices)[tf.newaxis, ..., tf.newaxis]\n    z = tf.tile(z, [num_batch, 1, 1])\n\n    batch_range = tf.tile(y[..., tf.newaxis], [1, 1, samples_per_vertex])\n    max_vertices_range = tf.tile(z, [1, 1, samples_per_vertex])\n\n    indexing_tensor = tf.concat(\n        [batch_range[..., tf.newaxis], max_vertices_range[..., tf.newaxis], samples[..., tf.newaxis]],\n        axis=-1\n    )\n\n    gathered_gt_matrix = tf.gather_nd(gt_matrix, indexing_tensor) * mask\n    return gathered_gt_matrix", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_batch = np.random.randint(1, 10)\n        max_vertices = np.random.randint(5, 20)\n        samples_per_vertex = np.random.randint(1, 10)\n        gt_matrix = tf.convert_to_tensor(\n            np.random.rand(num_batch, max_vertices, max_vertices), dtype=tf.float32\n        )\n        samples = tf.convert_to_tensor(\n            np.random.randint(0, max_vertices + 1, size=(num_batch, max_vertices, samples_per_vertex)),\n            dtype=tf.int32\n        )\n        predicted_flags = tf.convert_to_tensor(\n            np.random.randint(0, 2, size=(num_batch, max_vertices)), dtype=tf.float32\n        )\n\n        test_cases.append((gt_matrix, samples, predicted_flags, samples_per_vertex, max_vertices, num_batch))\n\n    return test_cases"}
{"problem_id": "tensorflow_41", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs skinning transformations on a set of vertices based on joint rotations and skinning weights. The function will take in the vertices of a 3D model, the joint rotations, and the skinning weights, and will return the transformed vertices after applying the skinning process.\n\nFunction signature:\n```python\ndef call(vertices, joint_rotations, skinning_weights, dtype):\n```\n\nConstants used in the main code:\n- The constant `16` is used to reshape the joint rotations, indicating that each joint's rotation is represented by a 4x4 transformation matrix (which has 16 elements).\n\nInput format:\n- `vertices`: A tensor of shape (batch_size, num_vertices, 3) representing the 3D coordinates of the vertices.\n- `joint_rotations`: A tensor of shape (num_joints, 4, 4) representing the rotation matrices for each joint.\n- `skinning_weights`: A tensor of shape (num_vertices, num_joints) representing the weights for each vertex corresponding to each joint.\n- `dtype`: The data type for the tensors (e.g., tf.float32).\n\nOutput format:\n- Returns a tensor of shape (batch_size, num_vertices, 3) representing the transformed 3D coordinates of the vertices after applying the skinning transformations.\n\n**Input:**\n```python\nvertices = tf.constant([[[0.1, 0.2, 0.3],\n                          [0.4, 0.5, 0.6],\n                          [0.7, 0.8, 0.9]]], dtype=tf.float32)  # Shape: (1, 3, 3)\n\njoint_rotations = tf.constant([[\n    [[1.0, 0.0, 0.0, 0.0],\n     [0.0, 1.0, 0.0, 0.0],\n     [0.0, 0.0, 1.0, 0.0],\n     [0.0, 0.0, 0.0, 1.0]],\n] * 10], dtype=tf.float32)\n\nskinning_weights = tf.constant([[[0.1, 0.2, 0.3, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0, 0.0],\n                                  [0.0, 0.1, 0.2, 0.3, 0.4, 0.0, 0.0, 0.0, 0.0, 0.0],\n                                  [0.0, 0.0, 0.1, 0.2, 0.3, 0.4, 0.0, 0.0, 0.0, 0.0]]], dtype=tf.float32)  # Shape: (1, 3, 10)\n\ndtype = tf.float32\n```\n\n**Output:**\n```python\nskinned_vertices = call(vertices, joint_rotations, skinning_weights, dtype)\n# skinned_vertices\ntf.Tensor(\n[[[0.1 0.2 0.3]\n  [0.4 0.5 0.6]\n  [0.7 0.8 0.9]]], shape=(1, 3, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(vertices, joint_rotations, skinning_weights, dtype):\n    skinning_weights = tf.convert_to_tensor(skinning_weights, dtype)\n    batch_size = tf.shape(vertices)[0]\n    num_joints = tf.shape(skinning_weights)[-1]\n    num_vertices = tf.shape(vertices)[-2]\n\n    W = skinning_weights\n    if tf.rank(skinning_weights) < tf.rank(vertices):\n        W = tf.tile(tf.expand_dims(skinning_weights, axis=0), [batch_size, 1, 1])\n\n    A = tf.reshape(joint_rotations, (-1, num_joints, 16))\n    T = tf.matmul(W, A)\n    T = tf.reshape(T, (-1, num_vertices, 4, 4))\n\n    ones = tf.ones([batch_size, num_vertices, 1], dtype=dtype)\n    vertices_homo = tf.concat([vertices, ones], axis=2)\n\n    skinned_homo = tf.matmul(T, tf.expand_dims(vertices_homo, -1))\n    skinned_vertices = skinned_homo[:, :, :3, 0]\n\n    return skinned_vertices", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        num_vertices = np.random.randint(5, 20)\n        num_joints = np.random.randint(3, 10)\n\n        dtype = tf.float32 if np.random.rand() > 0.5 else tf.float64\n        vertices = tf.random.uniform(\n            shape=(batch_size, num_vertices, 3), minval=-1.0, maxval=1.0, dtype=dtype\n        )\n        joint_rotations = tf.random.uniform(\n            shape=(batch_size, num_joints, 4, 4), minval=-1.0, maxval=1.0, dtype=dtype\n        )\n        skinning_weights = tf.random.uniform(\n            shape=(batch_size, num_vertices, num_joints), minval=0.0, maxval=1.0, dtype=dtype\n        )\n        skinning_weights /= tf.reduce_sum(skinning_weights, axis=-1, keepdims=True)\n        test_cases.append((vertices, joint_rotations, skinning_weights, dtype))\n\n    return test_cases"}
{"problem_id": "tensorflow_42", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for bounding box predictions in an object detection model using the Mask R-CNN architecture. The loss function should utilize a Smooth L1 loss, which is a combination of L1 and L2 loss, to handle the differences between the predicted bounding boxes and the target bounding boxes.\n\nFunction Signature:\n```python\ndef mrcnn_bbox_loss_graph(target_bbox, target_class_ids, pred_bbox):\n```\n\nConstant Used:\n- The constant `1.0` is used to determine the threshold for the Smooth L1 loss calculation.\n\nInput Format:\n- `target_bbox`: A tensor of shape `(N, 4)` where `N` is the number of target bounding boxes, and each bounding box is represented by 4 coordinates.\n- `target_class_ids`: A tensor of shape `(N,)` containing the class IDs for each target bounding box.\n- `pred_bbox`: A tensor of shape `(M, C, 4)` where `M` is the number of predicted ROIs, `C` is the number of classes, and each bounding box is represented by 4 coordinates.\n\nOutput Format:\n- The function returns a tensor of shape `(1, 1)` representing the mean Smooth L1 loss for the selected bounding boxes.\n\n**Input:**\n```python\ntarget_bbox = np.array([[0.1, 0.2, 0.3, 0.4], \n                         [0.5, 0.6, 0.7, 0.8]], dtype=np.float32)  # Shape: (2, 4)\n\ntarget_class_ids = np.array([1, 0], dtype=np.int32)  # Shape: (2,)\n\npred_bbox = np.array([[[0.15, 0.25, 0.35, 0.45], \n                        [0.55, 0.65, 0.75, 0.85]], \n                       [[0.2, 0.3, 0.4, 0.5], \n                        [0.6, 0.7, 0.8, 0.9]]], dtype=np.float32)  # Shape: (2, 2, 4)\n```\n\n**Output:**\n```python\nloss = mrcnn_bbox_loss_graph(target_bbox, target_class_ids, pred_bbox)\n# loss\ntf.Tensor([[0.10124999]], shape=(1, 1), dtype=float32)\n```", "ground_truth_code": "import keras.backend as K\nimport tensorflow as tf\n\n\ndef smooth_l1_loss(y_true, y_pred):\n    K = tf.keras.backend\n    diff = K.abs(y_true - y_pred)\n    less_than_one = K.cast(K.less(diff, 1.0), 'float32')\n    return less_than_one * 0.5 * diff ** 2 + (1 - less_than_one) * (diff - 0.5)\n\n\n# main code\ndef mrcnn_bbox_loss_graph(target_bbox, target_class_ids, pred_bbox):\n    K = tf.keras.backend\n    target_class_ids = K.reshape(target_class_ids, (-1,))\n    target_bbox = K.reshape(target_bbox, (-1, 4))\n    pred_bbox = K.reshape(pred_bbox, (-1, K.int_shape(pred_bbox)[1], 4))\n    positive_roi_ix = tf.where(target_class_ids > 0)[:, 0]\n    positive_roi_class_ids = tf.gather(target_class_ids, positive_roi_ix)\n    num_rois, num_classes, _ = tf.shape(pred_bbox)\n    positive_roi_ix = tf.cast(positive_roi_ix, tf.int32)\n    positive_roi_class_ids = tf.cast(positive_roi_class_ids, tf.int32)\n    valid_mask = tf.logical_and(positive_roi_ix < num_rois, positive_roi_class_ids < num_classes)\n    valid_positive_roi_ix = tf.boolean_mask(positive_roi_ix, valid_mask)\n    valid_positive_roi_class_ids = tf.boolean_mask(positive_roi_class_ids, valid_mask)\n    pred_bbox_flat = tf.reshape(pred_bbox, [-1, 4])\n    flat_indices = valid_positive_roi_ix * K.int_shape(pred_bbox)[1] + valid_positive_roi_class_ids\n    pred_bbox_selected = tf.gather(pred_bbox_flat, flat_indices)\n    target_bbox_selected = tf.gather(target_bbox, valid_positive_roi_ix)\n    loss = K.switch(\n        tf.size(target_bbox_selected) > 0,\n        smooth_l1_loss(target_bbox_selected, pred_bbox_selected),\n        tf.constant(0.0)\n    )\n    return K.reshape(K.mean(loss), [1, 1])", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        num_rois = np.random.randint(1, 20)\n        num_classes = np.random.randint(2, 10)\n        target_class_ids = np.random.randint(0, num_classes, size=(num_rois,)).astype(np.int32)\n        target_bbox = np.random.rand(num_rois, 4).astype(np.float32)\n        pred_bbox = np.random.rand(num_rois, num_classes, 4).astype(np.float32)\n\n        test_cases.append((target_bbox, target_class_ids, pred_bbox))\n    return test_cases\n"}
{"problem_id": "tensorflow_43", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that rescales a given tensor and applies a shift based on a specified zero limit. The function should ensure that values in the tensor are adjusted according to whether they are non-negative or negative.\n\nFunction signature:\n```python\ndef wrap_distribution_non_zero(x, zero_limit, limit):\n```\n\nConstants used in the main code:\n- `zero_limit`: A threshold value that determines the amount of shift applied to the tensor.\n- `limit`: The maximum value that the tensor can be rescaled to.\n\n\nInput format:\n- `x`: A tensor of any shape containing float values.\n- `zero_limit`: A float value representing the minimum shift to be applied to non-negative elements.\n- `limit`: A float value representing the maximum value for rescaling.\n\nOutput format:\n- The function returns a tensor of the same shape as `x`, with values adjusted according to the rescaling and shifting logic described.\n\nInput:\n```python\nx = tf.convert_to_tensor([[0.5, -0.3], [0.1, -0.7]], dtype=tf.float32)\nzero_limit = 0.2\nlimit = 1.0\n```\n\nOutput:\n```python\ntf.Tensor(\n[[ 0.6  -0.44]\n [ 0.28 -0.76]], shape=(2, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef wrap_distribution_non_zero(x, zero_limit, limit):\n    x_rescaled = x * ((limit - zero_limit) / limit)\n    shift = tf.ones_like(x) * zero_limit\n    return x_rescaled + tf.where(tf.greater_equal(x, 0.0), shift, -shift)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(1, 5, size=np.random.randint(1, 4))\n        x = tf.convert_to_tensor(np.random.uniform(-1, 1, size=shape), dtype=tf.float32)\n        zero_limit = np.random.uniform(0.01, 1.0)\n        limit = np.random.uniform(zero_limit + 0.01, zero_limit + 2.0)\n\n        test_cases.append((x, zero_limit, limit))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_44", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that takes a 1-dimensional tensor (array) as input and returns a new tensor containing only the unique elements from the input tensor, preserving the order of their first appearance. The function should handle cases where the input tensor has only one element or is empty.\n\nFunction signature:\n```python\ndef uniq(x):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to create a tensor of ones for the purpose of calculating differences between consecutive elements.\n\nInput format:\n- The input to the function is a 1-dimensional tensor `x`.\n\nOutput format:\n- The output of the function is a 1-dimensional tensor containing the unique elements from the input tensor `x`, in the order of their first appearance.\n\n```python\nInput: tf.constant([1, 2, 2, 3, 3, 3, 4])\nOutput: tf.constant([1, 2, 3, 4])\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef uniq(x):\n    if tf.shape(x)[0] == 1:\n        return x\n\n    diffs = tf.concat([tf.ones_like(x[:1]), x[1:] - x[:-1]], axis=0)\n    nonzero_idx = tf.where(diffs != 0)\n    x_uniq = tf.gather_nd(x, nonzero_idx)\n    return x_uniq", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        length = np.random.randint(1, 101)\n        x = np.random.randint(0, 10, size=length, dtype=np.int32)\n        x_tensor = tf.convert_to_tensor(x, dtype=tf.int32)\n        test_cases.append(x_tensor)\n    return test_cases"}
{"problem_id": "tensorflow_45", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs 3D upsampling on a given tensor using the nearest neighbor method. The function should take an input tensor representing a batch of 3D images and a new size for the output images. The function will resize each image in the batch to the specified dimensions while maintaining the original aspect ratio.\n\nFunction signature:\n```python\ndef upsampling3d_nearest(input_tensor, new_size):\n```\n\nConstant used in the main code:\n- `tf.image.ResizeMethod.NEAREST_NEIGHBOR`: This constant is used to specify the nearest neighbor interpolation method for resizing images.\n\nInput format:\n- `input_tensor`: A 4D tensor of shape (batch_size, depth, height, width, channels).\n- `new_size`: A tuple of three integers representing the new dimensions (depth, height, width) for the output images.\n\nOutput format:\n- A 4D tensor of shape (batch_size, new_depth, new_height, new_width, channels) containing the upsampled images.\n\n**Input:**\n```python\ninput_tensor = tf.constant([[[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]]], dtype=tf.float32)  # Shape: (1, 2, 2, 2, 2)\nnew_size = (4, 4, 4)  # New size for upsampling\n```\n\n**Output:**\n```python\noutput_tensor = tf.Tensor(\n[[[[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]]\n [[[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]]\n [[[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]]\n [[[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.1 0.2]\n   [0.1 0.2]\n   [0.3 0.4]\n   [0.3 0.4]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]\n  [[0.5 0.6]\n   [0.5 0.6]\n   [0.7 0.8]\n   [0.7 0.8]]]], shape=(4, 4, 4, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef upsampling3d_nearest(input_tensor, new_size):\n    d, h, w = new_size\n    resized_list = []\n\n    for img in tf.unstack(input_tensor, axis=1):\n        resized_list.append(\n            tf.image.resize(\n                images=img,\n                size=[h, w],\n                method=tf.image.ResizeMethod.NEAREST_NEIGHBOR\n            )\n        )\n\n    stack_img_hw = tf.stack(resized_list, axis=1)\n    resized_list.clear()\n\n    for img in tf.unstack(stack_img_hw, axis=3):\n        resized_list.append(\n            tf.image.resize(\n                images=img,\n                size=[d, h],\n                method=tf.image.ResizeMethod.NEAREST_NEIGHBOR\n            )\n        )\n\n    return tf.stack(resized_list, axis=3)\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        depth = np.random.randint(2, 10)\n        height = np.random.randint(2, 10)\n        width = np.random.randint(2, 10)\n        channels = np.random.randint(1, 5)\n\n        new_depth = np.random.randint(depth + 1, depth * 3)\n        new_height = np.random.randint(height + 1, height * 3)\n        new_width = np.random.randint(width + 1, width * 3)\n\n        input_tensor = tf.random.uniform(\n            shape=(batch_size, depth, height, width, channels),\n            minval=0.0,\n            maxval=1.0\n        )\n        new_size = (new_depth, new_height, new_width)\n\n        test_cases.append((input_tensor, new_size))\n\n    return test_cases"}
{"problem_id": "tensorflow_46", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the Cartesian product of two tensors using TensorFlow. The function should take two input tensors and return a new tensor that represents the combination of each element from the first tensor with each element from the second tensor.\n\nFunction signature:\n```python\ndef tf_product(a, b):\n```\n\nIn this function, the following constant is used:\n- The constant `[1, tf.shape(b)[0]]` is used to determine how many times to tile the first tensor `a` along the first dimension based on the number of rows in tensor `b`.\n\nInput format:\n- The function takes two input tensors `a` and `b`, which can be of any shape.\n\nOutput format:\n- The function returns a tensor that contains the Cartesian product of the input tensors `a` and `b`. The shape of the output tensor will depend on the shapes of the input tensors.\n\n```python\n# Input\na = tf.convert_to_tensor([[0.5], [0.2]], dtype=tf.float32)  # Shape (2, 1)\nb = tf.convert_to_tensor([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0]], dtype=tf.float32)  # Shape (3, 2)\n\n# Output\noutput = tf_product(a, b)\n# Expected Output\ntf.Tensor(\n[[0.5 1.  2. ]\n [0.5 3.  4. ]\n [0.5 5.  6. ]\n [0.2 1.  2. ]\n [0.2 3.  4. ]\n [0.2 5.  6. ]], shape=(6, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tf_product(a, b):\n    tile_a = tf.tile(a, [1, tf.shape(b)[0]])\n    tile_a = tf.expand_dims(tile_a, 2)\n    tile_a = tf.reshape(tile_a, [-1, 1])\n    b = tf.tile(b, [tf.shape(a)[0], 1])\n    b = tf.concat([tile_a, b], axis=1)\n    return b", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        a_rows = np.random.randint(1, 10)\n        b_rows = np.random.randint(1, 10)\n        a = tf.convert_to_tensor(np.random.rand(a_rows, 1).astype(np.float32))\n        b = tf.convert_to_tensor(np.random.rand(b_rows, 2).astype(np.float32))\n\n        test_cases.append((a, b))\n\n    return test_cases"}
{"problem_id": "tensorflow_47", "library": "tensorflow", "code_problem": "You are tasked with implementing a function to compute the focal loss, which is commonly used in classification tasks, particularly in scenarios with class imbalance. The focal loss function helps to focus more on hard-to-classify examples by down-weighting the loss contribution from easy examples.\n\nFunction signature:\n```python\ndef focal_loss(y, logits, gamma, epsilon):\n```\n\nConstants used in the main code:\n- `epsilon`: A small constant added to the predicted probabilities to prevent logarithm of zero.\n\nInput format:\n- `y`: A tensor of shape (batch_size,) containing the true class labels.\n- `logits`: A tensor of shape (batch_size, num_classes) containing the raw output scores from the model.\n- `gamma`: A float representing the focusing parameter.\n- `epsilon`: A small float to prevent log(0).\n\nOutput format:\n- A single float value representing the computed focal loss for the batch.\n\n```python\n# Input\ny = np.array([0, 1, 2])\nlogits = np.array([[1.0, 2.0, 0.5], [0.5, 1.5, 2.5], [2.0, 0.0, 1.0]], dtype=np.float32)\ngamma = 2.0\nepsilon = 1e-7\n\n# Output\nloss = focal_loss(y, logits, gamma, epsilon)  # The expected output will be a scalar loss value\n# loss\ntf.Tensor(0.82378703, shape=(), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef focal_loss(y, logits, gamma, epsilon):\n    y = tf.cast(tf.expand_dims(y, -1), tf.int32)\n    predictions = tf.nn.softmax(logits)\n    batch_idxs = tf.range(0, tf.shape(y)[0])\n    batch_idxs = tf.expand_dims(batch_idxs, 1)\n    idxs = tf.concat([batch_idxs, y], 1)\n    y_true_pred = tf.gather_nd(predictions, idxs)\n\n    losses = tf.math.log(y_true_pred + epsilon) * tf.pow(1 - y_true_pred, gamma)\n\n    return -tf.reduce_mean(losses)\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 100)\n        num_classes = np.random.randint(2, 20)\n\n        y = np.random.randint(0, num_classes, size=(batch_size,))\n        logits = np.random.randn(batch_size, num_classes).astype(np.float32)\n        gamma = np.random.uniform(0.0, 5.0)\n        epsilon = np.random.uniform(1e-8, 1e-3)\n\n        test_cases.append((y, logits, gamma, epsilon))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_48", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a keypoint detection model using Mask R-CNN. The function will take in several parameters related to the predicted and target keypoints, as well as their associated weights and class IDs. The goal is to calculate a loss value that can be used to train the model effectively.\n\nFunction Signature:\n```python\ndef test_keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoint_logits, mask_shape, number_point):\n```\n\nConstants Used:\n- The constant `number_point` represents the number of keypoints that the model is expected to predict.\n\nInput Format:\n- `target_keypoints`: A tensor containing the ground truth keypoints for the samples.\n- `target_keypoint_weights`: A tensor containing weights for each keypoint indicating their importance.\n- `target_class_ids`: A tensor containing class IDs for each sample.\n- `pred_keypoint_logits`: A tensor containing the predicted logits for the keypoints.\n- `mask_shape`: A tuple representing the shape of the mask for the keypoints.\n- `number_point`: An integer representing the number of keypoints.\n\nOutput Format:\n- The function returns a tensor representing the computed loss value for the keypoint detection model.\n\n```python\n# Input\n(\n    np.array([[5, 12, 3], [1, 8, 15]]),  # target_keypoints\n    np.array([[1, 0, 1], [1, 1, 0]]),    # target_keypoint_weights\n    np.array([[1], [0]]),                # target_class_ids\n    np.random.randn(2, 3, 16, 16).astype(np.float32),  # pred_keypoint_logits\n    (16, 16),                            # mask_shape\n    3                                    # number_point\n)\n\n# Output\ntf.Tensor(6.5479364, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef test_keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoint_logits, mask_shape, number_point):\n    K = tf.keras.backend\n    KL = tf.keras.layers\n    pred_keypoint_logits = KL.Lambda(lambda x: x, name='pred_keypoint')(pred_keypoint_logits)\n    target_keypoints = KL.Lambda(lambda x: x, name='target_keypoint')(target_keypoints)\n    target_class_ids = KL.Lambda(lambda x: K.reshape(x, (-1,)), name='target_class_ids_reshape')(target_class_ids)\n    target_keypoints = KL.Lambda(lambda x: K.reshape(x, (-1, number_point)), name='target_keypoint_reshape')(\n        target_keypoints)\n    target_keypoint_weights = KL.Lambda(lambda x: K.reshape(x, (-1, number_point)),\n                                        name='target_keypoint_weights_reshape')(target_keypoint_weights)\n    pred_keypoints_logits = KL.Lambda(lambda x: K.reshape(x, (-1, number_point, mask_shape[0] * mask_shape[1])),\n                                      name='pred_keypoint_reshape')(pred_keypoint_logits)\n\n    positive_people_ix = KL.Lambda(lambda x: tf.where(x > 0)[:, 0], name='positive_people_ix')(target_class_ids)\n    positive_target_keypoints = KL.Lambda(lambda x: tf.gather(x[0], tf.cast(x[1], tf.int64)),\n                                          name='positive_target_keypoints')([target_keypoints, positive_people_ix])\n    positive_keypoint_weights = KL.Lambda(lambda x: tf.cast(tf.gather(x[0], tf.cast(x[1], tf.int64)), tf.int64),\n                                          name='positive_keypoint_weights')(\n        [target_keypoint_weights, positive_people_ix])\n    positive_pred_keypoints_logits = KL.Lambda(lambda x: tf.gather(x[0], tf.cast(x[1], tf.int64)),\n                                               name='positive_pred_keypoint_masks')(\n        [pred_keypoints_logits, positive_people_ix])\n\n    positive_target_keypoints = tf.cast(positive_target_keypoints, tf.int32)\n    loss = KL.Lambda(lambda x: K.switch(tf.size(x[0]) > 0,\n                                        lambda: tf.nn.sparse_softmax_cross_entropy_with_logits(\n                                            labels=tf.cast(x[0], tf.int32), logits=x[1]),\n                                        lambda: tf.constant(0.0)), name='soft_loss')(\n        [positive_target_keypoints, positive_pred_keypoints_logits])\n\n    loss = KL.Lambda(lambda x: x * tf.cast(positive_keypoint_weights, tf.float32), name='positive_loss')(loss)\n    num_valid = KL.Lambda(lambda x: tf.reduce_sum(tf.cast(x, tf.float32)), name='num_valid')(positive_keypoint_weights)\n    loss = KL.Lambda(lambda x: K.switch(x[1] > 0,\n                                        lambda: tf.reduce_sum(x[0]) / x[1],\n                                        lambda: tf.constant(0.0)), name='keypoint_loss')([loss, num_valid])\n\n    return loss", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        number_point = np.random.randint(5, 20)\n        mask_shape = (np.random.randint(8, 32), np.random.randint(8, 32))\n\n        # Generate random tensors with proper shapes\n        target_keypoints = np.random.randint(0, mask_shape[0] * mask_shape[1],\n                                             size=(batch_size, number_point)).astype(np.int32)\n        target_keypoint_weights = np.random.randint(0, 2,\n                                                    size=(batch_size, number_point)).astype(np.float32)\n        target_class_ids = np.random.randint(0, 2, size=(batch_size, 1)).astype(np.int32)\n        pred_keypoint_logits = np.random.randn(batch_size, number_point, mask_shape[0], mask_shape[1]).astype(\n            np.float32)\n\n        test_cases.append((\n                          target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoint_logits, mask_shape,\n                          number_point))\n\n    return test_cases"}
{"problem_id": "tensorflow_49", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs a specific operation on two tensors, representing a query and a set of responses. The function will compute a weighted sum of the responses based on the query, using a softmax function to determine the weights.\n\nFunction signature:\n```python\ndef integral_query_matching(r_p, u_q):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the axis parameter for tensor operations, specifically `axis=1` and `axis=2`.\n\nInput format:\n- The function takes two input tensors:\n  - `r_p`: A tensor representing the responses.\n  - `u_q`: A tensor representing the query.\n\nOutput format:\n- The function returns a tensor that represents the aggregated response based on the input query and responses.\n\nInput:\n```python\nr_p = tf.convert_to_tensor([[[0.1, 0.2, 0.3], \n                              [0.4, 0.5, 0.6], \n                              [0.7, 0.8, 0.9]], \n                             [[0.2, 0.3, 0.4], \n                              [0.5, 0.6, 0.7], \n                              [0.8, 0.9, 1.0]]], dtype=tf.float32)\n\nu_q = tf.convert_to_tensor([[0.5, 0.5, 0.5], \n                             [0.1, 0.1, 0.1]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[0.48708993 0.58708996 0.6870899 ]\n [0.51797575 0.6179757  0.71797574]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef integral_query_matching(r_p, u_q):\n    u_q_expand = tf.expand_dims(u_q, axis=1)\n    score = tf.multiply(u_q_expand, r_p)\n    logits = tf.reduce_sum(score, axis=2)\n    c = tf.nn.softmax(logits, axis=1)\n    c_expand = tf.expand_dims(c, axis=2)\n    m_1 = tf.multiply(c_expand, r_p)\n    m_1 = tf.reduce_sum(m_1, axis=1)\n    return m_1", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_items = np.random.randint(5, 20)\n        feature_dim = np.random.randint(3, 10)\n        r_p = tf.convert_to_tensor(np.random.rand(batch_size, num_items, feature_dim), dtype=tf.float32)\n        u_q = tf.convert_to_tensor(np.random.rand(batch_size, feature_dim), dtype=tf.float32)\n\n        test_cases.append((r_p, u_q))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_50", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the loss for a keypoint detection model using TensorFlow and Keras. The function will compute the loss based on the predicted keypoint classes and the target keypoint weights, which indicate the importance of each keypoint in the loss calculation.\n\nFunction signature:\n```python\ndef keypoint_weight_loss_graph(target_keypoint_weight, pred_class, target_class_ids, num_keypoints):\n```\n\nConstant used in the main code:\n- The constant `0.0` is used to return a loss value when there are no positive class instances.\n\n\nInput format:\n- `target_keypoint_weight`: A tensor of shape (N, num_keypoints) where N is the number of samples.\n- `pred_class`: A tensor of shape (N, num_keypoints, num_classes) where num_classes is the number of possible classes for each keypoint.\n- `target_class_ids`: A tensor of shape (N, num_keypoints) containing class IDs for each keypoint.\n- `num_keypoints`: An integer representing the number of keypoints.\n\nOutput format:\n- The function returns a scalar tensor representing the computed loss value.\n\n**Input:**\n```python\n(\n    tf.convert_to_tensor([[1, 0, 1], [0, 1, 1]], dtype=tf.float32),  # target_keypoint_weight\n    tf.convert_to_tensor([[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]], [[0.7, 0.8], [0.9, 1.0], [1.1, 1.2]]], dtype=tf.float32),  # pred_class\n    tf.convert_to_tensor([[0], [1]], dtype=tf.int32),  # target_class_ids\n    3  # num_keypoints\n)\n```\n\n**Output:**\n```python\ntf.Tensor(0.67773, shape=(), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef keypoint_weight_loss_graph(target_keypoint_weight, pred_class, target_class_ids, num_keypoints):\n    K = tf.keras.backend\n    target_mask_class = tf.cast(target_keypoint_weight, tf.int64)\n    target_class_ids = K.reshape(target_class_ids, (-1,))\n\n    pred_class_shape = tf.shape(pred_class)  # Use dynamic shape\n    pred_class = K.reshape(pred_class, (-1, num_keypoints, pred_class_shape[-1]))\n\n    target_mask_class = tf.cast(K.reshape(target_mask_class, (-1, num_keypoints)), tf.int64)\n\n    positive_roi_ix = tf.where(target_class_ids > 0)[:, 0]\n    target_class = tf.gather(target_mask_class, positive_roi_ix)\n    pred_class = tf.gather(pred_class, positive_roi_ix)\n\n    loss = tf.nn.sparse_softmax_cross_entropy_with_logits(labels=target_class, logits=pred_class)\n    loss = tf.reduce_mean(loss) if tf.size(target_class) > 0 else tf.constant(0.0)\n\n    return loss", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_keypoints = np.random.randint(1, 20)\n        num_classes = np.random.randint(2, 10)\n\n        target_keypoint_weight = np.random.randint(0, 2, size=(batch_size, num_keypoints))\n        pred_class = np.random.randn(batch_size, num_keypoints, num_classes).astype(np.float32)\n        target_class_ids = np.random.randint(0, num_classes, size=(batch_size, 1))\n\n        test_cases.append((\n            tf.convert_to_tensor(target_keypoint_weight, dtype=tf.float32),\n            tf.convert_to_tensor(pred_class, dtype=tf.float32),\n            tf.convert_to_tensor(target_class_ids, dtype=tf.int32),\n            num_keypoints\n        ))\n\n    return test_cases"}
{"problem_id": "tensorflow_51", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that determines the shape of a given tensor. The function should handle both fully defined shapes and dynamic shapes. The function signature is as follows:\n\n```python\ndef tf_shape(tensor, dtype):\n```\n\nIn this function, the following constant is used:\n- `dtype`: This parameter represents the desired data type for the output shape array.\n\nThe function ultimately returns a NumPy array representing the shape of the tensor, either as a fully defined shape or a dynamic shape.\n\nInput format:\n- The function takes two parameters:\n  - `tensor`: A TensorFlow tensor whose shape is to be determined.\n  - `dtype`: A TensorFlow data type that specifies the desired output data type for the shape array.\n\nOutput format:\n- The function returns a NumPy array representing the shape of the input tensor, with the data type specified by the `dtype` parameter.\n\nInput:\n```python\ntensor = tf.Tensor(\n[[0.35192716 0.17475808]\n [0.6621031  0.42397422]], shape=(2, 2), dtype=float32)\ndtype = tf.int32\n```\n\nOutput:\n```python\n[2 2]\n\n```", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\n# main code\ndef tf_shape(tensor, dtype):\n    if tensor.shape.is_fully_defined():\n        return np.array(tensor.shape.as_list(), dtype=dtype.as_numpy_dtype)\n    else:\n        return tf.shape(tensor, out_type=dtype)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        rank = np.random.randint(1, 5)\n        shape = [np.random.randint(1, 10) if np.random.rand() > 0.3 else None for _ in range(rank)]\n        if None in shape:\n            tensor = tf.Variable(tf.random.uniform([s if s is not None else 1 for s in shape], dtype=tf.float32))\n        else:\n            tensor = tf.constant(np.random.rand(*shape), dtype=tf.float32)\n        dtype = np.random.choice([tf.int32, tf.int64])\n\n        test_cases.append((tensor, dtype))\n\n    return test_cases"}
{"problem_id": "tensorflow_52", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs resampling of particles based on their weights. This is a common operation in particle filtering, where a set of particles (representing possible states) is updated based on their associated weights (representing the likelihood of each state). The function should take into account a parameter `alpha` that influences the resampling process.\n\nFunction signature:\n```python\ndef resample(particle_states: tf.Tensor, particle_weights: tf.Tensor, alpha: float) -> Tuple[tf.Tensor, tf.Tensor]:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1.0`, which is used in the calculation of `log_1_minus_alpha`.\n\nInput format:\n- `particle_states`: A 2D tensor of shape (batch_size, num_particles, state_dimension) representing the states of the particles.\n- `particle_weights`: A 2D tensor of shape (batch_size, num_particles) representing the weights of the particles.\n- `alpha`: A float value that influences the resampling process.\n\nOutput format:\n- Returns a tuple containing:\n  - `particle_states`: A 2D tensor of shape (batch_size * num_particles, state_dimension) representing the resampled states of the particles.\n  - `particle_weights`: A 2D tensor of shape (batch_size * num_particles) representing the resampled weights of the particles.\n\n```python\n# Input\nparticle_states = tf.convert_to_tensor(\n    [[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]],\n     [[0.7, 0.8], [0.9, 1.0], [1.1, 1.2]]], dtype=tf.float32)\nparticle_weights = tf.convert_to_tensor(\n    [[-0.5, -0.3, -0.2],\n     [-0.4, -0.6, -0.1]], dtype=tf.float32)\nalpha = 0.5\n\n# Output\nparticle_states, particle_weights = resample(particle_states, particle_weights, alpha)\n# particle_states\ntf.Tensor(\n[[[0.1 0.2]\n  [0.5 0.6]\n  [0.1 0.2]]\n [[0.9 1. ]\n  [1.1 1.2]\n  [0.9 1. ]]], shape=(2, 3, 2), dtype=float32)\n# particle_weights\ntf.Tensor(\n[[-0.09094644  0.06087309 -0.09094644]\n [-0.1354227   0.11515868 -0.1354227 ]], shape=(2, 3), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef resample(particle_states, particle_weights, alpha):\n    with tf.name_scope('resample'):\n        batch_size, num_particles = tf.shape(particle_states)[0], tf.shape(particle_states)[1]\n        particle_weights = particle_weights - tf.reduce_logsumexp(particle_weights, axis=-1, keepdims=True)\n        uniform_weights = tf.fill([batch_size, num_particles], -tf.math.log(tf.cast(num_particles, tf.float32)))\n\n        if alpha < 1.0:\n            log_alpha = tf.math.log(alpha)\n            log_1_minus_alpha = tf.math.log(1.0 - alpha)\n            q_weights = tf.stack([particle_weights + log_alpha, uniform_weights + log_1_minus_alpha], axis=-1)\n            q_weights = tf.reduce_logsumexp(q_weights, axis=-1)\n            q_weights = q_weights - tf.reduce_logsumexp(q_weights, axis=-1, keepdims=True)\n            particle_weights = particle_weights - q_weights\n        else:\n            q_weights = particle_weights\n            particle_weights = uniform_weights\n\n        indices = tf.cast(tf.random.categorical(q_weights, num_particles), tf.int32)\n        helper = tf.range(batch_size) * num_particles\n        indices = indices + tf.reshape(helper, [-1, 1])\n\n        reshaped_states = tf.reshape(particle_states, [batch_size * num_particles, -1])\n        particle_states = tf.gather(reshaped_states, indices=indices, axis=0)\n\n        reshaped_weights = tf.reshape(particle_weights, [batch_size * num_particles])\n        particle_weights = tf.gather(reshaped_weights, indices=indices, axis=0)\n\n        return particle_states, particle_weights", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(2, 10)\n        num_particles = np.random.randint(5, 20)\n        state_dim = np.random.randint(2, 10)\n        particle_states = tf.convert_to_tensor(\n            np.random.randn(batch_size, num_particles, state_dim).astype(np.float32)\n        )\n        raw_weights = np.random.randn(batch_size, num_particles).astype(np.float32)\n        particle_weights = tf.math.log(tf.nn.softmax(raw_weights, axis=-1))\n        alpha = np.random.uniform(0.0, 1.0)\n\n        test_cases.append((particle_states, particle_weights, alpha))\n\n    return test_cases"}
{"problem_id": "tensorflow_53", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes a specific mathematical expression involving gradients in a multi-dimensional space using TensorFlow. The function signature is as follows:\n\n```python\ndef h2(u, x, dimension):\n```\n\n### Constants:\nIn the main code, the constant used is `0.0`, which is returned in cases where certain conditions are not met.\n\n### Input and Output Format:\n- **Input**: The function takes three parameters:\n  - `u`: A tensor representing the input values.\n  - `x`: A tensor representing the variables with respect to which gradients are computed.\n  - `dimension`: An integer representing the number of dimensions to consider for gradient calculations.\n\n- **Output**: The function returns a tensor that is the square root of the computed value `ans`, or a constant tensor `0.0` if the conditions are not met.\n\n```python\n# Input\nu = tf.convert_to_tensor([[0.5], [-1.2], [0.3]], dtype=tf.float32)\nx = tf.convert_to_tensor([[1.0, 2.0], [3.0, -1.0], [0.0, 0.5]], dtype=tf.float32)\ndimension = 2\n\n# Output\noutput = h2(u, x, dimension)\n# output\ntf.Tensor(0.7702814, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef norm2_grad(u, x):\n    with tf.GradientTape() as tape:\n        tape.watch(x)\n        grad = tape.gradient(u, x)\n    return tf.reduce_sum(grad ** 2, axis=1) if grad is not None else tf.zeros_like(x[:, 0])\n\n\n# main code\ndef h2(u, x, dimension):\n    with tf.GradientTape(persistent=True) as tape:\n        tape.watch(x)\n        ans = tf.reduce_mean(u ** 2 + norm2_grad(u, x))\n        grad = tape.gradient(u, x)\n\n    if grad is not None:\n        for i in range(dimension):\n            g = tape.gradient(grad[:, i], x)\n            ans += tf.reduce_mean(tf.reduce_sum(g ** 2, axis=1)) if g is not None else 0.0\n\n    return tf.sqrt(ans) if ans is not None else tf.constant(0.0)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        dimension = np.random.randint(1, 5)\n        batch_size = np.random.randint(5, 20)\n\n        x_shape = (batch_size, dimension)\n        u_shape = (batch_size, 1)\n\n        x = tf.convert_to_tensor(np.random.randn(*x_shape), dtype=tf.float32)\n        u = tf.convert_to_tensor(np.random.randn(*u_shape), dtype=tf.float32)\n\n        test_cases.append((u, x, dimension))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_54", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates a specific loss value based on the activations of a neural network and the corresponding labels. The function should be able to handle binary classification tasks where the labels indicate the presence (1) or absence (0) of a class.\n\nFunction signature:\n```python\ndef spread_loss(labels, activations, margin):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `margin`, which is a parameter passed to the function.\n\nInput format:\n- `labels`: A list or array of integers (0 or 1) representing the class labels for each sample in the batch.\n- `activations`: A 2D list or array of floats representing the activation values for each class for each sample in the batch.\n- `margin`: A float value representing the margin used in the loss calculation.\n\nOutput format:\n- The function returns a single float value representing the computed loss based on the provided labels and activations.\n\nInput:\n```python\nlabels = np.array([[0, 1, 0], [1, 0, 0], [0, 0, 1]], dtype=np.int32)\nactivations = np.array([[0.5, 0.2, 0.1], [0.9, 0.3, 0.4], [0.0, 0.8, 0.6]], dtype=np.float32)\nmargin = 0.5\n```\n\nOutput:\n```python\ntf.Tensor(1.2900001, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef spread_loss(labels, activations, margin):\n    labels = tf.convert_to_tensor(labels, dtype=tf.int32)\n    activations = tf.convert_to_tensor(activations, dtype=tf.float32)\n\n    activations_shape = tf.shape(activations)\n    batch_size = activations_shape[0]\n    num_classes = activations_shape[1]\n\n    mask_t = tf.equal(labels, 1)\n    mask_i = tf.equal(labels, 0)\n\n    activations_t = tf.reshape(tf.boolean_mask(activations, mask_t), [batch_size, 1])\n    activations_i = tf.reshape(tf.boolean_mask(activations, mask_i), [batch_size, num_classes - 1])\n\n    gap_mit = tf.reduce_sum(tf.square(tf.nn.relu(margin - (activations_t - activations_i))))\n    return gap_mit", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(2, 20)\n        num_classes = np.random.randint(2, 10)\n        labels = np.zeros((batch_size, num_classes), dtype=np.int32)\n        for i in range(batch_size):\n            labels[i, np.random.randint(0, num_classes)] = 1\n        activations = np.random.uniform(-1, 1, (batch_size, num_classes)).astype(np.float32)\n        margin = np.random.uniform(0, 2)\n\n        test_cases.append((labels, activations, margin))\n\n    return test_cases"}
{"problem_id": "tensorflow_55", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the loss for a keypoint detection model using Mask R-CNN. The function will take in several parameters related to the target keypoints, their weights, class IDs, and the predicted keypoints logits. The loss is calculated based on the positive keypoints identified from the target class IDs, and it incorporates an option to weight the loss based on the keypoint weights.\n\nFunction signature:\n```python\ndef keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoints_logit, config):\n```\n\nConstants used in the main code:\n- `config.NUM_KEYPOINTS`: The number of keypoints that the model is expected to predict.\n- `config.KEYPOINT_MASK_SHAPE`: A tuple representing the shape of the keypoint mask.\n- `config.WEIGHT_LOSS`: A boolean indicating whether to weight the loss by the keypoint weights.\n\nInput format:\n- `target_keypoints`: A tensor of shape (N, NUM_KEYPOINTS) representing the ground truth keypoints.\n- `target_keypoint_weights`: A tensor of shape (N, NUM_KEYPOINTS) representing the weights for each keypoint.\n- `target_class_ids`: A tensor of shape (N,) representing the class IDs for each instance.\n- `pred_keypoints_logit`: A tensor of shape (N, NUM_KEYPOINTS, KEYPOINT_MASK_SHAPE[0] * KEYPOINT_MASK_SHAPE[1]) representing the predicted logits for the keypoints.\n- `config`: An object containing configuration parameters including `NUM_KEYPOINTS`, `KEYPOINT_MASK_SHAPE`, and `WEIGHT_LOSS`.\n\nOutput format:\n- The function returns a tensor of shape (1, 1) representing the computed loss value.\n\n**Input:**\n```python\ntarget_keypoints = np.array([[5, 10, 15], [20, 25, 30]])\ntarget_keypoint_weights = np.array([[1.0, 0.5, 0.0], [1.0, 1.0, 0.0]])\ntarget_class_ids = np.array([[1], [0]])\npred_keypoints_logit = np.random.randn(2, 3, 2500).astype(np.float32)  # Assuming KEYPOINT_MASK_SHAPE is (50, 50)\nconfig = Config()\nconfig.NUM_KEYPOINTS = 3\nconfig.KEYPOINT_MASK_SHAPE = (50, 50)\nconfig.WEIGHT_LOSS = True\n```\n\n**Output:**\n```python\nloss = tf.Tensor([[7.716488]], shape=(1, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef keypoint_mrcnn_mask_loss_graph(target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoints_logit, config):\n    K = tf.keras.backend\n    target_class_ids = K.reshape(target_class_ids, (-1,))\n    positive_people_ix = tf.where(target_class_ids > 0)[:, 0]\n    target_keypoint_weights = K.reshape(target_keypoint_weights, (-1, config.NUM_KEYPOINTS))\n    target_keypoints = K.reshape(target_keypoints, (-1, config.NUM_KEYPOINTS))\n    pred_keypoints_logit = K.reshape(pred_keypoints_logit, (-1, config.NUM_KEYPOINTS, config.KEYPOINT_MASK_SHAPE[0] * config.KEYPOINT_MASK_SHAPE[1]))\n    positive_target_keypoints = tf.cast(tf.gather(target_keypoints, positive_people_ix), tf.int32)\n    positive_pred_keypoints_logit = tf.gather(pred_keypoints_logit, positive_people_ix)\n    positive_keypoint_weights = tf.cast(tf.gather(target_keypoint_weights, positive_people_ix), tf.float32)\n    loss = K.switch(tf.size(positive_target_keypoints) > 0, lambda : tf.nn.sparse_softmax_cross_entropy_with_logits(logits=positive_pred_keypoints_logit, labels=positive_target_keypoints), lambda : tf.constant(0.0))\n    loss = loss * positive_keypoint_weights\n    if config.WEIGHT_LOSS:\n        loss = K.switch(tf.reduce_sum(positive_keypoint_weights) > 0, lambda : tf.reduce_sum(loss) / tf.reduce_sum(positive_keypoint_weights), lambda : tf.constant(0.0))\n    else:\n        loss = K.mean(loss)\n    loss = tf.reshape(loss, [1, 1])\n    return loss", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    class Config:\n        NUM_KEYPOINTS = np.random.randint(10, 20)\n        KEYPOINT_MASK_SHAPE = (np.random.randint(40, 60), np.random.randint(40, 60))\n        WEIGHT_LOSS = np.random.choice([True, False])\n    config = Config()\n    test_cases = []\n\n    for _ in range(n):\n        num_instances = np.random.randint(1, 10)\n        target_class_ids = np.random.randint(0, 2, size=(num_instances, 1)).astype(np.int32)\n        target_keypoints = np.random.randint(0, config.KEYPOINT_MASK_SHAPE[0] * config.KEYPOINT_MASK_SHAPE[1],\n                                             size=(num_instances, config.NUM_KEYPOINTS)).astype(np.int32)\n        target_keypoint_weights = np.random.rand(num_instances, config.NUM_KEYPOINTS).astype(np.float32)\n        pred_keypoints_logit = np.random.randn(num_instances, config.NUM_KEYPOINTS,\n                                               config.KEYPOINT_MASK_SHAPE[0] * config.KEYPOINT_MASK_SHAPE[1]).astype(\n            np.float32)\n\n        test_case = (target_keypoints, target_keypoint_weights, target_class_ids, pred_keypoints_logit, config)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "tensorflow_56", "library": "tensorflow", "code_problem": "The task is to implement a function that performs a region of interest (ROI) rotation on a feature map using quadrilateral bounding boxes. The function will take a feature map, a set of quadrilateral bounding boxes, the desired output shape, and the input shape, and will return the rotated feature map along with additional information about the non-zero indices, batch coordinates, and rotation angles.\n\nFunction signature:\n```python\ndef roi_rotate_quad(featuremap, quadboxes, shape, input_shape):\n```\n\n### Constants:\n- `eps`: A small constant value set to `1e-5` to prevent division by zero during calculations.\n\n### Input Format:\n- `featuremap`: A tensor representing the feature map from which regions will be extracted.\n- `quadboxes`: A tensor containing the quadrilateral bounding boxes defined by their corner coordinates.\n- `shape`: A tuple or list representing the desired output shape of the cropped and rotated feature map.\n- `input_shape`: A tuple or list representing the original shape of the input feature map.\n\n### Output Format:\n- Returns a tuple containing:\n  - `new_featuremap`: The rotated feature map after applying the ROI transformation.\n  - `tf_non_zero_idx`: The indices of the non-zero bounding boxes.\n  - `batch_cord`: The batch coordinates corresponding to the non-zero bounding boxes.\n  - `theta_cord`: The rotation angles for the non-zero bounding boxes.\n\n**Input:**\n```python\nimport tensorflow as tf\n\n# Test case input\nfeaturemap = tf.constant([[[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]]], dtype=tf.float32)  # Shape: (1, 2, 2, 2)\nquadboxes = tf.constant([[[0.0, 0.0, 1.0, 0.0, 1.0, 1.0, 0.0, 1.0]]], dtype=tf.float32)  # Shape: (1, 1, 8)\nshape = [2, 2]  # Output shape\ninput_shape = [1, 2, 2, 2]  # Input shape\n```\n\n**Output:**\n```python\n# Expected output (the actual values may vary due to randomness in the featuremap)\nnew_featuremap, tf_non_zero_idx, batch_cord, theta_cord = roi_rotate_quad(featuremap, quadboxes, shape, input_shape)\n\n# Example output shapes\ntf.Tensor(\n[[[[0.1        0.2       ]\n   [0.20000002 0.3       ]]\n  [[0.3        0.40000004]\n   [0.40000004 0.5       ]]]], shape=(1, 2, 2, 2), dtype=float32)\n\ntf.Tensor([[0 0]], shape=(1, 2), dtype=int64)\n\ntf.Tensor([0], shape=(1,), dtype=int32)\n\ntf.Tensor([-5.00679e-06], shape=(1,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\nimport math\n\n# main code\ndef roi_rotate_quad(featuremap, quadboxes, shape, input_shape):\n    quadboxes = tf.stop_gradient(quadboxes)\n    feature_shape = tf.shape(featuremap)\n    bboxes_shape = tf.shape(quadboxes)\n    (x1, y1, x2, y2, x3, y3, x4, y4) = tf.split(value=quadboxes, num_or_size_splits=8, axis=-1)\n    w = tf.cast(input_shape[2], tf.float32)\n    h = tf.cast(input_shape[1], tf.float32)\n    x1, x2, x3, x4 = x1 / w, x2 / w, x3 / w, x4 / w\n    y1, y2, y3, y4 = y1 / h, y2 / h, y3 / h, y4 / h\n    x_bundle = tf.concat([x1, x2, x3, x4], axis=-1)\n    y_bundle = tf.concat([y1, y2, y3, y4], axis=-1)\n    min_x, max_x = tf.reduce_min(x_bundle, -1), tf.reduce_max(x_bundle, -1)\n    min_y, max_y = tf.reduce_min(y_bundle, -1), tf.reduce_max(y_bundle, -1)\n    point_lt, point_rt = tf.concat([x1, y1], axis=-1), tf.concat([x2, y2], axis=-1)\n    point_rb, point_lb = tf.concat([x3, y3], axis=-1), tf.concat([x4, y4], axis=-1)\n    theta_vector1 = (point_rt - point_lt + point_rb - point_lb) / 2.0\n    x_vector1 = theta_vector1[:, :, 0] * (shape[1] / (max_x - min_x))\n    eps = tf.fill(tf.shape(x_vector1), 1e-5)\n    div_x_vector1 = tf.where(x_vector1 == 0, eps, x_vector1)\n    theta1 = theta_vector1[:, :, 1] / div_x_vector1 * (shape[0] / (max_y - min_y))\n    theta_vector2 = (point_rb - point_rt + point_lb - point_lt) / 2.0\n    x_vector2 = theta_vector2[:, :, 0] * (shape[1] / (max_x - min_x))\n    div_x_vector2 = tf.where(x_vector2 == 0, eps, x_vector2)\n    theta2 = theta_vector2[:, :, 1] / div_x_vector2 * (shape[0] / (max_y - min_y))\n    theta1, theta2 = tf.atan(theta1), tf.atan(theta2)\n    theta2_recal = tf.where(theta2 < 0, math.pi / 2.0 + theta2, theta2 - math.pi / 2.0)\n    theta = tf.where(tf.norm(theta_vector1, axis=-1) > tf.norm(theta_vector2, axis=-1), theta1, theta2_recal)\n    batch_size = feature_shape[0]\n    batch_linspace = tf.reshape(tf.range(0, batch_size), [-1, 1])\n    batch_idx = tf.tile(batch_linspace, [1, bboxes_shape[1]])\n    tf_non_zero_idx = tf.where(tf.logical_and(tf.not_equal(max_x - min_x, 0), tf.not_equal(max_y - min_y, 0)))\n    y1_cord, x1_cord = tf.gather_nd(min_y, tf_non_zero_idx), tf.gather_nd(min_x, tf_non_zero_idx)\n    y2_cord, x2_cord = tf.gather_nd(max_y, tf_non_zero_idx), tf.gather_nd(max_x, tf_non_zero_idx)\n    batch_cord, theta_cord = tf.gather_nd(batch_idx, tf_non_zero_idx), tf.gather_nd(theta, tf_non_zero_idx)\n    filtered_bboxes = tf.stack([y1_cord, x1_cord, y2_cord, x2_cord], axis=-1)\n    cropped = tf.image.crop_and_resize(featuremap, filtered_bboxes, batch_cord, shape)\n    cropped_shape = tf.shape(cropped)\n    theta_cord_expand = tf.tile(tf.expand_dims(theta_cord, axis=-1), [1, shape[0] * shape[1]])\n    sine, cos = tf.sin(theta_cord_expand), tf.cos(theta_cord_expand)\n    grid = tf.meshgrid(tf.linspace(-1.0, 1.0, shape[0]), tf.linspace(-1.0, 1.0, shape[1]), indexing='ij')\n    grid = tf.reshape(tf.stack(grid, axis=-1), (-1, 2))\n    grid = tf.tile(tf.expand_dims(grid, axis=0), [cropped_shape[0], 1, 1])\n    new_grid_x = grid[:, :, 1] * cos - grid[:, :, 0] * sine\n    new_grid_y = grid[:, :, 1] * sine + grid[:, :, 0] * cos\n    output = tf.reshape(tf.stack([new_grid_y, new_grid_x], axis=-1), [cropped_shape[0], shape[0], shape[1], 2])\n    height_f, width_f = tf.cast(shape[0], 'float32'), tf.cast(shape[1], 'float32')\n    new_h, new_w = (output[:, :, :, 0] + 1.0) * height_f / 2.0, (output[:, :, :, 1] + 1.0) * width_f / 2.0\n    new_h, new_w = tf.cast(tf.floor(new_h), tf.int32), tf.cast(tf.floor(new_w), tf.int32)\n    new_h = tf.clip_by_value(new_h, 0, shape[0] - 1)\n    new_w = tf.clip_by_value(new_w, 0, shape[1] - 1)\n    batch_idx = tf.reshape(tf.range(cropped_shape[0]), (cropped_shape[0], 1, 1))\n    b = tf.tile(batch_idx, (1, shape[0], shape[1]))\n    indexa = tf.stack([b, new_h, new_w], axis=-1)\n    new_featuremap = tf.gather_nd(cropped, indexa)\n\n    return new_featuremap, tf_non_zero_idx, batch_cord, theta_cord", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(32, 256)\n        width = np.random.randint(32, 256)\n        channels = np.random.randint(1, 10)\n        num_boxes = np.random.randint(1, 10)\n        output_height = np.random.randint(4, 64)\n        output_width = np.random.randint(4, 64)\n        featuremap = tf.random.normal([batch_size, height, width, channels])\n        quadboxes = tf.random.uniform([batch_size, num_boxes, 8], minval=0, maxval=max(height, width), dtype=tf.float32)\n        shape = [output_height, output_width]\n        input_shape = [batch_size, height, width, channels]\n\n        test_cases.append((featuremap, quadboxes, shape, input_shape))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_57", "library": "tensorflow", "code_problem": "```python\ndef get_positional_encoding(num_channels, length, position, min_timescale, max_timescale):\n```\n\nIn this function, `get_positional_encoding`, the goal is to generate a positional encoding tensor that can be used in neural networks, particularly in transformer models. The function takes the following parameters:\n\n- `num_channels`: An integer representing the number of channels in the output tensor.\n- `length`: An integer representing the length of the sequence for which the positional encoding is to be generated.\n- `position`: A tensor or None, representing specific positions for which the encoding is to be computed. If it is None, the function will generate positions from 0 to `length - 1`.\n- `min_timescale`: A float representing the minimum timescale for the encoding.\n- `max_timescale`: A float representing the maximum timescale for the encoding.\n\n### Input and Output Format:\n- **Input**: The function accepts five parameters: `num_channels` (int), `length` (int), `position` (tensor or None), `min_timescale` (float), and `max_timescale` (float).\n- **Output**: The function returns a tensor of shape `[length, num_channels]` containing the positional encodings, or an empty tensor if no valid positions are provided.\n\nInput:\n```python\nnum_channels = 8\nlength = 5\nposition = None\nmin_timescale = 1.0\nmax_timescale = 10000.0\n```\n\nOutput:\n```python\ntf.Tensor(\n[[ 0.0000000e+00  0.0000000e+00  0.0000000e+00  0.0000000e+00\n   1.0000000e+00  1.0000000e+00  1.0000000e+00  1.0000000e+00]\n [ 8.4147096e-01  4.6399228e-02  2.1544332e-03  9.9999990e-05\n   5.4030228e-01  9.9892300e-01  9.9999768e-01  1.0000000e+00]\n [ 9.0929741e-01  9.2698507e-02  4.3088561e-03  1.9999998e-04\n  -4.1614681e-01  9.9569422e-01  9.9999070e-01  1.0000000e+00]\n [ 1.4112000e-01  1.3879810e-01  6.4632590e-03  2.9999996e-04\n  -9.8999250e-01  9.9032068e-01  9.9997914e-01  9.9999994e-01]\n [-7.5680250e-01  1.8459874e-01  8.6176321e-03  3.9999996e-04\n  -6.5364361e-01  9.8281395e-01  9.9996287e-01  9.9999994e-01]], shape=(5, 8), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\nimport math\n\n# main code\ndef get_positional_encoding(num_channels, length, position, min_timescale, max_timescale):\n    if position is None and length is not None:\n        position = tf.range(length)\n\n    if position is not None:\n        position = tf.cast(position, tf.float32)\n        num_timescales = num_channels // 2\n        log_timescale_increment = math.log(float(max_timescale) / float(min_timescale)) / float(max(num_timescales - 1, 1))\n        inv_timescales = min_timescale * tf.exp(tf.cast(tf.range(num_timescales), tf.float32) * -log_timescale_increment)\n        scale = tf.reshape(inv_timescales, [1] * len(position.shape) + [num_timescales])\n        scaled_time = tf.expand_dims(position, -1) * scale\n        signal = tf.concat([tf.sin(scaled_time), tf.cos(scaled_time)], axis=-1)\n\n        if num_channels % 2 != 0:\n            signal = tf.pad(signal, [[0, 0]] * len(position.shape) + [[0, num_channels % 2]])\n        return signal\n\n    return tf.constant([])", "test_script": "import tensorflow as tf\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_channels = random.randint(1, 512)\n        length = random.randint(1, 1024) if random.random() < 0.5 else None\n        position = (tf.random.uniform(shape=[random.randint(1, 10)], minval=0, maxval=1000, dtype=tf.int32)\n                    if length is None and random.random() < 0.5 else None)\n        min_timescale = 1.0\n        max_timescale = 10000.0\n\n        test_cases.append((num_channels, length, position, min_timescale, max_timescale))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_58", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes radial symmetry features for a set of atoms based on their types and coordinates. The function will take in a matrix representing the atoms, their types, and several parameters that define the radial symmetry calculations.\n\nFunction signature:\n```python\ndef radial_symmetry(atom_matrix, max_atom_types, R_Rc, R_eta, R_Rs):\n```\n\nConstants used in the main code:\n- A small constant value `1e-06` is used to avoid division by zero when calculating flags for distances.\n\n\nInput format:\n- `atom_matrix`: A 2D tensor of shape (N, M) where N is the number of atoms and M is the number of features (1 for type and 3 for coordinates).\n- `max_atom_types`: An integer.\n- `R_Rc`: A float.\n- `R_eta`: A float.\n- `R_Rs`: A 1D tensor of distances.\n\nOutput format:\n- A 2D tensor of shape (N, radial_feature_size(R_Rs, max_atom_types)), where N is the number of atoms and the second dimension is determined by the radial feature size based on `R_Rs` and `max_atom_types`.\n\n**Input:**\n```python\natom_matrix = np.array([[0, 1.0, 2.0, 3.0],\n                        [1, 4.0, 5.0, 6.0],\n                        [0, 7.0, 8.0, 9.0]], dtype=np.float32)\n\nmax_atom_types = 2\nR_Rc = np.float32(3.0)\nR_eta = np.float32(0.5)\nR_Rs = np.array([1.0, 2.0], dtype=np.float32)\n```\n\n**Output:**\n```python\nradial_features = radial_symmetry(atom_matrix, max_atom_types, R_Rc, R_eta, R_Rs)\n# radial_features\ntf.Tensor(\n[[0. 0. 0. 0.]\n [0. 0. 0. 0.]\n [0. 0. 0. 0.]], shape=(3, 4), dtype=float32)\n```\n", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\n\ndef radial_feature_size(R_Rs, max_atom_types):\n    return tf.cast(max_atom_types * tf.shape(R_Rs)[0], dtype=tf.int32)\n\n# main code\ndef radial_symmetry(atom_matrix, max_atom_types, R_Rc, R_eta, R_Rs):\n    num_atoms = tf.shape(atom_matrix)[0]\n    atom_types = tf.cast(atom_matrix[:, 0], dtype=tf.int32)\n    atom_coords = atom_matrix[:, 1:]\n    type_groups = tf.dynamic_partition(atom_coords, atom_types, max_atom_types, name='dp_radial')\n\n    atom_coords = tf.expand_dims(atom_coords, axis=1)\n    radial_features = []\n\n    R_Rs = tf.cast(R_Rs, tf.float32)\n    R_Rc = tf.cast(R_Rc, tf.float32)\n    R_eta = tf.cast(R_eta, tf.float32)\n\n    for grp_pos in type_groups:\n        grp_pos = tf.expand_dims(grp_pos, axis=0)\n        R_ij = tf.norm(atom_coords - grp_pos, axis=2)\n\n        f_C_true = 0.5 * tf.cos(np.pi * R_ij / R_Rc) + 0.5\n        f_C_flags = tf.nn.relu(tf.sign(R_Rc - R_ij))\n        f_C = f_C_true * f_C_flags\n        f_C = tf.expand_dims(f_C, 2)\n\n        delta_Rs = tf.expand_dims(R_ij, axis=-1) - tf.reshape(R_Rs, (1, 1, -1))\n        summand = tf.exp(-R_eta * tf.pow(delta_Rs, 2)) * f_C\n\n        R_ij_flags = tf.nn.relu(tf.sign(tf.abs(R_ij) - 1e-06))\n        R_ij_flags = tf.expand_dims(R_ij_flags, 2)\n\n        radial_features.append(tf.reduce_sum(summand * R_ij_flags, axis=1))\n\n    if radial_features:\n        radial_features = tf.concat(radial_features, axis=1)\n        radial_features = tf.reshape(radial_features, (num_atoms, radial_feature_size(R_Rs, max_atom_types)))\n    else:\n        radial_features = tf.zeros((num_atoms, radial_feature_size(R_Rs, max_atom_types)))\n\n    return radial_features", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_atoms = np.random.randint(1, 50)\n        max_atom_types = np.random.randint(1, 10)\n        num_Rs = np.random.randint(1, 10)\n\n        atom_types = np.random.randint(0, max_atom_types, size=(num_atoms, 1))\n        atom_coords = np.random.uniform(-10, 10, size=(num_atoms, 3))\n        atom_matrix = np.hstack([atom_types, atom_coords]).astype(np.float32)\n\n        R_Rc = np.float32(np.random.uniform(1.0, 5.0))\n        R_eta = np.float32(np.random.uniform(0.1, 2.0))\n        R_Rs = np.random.uniform(0, R_Rc, size=(num_Rs,)).astype(np.float32)\n\n        test_cases.append((atom_matrix, max_atom_types, R_Rc, R_eta, R_Rs))\n\n    return test_cases"}
{"problem_id": "tensorflow_59", "library": "tensorflow", "code_problem": "```python\ndef refine_detections(rois, probs, deltas, window, bbox_std_dev):\n```\n\nIn this code, the function `refine_detections` is designed to process bounding box predictions from a neural network, refining them based on class probabilities and deltas, and then returning the refined bounding boxes in a normalized format.\n\n### Constant Used:\n- The constant `[256, 256]` is used to define the shape of the output for denormalizing the bounding boxes.\n\n### Input and Output Format:\n- **Input**: \n  - `rois`: A tensor of shape (N, 4) representing the regions of interest (bounding boxes).\n  - `probs`: A tensor of shape (N, num_classes) representing the class probabilities for each ROI.\n  - `deltas`: A tensor of shape (N, 4) representing the adjustments to be applied to the bounding boxes.\n  - `window`: A tensor of shape (4,) representing the bounding box limits to clip the boxes.\n  - `bbox_std_dev`: A scalar value used to scale the deltas.\n\n- **Output**: \n  - A tuple containing:\n    - An integer representing the number of valid detected bounding boxes.\n    - A tensor of shape (M, 4) representing the denormalized bounding boxes, where M is the number of valid boxes.\n\n**Input:**\n```python\nrois = tf.constant([[0.1, 0.1, 0.4, 0.4], \n                    [0.2, 0.2, 0.5, 0.5]], dtype=tf.float32)  # 2 ROIs\nprobs = tf.constant([[0.9, 0.1], \n                     [0.2, 0.8]], dtype=tf.float32)  # 2 classes\ndeltas = tf.constant([[[0.1, 0.1, 0.2, 0.2], \n                        [0.0, 0.0, 0.0, 0.0]], \n                       [[-0.1, -0.1, -0.2, -0.2], \n                        [0.0, 0.0, 0.0, 0.0]]], dtype=tf.float32)  # 2 ROIs, 2 classes\nwindow = tf.constant([0, 0, 1, 1], dtype=tf.float32)  # Window\nbbox_std_dev = tf.constant([0.1, 0.1, 0.2, 0.2], dtype=tf.float32)  # Standard deviations\n```\n\n**Output:**\n```python\nnum_detections, detected_boxes = refine_detections(rois, probs, deltas, window, bbox_std_dev)\n# num_detections: tf.Tensor(1, shape=(), dtype=int32)\n# detected_boxes: tf.Tensor([[ 51.  51. 128. 128.]], shape=(1, 4), dtype=float32)\n```\n\n### Explanation:\n- The input consists of 2 regions of interest (ROIs) with their respective probabilities and deltas for 2 classes.\n- The output indicates that 1 detection was made, and the coordinates of the detected bounding box are provided in the `detected_boxes` tensor.", "ground_truth_code": "import tensorflow as tf\n\ndef apply_box_deltas(boxes, deltas):\n    height, width = boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1]\n    center_y, center_x = boxes[:, 0] + 0.5 * height, boxes[:, 1] + 0.5 * width\n    center_y += deltas[:, 0] * height\n    center_x += deltas[:, 1] * width\n    height, width = height * tf.exp(deltas[:, 2]), width * tf.exp(deltas[:, 3])\n    return tf.stack([center_y - 0.5 * height, center_x - 0.5 * width, center_y + 0.5 * height, center_x + 0.5 * width], axis=1)\n\ndef clip_boxes(boxes, window):\n    wy1, wx1, wy2, wx2 = tf.split(window, 4)\n    y1, x1, y2, x2 = tf.split(boxes, 4, axis=1)\n    return tf.concat([tf.clip_by_value(y1, wy1, wy2), tf.clip_by_value(x1, wx1, wx2), tf.clip_by_value(y2, wy1, wy2), tf.clip_by_value(x2, wx1, wx2)], axis=1)\n\ndef trim_zeros(boxes):\n    mask = tf.reduce_sum(tf.abs(boxes), axis=1) > 0\n    return tf.boolean_mask(boxes, mask), mask\n\ndef denorm_boxes(boxes, shape):\n    scale = tf.cast([shape[0] - 1, shape[1] - 1, shape[0] - 1, shape[1] - 1], tf.float32)\n    return tf.cast(tf.round(boxes * scale + [0, 0, 1, 1]), tf.int32)\n\n\n# main code\ndef refine_detections(rois, probs, deltas, window, bbox_std_dev):\n    class_ids = tf.argmax(probs, axis=1, output_type=tf.int32)\n    indices = tf.stack([tf.range(tf.shape(probs)[0]), class_ids], axis=1)\n    class_scores, deltas_specific = tf.gather_nd(probs, indices), tf.gather_nd(deltas, indices)\n    refined_rois = clip_boxes(apply_box_deltas(rois, deltas_specific * bbox_std_dev), window)\n    keep = tf.where(class_ids > 0)[:, 0]\n    detected_regions, _ = trim_zeros(tf.gather(refined_rois, keep))\n    return tf.shape(denorm_boxes(detected_regions, [256, 256]))[0], tf.cast(denorm_boxes(detected_regions, [256, 256]), tf.float32)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rois = np.random.randint(1, 100)\n        num_classes = np.random.randint(2, 21)\n\n        rois = tf.random.uniform((num_rois, 4), minval=0, maxval=1, dtype=tf.float32)\n        probs = tf.random.uniform((num_rois, num_classes), minval=0, maxval=1,\n                                  dtype=tf.float32)\n        deltas = tf.random.normal((num_rois, num_classes, 4), mean=0, stddev=0.1,\n                                  dtype=tf.float32)\n        window = tf.constant([0, 0, 1, 1], dtype=tf.float32)\n        bbox_std_dev = tf.constant([0.1, 0.1, 0.2, 0.2], dtype=tf.float32)\n\n        test_cases.append((rois, probs, deltas, window, bbox_std_dev))\n\n    return test_cases"}
{"problem_id": "tensorflow_60", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that updates weights using a power iteration method. The function will take in several parameters, including a small epsilon value to prevent division by zero, a vector `u`, a boolean flag indicating whether to perform power iteration, the number of iterations to run, the weight matrix `w`, and the shape of the weight matrix.\n\nFunction signature:\n```python\ndef update_weights(eps: float, u: tf.Tensor, do_power_iteration: bool, iteration: int, w: tf.Tensor, w_shape: list) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- `eps`: A small constant value to avoid division by zero during normalization.\n\nInput format:\n- `eps`: A float representing a small constant.\n- `u`: A TensorFlow tensor representing the input vector.\n- `do_power_iteration`: A boolean indicating whether to perform power iteration.\n- `iteration`: An integer representing the number of iterations for the power iteration.\n- `w`: A TensorFlow tensor representing the weight matrix.\n- `w_shape`: A list representing the shape of the weight matrix.\n\nOutput format:\n- The function returns a TensorFlow tensor representing the updated weights after applying the power iteration method.\n\n**Input:**\n```python\neps = tf.constant(1e-5, dtype=tf.float32)\nu = tf.Variable(tf.random.normal([1, 3]))  # Example shape\ndo_power_iteration = True\niteration = 5\nw_shape = [3, 4]  # Example shape\nw = tf.random.normal(w_shape)\n```\n\n**Output:**\n```python\nsigma = update_weights(eps, u, do_power_iteration, iteration, w, w_shape)\n# tf.Tensor([[3.2557082]], shape=(1, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef update_weights(eps, u, do_power_iteration, iteration, w, w_shape):\n    w_reshaped = tf.reshape(w, [-1, w_shape[-1]])\n    u_hat = u\n    v_hat = tf.zeros([1, tf.shape(w_reshaped)[0]], dtype=w.dtype)\n\n    if do_power_iteration:\n        for _ in range(iteration):\n            v_ = tf.matmul(u_hat, tf.transpose(w_reshaped))\n            v_hat = v_ / (tf.sqrt(tf.reduce_sum(v_ ** 2, axis=1, keepdims=True)) + eps)\n            u_ = tf.matmul(v_hat, w_reshaped)\n            u_hat = u_ / (tf.sqrt(tf.reduce_sum(u_ ** 2, axis=1, keepdims=True)) + eps)\n\n    sigma = tf.matmul(tf.matmul(v_hat, w_reshaped), tf.transpose(u_hat))\n\n    return sigma", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        w_shape = list(np.random.randint(2, 10, size=np.random.randint(2, 5)))\n        w_shape[-1] = np.random.randint(1, 10)\n        w = tf.random.normal(w_shape)\n        u = tf.Variable(tf.random.normal([1, w_shape[-1]]))\n        do_power_iteration = np.random.choice([True, False])\n        iteration = np.random.randint(1, 10) if do_power_iteration else 0\n        eps = tf.constant(1e-5, dtype=tf.float32)\n\n        test_cases.append((eps, u, do_power_iteration, iteration, w, w_shape))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_61", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that clips bounding boxes to a specified window. The function should ensure that the coordinates of the bounding boxes do not exceed the limits defined by the window. This is particularly useful in computer vision tasks where you want to ensure that detected objects remain within a certain area of interest.\n\nFunction signature:\n```python\ndef clip_boxes_graph(boxes, window):\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code; however, the function utilizes TensorFlow operations to perform clipping.\n\nInput format:\n- The input `boxes` is a tensor of shape (N, 4), where N is the number of bounding boxes, and each bounding box is represented by four coordinates (y1, x1, y2, x2).\n- The input `window` is a tensor of shape (4,), representing the clipping window with four values (wy1, wx1, wy2, wx2).\n\nOutput format:\n- The output is a tensor of the same shape as `boxes` (N, 4), containing the clipped bounding box coordinates.\n\nInput:\n```python\nboxes_tensor = tf.convert_to_tensor([[5.0, -3.0, 7.0, 2.0], [-12.0, -5.0, 8.0, 3.0]], dtype=tf.float32)\nwindow_tensor = tf.convert_to_tensor([-5.0, -4.0, 5.0, 4.0], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[ 5. -3.  5.  2.]\n [-5. -4.  5.  3.]], shape=(2, 4), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef clip_boxes_graph(boxes, window):\n    wy1, wx1, wy2, wx2 = tf.split(window, num_or_size_splits=4)\n    y1, x1, y2, x2 = tf.split(boxes, num_or_size_splits=4, axis=1)\n\n    y1 = tf.clip_by_value(y1, wy1, wy2)\n    x1 = tf.clip_by_value(x1, wx1, wx2)\n    y2 = tf.clip_by_value(y2, wy1, wy2)\n    x2 = tf.clip_by_value(x2, wx1, wx2)\n\n    return tf.concat([y1, x1, y2, x2], axis=1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 100)\n        boxes = np.random.uniform(-10, 10, size=(batch_size, 4)).astype(np.float32)\n        wy1, wx1 = np.random.uniform(-10, 0, size=(2,)).astype(np.float32)\n        wy2, wx2 = np.random.uniform(0, 10, size=(2,)).astype(np.float32)\n        window = np.array([wy1, wx1, wy2, wx2], dtype=np.float32)\n        boxes_tensor = tf.convert_to_tensor(boxes, dtype=tf.float32)\n        window_tensor = tf.convert_to_tensor(window, dtype=tf.float32)\n\n        test_cases.append((boxes_tensor, window_tensor))\n\n    return test_cases"}
{"problem_id": "tensorflow_62", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the regularization loss for a machine learning model using L1 and L2 regularization techniques. The function should take into account both the weights and the bias of the model, applying the specified regularization parameters.\n\nFunction signature:\n```python\ndef tf_regularization_loss(bias, l2_reg, weights, l1_reg):\n```\n\nConstants used in the main code:\n- `tf.constant(0.0)`: This constant is used to return a zero loss when no regularization is applied.\n\nInput format:\n- `bias`: A tensor representing the bias of the model (can be `None`).\n- `l2_reg`: A float representing the L2 regularization coefficient.\n- `weights`: A tensor representing the weights of the model.\n- `l1_reg`: A float representing the L1 regularization coefficient.\n\nOutput format:\n- The function returns a tensor representing the total regularization loss, which is a scalar value.\n\nInput:\n```python\nbias = tf.constant([-0.5, 0.3], dtype=tf.float32)\nl2_reg = 0.1\nweights = tf.constant([[0.2, -0.1], [0.4, 0.5]], dtype=tf.float32)\nl1_reg = 0.05\n```\n\nOutput:\n```python\ntf_regularization_loss(bias, l2_reg, weights, l1_reg)  # Expected output: tf.Tensor(0.14, shape=(), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tf_regularization_loss(bias, l2_reg, weights, l1_reg):\n    losses = []\n\n    if l2_reg > 0:\n        losses.append(l2_reg * tf.nn.l2_loss(weights))\n        if bias is not None:\n            losses.append(l2_reg * tf.nn.l2_loss(bias))\n\n    if l1_reg > 0:\n        losses.append(l1_reg * tf.reduce_sum(tf.abs(weights)))\n        if bias is not None:\n            losses.append(l1_reg * tf.reduce_sum(tf.abs(bias)))\n\n    return tf.add_n(losses) if losses else tf.constant(0.0)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        rank = np.random.randint(1, 4)\n        shape = tuple(np.random.randint(1, 10, size=rank))\n        weights = tf.constant(np.random.randn(*shape).astype(np.float32))\n        bias = None if np.random.rand() < 0.5 else tf.constant(np.random.randn(shape[-1]).astype(np.float32))\n        l1_reg = np.random.uniform(0, 1)\n        l2_reg = np.random.uniform(0, 1)\n\n        test_cases.append((bias, l2_reg, weights, l1_reg))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_63", "library": "tensorflow", "code_problem": "The task is to implement a function that computes the gradients of two tensors with respect to a given gradient tensor, taking into account the broadcasting rules of TensorFlow. The function should handle the shapes of the input tensors and ensure that the gradients are correctly summed and reshaped according to the broadcasting dimensions.\n\nFunction signature:\n```python\ndef alternative_minmax_grad(x, y, grad):\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the code.\n\nInput format:\n- The function takes three inputs:\n  - `x`: A tensor of any shape.\n  - `y`: A tensor of any shape.\n  - `grad`: A tensor of the same shape as the broadcasted result of `x` and `y`.\n\nOutput format:\n- The function returns a tuple containing two tensors:\n  - `gx`: The computed gradient tensor for `x`, reshaped to match the shape of `x`.\n  - `gy`: The computed gradient tensor for `y`, reshaped to match the shape of `y`.\n\n**Input:**\n```python\nx = tf.constant([[1.0, 2.0], [3.0, 4.0]])  # Shape: (2, 2)\ny = tf.constant([[5.0], [6.0]])              # Shape: (2, 1)\ngrad = tf.constant([[0.1, 0.2], [0.3, 0.4]]) # Shape: (2, 2)\n```\n\n**Output:**\n```python\ngx, gy = alternative_minmax_grad(x, y, grad)\n# gx will be: tf.Tensor(\n# [[0.1 0.2]\n# [0.3 0.4]], shape=(2, 2), dtype=float32)\n# gy will be: tf.Tensor(\n# [[0.3       ]\n#  [0.70000005]], shape=(2, 1), dtype=float32)\n```\n\n### Explanation:\n- The input tensors `x` and `y` have shapes that can be broadcasted together.\n- The `grad` tensor has the same shape as `x`.\n- The output `gx` is computed by summing `grad` along the appropriate axis, and `gy` is computed similarly, resulting in the specified output values.", "ground_truth_code": "import tensorflow as tf\nfrom tensorflow.python.ops import gen_array_ops\n\n\n# main code\ndef alternative_minmax_grad(x, y, grad):\n    sx, sy = tf.shape(x), tf.shape(y)\n    rx, ry = gen_array_ops.broadcast_gradient_args(sx, sy)\n    gx, gy = tf.reshape(tf.reduce_sum(grad, axis=rx), sx), tf.reshape(tf.reduce_sum(grad, axis=ry), sy)\n    return gx, gy\n", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank_x = np.random.randint(1, 5)\n        rank_y = np.random.randint(1, 5)\n\n        shape_x = np.random.randint(1, 6, size=rank_x)\n        shape_y = np.random.randint(1, 6, size=rank_y)\n        max_rank = max(rank_x, rank_y)\n        shape_x = np.pad(shape_x, (max_rank - rank_x, 0), constant_values=1)\n        shape_y = np.pad(shape_y, (max_rank - rank_y, 0), constant_values=1)\n        for i in range(max_rank):\n            if shape_x[i] != shape_y[i]:\n                if shape_x[i] == 1 or shape_y[i] == 1:\n                    continue\n                else:\n                    shape_y[i] = 1\n        broadcast_shape = tf.broadcast_static_shape(tf.TensorShape(shape_x), tf.TensorShape(shape_y))\n        x = tf.random.normal(shape_x.tolist())\n        y = tf.random.normal(shape_y.tolist())\n        grad = tf.random.normal(broadcast_shape.as_list())\n        test_cases.append((x, y, grad))\n    return test_cases"}
{"problem_id": "tensorflow_64", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the length of sequences represented as tensors in TensorFlow. The function should determine the number of non-zero elements in each sequence and return these counts as a tensor of integers.\n\nFunction signature:\n```python\ndef get_length(seq):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0`, which is used in the `tf.zeros_like` function to create a tensor of zeros with the same shape as the input tensor when the length is `None`.\n\nInput format:\n- The input to the function is a tensor `seq` of shape (N, M), where N is the number of sequences and M is the length of each sequence.\n\nOutput format:\n- The output of the function is a tensor of shape (N,) containing the counts of non-zero elements for each sequence in the input tensor. Each element in the output tensor is of type `int32`.\n\n```python\n{\n    \"input\": [[0.5, -0.2, 0.0, 0.3, -0.1], [-0.4, 0.0, 0.0, 0.2, 0.1]],\n    \"output\": tf.Tensor([4 3], shape=(2,), dtype=int32)\n}\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef get_length(seq):\n    relevant = tf.sign(tf.abs(seq))\n    length = tf.reduce_sum(relevant, axis=1)\n    length = tf.cast(length, tf.int32)\n    return length if length is not None else tf.zeros_like(seq, dtype=tf.int32)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_length = np.random.randint(5, 20)\n        seq = np.random.uniform(-1, 1, size=(batch_size, seq_length)).astype(np.float32)\n        test_cases.append(seq)\n\n    return test_cases"}
{"problem_id": "tensorflow_65", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes various statistical summaries of a given tensor. The function should handle both integer and floating-point tensors, converting integers to floats for the calculations. The function will return the mean, standard deviation, root mean square (RMS), L2 norm, maximum, and minimum values of the input tensor.\n\nFunction signature:\n```python\ndef variable_scalar_summaries_dict(x):\n```\n\nConstant used in the main code:\n- The constant `0.5` is used in the calculation of the L2 norm.\n\nInput format:\n- The input to the function is a tensor `x`, which can be either an integer or a floating-point tensor.\n\nOutput format:\n- The output of the function is a tuple containing six values: mean, standard deviation, RMS, L2 norm, maximum, and minimum, all of which are floating-point numbers.\n\nInput:\n```python\ntensor = tf.convert_to_tensor([[1, 2, 3], [4, 5, 6]], dtype=tf.int32)\n```\n\nOutput:\n```python\n(mean, stddev, rms, l2, max, min) = \n(\n<tf.Tensor: shape=(), dtype=float32, numpy=3.5>, \n<tf.Tensor: shape=(), dtype=float32, numpy=1.7078252>, \n<tf.Tensor: shape=(), dtype=float32, numpy=3.8944404>, \n<tf.Tensor: shape=(), dtype=float32, numpy=4.769696>, \n<tf.Tensor: shape=(), dtype=int32, numpy=6>, \n<tf.Tensor: shape=(), dtype=int32, numpy=1>\n)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef variable_scalar_summaries_dict(x):\n    if x.dtype.is_integer:\n        x_float = tf.cast(x, tf.float32)\n    else:\n        x_float = x\n\n    mean = tf.reduce_mean(x_float)\n    stddev = tf.sqrt(tf.reduce_mean(tf.square(x_float - mean)))\n    rms =  tf.sqrt(tf.reduce_mean(tf.square(x_float)))\n    l2 = tf.sqrt(tf.nn.l2_loss(x_float) * 0.5)\n    max = tf.reduce_max(x)\n    min = tf.reduce_min(x)\n    return mean, stddev, rms, l2, max, min", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        shape = np.random.randint(1, 6, size=2)\n        dtype_choice = np.random.choice([tf.int32, tf.float32])\n\n        tensor_data = np.random.random(size=shape) * 10\n        if dtype_choice == tf.int32:\n            tensor_data = tensor_data.astype(np.int32)\n        elif dtype_choice == tf.float32:\n            tensor_data = tensor_data.astype(np.float32)\n        tensor = tf.convert_to_tensor(tensor_data, dtype=dtype_choice)\n\n        test_cases.append(tensor)\n\n    return test_cases\n"}
{"problem_id": "tensorflow_66", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a batch of vectors and transforms them into a specific 3x3 matrix format using TensorFlow. The function signature is as follows:\n\n```python\ndef call(vec):\n```\n\nIn this function, the following constant is used:\n\n- `col_inds`: A constant tensor defined as `[1, 2, 3, 5, 6, 7]`, which represents the column indices for the scatter operation.\n\nInput format:\n- The input to the function `call` is a 2D tensor `vec` of shape `[batch_size, 3]`, where each row represents a vector of three elements.\n\nOutput format:\n- The output of the function is a 3D tensor of shape `[batch_size, 3, 3]`, where each 3x3 matrix is constructed based on the transformations applied to the corresponding input vector.\n\nInput:\n```python\ntf.constant([[1.0, 2.0, 3.0], \n              [4.0, 5.0, 6.0]])\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[ 0. -3.  2.]\n  [ 3.  0. -1.]\n  [-2.  1.  0.]]\n [[ 0. -6.  5.]\n  [ 6.  0. -4.]\n  [-5.  4.  0.]]], shape=(2, 3, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef call(vec):\n    batch_size = tf.shape(vec)[0]\n    col_inds = tf.constant([1, 2, 3, 5, 6, 7])\n    batch_inds = tf.reshape(tf.range(0, batch_size) * 9, [-1, 1])\n    indices = tf.reshape(batch_inds + col_inds, [-1, 1])\n    updates = tf.stack(values=[-vec[:, 2], vec[:, 1], vec[:, 2], -vec[:, 0], -vec[:, 1], vec[:, 0]], axis=1)\n    updates = tf.reshape(updates, [-1])\n    out_shape = [batch_size * 9]\n    res = tf.scatter_nd(indices, updates, out_shape)\n    res = tf.reshape(res, [batch_size, 3, 3])\n\n    return res if res is not None else tf.zeros([batch_size, 3, 3])", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 11)\n        vec = np.random.randn(batch_size, 3).astype(np.float32)\n        tensor_input = tf.constant(vec)\n        test_cases.append(tensor_input)\n\n    return test_cases"}
{"problem_id": "tensorflow_67", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the normals of triangular faces defined by a set of vertices in a 3D space. The function should handle both batched and non-batched inputs for vertices and faces.\n\nFunction signature:\n```python\ndef call(vertices, faces, normalize):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used in the `tf.tile` function to replicate the faces tensor.\n\nInput format:\n- `vertices`: A tensor of shape (N, 3) or (B, N, 3), where N is the number of vertices and B is the batch size.\n- `faces`: A tensor of shape (M, 3) or (B, M, 3), where M is the number of faces and B is the batch size.\n- `normalize`: A boolean indicating whether to normalize the face normals.\n\nOutput format:\n- A tensor of shape (M, 3) or (B, M, 3) representing the computed face normals for each triangle. If the normals are not computed, a tensor of zeros with the same shape as `vertices` is returned.\n\n**Input:**\n```python\nvertices = tf.convert_to_tensor([[[0.0, 0.0, 0.0],\n                                   [1.0, 0.0, 0.0],\n                                   [0.0, 1.0, 0.0]]], dtype=tf.float32)  # Shape: (1, 3, 3)\n\nfaces = tf.convert_to_tensor([[0, 1, 2]], dtype=tf.int32)  # Shape: (1, 3)\n\nnormalize = True\n```\n\n**Output:**\n```python\noutput = call(vertices, faces, normalize)\n# Expected output: tf.Tensor([[[0. 0. 1.]]], shape=(1, 1, 3), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(vertices, faces, normalize):\n    v = vertices\n    f = faces\n    if v.shape.ndims == f.shape.ndims + 1:\n        f = tf.tile([f], [tf.shape(v)[0], 1, 1])\n    triangles = tf.gather(v, f, axis=-2, batch_dims=v.shape.ndims - 2)\n    (v0, v1, v2) = tf.unstack(triangles, axis=-2)\n    e1 = v0 - v1\n    e2 = v2 - v1\n    face_normals = tf.linalg.cross(e2, e1)\n    if normalize:\n        face_normals = tf.math.l2_normalize(face_normals, axis=-1)\n    return face_normals if face_normals is not None else tf.zeros_like(v)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_vertices = np.random.randint(3, 100)\n        num_faces = np.random.randint(1, max(2, num_vertices - 2))\n        vertices = tf.convert_to_tensor(np.random.rand(batch_size, num_vertices, 3), dtype=tf.float32)\n        faces = tf.convert_to_tensor(np.random.randint(0, num_vertices, size=(num_faces, 3)), dtype=tf.int32)\n        if np.random.rand() > 0.5:\n            faces = tf.tile(tf.expand_dims(faces, axis=0), [batch_size, 1, 1])\n        normalize = bool(np.random.choice([True, False]))\n\n        test_cases.append((vertices, faces, normalize))\n\n    return test_cases"}
{"problem_id": "tensorflow_68", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes an image using TensorFlow. The function will normalize the image, apply a random phase shift, and then compute the inverse Fourier transform of the modified image. The output will be the phase angle of the resulting complex image.\n\nFunction signature:\n```python\ndef process_image(img):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `0.0`, which is used to create a complex number with zero imaginary part.\n\nInput format:\n- The input to the function is a 2D tensor representing the image.\n\nOutput format:\n- The output of the function is a 2D tensor representing the phase angles of the complex image after processing.\n\nInput:\n```python\ntf.constant([[[ 34,  67,  89],\n               [ 12,  45,  78],\n               [ 90,  23,  56]],\n\n              [[ 45,  78,  12],\n               [ 67,  89,  34],\n               [ 23,  56,  90]],\n\n              [[ 78,  12,  45],\n               [ 89,  34,  67],\n               [ 56,  90,  23]]], dtype=tf.int32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[ 0.4015485   0.8178201   0.6768591 ]\n  [ 0.78210807 -1.445979    0.2424993 ]\n  [-1.0105277  -0.41656703  2.7446864 ]]\n [[ 0.47876674 -1.5931575   2.7547114 ]\n  [ 1.3599174   1.9977037   2.5097377 ]\n  [ 1.2323312  -1.6484768  -2.0069714 ]]\n [[ 0.38187337 -3.1133652  -0.97040635]\n  [ 2.3211367   0.88178587 -1.7843219 ]\n  [ 3.107995    1.7947593   0.5884493 ]]], shape=(3, 3, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef normalize_minmax(img):\n    img = tf.cast(img, tf.float32)\n    img -= tf.reduce_min(img, axis=[0, 1], keepdims=True)\n    img /= tf.reduce_max(img, axis=[0, 1], keepdims=True)\n    return img\n\n# main code\ndef process_image(img):\n    rand_phi = tf.random.uniform(tf.shape(img))\n    img = normalize_minmax(img)\n    img_cf = tf.complex(img, 0.0) * tf.math.exp(tf.complex(0.0, rand_phi))\n    slm_cf = tf.signal.ifft2d(tf.signal.ifftshift(img_cf))\n    return tf.math.angle(slm_cf)", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(32, 512)\n        width = np.random.randint(32, 512)\n        channels = np.random.choice([1, 3])\n        img = tf.random.uniform(shape=(height, width, channels), minval=0, maxval=256, dtype=tf.int32)\n\n        test_cases.append(img)\n\n    return test_cases\n"}
{"problem_id": "tensorflow_69", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes a loss operation for a particle filter-based state estimation system. The function will evaluate the difference between estimated particle states and true states, incorporating both positional and orientation errors. The function will also include an optional regularization term to prevent overfitting.\n\nFunction signature:\n```python\ndef build_loss_op(particle_states, particle_weights, true_states, map_pixel_in_meters, l2scale):\n```\n\n### Constants:\n- The constant used in the main code is `0.36`, which is a weight applied to the orientation loss in the combined loss calculation.\n\n### Input Format:\n- `particle_states`: A tensor of shape (num_particles, num_timesteps, num_particles, state_dimension) representing the states of the particles.\n- `particle_weights`: A tensor of shape (num_particles, num_timesteps, num_particles) representing the weights of the particles.\n- `true_states`: A tensor of shape (num_timesteps, num_particles, state_dimension) representing the true states.\n- `map_pixel_in_meters`: A float representing the conversion factor from pixels to meters.\n- `l2scale`: A float representing the scaling factor for the regularization loss.\n\n### Output Format:\n- The function returns a tuple containing:\n  - `train_loss_op`: A TensorFlow operation representing the total training loss.\n  - `loss_pred`: A TensorFlow tensor representing the prediction loss.\n  - `loss_coords`: A TensorFlow tensor representing the loss associated with the coordinates.\n\n```python\n# Input\nparticle_states = np.array([[[[ 0.5, 0.1, 0.0],\n                               [ 0.2, -0.3, 0.1],\n                               [-0.1, 0.4, 0.2]],\n                              [[ 0.3, 0.0, 0.0],\n                               [ 0.1, -0.2, 0.1],\n                               [ 0.0, 0.5, 0.3]]],\n                             [[[ 0.4, 0.2, 0.0],\n                               [ 0.3, -0.1, 0.1],\n                               [ 0.0, 0.3, 0.2]],\n                              [[ 0.2, 0.1, 0.0],\n                               [ 0.0, -0.4, 0.1],\n                               [ 0.1, 0.2, 0.3]]]])\n\nparticle_weights = np.array([[[0.1, 0.3, 0.6],\n                               [0.2, 0.5, 0.3]]],\n                             [[[0.4, 0.4, 0.2],\n                               [0.3, 0.3, 0.4]]]])\n\ntrue_states = np.array([[[0.3, 0.0, 0.0],\n                         [0.1, -0.1, 0.1]]],\n                       [[[0.2, 0.1, 0.0],\n                         [0.0, -0.2, 0.1]]]])\n\nmap_pixel_in_meters = 0.5\nl2scale = 0.1\n\n# Output\ntrain_loss_op, loss_pred, loss_coords = build_loss_op(particle_states, particle_weights, true_states, map_pixel_in_meters, l2scale)\n# train_loss_op = tf.Tensor(0.009133743, shape=(), dtype=float32)\n# loss_pred = tf.Tensor(0.009133743, shape=(), dtype=float32)\n# loss_coords = tf.Tensor([[0.00822538 0.0084303 ] [0.00071202 0.01011863]], shape=(2, 2), dtype=float32)\n``` \n", "ground_truth_code": "import tensorflow as tf\nimport numpy as np\n\n# main code\ndef build_loss_op(particle_states, particle_weights, true_states, map_pixel_in_meters, l2scale):\n    lin_weights = tf.nn.softmax(particle_weights, axis=-1)\n    true_coords = true_states[:, :, :2]\n    mean_coords = tf.reduce_sum(particle_states[:, :, :, :2] * lin_weights[:, :, :, None], axis=2)\n    coord_diffs = (mean_coords - true_coords) * map_pixel_in_meters\n    loss_coords = tf.reduce_sum(tf.square(coord_diffs), axis=2)\n\n    true_orients = true_states[:, :, 2]\n    orient_diffs = particle_states[:, :, :, 2] - true_orients[:, :, None]\n    orient_diffs = tf.math.mod(orient_diffs + np.pi, 2 * np.pi) - np.pi\n\n    loss_orient = tf.square(tf.reduce_sum(orient_diffs * lin_weights, axis=2))\n\n    loss_combined = loss_coords + 0.36 * loss_orient\n    loss_pred = tf.reduce_mean(loss_combined, name='prediction_loss')\n\n    # Handle case where there are no regularization losses\n    reg_losses = tf.compat.v1.get_collection(tf.compat.v1.GraphKeys.REGULARIZATION_LOSSES)\n    if reg_losses:\n        loss_reg = tf.multiply(tf.add_n(reg_losses), l2scale, name='l2')\n    else:\n        loss_reg = tf.constant(0.0, dtype=tf.float32, name='l2')\n\n    train_loss_op = tf.add(loss_pred, loss_reg, name='training_loss')\n\n    return train_loss_op, loss_pred, loss_coords", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_particles = np.random.randint(5, 50)\n        num_timesteps = np.random.randint(1, 10)\n\n        particle_states = np.random.randn(batch_size, num_timesteps, num_particles, 3).astype(np.float32)\n        particle_weights = np.random.randn(batch_size, num_timesteps, num_particles).astype(np.float32)\n        true_states = np.random.randn(batch_size, num_timesteps, 3).astype(np.float32)\n        map_pixel_in_meters = np.random.uniform(0.1, 5.0)\n        l2scale = np.random.uniform(0.01, 1.0)\n\n        test_cases.append((particle_states, particle_weights, true_states, map_pixel_in_meters, l2scale))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_70", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the Intersection over Union (IoU) for pairs of bounding boxes. The function will take two sets of bounding boxes defined by their corner coordinates and return the IoU for each pair of boxes.\n\nFunction Signature:\n```python\ndef compute_iou(boxes1_corners, boxes2_corners):\n```\n\nConstant used in the main code:\n- `tf.keras.backend.epsilon()`: This constant is used to prevent division by zero when calculating the union area.\n\nInput Format:\n- `boxes1_corners`: A tensor of shape `(N, 4)` where `N` is the number of boxes, and each box is represented by its corner coordinates `[x_min, y_min, x_max, y_max]`.\n- `boxes2_corners`: A tensor of shape `(M, 4)` where `M` is the number of boxes, and each box is represented by its corner coordinates `[x_min, y_min, x_max, y_max]`.\n\nOutput Format:\n- A tensor of shape `(N, M)` where each element at position `(i, j)` represents the IoU between the `i-th` box from `boxes1_corners` and the `j-th` box from `boxes2_corners`. The values will be clamped between 0.0 and 1.0.\n\nInput:\n```python\nboxes1_corners = tf.convert_to_tensor([[10.0, 10.0, 20.0, 20.0], \n                                         [30.0, 30.0, 40.0, 40.0]], dtype=tf.float32)\nboxes2_corners = tf.convert_to_tensor([[15.0, 15.0, 25.0, 25.0], \n                                         [35.0, 35.0, 45.0, 45.0]], dtype=tf.float32)\n```\n\nOutput:\n```python\niou = compute_iou(boxes1_corners, boxes2_corners)\n# Expected Output: \n# tf.Tensor(\n# [[0.14285715 0.        ]\n#  [0.         0.14285715]], shape=(2, 2), dtype=float32)\n``` \n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef compute_iou(boxes1_corners, boxes2_corners):\n    lu = tf.maximum(boxes1_corners[:, None, :2], boxes2_corners[:, :2])\n    rd = tf.minimum(boxes1_corners[:, None, 2:], boxes2_corners[:, 2:])\n\n    intersection = tf.maximum(0.0, rd - lu)\n    intersection_area = intersection[:, :, 0] * intersection[:, :, 1]\n\n    boxes1_area = tf.reduce_prod(boxes1_corners[:, 2:] - boxes1_corners[:, :2], axis=1)\n    boxes2_area = tf.reduce_prod(boxes2_corners[:, 2:] - boxes2_corners[:, :2], axis=1)\n\n    union_area = tf.maximum(boxes1_area[:, None] + boxes2_area - intersection_area, tf.keras.backend.epsilon())\n    return tf.clip_by_value(intersection_area / union_area, 0.0, 1.0)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_boxes1 = np.random.randint(1, 10)\n        num_boxes2 = np.random.randint(1, 10)\n        boxes1_corners = np.random.rand(num_boxes1, 4) * 100\n        boxes2_corners = np.random.rand(num_boxes2, 4) * 100\n        boxes1_corners[:, 2:] = np.maximum(boxes1_corners[:, 2:], boxes1_corners[:, :2] + 1)\n        boxes2_corners[:, 2:] = np.maximum(boxes2_corners[:, 2:], boxes2_corners[:, :2] + 1)\n        boxes1_corners = tf.convert_to_tensor(boxes1_corners, dtype=tf.float32)\n        boxes2_corners = tf.convert_to_tensor(boxes2_corners, dtype=tf.float32)\n\n        test_cases.append((boxes1_corners, boxes2_corners))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_71", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs a strided slice operation on a tensor using TensorFlow. The function should allow for flexible slicing based on specified parameters, including the axis along which to slice, the starting and ending indices, and the step size for the slicing operation.\n\nFunction signature:\n```python\ndef single_strided_slice(x, axis, begin, end, step):\n```\n\nConstant used in the main code:\n- The constant `tf.ones((axis,), tf.int32)` is used to create a tensor of ones with a shape corresponding to the specified axis, which is utilized for defining strides.\n\nInput format:\n- The input consists of a tensor `x`, an integer or list of integers `axis`, an integer or `None` for `begin`, an integer or `None` for `end`, and an integer or `None` for `step`.\n\nOutput format:\n- The output is a tensor that represents the sliced portion of the input tensor `x` based on the specified parameters.\n\nInput:\n```python\nx = tf.constant([[1, 2, 3], [4, 5, 6]], dtype=tf.int32)\naxis = 1\nbegin = 0\nend = 3\nstep = 1\n```\n\nOutput:\n```python\ntf.Tensor(\n[[1 2 3]\n [4 5 6]], shape=(2, 3), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef single_strided_slice(x, axis, begin, end, step):\n    if isinstance(axis, int):\n        if axis < 0 and x.get_shape().ndims is not None:\n            axis %= x.get_shape().ndims\n        return x[(slice(None),) * axis + (slice(begin, end, step),)]\n\n    axis = axis % tf.rank(x)\n    shape = tf.shape(x)\n    begin = 0 if begin is None else begin\n    end = shape[axis] if end is None else end\n    strides = tf.ones((axis,), tf.int32) if step is None else tf.concat([tf.ones((axis,), tf.int32), (step,)],\n                                                                        axis=0)\n\n    begins = tf.concat([tf.zeros((axis,), tf.int32), [begin]], axis=0)\n    ends = tf.concat([shape[:axis], [end]], axis=0)\n\n    return tf.strided_slice(x, begin=begins, end=ends, strides=strides)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = np.random.randint(1, 5)\n        shape = tuple(np.random.randint(1, 10, size=rank))\n        x = tf.constant(np.random.randint(-10, 10, size=shape), dtype=tf.int32)\n        axis = np.random.randint(-rank, rank)\n        dim_size = shape[axis]\n        begin = np.random.randint(-dim_size, dim_size) if np.random.rand() > 0.2 else None\n        end = np.random.randint(-dim_size, dim_size) if np.random.rand() > 0.2 else None\n        step = np.random.choice([-2, -1, 1, 2]) if np.random.rand() > 0.3 else None\n        test_cases.append((x, axis, begin, end, step))\n\n    return test_cases"}
{"problem_id": "tensorflow_72", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the squared Euclidean distance between two sets of vectors. The function should be able to handle batches of vectors and return the squared distances in a tensor format.\n\nFunction signature:\n```python\ndef euclidean_squared(A, B):\n```\n\nIn this function, `A` and `B` are 3-dimensional tensors representing batches of vectors. The first dimension corresponds to the batch size, the second dimension corresponds to the number of vectors in each batch, and the third dimension corresponds to the dimensionality of each vector.\n\nThe constant used in the main code is:\n- `-2`, which is used to compute the cross-term in the squared Euclidean distance formula.\n\nInput format:\n- The function takes two inputs, `A` and `B`, which are 3-dimensional tensors of shape `(batch_size, num_vectors, vector_dimension)`.\n\nOutput format:\n- The function returns a 3-dimensional tensor of shape `(batch_size, num_vectors, num_vectors)` containing the squared Euclidean distances between each pair of vectors from `A` and `B`.\n\nInput:\n```python\nA = tf.constant([[[ 1.5, -2.3,  0.0],\n                   [ 3.1,  4.5, -1.2]]], dtype=tf.float32)  # Shape: (1, 2, 3)\n\nB = tf.constant([[[ 0.0,  1.0, -1.0],\n                   [ 2.0, -3.0,  4.0],\n                   [-1.5,  2.5,  0.5]]], dtype=tf.float32)  # Shape: (1, 3, 3)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[14.139999 16.740002 32.29    ]\n  [21.900002 84.5      28.05    ]]], shape=(1, 2, 3), dtype=float32)\n``` \n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef euclidean_squared(A, B):\n    sub_factor = -2 * tf.matmul(A, tf.transpose(B, perm=[0, 2, 1]))\n    dotA = tf.expand_dims(tf.reduce_sum(A * A, axis=2), axis=2)\n    dotB = tf.expand_dims(tf.reduce_sum(B * B, axis=2), axis=1)\n    return tf.abs(sub_factor + dotA + dotB) if A is not None and B is not None else tf.constant([])", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_vectors_A = np.random.randint(1, 50)\n        num_vectors_B = np.random.randint(1, 50)\n        vector_dim = np.random.randint(1, 100)\n\n        A = tf.random.uniform((batch_size, num_vectors_A, vector_dim), minval=-10, maxval=10, dtype=tf.float32)\n        B = tf.random.uniform((batch_size, num_vectors_B, vector_dim), minval=-10, maxval=10, dtype=tf.float32)\n\n        test_cases.append((A, B))\n\n    return test_cases"}
{"problem_id": "tensorflow_73", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a tensor of logits and returns a modified tensor based on the top-k values. The function should be able to handle the case where k is zero, in which case it should return the original logits unchanged. The function signature is as follows:\n\n```python\ndef top_k(logits, k):\n```\n\nIn this function, the constant used is `0`, which is checked to determine if the function should return the original logits.\n\nInput format:\n- A tensor `logits` of shape (N, M) where N is the number of samples and M is the number of classes or features.\n- An integer `k` representing the number of top values to consider.\n\nOutput format:\n- A tensor of the same shape as `logits`, with values modified according to the top-k logic described above.\n\nInput:\n```python\nlogits = tf.constant([[1.0, 3.0, 2.0, 4.0, 0.0],\n                      [2.0, 1.0, 3.0, 5.0, 4.0]], dtype=tf.float32)\nk = 3\n```\n\nOutput:\n```python\ntf.Tensor(\n[[0. 3. 2. 4. 0.]\n [0. 0. 3. 5. 4.]], shape=(2, 5), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef top_k(logits, k):\n    if k == 0:\n        return logits\n    values, _ = tf.nn.top_k(logits, k=k)\n    min_values = values[:, -1, tf.newaxis]\n    mask = logits < min_values\n    return tf.where(mask, tf.fill(tf.shape(logits), tf.reduce_min(logits)), logits)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_length = np.random.randint(5, 50)\n        logits = tf.random.uniform((batch_size, seq_length), minval=-5.0, maxval=5.0, dtype=tf.float32)\n        k = np.random.randint(1, seq_length + 1)\n\n        test_cases.append((logits, k))\n\n    return test_cases"}
{"problem_id": "tensorflow_74", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that selects elements from a tensor based on a boolean mask. The function should take two inputs: a tensor `x` and a boolean mask `mask`. The function will return a new tensor containing only the elements of `x` where the corresponding elements in `mask` are `True`.\n\nFunction signature:\n```python\ndef masked_select(x: tf.Tensor, mask: tf.Tensor) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `-1`, which is used in the `tf.reshape` function to flatten the input tensors.\n\nInput format:\n- The function takes two inputs:\n  - `x`: A tensor of any shape containing the elements to be selected.\n  - `mask`: A boolean tensor of the same shape as `x`, where `True` indicates that the corresponding element in `x` should be included in the output.\n\nOutput format:\n- The function returns a tensor containing the elements from `x` that correspond to `True` values in the `mask`. The shape of the output tensor will depend on the number of `True` values in the mask.\n\n```python\n# Input\nx = np.array([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]], dtype=np.float32)\nmask = np.array([[1, 0, 1], [0, 1, 0]], dtype=np.int32)\n\n# Output\noutput = tf.Tensor([1. 3. 5.], shape=(3,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef masked_select(x, mask):\n    x = tf.cast(x, tf.float32)\n    mask = tf.cast(mask, tf.int32)\n    x = tf.reshape(x, [-1])\n    mask = tf.reshape(mask, [-1])\n    mask_true_idx = tf.where(mask)\n    return tf.gather_nd(x, mask_true_idx)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(1, 5, size=np.random.randint(1, 4))\n        x = np.random.randn(*shape).astype(np.float32)\n        mask = np.random.choice([0, 1], size=shape).astype(np.int32)\n        test_cases.append((x, mask))\n\n    return test_cases"}
{"problem_id": "tensorflow_75", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that denormalizes bounding box coordinates based on the dimensions of an image. The function will take in normalized bounding box coordinates and the shape of the image, and it will return the corresponding pixel coordinates of the bounding boxes.\n\nFunction signature:\n```python\ndef denorm_boxes_graph(boxes, shape):\n```\n\nConstant used in the main code:\n- The constant `1.0` is used to adjust the bounding box coordinates to account for the pixel grid.\n\nInput format:\n- `boxes`: A tensor of shape (N, 4) where N is the number of bounding boxes, and each bounding box is represented by four normalized coordinates (x-min, y-min, x-max, y-max).\n- `shape`: A tensor of shape (2,) representing the height and width of the image.\n\nOutput format:\n- A tensor of shape (N, 4) containing the denormalized bounding box coordinates in pixel values (x-min, y-min, x-max, y-max).\n\nInput:\n```python\nboxes = tf.constant([[0.1, 0.2, 0.4, 0.5], [0.3, 0.6, 0.7, 0.9]], dtype=tf.float32)\nshape = tf.constant([50.0, 100.0], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[ 5 20 21 50]\n [15 59 35 90]], shape=(2, 4), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef denorm_boxes_graph(boxes, shape):\n\n    shape = tf.convert_to_tensor(shape, dtype=tf.float32)\n    h, w = tf.split(shape, num_or_size_splits=2, axis=-1)\n    scale = tf.concat([h, w, h, w], axis=-1) - 1.0\n    shift = tf.zeros_like(scale)\n    shift = tf.tensor_scatter_nd_update(shift, [[2], [3]], [1.0, 1.0])\n    return tf.cast(tf.round(boxes * scale + shift), tf.int32)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 11)\n        boxes = tf.random.uniform((batch_size, 4), minval=0, maxval=1, dtype=tf.float32)\n        shape = tf.random.uniform((2,), minval=10, maxval=1000, dtype=tf.float32)\n\n        test_cases.append((boxes, shape))\n\n    return test_cases"}
{"problem_id": "tensorflow_76", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the pairwise distance matrix for a given point cloud using TensorFlow. The function should take a 3D tensor representing a batch of point clouds and return a 3D tensor representing the adjacency matrix based on the pairwise distances between the points in the clouds.\n\nFunction signature:\n```python\ndef pairwise_distance(point_cloud):\n```\n\nConstant used in the main code:\n- The constant `-2` is used to scale the inner product of the point cloud.\n\nInput format:\n- The input to the function is a 3D tensor `point_cloud` of shape `(batch_size, num_points, num_features)`.\n\nOutput format:\n- The output of the function is a 3D tensor `adj_matrix` of shape `(batch_size, num_points, num_points)`, representing the pairwise distances between points in the point clouds.\n\nInput:\n```python\ntf.convert_to_tensor([[[ 0.5, -1.2], \n                        [ 1.0,  0.3], \n                        [-0.5,  0.8]], \n                       [[-0.3,  0.7], \n                        [ 0.2, -0.1], \n                        [ 1.5,  1.0]]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[1.         0.08208498 0.00673795]\n  [0.08208498 1.         0.082085  ]\n  [0.00673795 0.082085   1.        ]]\n [[1.         0.41065577 0.03579311]\n  [0.41065577 1.         0.05502323]\n  [0.03579311 0.05502323 1.        ]]], shape=(2, 3, 3), dtype=float32)\n``` \n", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef pairwise_distance(point_cloud):\n    point_cloud = tf.squeeze(point_cloud)\n    batch_size = tf.shape(point_cloud)[0]\n    point_cloud = tf.reshape(point_cloud, (batch_size, -1, tf.shape(point_cloud)[-1]))\n\n    point_cloud_transpose = tf.transpose(point_cloud, perm=[0, 2, 1])\n    point_cloud_inner = tf.matmul(point_cloud, point_cloud_transpose)\n    point_cloud_inner = -2 * point_cloud_inner\n\n    point_cloud_square = tf.reduce_sum(tf.square(point_cloud), axis=-1, keepdims=True)\n    adj_matrix = point_cloud_square + tf.transpose(point_cloud_square, perm=[0, 2, 1]) + point_cloud_inner\n    adj_matrix = tf.exp(-adj_matrix)\n\n    return adj_matrix", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_points = np.random.randint(5, 100)\n        feature_dim = np.random.randint(2, 20)\n        point_cloud = tf.convert_to_tensor(np.random.randn(batch_size, num_points, feature_dim), dtype=tf.float32)\n\n        test_cases.append(point_cloud)\n\n    return test_cases"}
{"problem_id": "tensorflow_77", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that generates the Cartesian product of multiple input arrays. The function should take a list of tensors as input, where each tensor represents a set of points in a multi-dimensional space. The output should be a tensor that contains all possible combinations of points from the input tensors.\n\nFunction Signature:\n```python\ndef cartesian_graph(a):\n```\n\nConstant Used:\n- The function uses a constant tensor of type `tf.int32` to represent an empty output when the input conditions are not met.\n\nInput Format:\n- The input to the function is a list of tensors, where each tensor is a 1D tensor representing a set of points.\n\nOutput Format:\n- The output of the function is a 2D tensor containing all possible combinations of points from the input tensors, with each row representing a unique combination.\n\nInput:\n```python\n[\n    tf.constant([1, 2, 3], dtype=tf.int32),\n    tf.constant([4, 5], dtype=tf.int32),\n    tf.constant([6, 7], dtype=tf.int32)\n]\n```\n\nOutput:\n```python\ntf.Tensor(\n[[6 1 4]\n [6 1 5]\n [6 2 4]\n [6 2 5]\n [6 3 4]\n [6 3 5]\n [7 1 4]\n [7 1 5]\n [7 2 4]\n [7 2 5]\n [7 3 4]\n [7 3 5]], shape=(12, 3), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef cartesian_graph(a):\n    if not a or len(a) < 2:\n        return tf.constant([], dtype=tf.int32)\n\n    tile_a = tf.expand_dims(tf.tile(tf.expand_dims(a[0], 1), [1, tf.shape(a[1])[0]]), 2)\n    tile_b = tf.expand_dims(tf.tile(tf.expand_dims(a[1], 0), [tf.shape(a[0])[0], 1]), 2)\n    cart = tf.concat([tile_a, tile_b], axis=2)\n    cart = tf.reshape(cart, [-1, 2])\n\n    for c in a[2:]:\n        tile_c = tf.tile(tf.expand_dims(c, 1), [1, tf.shape(cart)[0]])\n        tile_c = tf.expand_dims(tile_c, 2)\n        tile_c = tf.reshape(tile_c, [-1, 1])\n        cart = tf.tile(cart, [tf.shape(c)[0], 1])\n        cart = tf.concat([tile_c, cart], axis=1)\n\n    return cart\n", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_tensors = np.random.randint(2, 6)\n        tensors = [tf.constant(np.random.randint(0, 10, size=np.random.randint(1, 6)), dtype=tf.int32) for _ in\n                   range(num_tensors)]\n\n        test_cases.append(tensors)\n\n    return test_cases"}
{"problem_id": "tensorflow_78", "library": "tensorflow", "code_problem": "You are tasked with implementing a function to calculate the accuracy between two sets of predictions and their corresponding true values using TensorFlow. The function should be able to handle multi-dimensional tensors, which are commonly used in machine learning tasks, particularly in image processing.\n\nFunction signature:\n```python\ndef accuracy(y_true, y_pred):\n```\n\nIn this function, `y_true` represents the ground truth values, while `y_pred` represents the predicted values from a model. Both inputs are expected to be multi-dimensional tensors.\n\nThe constant used in the main code is `1`, which is added to both the numerator and denominator to avoid division by zero.\n\nInput format:\n- `y_true`: A multi-dimensional tensor of true values.\n- `y_pred`: A multi-dimensional tensor of predicted values.\n\nOutput format:\n- A single scalar value representing the mean accuracy between the predicted and true values.\n\nInput:\n```python\ny_true = tf.constant([[[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]]])\ny_pred = tf.constant([[[[0.1, 0.2], [0.3, 0.5]], [[0.5, 0.7], [0.6, 0.8]]]])\n```\n\nOutput:\n```python\naccuracy_value = tf.Tensor(0.9952945, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef accuracy(y_true, y_pred):\n    denom = tf.sqrt(tf.reduce_sum(tf.pow(y_pred, 2), axis=[1, 2, 3]) * tf.reduce_sum(tf.pow(y_true, 2), axis=[1, 2, 3]))\n    return tf.reduce_mean((tf.reduce_sum(y_pred * y_true, axis=[1, 2, 3]) + 1) / (denom + 1), axis=0)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(10, 50)\n        width = np.random.randint(10, 50)\n        channels = np.random.choice([1, 3, 4])\n\n        y_true = tf.random.uniform(shape=(batch_size, height, width, channels), minval=0, maxval=1)\n        y_pred = tf.random.uniform(shape=(batch_size, height, width, channels), minval=0, maxval=1)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "tensorflow_79", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that modifies a set of logits based on a specified probability threshold using the top-p sampling technique. The function should filter out logits that are below a certain cumulative probability threshold, effectively limiting the number of logits considered for sampling.\n\nFunction signature:\n```python\ndef top_p_logits(logits, p):\n```\n\nConstant used in the main code:\n- `-1e10`: This constant is used to replace logits that are below the minimum value determined by the cumulative probability threshold.\n\nInput format:\n- The input `logits` is a tensor of shape `(batch_size, num_logits)` where `batch_size` is the number of samples and `num_logits` is the number of logits for each sample.\n- The input `p` is a float representing the cumulative probability threshold.\n\nOutput format:\n- The output is a tensor of the same shape as `logits`, where logits below the cumulative probability threshold are replaced with `-1e10`.\n\n```python\n# Input\nlogits = tf.convert_to_tensor([[0.2, 0.5, 0.1], [0.4, 0.3, 0.6]], dtype=tf.float32)\np = tf.convert_to_tensor(0.8, dtype=tf.float32)\n\n# Output\noutput = tf.Tensor(\n[[ 2.e-01  5.e-01 -1.e+10]\n [ 4.e-01 -1.e+10  6.e-01]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef top_p_logits(logits, p):\n    shape = tf.shape(logits)\n    batch = shape[0]\n    sorted_logits = tf.sort(logits, direction='DESCENDING', axis=-1)\n    cumulative_probs = tf.cumsum(tf.nn.softmax(sorted_logits, axis=-1), axis=-1)\n    indices = tf.stack([\n        tf.range(batch),\n        tf.maximum(tf.reduce_sum(tf.cast(cumulative_probs <= p, tf.int32), axis=-1) - 1, 0)\n    ], axis=-1)\n\n    min_values = tf.gather_nd(sorted_logits, indices)\n    min_values = tf.expand_dims(min_values, axis=-1)\n\n    return tf.where(logits < min_values, tf.fill(tf.shape(logits), -1e10), logits)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        vocab_size = np.random.randint(5, 100)\n        logits = np.random.randn(batch_size, vocab_size).astype(np.float32)\n        p = np.random.uniform(0.5, 1.0)\n\n        test_cases.append((tf.convert_to_tensor(logits), tf.convert_to_tensor(p)))\n\n    return test_cases"}
{"problem_id": "tensorflow_80", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the total regularization loss for a machine learning model using TensorFlow. The function should consider both L1 and L2 regularization for the model's weights (filters) and biases, as well as any additional regularization loss from a specified nonlinearity.\n\nFunction signature:\n```python\ndef tf_regularization_loss(bias, l2_regularization, filters, nonlinearity, l1_regularization):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `0.0`, which is used to check if the regularization parameters (L1 and L2) are greater than zero.\n\nInput format:\n- `bias`: A tensor representing the bias weights of the model (can be `None`).\n- `l2_regularization`: A float representing the L2 regularization factor.\n- `filters`: A tensor representing the model's filter weights.\n- `nonlinearity`: An object that has a method `regularization_loss()` which returns a float or `None`.\n- `l1_regularization`: A float representing the L1 regularization factor.\n\nOutput format:\n- The function returns a tensor representing the total regularization loss, which is a scalar value. If no losses are calculated, it returns `0`.\n\nInput:\n```python\nbias = tf.constant([-0.5, 0.3], dtype=tf.float32)\nl2_regularization = 0.1\nfilters = tf.constant([[0.2, -0.1], [0.4, 0.5]], dtype=tf.float32)\nclass DummyNonlinearity:\n    def regularization_loss(self):\n        return tf.constant(0.05, dtype=tf.float32)\n\nnonlinearity = DummyNonlinearity()\nl1_regularization = 0.2\n```\n\nOutput:\n```python\ntf_regularization_loss(bias, l2_regularization, filters, nonlinearity, l1_regularization)\n# Expected output: tf.Tensor(0.49, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tf_regularization_loss(bias, l2_regularization, filters, nonlinearity, l1_regularization):\n    losses = []\n\n    if l2_regularization > 0.0:\n        losses.append(l2_regularization * tf.nn.l2_loss(filters))\n        if bias is not None:\n            losses.append(l2_regularization * tf.nn.l2_loss(bias))\n\n    if l1_regularization > 0.0:\n        losses.append(l1_regularization * tf.reduce_sum(tf.abs(filters)))\n        if bias is not None:\n            losses.append(l1_regularization * tf.reduce_sum(tf.abs(bias)))\n\n    nonlin_loss = nonlinearity.regularization_loss()\n    if nonlin_loss is not None:\n        losses.append(nonlin_loss)\n\n    return tf.add_n(losses) if losses else 0", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        include_bias = np.random.choice([True, False])\n        bias_shape = (np.random.randint(1, 10),) if include_bias else None\n        bias = tf.constant(np.random.randn(*bias_shape), dtype=tf.float32) if include_bias else None\n        filter_shape = tuple(np.random.randint(1, 10, size=np.random.randint(2, 5)))\n        filters = tf.constant(np.random.randn(*filter_shape), dtype=tf.float32)\n        l1_regularization = np.random.uniform(0.0, 1.0)\n        l2_regularization = np.random.uniform(0.0, 1.0)\n        class DummyNonlinearity:\n            def regularization_loss(self):\n                return tf.constant(np.random.randn(), dtype=tf.float32) if np.random.choice([True, False]) else None\n\n        nonlinearity = DummyNonlinearity()\n\n        test_cases.append((bias, l2_regularization, filters, nonlinearity, l1_regularization))\n\n    return test_cases"}
{"problem_id": "tensorflow_81", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes a rotation matrix based on a given axis-angle representation and a skew matrix. The function should be able to handle multiple axis-angle inputs in a batch format.\n\nFunction signature:\n```python\ndef rotate(axis_angle, skew):\n```\n\n### Constants:\n- `eps`: A small constant value set to `1e-8`, used to prevent division by zero when normalizing the axis vector.\n\n### Input Format:\n- `axis_angle`: A tensor of shape `[N, 3]` where `N` is the number of axis-angle vectors.\n- `skew`: A tensor of shape `[N, 3, 3]` representing the skew matrices corresponding to each axis-angle vector.\n\n### Output Format:\n- The function returns a tensor of shape `[N, 3, 3]`, which represents the rotation matrices corresponding to the input axis-angle and skew matrices.\n\nInput:\n```python\naxis_angle = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=np.float32)\nskew = np.array([[[0, -0.3, 0.2], [0.3, 0, -0.1], [-0.2, 0.1, 0]], \n                  [[0, -0.5, 0.4], [0.5, 0, -0.2], [-0.4, 0.2, 0]]], dtype=np.float32)\n```\n\nOutput:\n```python\nrotation_matrix = tf.Tensor(\n[[[ 0.9357548  -0.09976497  0.08792505]\n  [ 0.11953273  0.9505806  -0.00689798]\n  [-0.05827342  0.06620125  0.9752903 ]]\n [[ 0.7140753  -0.2908249   0.42015147]\n  [ 0.47831643  0.756261   -0.0132096 ]\n  [-0.19516158  0.29444695  0.80782115]]], shape=(2, 3, 3), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef rotate(axis_angle, skew):\n    initial_shape = tf.shape(axis_angle)\n    axis_angle = tf.reshape(axis_angle, [-1, 3])\n    batch_size = tf.shape(axis_angle)[0]\n\n    eps = tf.constant(1e-8, dtype=axis_angle.dtype)\n    angle = tf.expand_dims(tf.norm(axis_angle + eps, axis=1), -1)\n    axis = tf.expand_dims(axis_angle / angle, -1)\n    angle = tf.expand_dims(angle, -1)\n\n    cos_angle = tf.cos(angle)\n    sin_angle = tf.sin(angle)\n\n    outer_product = tf.matmul(axis, axis, transpose_b=True)\n    identity_matrix = tf.eye(3, dtype=axis_angle.dtype)\n    identity_matrix = tf.tile(tf.expand_dims(identity_matrix, 0), [batch_size, 1, 1])\n\n    rotation_matrix = cos_angle * identity_matrix + (1 - cos_angle) * outer_product + sin_angle * skew\n    rotation_matrix = tf.reshape(rotation_matrix, tf.concat([initial_shape, [3]], axis=0))\n\n    return rotation_matrix", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 11)\n        axis_angle = np.random.randn(batch_size, 3).astype(np.float32)\n        skew = np.random.randn(batch_size, 3, 3).astype(np.float32)\n\n        test_cases.append((axis_angle, skew))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_82", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that generates a set of indices for a given tensor based on specified batch dimensions. The function should be able to handle both batch-major and index-major formats for the output indices.\n\nFunction signature:\n```python\ndef nd_indices(indices: tf.Tensor, batch_axis: int, indices_batch_major: bool) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- There are no explicit constants defined in the main code.\n\nInput format:\n- `indices`: A tensor of shape `(N, ...)` where `N` is the number of indices and `...` represents additional dimensions.\n- `batch_axis`: An integer representing the axis of the batch dimension in the `indices` tensor.\n- `indices_batch_major`: A boolean indicating whether the output should have batch indices first or second.\n\nOutput format:\n- A tensor of shape `(N, 2)` where each entry contains a pair of indices, with the first index being from the batch dimension and the second index being from the original `indices` tensor, arranged according to the `indices_batch_major` flag.\n\n**Input:**\n```python\nindices = tf.convert_to_tensor([[1, 2], [3, 4]], dtype=tf.int32)\nbatch_axis = 0\nindices_batch_major = True\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[[0 1]\n  [0 2]]\n [[1 3]\n  [1 4]]], shape=(2, 2, 2), dtype=int32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\ndef expand_dims_unbroadcast(x, axis, dim):\n    x = tf.convert_to_tensor(x)\n    x = tf.expand_dims(x, axis)\n    new_ndim = x.get_shape().ndims\n    if new_ndim is not None and isinstance(axis, int):\n        if axis < 0:\n            axis = new_ndim + axis\n        x = tf.tile(x, [dim if axis == i else 1 for i in range(new_ndim)])\n    return x\n\n# main code\ndef nd_indices(indices, batch_axis, indices_batch_major):\n    batches_idxs = tf.range(tf.shape(indices)[batch_axis])\n    batches_idxs = tf.cast(batches_idxs, dtype=indices.dtype)\n    for axis in range(indices.get_shape().ndims):\n        if axis == batch_axis:\n            continue\n        batches_idxs = expand_dims_unbroadcast(batches_idxs, axis=axis, dim=tf.shape(indices)[axis])\n    batches_idxs.set_shape(indices.get_shape())\n    if indices_batch_major:\n        idxs_exp = tf.stack([batches_idxs, indices], axis=-1)\n    else:\n        idxs_exp = tf.stack([indices, batches_idxs], axis=-1)\n    return idxs_exp", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = np.random.randint(2, 5)\n        shape = np.random.randint(1, 10, size=rank).tolist()\n        indices = tf.convert_to_tensor(np.random.randint(0, 10, size=shape, dtype=np.int32))\n        batch_axis = np.random.randint(0, rank)\n        indices_batch_major = bool(np.random.choice([True, False]))\n        test_cases.append((indices, batch_axis, indices_batch_major))\n\n    return test_cases"}
{"problem_id": "tensorflow_83", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes sequential data using a recurrent neural network (RNN) architecture. The function should support different types of RNN cells, including LSTM, GRU, and SimpleRNN, and it should be capable of handling both static and dynamic input sequences. Additionally, the function should allow for the use of attention mechanisms and dropout for regularization.\n\nFunction signature:\n```python\ndef forward(x, _rnn_cell, _dropout_keep_prob, _hidden_units, _use_attention, _use_dynamic, _num_layers):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the dictionary that maps string representations of RNN cell types to their corresponding TensorFlow classes: `{'lstm': LSTM, 'gru': GRU, 'rnn': SimpleRNN}`.\n\nInput format:\n- The input tensor `x` should be a 3D tensor of shape (batch_size, timesteps, features).\n- The other parameters are as described in the function signature.\n\nOutput format:\n- The output will be a 2D tensor of shape (batch_size, 2 * hidden_units), representing the concatenated hidden states from the forward and backward RNN layers.\n\n**Input:**\n```python\nimport numpy as np\nimport tensorflow as tf\n\n# Test case\nbatch_size = 10\nseq_length = 20\nfeature_dim = 8\nhidden_units = 32\nrnn_cell = 'lstm'\ndropout_keep_prob = 0.8\nuse_attention = False\nuse_dynamic = True\nnum_layers = 2\n\n# Generate input tensor\nx = tf.random.normal((batch_size, seq_length, feature_dim))\n\n# Call the forward function\noutput = forward(x, rnn_cell, dropout_keep_prob, hidden_units, use_attention, use_dynamic, num_layers)\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[ 1.71069894e-02 -2.44057745e-01  1.29624149e-02 -1.39191449e-01\n  ...\n   2.69076258e-01  4.39973772e-02  6.17068075e-02  6.06336519e-02]\n ...\n [ 3.99467126e-02 -3.36670429e-02 -5.50915822e-02  1.18388813e-02\n  ...\n  -2.47200206e-02 -6.08722344e-02  5.04699796e-02 -2.06258688e-02]], shape=(10, 64), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\nfrom tensorflow.keras.layers import LSTM, GRU, SimpleRNN, Bidirectional\n\n# main code\ndef forward(x, _rnn_cell, _dropout_keep_prob, _hidden_units, _use_attention, _use_dynamic, _num_layers):\n    if not _use_dynamic:\n        x = tf.transpose(x, perm=[1, 0, 2])\n\n    rnn_cell = {'lstm': LSTM, 'gru': GRU, 'rnn': SimpleRNN}.get(_rnn_cell.lower(), SimpleRNN)\n\n    rnn_layer = Bidirectional(rnn_cell(_hidden_units, return_sequences=True, return_state=True))\n\n    rnn_outputs = rnn_layer(x)\n\n    if _rnn_cell.lower() == 'lstm':\n        outputs, forward_h, forward_c, backward_h, backward_c = rnn_outputs\n        out = tf.concat([forward_h, backward_h], axis=1)\n    else:\n        outputs, forward_state, backward_state = rnn_outputs\n        out = tf.concat([forward_state, backward_state], axis=1)\n\n    return out\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    rnn_cell_types = ['lstm', 'gru', 'rnn']\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 33)\n        seq_length = np.random.randint(5, 51)\n        feature_dim = np.random.randint(4, 129)\n        hidden_units = np.random.randint(16, 129)\n        num_layers = np.random.randint(1, 5)\n\n        rnn_cell = np.random.choice(rnn_cell_types)\n        dropout_keep_prob = np.random.uniform(0.5, 1.0)\n        use_attention = np.random.choice([True, False])\n        use_dynamic = np.random.choice([True, False])\n\n        # Ensure the tensor shape is correct\n        x = tf.random.normal((batch_size, seq_length, feature_dim))\n\n        test_cases.append((x, rnn_cell, dropout_keep_prob, hidden_units, use_attention, use_dynamic, num_layers))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_84", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that slices a tensor along a specified axis and pads it with zeros if the slice indices go out of bounds. The function should handle both negative and positive indices for slicing and ensure that the resulting tensor maintains the original shape where possible.\n\nFunction signature:\n```python\ndef slice_pad_zeros(x, begin, end, axis):\n```\n\n### Constants:\n- The constant used in the main code is `0`, which is used for padding and as a default value for the `begin` and `end` parameters.\n\n### Input Format:\n- The input consists of a tensor `x`, two integers `begin` and `end`, and an integer `axis`.\n\n### Output Format:\n- The output is a tensor that is sliced according to the specified `begin` and `end` indices, with zeros padded as necessary to ensure the slice is valid.\n\n**Input:**\n```python\nx = tf.convert_to_tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]], dtype=tf.int32)\nbegin = -2\nend = 2\naxis = 1\n```\n\n**Output:**\n```python\nresult = tf.Tensor(\n[[0 0 1 2]\n [0 0 4 5]\n [0 0 7 8]], shape=(3, 4), dtype=int32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef single_strided_slice(x, axis, begin=None, end=None, step=None):\n    if isinstance(axis, int):\n        if axis < 0 and x.get_shape().ndims is not None:\n            axis %= x.get_shape().ndims\n        return x[(slice(None),) * axis + (slice(begin, end, step),)]\n\n    axis = axis % tf.rank(x)\n    shape = tf.shape(x)\n    begin = begin if begin is not None else 0\n    end = end if end is not None else shape[axis]\n    begins = tf.concat([tf.zeros((axis,), tf.int32), [begin]], axis=0)\n    ends = tf.concat([shape[:axis], [end]], axis=0)\n    strides = tf.concat([tf.ones((axis,), tf.int32), [step]], axis=0) if step is not None else None\n\n    return tf.strided_slice(x, begin=begins, end=ends, strides=strides)\n\n\ndef pad_zeros_in_axis(x, before=0, after=0, axis=0):\n    paddings = tf.tensor_scatter_nd_update(tf.zeros((tf.rank(x), 2), dtype=tf.int32),\n                                           [[axis]], [[before, after]])\n    return tf.pad(x, paddings=paddings)\n\n# main code\ndef slice_pad_zeros(x, begin, end, axis):\n    min_frame = tf.minimum(begin, end)\n    left_rem = -min_frame\n    x, begin, end = tf.cond(tf.less_equal(left_rem, 0),\n                            lambda: (x, begin, end),\n                            lambda: (\n                            pad_zeros_in_axis(x, before=left_rem, axis=axis), begin + left_rem, end + left_rem))\n\n    max_frame = tf.maximum(begin, end)\n    right_rem = max_frame - tf.shape(x)[axis]\n    x = tf.cond(tf.less_equal(right_rem, 0),\n                lambda: x,\n                lambda: pad_zeros_in_axis(x, after=right_rem, axis=axis))\n\n    return single_strided_slice(x, axis=axis, begin=begin, end=end)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = np.random.randint(1, 5)\n        shape = np.random.randint(2, 11, size=rank)\n        x = tf.convert_to_tensor(np.random.randint(-100, 100, size=shape), dtype=tf.int32)\n        axis = np.random.randint(0, rank)\n        begin = np.random.randint(-shape[axis] // 2, shape[axis] // 2)\n        end = np.random.randint(begin, shape[axis])\n\n        test_cases.append((x, begin, end, axis))\n\n    return test_cases"}
{"problem_id": "tensorflow_85", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that reshapes a tensor by rearranging its dimensions based on specified axes. The function should handle both real axes (specified as integers) and broadcast axes (specified as the string 'x'). The function will ensure that the tensor is properly reshaped, squeezed, and transposed according to the provided axes.\n\nFunction signature:\n```python\ndef dimshuffle(x, axes):\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- The input consists of a tensor `x` and a list `axes` that specifies the desired arrangement of the tensor's dimensions.\n\nOutput format:\n- The output is a tensor that has been reshaped according to the specified axes, with the appropriate dimensions squeezed and expanded as necessary.\n\n**Input:**\n```python\nx = tf.constant([[1, 2], [3, 4]], dtype=tf.float32)  # Shape: (2, 2)\naxes = [0, 'x', 1]  # Expanding the second dimension\n```\n\n**Output:**\n```python\noutput = tf.Tensor(\n[[[1. 2.]]\n [[3. 4.]]], shape=(2, 1, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef expand_multiple_dims(x, axes):\n    for i in sorted(axes):\n        x = tf.expand_dims(x, axis=i)\n    return x\n\n# main code\ndef dimshuffle(x, axes):\n    real_axes = [i for i in axes if isinstance(i, int)]\n    bc_axes = [i for i, j in enumerate(axes) if j == 'x']\n\n    if x.get_shape().ndims is None:\n        x = tf.reshape(x, tf.shape(x)[:max(real_axes) + 1])\n\n    i = 0\n    while i < x.get_shape().ndims:\n        if i not in real_axes:\n            x = tf.squeeze(x, axis=i)\n            real_axes = [j if j < i else j - 1 for j in real_axes]\n        else:\n            i += 1\n\n    if real_axes != list(range(x.get_shape().ndims)):\n        x = tf.transpose(x, real_axes)\n\n    if bc_axes:\n        x = expand_multiple_dims(x, bc_axes)\n\n    return x", "test_script": "import tensorflow as tf\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = random.randint(1, 5)\n        shape = [random.randint(1, 10) for _ in range(rank)]\n        x = tf.constant(np.random.rand(*shape), dtype=tf.float32)\n        permuted_axes = list(range(rank))\n        random.shuffle(permuted_axes)\n        num_bc_axes = random.randint(0, 2)\n        bc_positions = sorted(random.sample(range(rank + num_bc_axes), num_bc_axes))\n        axes = []\n        j = 0\n        for i in range(rank + num_bc_axes):\n            if i in bc_positions:\n                axes.append('x')\n            else:\n                axes.append(permuted_axes[j])\n                j += 1\n\n        test_cases.append((x, axes))\n\n    return test_cases"}
{"problem_id": "tensorflow_86", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs padding on a tensor by replicating its boundary values. The function should allow for specifying which axes to pad and how much padding to apply on each side of the specified axis.\n\nFunction signature:\n```python\ndef pad_replicate(x: tf.Tensor, axes: List[int], padding: List[List[int]]) -> tf.Tensor:\n```\n\nConstants used in the main code:\n- The constant used in the main code is `0`, which is used to gather the first element of the tensor for left padding and to gather the last element of the tensor for right padding.\n\nInput format:\n- `x`: A TensorFlow tensor of any shape.\n- `axes`: A list of integers indicating the axes to pad.\n- `padding`: A list of lists where each inner list contains two integers for left and right padding.\n\nOutput format:\n- The function returns a TensorFlow tensor that has been padded according to the specified parameters.\n\nInput:\n```python\nx = tf.constant([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)\naxes = [0]\npadding = [[1, 2]]\n```\n\nOutput:\n```python\ntf.Tensor(\n[[1. 2.]\n [1. 2.]\n [3. 4.]\n [3. 4.]\n [3. 4.]], shape=(5, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef pad_replicate(x, axes, padding):\n    pad_left = tf.gather(x, 0, axis=axes[0])\n    pad_left = tf.expand_dims(pad_left, axis=axes[0])\n    pad_left = tf.repeat(pad_left, padding[0][0], axis=axes[0])\n\n    pad_right = tf.gather(x, tf.shape(x)[axes[0]] - 1, axis=axes[0])\n    pad_right = tf.expand_dims(pad_right, axis=axes[0])\n    pad_right = tf.repeat(pad_right, padding[0][1], axis=axes[0])\n\n    return tf.concat([pad_left, x, pad_right], axis=axes[0])", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = np.random.randint(2, 10, size=np.random.randint(1, 6)).tolist()\n        x = tf.random.uniform(shape, dtype=tf.float32)\n        axes = [np.random.randint(0, len(shape))]\n        pad_before = np.random.randint(0, shape[axes[0]] + 1)\n        pad_after = np.random.randint(0, shape[axes[0]] + 1)\n        padding = [[pad_before, pad_after]]\n\n        test_cases.append((x, axes, padding))\n\n    return test_cases"}
{"problem_id": "tensorflow_87", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the R1 regularization penalty for a given discriminator model in a Generative Adversarial Network (GAN) setup. The function will compute the gradient of the discriminator's output with respect to real input data and use this to derive the R1 penalty.\n\nFunction signature:\n```python\ndef r1_gp_req(discriminator, x_real, y_org):\n```\n\nConstant used in the main code:\n- The constant `0.5` is used in the calculation of the R1 penalty.\n\nInput format:\n- `discriminator`: A TensorFlow model that takes a batch of real data and corresponding labels as input.\n- `x_real`: A tensor representing a batch of real input data.\n- `y_org`: A tensor representing the corresponding labels or additional information for the real input data.\n\nOutput format:\n- The function returns a tensor representing the R1 regularization penalty, which is a scalar value derived from the gradients of the discriminator's output with respect to the real input data.\n\nInput:\n```python\ndiscriminator = SimpleDiscriminator()\nx_real = tf.random.normal(shape=(5, 64, 64, 3))  # Batch of 5 images, 64x64 pixels, 3 channels\ny_org = tf.random.uniform(shape=(5, 10), minval=0, maxval=1, dtype=tf.float32)  # Batch of 5 labels, 10 classes\n```\n\nOutput:\n```python\nr1_penalty = r1_gp_req(discriminator, x_real, y_org)\n# r1_penalty: tf.Tensor(6144.0, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef r1_gp_req(discriminator, x_real, y_org):\n    with tf.GradientTape() as p_tape:\n        p_tape.watch(x_real)\n        real_loss = tf.reduce_sum(discriminator([x_real, y_org]))\n    real_grads = p_tape.gradient(real_loss, x_real)\n    r1_penalty = 0.5 * tf.reduce_mean(tf.reduce_sum(tf.square(real_grads), axis=[1, 2, 3]))\n    return r1_penalty", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    class SimpleDiscriminator(tf.keras.Model):\n        def call(self, inputs):\n            x_real, y_org = inputs\n            x_flat = tf.reshape(x_real, [tf.shape(x_real)[0], -1])\n            y_flat = tf.reshape(y_org, [tf.shape(y_org)[0], -1])\n            combined = tf.concat([x_flat, y_flat], axis=-1)\n            return tf.reduce_sum(combined, axis=-1, keepdims=True)\n\n    test_cases = []\n    discriminator = SimpleDiscriminator()\n    for _ in range(n):\n        batch_size = np.random.randint(1, 16)\n        height = np.random.randint(16, 128)\n        width = np.random.randint(16, 128)\n        channels = np.random.choice([1, 3, 64])\n        x_real = tf.random.normal(shape=(batch_size, height, width, channels))\n        y_org_dim = np.random.choice([1, 10, 100])\n        y_org = tf.random.uniform(shape=(batch_size, y_org_dim), minval=0, maxval=1, dtype=tf.float32)\n        test_cases.append((discriminator, x_real, y_org))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_88", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the vertex normals for a 3D mesh given its vertices and faces. The function should allow for the option to normalize the computed vertex normals. The function signature is as follows:\n\n```python\ndef compute_vertex_normals(vertices, faces, normalize=False, dtype=tf.float32):\n```\n\n### Constants:\n- The constant used in the main code is `dtype`, which defaults to `tf.float32`.\n\n### Input and Output Format:\n- **Input**:\n  - `vertices`: A tensor of shape (N, 3) where N is the number of vertices.\n  - `faces`: A tensor of shape (M, 3) where M is the number of faces, or a list of indices defining the faces.\n  - `normalize`: A boolean indicating whether to normalize the output.\n  - `dtype`: The data type for the computations.\n\n- **Output**:\n  - A tensor of shape (N, 3) representing the computed vertex normals, either normalized or raw based on the `normalize` flag.\n\n**Input:**\n```python\nvertices = np.array([[[0.0, 0.0, 0.0],\n                       [1.0, 0.0, 0.0],\n                       [0.0, 1.0, 0.0],\n                       [0.0, 0.0, 1.0]]], dtype=np.float32)  # Batch size = 1, 4 vertices\n\nfaces = np.array([[0, 1, 2],  # One face defined by vertices 0, 1, 2\n                  [0, 1, 3]], dtype=np.int32)  # Another face defined by vertices 0, 1, 3\n\nnormalize = False\ndtype = tf.float32\n```\n\n**Output:**\n```python\nvertex_normals = tf.Tensor(\n[[[ 0. -1.  1.]\n  [ 0. -1.  1.]\n  [ 0.  0.  1.]\n  [ 0. -1.  0.]]], shape=(1, 4, 3), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n\nclass FaceNormalCalculator:\n    def __init__(self, normalize=False, dtype=tf.float32):\n        self.normalize = normalize\n        self.dtype = dtype\n\n    def compute(self, vertices, faces):\n        v0, v1, v2 = [tf.gather(vertices, faces[..., i], batch_dims=1) for i in range(3)]\n        normals = tf.linalg.cross(v1 - v0, v2 - v0)\n        return tf.math.l2_normalize(normals, axis=-1) if self.normalize else normals\n\n# main code\ndef compute_vertex_normals(vertices, faces, normalize=False, dtype=tf.float32):\n    batch_size = tf.shape(vertices)[0]\n\n    faces = tf.convert_to_tensor(faces, dtype=tf.int32) if not tf.is_tensor(faces) else faces\n    faces = tf.reshape(tf.tile(tf.reshape(faces, [-1]), [batch_size]), [batch_size] + faces.shape.as_list())\n\n    shape_faces = faces.shape.as_list()\n    normal_calculator = FaceNormalCalculator(normalize=False, dtype=dtype)\n    mesh_face_normals = normal_calculator.compute(vertices, faces)\n\n    outer_indices = tf.tile(tf.expand_dims(tf.range(batch_size, dtype=tf.int32), axis=-1),\n                            [1, tf.shape(faces)[-2]])\n\n    vertex_normals = tf.zeros_like(vertices)\n\n    for i in range(shape_faces[-1]):\n        scatter_indices = tf.concat([tf.expand_dims(outer_indices, axis=-1), faces[..., i:i + 1]], axis=-1)\n\n        vertex_normals = tf.tensor_scatter_nd_add(vertex_normals, scatter_indices, mesh_face_normals)\n\n    return tf.math.l2_normalize(vertex_normals, axis=-1) if normalize else vertex_normals", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        num_vertices = np.random.randint(4, 100)\n        num_faces = np.random.randint(2, max(3, num_vertices // 2))\n        vertices = np.random.randn(batch_size, num_vertices, 3).astype(np.float32)\n        faces = np.random.randint(0, num_vertices, size=(num_faces, 3)).astype(np.int32)\n\n        normalize = np.random.choice([True, False])\n        dtype = tf.float32\n\n        test_cases.append((vertices, faces, normalize, dtype))\n\n    return test_cases"}
{"problem_id": "tensorflow_89", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates a custom margin loss for a binary classification problem using TensorFlow. The function should be able to handle the true labels and the predicted logits, applying specific transformations to compute the loss.\n\nFunction signature:\n```python\ndef margin_loss(y, logits):\n```\n\nIn this function, the following constant is used:\n- `0.9`: This constant represents the margin threshold for positive samples.\n- `0.1`: This constant represents the margin threshold for negative samples.\n- `0.25`: This constant is a scaling factor for the loss associated with negative samples.\n\nInput format:\n- `y`: A tensor of shape (batch_size, num_classes) containing the true labels (0 or 1).\n- `logits`: A tensor of shape (batch_size, num_classes) containing the predicted logits from the model.\n\nOutput format:\n- A single scalar tensor representing the computed margin loss for the input batch.\n\n```python\n# Input\ny = tf.convert_to_tensor([[1, 0, 1], [0, 1, 0]], dtype=tf.float32)\nlogits = tf.convert_to_tensor([[0.5, 1.5, 0.2], [0.0, 0.8, 1.0]], dtype=tf.float32)\n\n# Output\nloss = margin_loss(y, logits)\n# The expected output: tf.Tensor(0.67625, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef margin_loss(y, logits):\n    y = tf.cast(y, tf.float32)\n    loss = y * tf.square(tf.maximum(0.0, 0.9 - logits)) + 0.25 * (1.0 - y) * tf.square(tf.maximum(0.0, logits - 0.1))\n    loss = tf.reduce_mean(tf.reduce_sum(loss, axis=1))\n    return loss\n", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_classes = np.random.randint(2, 5)\n\n        y = np.random.randint(0, 2, size=(batch_size, num_classes))\n        logits = np.random.uniform(-1.0, 2.0, size=(batch_size, num_classes))\n        y_tensor = tf.convert_to_tensor(y, dtype=tf.float32)\n        logits_tensor = tf.convert_to_tensor(logits, dtype=tf.float32)\n        test_cases.append((y_tensor, logits_tensor))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_90", "library": "tensorflow", "code_problem": "```python\ndef unbroadcast_to_common_shape(value, common_shape, ignore_axes=(), allow_only_noop=False):\n```\n\nIn this code, the function `unbroadcast_to_common_shape` is designed to adjust the shape of a given tensor `value` to match a specified `common_shape`. The function takes into account certain axes that can be ignored during this adjustment and has an option to allow only no-operation (noop) transformations.\n\n\n### Input and Output Format:\n- **Input**:\n  - `value`: A tensor or a scalar value to be reshaped.\n  - `common_shape`: A list or tuple representing the target shape to match.\n  - `ignore_axes`: An optional list or tuple of axes to ignore during the reshaping process.\n  - `allow_only_noop`: A boolean flag indicating whether to allow only no-operation transformations.\n\n- **Output**:\n  - The function returns a tensor that has been reshaped to match the `common_shape`, taking into account the specified ignored axes and the no-operation flag.\n\n**Input:**\n```python\nvalue = tf.constant([[1]], dtype=tf.int32)  # Shape (1, 1)\ncommon_shape = [2, 3]                        # Target shape (2, 3)\nignore_axes = []                              # No axes to ignore\nallow_only_noop = False                       # Allow tiling\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[1 1 1]\n [1 1 1]], shape=(2, 3), dtype=int32\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef expand_multiple_dims(x, axes):\n    for i in sorted(axes):\n        x = tf.expand_dims(x, axis=i)\n    return x\n\n# main code\ndef unbroadcast_to_common_shape(value, common_shape, ignore_axes=(), allow_only_noop=False):\n    if not isinstance(value, tf.Tensor):\n        if isinstance(value, (float, int)) and not common_shape:\n            return value\n        value = tf.convert_to_tensor(value)\n\n    ndim = value.shape.ndims if value.shape.ndims is not None else len(common_shape)\n\n    if ndim == 0:\n        value = expand_multiple_dims(value, axes=list(range(len(common_shape))))\n        ndim = len(common_shape)\n\n    static_shape = value.shape.as_list()\n    tile_multiples = [(common_shape[i] if static_shape[i] == 1 else 1) for i in range(ndim)]\n\n    for axis in ignore_axes:\n        if 0 <= axis < ndim:\n            tile_multiples[axis] = 1\n\n    if all(isinstance(m, int) and m == 1 for m in tile_multiples):\n        return value\n\n    if not allow_only_noop:\n        value = tf.tile(value, tile_multiples)\n\n    return value", "test_script": "import tensorflow as tf\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rank = random.randint(0, 4)\n        common_shape = [random.choice([1, random.randint(2, 5)]) for _ in range(rank)]\n        value_shape = [\n            1 if random.random() < 0.5 else dim\n            for dim in common_shape\n        ]\n        dtype = random.choice([tf.float32, tf.int32])\n        if dtype == tf.int32:\n            value = tf.constant(np.random.randint(0, 10, size=value_shape), dtype=dtype)\n        else:\n            value = tf.constant(np.random.rand(*value_shape) * 10, dtype=dtype)\n        ignore_axes = random.sample(range(len(common_shape)), random.randint(0, len(common_shape)))\n        allow_only_noop = random.choice([True, False])\n\n        test_cases.append((value, common_shape, ignore_axes, allow_only_noop))\n\n    return test_cases"}
{"problem_id": "tensorflow_91", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that refines object detection results based on region proposals, class probabilities, and bounding box deltas. The function will process these inputs to produce a refined set of detections that are clipped to a specified window and filtered based on confidence scores.\n\nFunction signature:\n```python\ndef refine_detections_graph(rois, probs, deltas, window, config):\n```\n\nConstants used in the main code:\n- `config.BBOX_STD_DEV`: A constant used to scale the bounding box deltas.\n- `config.DETECTION_MIN_CONFIDENCE`: A threshold for filtering detections based on their confidence scores.\n- `config.DETECTION_MAX_INSTANCES`: The maximum number of instances to keep after refinement.\n\nInput format:\n- `rois`: A tensor of shape (N, 4) representing the region proposals, where N is the number of proposals.\n- `probs`: A tensor of shape (N, num_classes) representing the class probabilities for each proposal.\n- `deltas`: A tensor of shape (N, 4) representing the bounding box deltas for each proposal.\n- `window`: A tensor of shape (4,) representing the window to which the boxes should be clipped.\n- `config`: An object containing configuration parameters, including `BBOX_STD_DEV`, `DETECTION_MIN_CONFIDENCE`, and `DETECTION_MAX_INSTANCES`.\n\nOutput format:\n- A tensor of shape (config.DETECTION_MAX_INSTANCES, 6) containing the refined detections, where each detection includes the bounding box coordinates, class ID, and class score. The output is padded with zeros if the number of detections is less than `config.DETECTION_MAX_INSTANCES`.\n\n**Input:**\n```python\nrois = tf.constant([[0.1, 0.1, 0.4, 0.4],\n                    [0.2, 0.2, 0.5, 0.5],\n                    [0.3, 0.3, 0.6, 0.6]], dtype=tf.float32)\n\nprobs = tf.constant([[0.6, 0.4],\n                     [0.7, 0.3],\n                     [0.2, 0.8]], dtype=tf.float32)\n\ndeltas = tf.constant([[[0.1, 0.1, 0.2, 0.2],\n                       [0.0, 0.0, 0.0, 0.0]],\n                      [[0.0, 0.0, 0.1, 0.1],\n                       [0.1, 0.1, 0.0, 0.0]],\n                      [[-0.1, -0.1, -0.2, -0.2],\n                       [0.0, 0.0, 0.0, 0.0]]], dtype=tf.float32)\n\nwindow = tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32)\n\nclass MockConfig:\n    BBOX_STD_DEV = tf.constant([0.1, 0.1, 0.2, 0.2], dtype=tf.float32)\n    DETECTION_MIN_CONFIDENCE = 0.5\n    DETECTION_MAX_INSTANCES = 100\n\nconfig = MockConfig()\n```\n\n**Output:**\n```python\nrefined_detections = tf.Tensor(\n[[0.3 0.3 0.6 0.6 1.  0.8]\n ...\n [0.  0.  0.  0.  0.  0. ]], shape=(100, 6), dtype=float32)\n\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef apply_box_deltas_graph(boxes, deltas):\n    height, width = boxes[:, 2] - boxes[:, 0], boxes[:, 3] - boxes[:, 1]\n    center_y, center_x = boxes[:, 0] + 0.5 * height, boxes[:, 1] + 0.5 * width\n\n    center_y += deltas[:, 0] * height\n    center_x += deltas[:, 1] * width\n    height *= tf.exp(deltas[:, 2])\n    width *= tf.exp(deltas[:, 3])\n\n    return tf.stack([center_y - 0.5 * height, center_x - 0.5 * width, center_y + 0.5 * height, center_x + 0.5 * width],\n                    axis=1)\n\n\ndef clip_boxes_graph(boxes, window):\n    wy1, wx1, wy2, wx2 = tf.split(window, 4)\n    y1, x1, y2, x2 = tf.split(boxes, 4, axis=1)\n\n    return tf.concat([tf.clip_by_value(y1, wy1, wy2), tf.clip_by_value(x1, wx1, wx2), tf.clip_by_value(y2, wy1, wy2),\n                      tf.clip_by_value(x2, wx1, wx2)], axis=1)\n\n\ndef denorm_boxes_graph(boxes, shape):\n    scale = tf.concat(tf.split(tf.cast(shape, tf.float32), 2) * 2, axis=-1) - 1.0\n    return tf.cast(tf.round(boxes * scale + [0.0, 0.0, 1.0, 1.0]), tf.int32)\n\n# main code\ndef refine_detections_graph(rois, probs, deltas, window, config):\n    class_ids = tf.argmax(probs, axis=1, output_type=tf.int32)\n    indices = tf.stack([tf.range(tf.shape(probs)[0]), class_ids], axis=1)\n    class_scores = tf.gather_nd(probs, indices)\n    refined_rois = clip_boxes_graph(apply_box_deltas_graph(rois, tf.gather_nd(deltas, indices) * config.BBOX_STD_DEV),\n                                    window)\n\n    keep = tf.where(class_ids > 0)[:, 0]\n    if config.DETECTION_MIN_CONFIDENCE:\n        keep = tf.sets.intersection(\n            tf.expand_dims(keep, 0),\n            tf.expand_dims(tf.where(class_scores >= config.DETECTION_MIN_CONFIDENCE)[:, 0], 0)\n        )\n        keep = tf.sparse.to_dense(keep)[0]\n\n    keep = tf.gather(keep, tf.nn.top_k(tf.gather(class_scores, keep),\n                                       k=tf.minimum(tf.shape(keep)[0], config.DETECTION_MAX_INSTANCES), sorted=True)[1])\n\n    return tf.pad(tf.concat(\n        [tf.gather(refined_rois, keep), tf.cast(tf.gather(class_ids, keep), tf.float32)[..., tf.newaxis],\n         tf.gather(class_scores, keep)[..., tf.newaxis]], axis=1),\n                  [(0, config.DETECTION_MAX_INSTANCES - tf.shape(keep)[0]), (0, 0)], constant_values=0)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    class MockConfig:\n        BBOX_STD_DEV = tf.constant([0.1, 0.1, 0.2, 0.2], dtype=tf.float32)\n        DETECTION_MIN_CONFIDENCE = 0.5\n        DETECTION_MAX_INSTANCES = 100\n\n    test_cases = []\n\n    for _ in range(n):\n        num_rois = np.random.randint(5, 50)\n        num_classes = np.random.randint(2, 10)\n\n        rois = tf.random.uniform((num_rois, 4), minval=0, maxval=1, dtype=tf.float32)\n        probs = tf.random.uniform((num_rois, num_classes), minval=0, maxval=1, dtype=tf.float32)\n        deltas = tf.random.uniform((num_rois, num_classes, 4), minval=-0.5, maxval=0.5, dtype=tf.float32)\n        window = tf.constant([0.0, 0.0, 1.0, 1.0], dtype=tf.float32)\n        config = MockConfig()\n\n        test_cases.append((rois, probs, deltas, window, config))\n\n    return test_cases"}
{"problem_id": "tensorflow_92", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the Dice Similarity Coefficient (DSC) loss for a multi-class classification problem using TensorFlow. The function should take in predicted logits, true labels, a list of text lengths, a sequence mask, and the number of slot labels. The DSC loss is a measure of overlap between the predicted and true labels, which is particularly useful in tasks such as natural language processing and image segmentation.\n\nFunction signature:\n```python\ndef dice_dsc_loss(logits, labels, text_length_list, seq_mask, slot_label_num, smoothing_lambda=1.0):\n```\n\nConstants used in the main code:\n- `smoothing_lambda`: A constant used to avoid division by zero and to smooth the calculation of the Dice coefficient.\n\nInput format:\n- `logits`: A tensor of shape (batch_size, sequence_length, slot_label_num) representing the predicted logits for each class.\n- `labels`: A tensor of shape (batch_size, sequence_length) representing the true class labels.\n- `text_length_list`: A tensor of shape (batch_size,) representing the actual lengths of each sequence in the batch.\n- `seq_mask`: A tensor of shape (batch_size, sequence_length) used to mask out certain positions in the sequences.\n- `slot_label_num`: An integer representing the number of unique slot labels.\n- `smoothing_lambda`: A float (default is 1.0) used for smoothing the Dice coefficient calculation.\n\nOutput format:\n- The function returns a single float value representing the mean Dice Similarity Coefficient loss across the batch.\n\nInput:\n```python\nlogits = np.array([[[ 0.1, -0.2, 0.3],\n                    [ 0.4,  0.5, -0.1]],\n                   [[ 0.2,  0.1, 0.0],\n                    [-0.3,  0.4, 0.5]]], dtype=np.float32)\n\nlabels = np.array([[2, 0],\n                   [1, 2]])\n\ntext_length_list = np.array([2, 2])\n\nseq_mask = np.array([[1, 1],\n                     [1, 1]], dtype=np.float32)\n\nslot_label_num = 3\n\nsmoothing_lambda = 1.0\n```\n\nOutput:\n```python\nresult = dice_dsc_loss(logits, labels, text_length_list, seq_mask, slot_label_num, smoothing_lambda)\n# tf.Tensor(0.35638303, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef dice_dsc_loss(logits, labels, text_length_list, seq_mask, slot_label_num, smoothing_lambda=1.0):\n    predict_prob = tf.nn.softmax(logits, axis=-1)\n    label_one_hot = tf.one_hot(labels, depth=slot_label_num, axis=-1)\n    nominator = 2 * predict_prob * label_one_hot + smoothing_lambda\n    denominator = predict_prob * predict_prob + label_one_hot * label_one_hot + smoothing_lambda\n    result = 1.0 - (nominator / denominator)\n    result = tf.reduce_sum(result, axis=-1) * seq_mask\n    result = tf.reduce_sum(result, axis=-1, keepdims=True) / tf.cast(text_length_list, tf.float32)\n    return tf.reduce_mean(result)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 20)\n        max_seq_length = np.random.randint(5, 50)\n        slot_label_num = np.random.randint(2, 15)\n\n        logits = np.random.randn(batch_size, max_seq_length, slot_label_num).astype(np.float32)\n        labels = np.random.randint(0, slot_label_num, size=(batch_size, max_seq_length))\n        text_length_list = np.random.randint(1, max_seq_length + 1, size=(batch_size,))\n        seq_mask = np.random.randint(0, 2, size=(batch_size, max_seq_length)).astype(np.float32)\n        smoothing_lambda = np.random.uniform(0.5, 2.0)\n\n        test_cases.append((logits, labels, text_length_list, seq_mask, slot_label_num, smoothing_lambda))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_93", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that performs complex batch normalization on a set of complex-valued inputs. The function will take in the real and imaginary parts of the centered complex data, along with various parameters that define the normalization process. The goal is to normalize the complex data using the provided parameters and return the normalized real and imaginary components.\n\nFunction signature:\n```python\ndef complex_bn(real_centred, imag_centred, Vrr, Vii, Vri, gamma_rr, gamma_ii, gamma_ri, beta_real, beta_imag, shape):\n```\n\nConstants used in the main code:\n- The constant `1.0` is used to compute the inverse of the product of `s` and `t`.\n\n\nInput format:\n- `real_centred`: A tensor representing the centered real part of the complex data.\n- `imag_centred`: A tensor representing the centered imaginary part of the complex data.\n- `Vrr`: A scalar representing the variance of the real part.\n- `Vii`: A scalar representing the variance of the imaginary part.\n- `Vri`: A scalar representing the covariance between the real and imaginary parts.\n- `gamma_rr`: A tensor for scaling the normalized real part.\n- `gamma_ii`: A tensor for scaling the normalized imaginary part.\n- `gamma_ri`: A tensor for scaling the interaction between the real and imaginary parts.\n- `beta_real`: A tensor for shifting the normalized real part.\n- `beta_imag`: A tensor for shifting the normalized imaginary part.\n- `shape`: A tuple representing the desired shape for the output tensors.\n\nOutput format:\n- The function returns a tuple containing:\n  - `BN_real`: A tensor representing the batch-normalized real part of the complex data.\n  - `BN_imag`: A tensor representing the batch-normalized imaginary part of the complex data.\n\n**Input:**\n```python\nreal_centred = tf.constant([[[[0.5]]]], dtype=tf.float32)  # Shape: (1, 1, 1, 1)\nimag_centred = tf.constant([[[[0.2]]]], dtype=tf.float32)  # Shape: (1, 1, 1, 1)\nVrr = tf.constant([[[[0.1]]]], dtype=tf.float32)           # Shape: (1, 1, 1, 1)\nVii = tf.constant([[[[0.3]]]], dtype=tf.float32)           # Shape: (1, 1, 1, 1)\nVri = tf.constant([[[[0.05]]]], dtype=tf.float32)          # Shape: (1, 1, 1, 1)\ngamma_rr = tf.constant([[[[1.0]]]], dtype=tf.float32)      # Shape: (1, 1, 1, 1)\ngamma_ii = tf.constant([[[[1.0]]]], dtype=tf.float32)      # Shape: (1, 1, 1, 1)\ngamma_ri = tf.constant([[[[0.0]]]], dtype=tf.float32)      # Shape: (1, 1, 1, 1)\nbeta_real = tf.constant([[[[0.0]]]], dtype=tf.float32)     # Shape: (1, 1, 1, 1)\nbeta_imag = tf.constant([[[[0.0]]]], dtype=tf.float32)     # Shape: (1, 1, 1, 1)\nshape = (1, 1, 1, 1)\n```\n\n**Output:**\n```python\nBN_real, BN_imag = complex_bn(real_centred, imag_centred, Vrr, Vii, Vri, gamma_rr, gamma_ii, gamma_ri, beta_real, beta_imag, shape)\n\n# Expected Output Values\nBN_real = tf.Tensor([[[[1.5715159]]]], shape=(1, 1, 1, 1), dtype=float32)\nBN_imag = tf.Tensor([[[[0.19856709]]]], shape=(1, 1, 1, 1), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef complex_bn(real_centred, imag_centred, Vrr, Vii, Vri, gamma_rr, gamma_ii, gamma_ri, beta_real, beta_imag, shape):\n    trace = Vrr + Vii\n    delta = Vrr * Vii - Vri ** 2\n    s = tf.sqrt(delta)\n    t = tf.sqrt(trace + 2 * s)\n    inverse_st = 1.0 / (s * t)\n\n    Wrr = (Vii + s) * inverse_st\n    Wii = (Vrr + s) * inverse_st\n    Wri = -Vri * inverse_st\n\n    broadcast_shape = lambda x: tf.reshape(x, shape)\n\n    real_normed = broadcast_shape(Wrr) * real_centred + broadcast_shape(Wri) * imag_centred\n    imag_normed = broadcast_shape(Wri) * real_centred + broadcast_shape(Wii) * imag_centred\n\n    BN_real = broadcast_shape(gamma_rr) * real_normed + broadcast_shape(gamma_ri) * imag_normed + broadcast_shape(\n        beta_real)\n    BN_imag = broadcast_shape(gamma_ri) * real_normed + broadcast_shape(gamma_ii) * imag_normed + broadcast_shape(\n        beta_imag)\n\n    return BN_real, BN_imag", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(1, 10)\n        width = np.random.randint(1, 10)\n        channels = np.random.randint(1, 10)\n        shape = (batch_size, height, width, channels)\n        real_centred = tf.random.normal(shape)\n        imag_centred = tf.random.normal(shape)\n        Vrr = tf.random.normal(shape)\n        Vii = tf.random.normal(shape)\n        Vri = tf.random.normal(shape)\n        gamma_rr = tf.random.normal(shape)\n        gamma_ii = tf.random.normal(shape)\n        gamma_ri = tf.random.normal(shape)\n        beta_real = tf.random.normal(shape)\n        beta_imag = tf.random.normal(shape)\n\n        test_cases.append(\n            (real_centred, imag_centred, Vrr, Vii, Vri, gamma_rr, gamma_ii, gamma_ri, beta_real, beta_imag, shape))\n\n    return test_cases"}
{"problem_id": "tensorflow_94", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the accuracy of predictions made by a machine learning model. The function will compare the predicted class probabilities with the actual target classes to determine how many predictions were correct.\n\nFunction signature:\n```python\ndef compute_accuracy(target_y, q_y_given_x):\n```\n\nIn this function, the following constant is used:\n- `1`: This constant is used as the axis parameter in the `tf.argmax` function to specify that the maximum value should be found along the rows of the input tensor.\n\nInput format:\n- `target_y`: A tensor of shape (n_samples, n_classes) representing the true class labels in one-hot encoding.\n- `q_y_given_x`: A tensor of shape (n_samples, n_classes) representing the predicted class probabilities.\n\nOutput format:\n- A float value representing the accuracy of the predictions, which is the proportion of correct predictions to the total number of samples.\n\nInput:\n```python\ntarget_y = np.array([[0., 1., 0.], \n                     [1., 0., 0.], \n                     [0., 0., 1.]], dtype=np.float32)\n\nq_y_given_x = np.array([[0.1, 0.8, 0.1], \n                         [0.7, 0.2, 0.1], \n                         [0.2, 0.3, 0.5]], dtype=np.float32)\n```\n\nOutput:\n```python\ntf.Tensor(1.0, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef compute_accuracy(target_y, q_y_given_x):\n    correct_prediction = tf.equal(tf.argmax(q_y_given_x, 1), tf.argmax(target_y, 1))\n    accuracy = tf.reduce_mean(tf.cast(correct_prediction, tf.float32))\n    return accuracy", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 100)\n        num_classes = np.random.randint(2, 20)\n        target_indices = np.random.randint(0, num_classes, size=batch_size)\n        target_y = np.eye(num_classes)[target_indices].astype(np.float32)\n\n        q_y_given_x = np.random.rand(batch_size, num_classes).astype(np.float32)\n        q_y_given_x /= q_y_given_x.sum(axis=1, keepdims=True)\n\n        test_cases.append((target_y, q_y_given_x))\n\n    return test_cases"}
{"problem_id": "tensorflow_95", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the word indices and their corresponding similarity scores based on input embeddings and key embeddings. The function will utilize TensorFlow to perform operations on the embeddings and apply dropout for regularization during training.\n\nFunction signature:\n```python\ndef calc_word_id(inputs: tf.Tensor, training: bool, key_embeddings: tf.Tensor, dropout_rate: float) -> Tuple[tf.Tensor, tf.Tensor]:\n```\n\nConstants used in the main code:\n- The constant used in the main code is `axis`, which is set to `-1` for normalization and reduction operations.\n\n\nInput format:\n- `inputs`: A tensor of shape (batch_size, embedding_dim) representing the input word embeddings.\n- `training`: A boolean indicating whether the model is in training mode or not.\n- `key_embeddings`: A tensor of shape (num_keys, embedding_dim) representing the key word embeddings.\n- `dropout_rate`: A float representing the dropout rate to be applied during training.\n\nOutput format:\n- The function returns a tuple containing:\n  - `word_idx`: A tensor of shape (batch_size,) containing the indices of the most similar key embeddings.\n  - `word_sim`: A tensor of shape (batch_size,) containing the maximum similarity scores corresponding to the indices.\n\nInput:\n```python\ninputs = tf.constant([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=tf.float32)\ntraining = True\nkey_embeddings = tf.constant([[0.1, 0.0, 0.0], [0.0, 0.1, 0.0], [0.0, 0.0, 0.1]], dtype=tf.float32)\ndropout_rate = 0.2\n```\n\nOutput:\n```python\nword_idx = tf.Tensor([2 0], shape=(2,), dtype=int64)\nword_sim = tf.Tensor([1.0022296 0.5698029], shape=(2,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef calc_word_id(inputs, training, key_embeddings, dropout_rate):\n    query = tf.nn.l2_normalize(inputs, axis=-1)\n    key = tf.nn.l2_normalize(key_embeddings, axis=-1)\n    sim_matrix = tf.matmul(query, key, transpose_b=True)\n\n    dropout_layer = tf.keras.layers.Dropout(dropout_rate)\n    sim_matrix = dropout_layer(sim_matrix, training=training)\n\n    word_idx = tf.argmax(sim_matrix, axis=-1)\n    word_sim = tf.reduce_max(sim_matrix, axis=-1)\n\n    return word_idx, word_sim", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        input_dim = np.random.randint(5, 50)\n        vocab_size = np.random.randint(20, 100)\n        dropout_rate = np.random.uniform(0.0, 0.5)\n\n        inputs = tf.random.normal(shape=(batch_size, input_dim))\n        training = np.random.choice([True, False])\n        key_embeddings = tf.random.normal(shape=(vocab_size, input_dim))\n\n        test_cases.append((inputs, training, key_embeddings, dropout_rate))\n\n    return test_cases"}
{"problem_id": "tensorflow_96", "library": "tensorflow", "code_problem": "You are tasked with creating a function that generates a heatmap from a given input tensor. The heatmap will be represented in RGB format, where the intensity of each color channel (red, green, and blue) is determined by the values in the input tensor. The function should be able to handle a 2D tensor of values ranging from 0.0 to 1.0.\n\nFunction signature:\n```python\ndef generate_heatmap(x):\n```\n\nIn the main code, the following constant is used:\n- The constant `255` is used to scale the heatmap values to the range of 0 to 255, which is the standard range for pixel values in an image.\n\nInput format:\n- A 2D tensor `x` of shape (height, width) with values in the range [0.0, 1.0].\n\nOutput format:\n- A 3D tensor representing the heatmap in RGB format, with shape (height, width, 3) and values in the range [0, 255].\n\nInput:\n```python\ntf.convert_to_tensor([[0.0, 0.5, 1.0], \n                       [0.2, 0.8, 0.4]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[  0   0 255]\n  [127 255 127]\n  [255   0   0]]\n [[ 51 101 204]\n  [204 101  50]\n  [102 204 153]]], shape=(2, 3, 3), dtype=uint8)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef generate_heatmap(x):\n    red = x\n    green = 1.0 - tf.abs(0.5 - x) * 2.0\n    blue = 1.0 - x\n    heatmap = tf.stack([red, green, blue])\n    heatmap = tf.transpose(heatmap, (1, 2, 0))\n    return tf.cast(heatmap * 255, tf.uint8)", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(10, 300)\n        width = np.random.randint(10, 300)\n        x = tf.convert_to_tensor(np.random.rand(height, width), dtype=tf.float32)\n\n        test_cases.append(x)\n    return test_cases\n"}
{"problem_id": "tensorflow_97", "library": "tensorflow", "code_problem": "The task is to implement a function that computes the contrastive divergence for a given data point in the context of a Restricted Boltzmann Machine (RBM). The function will update the weights and biases based on the difference between the visible and hidden states generated from the data point.\n\nFunction signature:\n```python\ndef contr_divergence(data_point, L2_l, _h_dim, hidden_biases, visible_biases, weights, k, _v_dim):\n```\n\nConstants used in the main code:\n- The constant `L2_l` is used as a regularization parameter for the weight updates.\n\nInput format:\n- `data_point`: A NumPy array representing the input data point.\n- `L2_l`: A float representing the L2 regularization parameter.\n- `_h_dim`: An integer representing the dimension of the hidden layer.\n- `hidden_biases`: A NumPy array representing the biases for the hidden layer.\n- `visible_biases`: A NumPy array representing the biases for the visible layer.\n- `weights`: A NumPy array representing the weights of the RBM.\n- `k`: An integer representing the number of Gibbs sampling steps.\n- `_v_dim`: An integer representing the dimension of the visible layer.\n\nOutput format:\n- The function returns a tuple containing three NumPy arrays: \n  - `delta_w`: The weight updates.\n  - `delta_vb`: The updates for the visible biases.\n  - `delta_hb`: The updates for the hidden biases.\n\nInput:\n```python\ndata_point = np.array([0.5, 0.2, 0.8, 0.1, 0.4]).astype(np.float64)\nL2_l = 0.05\n_h_dim = 3\nhidden_biases = np.array([0.1, 0.2, 0.3]).astype(np.float64)\nvisible_biases = np.array([0.4, 0.5, 0.6, 0.7, 0.8]).astype(np.float64)\nweights = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n                    [0.6, 0.7, 0.8, 0.9, 1.0],\n                    [1.1, 1.2, 1.3, 1.4, 1.5]]).astype(np.float64)\nk = 2\n_v_dim = 5\n```\n\nOutput:\n```python\ndelta_w, delta_vb, delta_hb = contr_divergence(data_point, L2_l, _h_dim, hidden_biases, visible_biases, weights, k, _v_dim)\n\n# delta_w\n[[ 0.505  0.21   0.815  0.12   0.425]\n [-0.47  -0.765 -0.16   0.145 -0.55 ]\n [-0.445 -0.74  -0.135  0.17  -0.525]]\n\n# delta_vb\n[-0.48  -0.775 -0.17   0.135 -0.56 ]\n\n# delta_hb\n[1.005 0.01  0.015]\n```\n", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\ndef calculate_state(probability):\n    return np.random.binomial(1, probability).astype(np.float64)\n\n# main code\ndef contr_divergence(data_point, L2_l, _h_dim, hidden_biases, visible_biases, weights, k, _v_dim):\n    hidden_probabilities_0 = tf.sigmoid(tf.add(tf.tensordot(weights, data_point, 1), hidden_biases))\n    hidden_states_0 = calculate_state(hidden_probabilities_0)\n    hidden_states_0_copy = hidden_states_0\n\n    for _ in range(k):\n        visible_probabilities_1 = tf.sigmoid(tf.add(tf.tensordot(hidden_states_0, weights, 1), visible_biases))\n        visible_states_1 = calculate_state(visible_probabilities_1)\n        hidden_probabilities_1 = tf.sigmoid(tf.add(tf.tensordot(visible_states_1, tf.transpose(weights), 1), hidden_biases))\n        hidden_states_1 = calculate_state(hidden_probabilities_1)\n        hidden_states_0 = hidden_states_1\n\n    vh_0 = tf.reshape(tf.tensordot(hidden_states_0_copy, data_point, 0), (_h_dim, _v_dim))\n    vh_1 = tf.reshape(tf.tensordot(hidden_states_1, visible_states_1, 0), (_h_dim, _v_dim))\n\n    delta_w = tf.add(vh_0, -vh_1) + L2_l * weights\n    delta_vb = tf.add(data_point, -visible_states_1) + L2_l * visible_biases\n    delta_hb = tf.add(hidden_states_0_copy, -hidden_states_1) + L2_l * hidden_biases\n\n    return delta_w.numpy(), delta_vb.numpy(), delta_hb.numpy()", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        _v_dim = np.random.randint(20, 100)\n        _h_dim = np.random.randint(20, 100)\n        k = np.random.randint(1, 10)\n        L2_l = np.random.uniform(0.001, 0.1)\n\n        data_point = np.random.rand(_v_dim).astype(np.float64)\n        hidden_biases = np.random.rand(_h_dim).astype(np.float64)\n        visible_biases = np.random.rand(_v_dim).astype(np.float64)\n        weights = np.random.rand(_h_dim, _v_dim).astype(np.float64)\n\n        test_case = (data_point, L2_l, _h_dim, hidden_biases, visible_biases, weights, k, _v_dim)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "tensorflow_98", "library": "tensorflow", "code_problem": "You are required to implement a function that calculates the contrastive loss between two models based on their outputs and a given margin. The contrastive loss is commonly used in tasks involving similarity learning, such as in Siamese networks.\n\nFunction signature:\n```python\ndef contrastive_loss(model1, model2, y, margin):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `margin`, which represents the threshold distance below which pairs of samples are considered similar.\n\nInput format:\n- `model1`: A tensor representing the output of the first model.\n- `model2`: A tensor representing the output of the second model.\n- `y`: A tensor of binary labels (0 or 1) indicating whether the pairs are similar or dissimilar.\n- `margin`: A scalar value representing the margin threshold.\n\nOutput format:\n- The function returns a scalar tensor representing the computed contrastive loss.\n\nInput:\n```python\nmodel1 = tf.constant([[0.5, -1.2], [1.0, 0.3]], dtype=tf.float32)\nmodel2 = tf.constant([[0.4, -1.0], [1.5, 0.1]], dtype=tf.float32)\ny = tf.constant([[1], [0]], dtype=tf.float32)\nmargin = tf.constant(0.5, dtype=tf.float32)\n```\n\nOutput:\n```python\nloss = contrastive_loss(model1, model2, y, margin)\n# tf.Tensor(0.012500005, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef contrastive_loss(model1, model2, y, margin):\n    d = tf.sqrt(tf.reduce_sum(tf.pow(model1 - model2, 2), axis=1, keepdims=True))\n    tmp = y * tf.square(d)\n    tmp2 = (1 - y) * tf.square(tf.maximum(margin - d, 0))\n    return tf.reduce_mean(tmp + tmp2) / 2", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 128)\n        feature_dim = np.random.randint(1, 512)\n\n        model1 = tf.constant(np.random.randn(batch_size, feature_dim), dtype=tf.float32)\n        model2 = tf.constant(np.random.randn(batch_size, feature_dim), dtype=tf.float32)\n        y = tf.constant(np.random.randint(0, 2, size=(batch_size, 1)), dtype=tf.float32)\n        margin = tf.constant(np.random.uniform(0.1, 2.0), dtype=tf.float32)\n\n        test_cases.append((model1, model2, y, margin))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_99", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the mean and variance of a convolution operation using TensorFlow. The function will take in several parameters that define the input tensor, convolutional parameters, and scaling factors for the weights and biases.\n\nFunction signature:\n```python\ndef get_mean_var(x, strides, padding, thres_var, w_log_scale_sq, b_log_scale_sq, b_loc, w_loc):\n```\n\nConstants used in the main code:\n- `thres_var`: A threshold value for the variance of the weights, used to clip the computed variance.\n\nInput format:\n- The function accepts a 4D tensor for `x`, a list or tuple for `strides`, a string for `padding`, and several tensors for the other parameters.\n\nOutput format:\n- The function returns a tuple containing two tensors: the first tensor is the mean output (`muout`), and the second tensor is the variance output (`varout`).\n\n**Input:**\n```python\n{\n    \"x\": tf.constant([[[[0.5, -0.2], [0.1, 0.3]]]], dtype=tf.float32),  # Shape: (1, 2, 2, 2)\n    \"strides\": [1, 1, 1, 1],\n    \"padding\": \"VALID\",\n    \"thres_var\": 2.0,\n    \"w_log_scale_sq\": tf.constant([[[[0.1, -0.1]], [[0.2, 0.3]]]], dtype=tf.float32),  # Shape: (2, 2, 2, 2)\n    \"b_log_scale_sq\": tf.constant([0.1, -0.2], dtype=tf.float32),  # Shape: (2,)\n    \"b_loc\": tf.constant([0.5, -0.5], dtype=tf.float32),  # Shape: (2,)\n    \"w_loc\": tf.constant([[[[0.1, 0.2]], [[0.3, 0.4]]]], dtype=tf.float32)  # Shape: (2, 2, 2, 2)\n}\n```\n\n**Output:**\n```python\ntf.Tensor([[[[ 0.58 -0.42]]]], shape=(1, 1, 1, 2), dtype=float32)\n\ntf.Tensor([[[[1.42544   1.0154707]]]], shape=(1, 1, 1, 2), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef get_mean_var(x, strides, padding, thres_var, w_log_scale_sq, b_log_scale_sq, b_loc, w_loc):\n    var_w = tf.clip_by_value(tf.exp(w_log_scale_sq), 0.0, thres_var)\n    var_w = tf.square(var_w)\n    var_b = tf.clip_by_value(tf.exp(b_log_scale_sq), 0.0, tf.square(thres_var))\n\n    muout = tf.nn.conv2d(x, w_loc, strides, padding) + b_loc\n    varout = tf.nn.conv2d(tf.square(x), var_w, strides, padding) + var_b\n\n    return muout, varout", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        height = np.random.randint(8, 32)\n        width = np.random.randint(8, 32)\n        in_channels = np.random.randint(1, 5)\n        filter_height = np.random.randint(1, 5)\n        filter_width = np.random.randint(1, 5)\n        out_channels = np.random.randint(1, 5)\n        strides = [1, np.random.randint(1, 3), np.random.randint(1, 3), 1]\n        padding = np.random.choice([\"SAME\", \"VALID\"])\n        thres_var = np.random.uniform(0.1, 5.0)\n        x = tf.random.normal([batch_size, height, width, in_channels])\n        w_log_scale_sq = tf.random.normal([filter_height, filter_width, in_channels, out_channels])\n        b_log_scale_sq = tf.random.normal([out_channels])\n        b_loc = tf.random.normal([out_channels])\n        w_loc = tf.random.normal([filter_height, filter_width, in_channels, out_channels])\n\n        test_cases.append((x, strides, padding, thres_var, w_log_scale_sq, b_log_scale_sq, b_loc, w_loc))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_100", "library": "tensorflow", "code_problem": "```python\ndef parallel_sample(inpt, n_step_MC, p_0, p_1, n_chains, save_evolution,\n                    hidden_biases, visible_biases, weights, _v_dim):\n```\n\nIn this code, the function `parallel_sample` is designed to perform a series of Monte Carlo sampling steps for a probabilistic model, specifically a Restricted Boltzmann Machine (RBM). The function takes several parameters that define the initial conditions, the number of sampling steps, and the model's architecture.\n\n### Constants Used:\n- The constant used in the main code is the probability values `p_0` and `p_1`, which are used to initialize the input states.\n\n### Input and Output Format:\n- **Input**:\n  - `inpt`: A 2D numpy array or `None`.\n  - `n_step_MC`: An integer representing the number of Monte Carlo steps.\n  - `p_0`: A float representing the probability of selecting 0 in the initial input.\n  - `p_1`: A float representing the probability of selecting 1 in the initial input.\n  - `n_chains`: An integer representing the number of parallel chains.\n  - `save_evolution`: A boolean indicating whether to save the evolution of visible states.\n  - `hidden_biases`: A 1D numpy array representing biases for the hidden layer.\n  - `visible_biases`: A 1D numpy array representing biases for the visible layer.\n  - `weights`: A 2D numpy array representing the weights between visible and hidden layers.\n  - `_v_dim`: An integer representing the dimensionality of the visible layer.\n\n- **Output**:\n  - If `save_evolution` is `True`, the output is a tuple containing:\n    - `visible_states`: The final sampled states of the visible layer.\n    - `visible_probabilities`: The probabilities of the final visible states.\n    - `inpt`: The initial input provided to the function.\n    - `evolution`: A 3D numpy array containing the evolution of visible states over the Monte Carlo steps.\n  - If `save_evolution` is `False`, the output is a tuple containing:\n    - `visible_states`: The final sampled states of the visible layer.\n    - `visible_probabilities`: The probabilities of the final visible states.\n    - `inpt`: The initial input provided to the function.\n\nInput:\n```python\n(\n    None, \n    5, \n    0.3, \n    0.7, \n    10, \n    True, \n    np.array([-0.5, 0.2, 0.1]), \n    np.array([0.3, -0.1, 0.4, 0.2, -0.3]), \n    np.array([[0.1, -0.2, 0.3, 0.4, -0.5], [-0.1, 0.2, -0.3, 0.4, 0.5], [0.2, -0.1, 0.4, -0.3, 0.1]]), \n    5\n)\n```\n\nOutput:\n```python\n(\n   [[0. 0. 0. 1. 0.]\n    [0. 0. 0. 0. 1.]\n    [0. 1. 1. 1. 0.]\n    [0. 1. 0. 1. 0.]\n    [1. 0. 0. 0. 1.]\n    [0. 1. 1. 0. 1.]\n    [1. 1. 1. 1. 0.]\n    [1. 1. 1. 1. 0.]\n    [0. 0. 0. 1. 0.]\n    [1. 0. 0. 0. 0.]],\n   \n   tf.Tensor(\n   [[0.62245933 0.450166   0.68997448 0.47502081 0.450166  ]\n    [0.64565631 0.40131234 0.75026011 0.57444252 0.33181223]\n    [0.57444252 0.47502081 0.59868766 0.73105858 0.42555748]\n    [0.57444252 0.47502081 0.59868766 0.73105858 0.42555748]\n    [0.549834   0.52497919 0.52497919 0.64565631 0.549834  ]\n    [0.59868766 0.5        0.62245933 0.57444252 0.57444252]\n    [0.549834   0.52497919 0.52497919 0.64565631 0.549834  ]\n    [0.57444252 0.47502081 0.59868766 0.73105858 0.42555748]\n    [0.549834   0.52497919 0.52497919 0.64565631 0.549834  ]\n    [0.62245933 0.450166   0.68997448 0.66818777 0.450166  ]], shape=(10, 5), dtype=float64),\n\n   [[1. 1. 1. 1. 1.]\n    [1. 1. 1. 1. 1.]\n    [1. 1. 0. 1. 1.]\n    [1. 0. 1. 1. 1.]\n    [0. 1. 0. 1. 1.]\n    [1. 0. 0. 1. 0.]\n    [1. 0. 0. 1. 1.]\n    [1. 1. 1. 1. 1.]\n    [1. 0. 1. 1. 1.]\n    [0. 0. 1. 1. 1.]]\n)\n```", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\n\ndef calculate_state(probability):\n    return np.random.binomial(1, probability).astype(np.float64)\n\n# main code\ndef parallel_sample(inpt, n_step_MC, p_0, p_1, n_chains, save_evolution,\n                    hidden_biases, visible_biases, weights, _v_dim):\n    if inpt is None or inpt.size == 0:\n        inpt = np.random.choice([0, 1], size=(n_chains, _v_dim), p=[p_0, p_1]).astype(np.float64)\n    elif inpt.ndim != 2:\n        inpt = inpt.reshape(1, -1)\n\n    if save_evolution:\n        evolution = np.empty((n_step_MC, inpt.shape[0], _v_dim))\n        evolution[0] = inpt\n\n    hidden_probabilities = tf.sigmoid(tf.tensordot(inpt, weights, axes=[[1], [1]]) + hidden_biases)\n    hidden_states = calculate_state(hidden_probabilities)\n\n    for i in range(n_step_MC):\n        visible_probabilities = tf.sigmoid(tf.tensordot(hidden_states, weights, axes=[[1], [0]]) + visible_biases)\n        visible_states = calculate_state(visible_probabilities)\n        hidden_probabilities = tf.sigmoid(tf.tensordot(visible_states, weights, axes=[[1], [1]]) + hidden_biases)\n        hidden_states = calculate_state(hidden_probabilities)\n\n        if save_evolution:\n            evolution[i] = visible_states\n\n    if save_evolution:\n        return visible_states, visible_probabilities, inpt, evolution\n    return visible_states, visible_probabilities, inpt", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_step_MC = np.random.randint(1, 10)\n        n_chains = np.random.randint(1, 20)\n        _v_dim = np.random.randint(5, 50)\n        p_0 = np.random.uniform(0.1, 0.9)\n        p_1 = 1.0 - p_0\n        save_evolution = np.random.choice([True, False])\n        hidden_biases_dim = np.random.randint(5, 50)\n        visible_biases = np.random.randn(_v_dim).astype(np.float64)\n        hidden_biases = np.random.randn(hidden_biases_dim).astype(np.float64)\n        weights = np.random.randn(hidden_biases_dim, _v_dim).astype(np.float64)\n        inpt = None if np.random.rand() < 0.5 else np.random.choice([0, 1], size=(n_chains, _v_dim)).astype(np.float64)\n\n        test_cases.append(\n            (inpt, n_step_MC, p_0, p_1, n_chains, save_evolution, hidden_biases, visible_biases, weights, _v_dim))\n\n    return test_cases"}
{"problem_id": "tensorflow_101", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a multi-dimensional tensor by appending positional information to it. The function will take a tensor as input and return a new tensor that includes the original data along with a positional encoding.\n\nFunction signature:\n```python\ndef call(inputs: tf.Tensor, dtype: tf.DType) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the dimension of the input tensor at index `-3`, which represents the number of positions to be generated.\n\nInput format:\n- The function accepts a tensor `inputs` of shape `(batch_size, ..., depth)` where `...` represents any number of dimensions, and `depth` is the dimension from which positional information is derived.\n- The function also accepts a `dtype` parameter that specifies the desired data type for the positional tensor.\n\nOutput format:\n- The function returns a tensor of shape `(batch_size, ..., depth + 1)` where the last dimension has been increased by one to accommodate the appended positional information. The data type of the output tensor matches that of the input tensor.\n\nInput:\n```python\ninputs = tf.random.uniform(shape=(3, 5, 5, 4), dtype=tf.float32)  # Example input tensor\ndtype = tf.float32  # Example dtype\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[[3.9492595e-01 2.0197296e-01 5.6029594e-01 5.6167364e-02\n    0.0000000e+00]\n   [6.8792832e-01 6.5829873e-02 8.4757352e-01 3.2844257e-01\n    0.0000000e+00]\n   [2.3794651e-01 4.5304656e-01 4.3189788e-01 4.3522608e-01\n    0.0000000e+00]\n   [1.5174389e-01 7.1280432e-01 7.6933968e-01 9.8715353e-01\n    0.0000000e+00]\n   [5.8193529e-01 9.3896246e-01 7.7452254e-01 8.3112919e-01\n    0.0000000e+00]]\n    ... \n  [[5.9691346e-01 7.6477432e-01 9.8605108e-01 9.4549870e-01\n    8.0000001e-01]\n   [7.8553283e-01 7.2249818e-01 1.1061275e-01 9.5477021e-01\n    8.0000001e-01]\n   [1.6658199e-01 3.9330685e-01 3.6230171e-01 1.7577982e-01\n    8.0000001e-01]\n   [4.8459649e-01 1.7523766e-05 6.8395054e-01 4.2152584e-01\n    8.0000001e-01]\n   [4.8504591e-01 3.1537926e-01 7.2637093e-01 2.0544755e-01\n    8.0000001e-01]]]], shape=(3, 5, 5, 5), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, dtype):\n    pos = tf.repeat(tf.reshape(tf.range(inputs.shape[-3], dtype=tf.int32), [1, -1, 1, 1]), inputs.shape[-2], -2)\n    pos = tf.cast(tf.repeat(pos, tf.shape(inputs)[0], 0), dtype)\n    pos = pos / tf.cast(inputs.shape[-3], dtype)\n    pos = tf.cast(pos, inputs.dtype)\n    return tf.concat([inputs, pos], -1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        dim1 = np.random.randint(1, 20)\n        dim2 = np.random.randint(1, 20)\n        channels = np.random.randint(1, 10)\n        inputs = tf.random.uniform(shape=(batch_size, dim1, dim2, channels), dtype=tf.float32)\n        dtype = np.random.choice([tf.float16, tf.float32, tf.float64])\n        test_cases.append((inputs, dtype))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_102", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the sequence lengths of a batch of sequences represented as a 2D tensor. Each sequence is composed of numerical values, and the length of a sequence is defined as the number of elements that are greater than zero. The function should return a 1D tensor containing the lengths of each sequence.\n\nFunction signature:\n```python\ndef retrieve_seq_length_op2(data):\n```\n\nIn the main code, the constant used is `tf.zeros_like(data)`, which creates a tensor of zeros with the same shape as the input tensor `data`.\n\nInput format:\n- A 2D tensor `data` of shape (batch_size, sequence_length), where each element is a numerical value.\n\nOutput format:\n- A 1D tensor of shape (batch_size), where each element represents the length of the corresponding sequence in `data`.\n\n```python\n{\n    \"input\": tf.convert_to_tensor([[1.0, -2.0, 3.0], [0.0, 0.0, 4.0]]),\n    \"output\": tf.Tensor([2 1], shape=(2,), dtype=int32)\n}\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef retrieve_seq_length_op2(data):\n    return tf.reduce_sum(tf.cast(tf.greater(data, tf.zeros_like(data)), tf.int32), 1)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_length = np.random.randint(5, 50)\n        data = np.random.randint(-5, 10, size=(batch_size, seq_length)).astype(np.float32)\n        test_cases.append(tf.convert_to_tensor(data))\n\n    return test_cases"}
{"problem_id": "tensorflow_103", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that processes a set of items and their associated parameters using TensorFlow. The function will retrieve specific parameters for each item from a given set of weights, apply certain transformations to these parameters, and return the modified values.\n\nFunction signature:\n```python\ndef _repeat_params(items, eps, inf, weights):\n```\n\nConstants used in the main code:\n- `eps`: A small positive value used to ensure numerical stability by preventing division by zero or log of zero.\n- `inf`: A large positive value used to cap the maximum values of certain parameters.\n\nInput format:\n- `items`: A tensor of item indices.\n- `eps`: A float representing a small positive value.\n- `inf`: A float representing a large positive value.\n- `weights`: A dictionary containing tensors for 'item_alpha', 'item_pi', 'item_beta', 'item_mu', and 'item_sigma'.\n\nOutput format:\n- A tuple containing five tensors: `(alpha, pi, beta, mu, sigma)`, where each tensor corresponds to the modified parameters for the input items.\n\n**Input:**\n```python\nitems = tf.constant([3, 7, 1], dtype=tf.int32)\neps = tf.constant(1e-5, dtype=tf.float32)\ninf = tf.constant(1e5, dtype=tf.float32)\nweights = {\n    'item_alpha': tf.Variable(tf.constant([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], dtype=tf.float32)),\n    'item_pi': tf.Variable(tf.constant([0.9, 0.8, 0.7, 0.6, 0.5, 0.4, 0.3, 0.2, 0.1, 0.0], dtype=tf.float32)),\n    'item_beta': tf.Variable(tf.constant([0.5, 0.4, 0.3, 0.2, 0.1, 0.0, 0.1, 0.2, 0.3, 0.4], dtype=tf.float32)),\n    'item_mu': tf.Variable(tf.constant([0.0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9], dtype=tf.float32)),\n    'item_sigma': tf.Variable(tf.constant([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0], dtype=tf.float32)),\n    'global_alpha': tf.Variable(tf.constant(0.5, dtype=tf.float32)),\n}\n```\n\n**Output:**\n```python\n(alpha, pi, beta, mu, sigma) = _repeat_params(items, eps, inf, weights)\n\n# Expected output values:\nalpha = tf.Tensor([0.9 1.3 0.7], shape=(3,), dtype=float32)\npi = tf.Tensor([0.6 0.2 0.8], shape=(3,), dtype=float32)\nbeta = tf.Tensor([0.2 0.2 0.4], shape=(3,), dtype=float32)\nmu = tf.Tensor([0.3 0.7 0.1], shape=(3,), dtype=float32)\nsigma = tf.Tensor([0.4 0.8 0.2], shape=(3,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef _repeat_params(items, eps, inf, weights):\n    item_alpha = tf.nn.embedding_lookup(weights['item_alpha'], items)\n    item_pi = tf.nn.embedding_lookup(weights['item_pi'], items)\n    item_beta = tf.nn.embedding_lookup(weights['item_beta'], items)\n    item_mu = tf.nn.embedding_lookup(weights['item_mu'], items)\n    item_sigma = tf.nn.embedding_lookup(weights['item_sigma'], items)\n    alpha = tf.clip_by_value(item_alpha + weights['global_alpha'], 0.0, inf)\n    beta = tf.clip_by_value(item_beta, eps, inf)\n    pi = tf.clip_by_value(item_pi, 0.0, 1.0)\n    mu = item_mu\n    sigma = tf.clip_by_value(item_sigma, eps, inf)\n    return (alpha, pi, beta, mu, sigma)", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 100)\n        vocab_size = 500\n        items = tf.constant(np.random.randint(0, vocab_size, size=(batch_size,)), dtype=tf.int32)\n        eps = tf.constant(1e-5, dtype=tf.float32)\n        inf = tf.constant(1e5, dtype=tf.float32)\n        weights = {\n            'item_alpha': tf.Variable(tf.random.uniform((vocab_size,), 0.0, 1.0), dtype=tf.float32),\n            'item_pi': tf.Variable(tf.random.uniform((vocab_size,), 0.0, 1.0), dtype=tf.float32),\n            'item_beta': tf.Variable(tf.random.uniform((vocab_size,), 0.0, 1.0), dtype=tf.float32),\n            'item_mu': tf.Variable(tf.random.uniform((vocab_size,), 0.0, 1.0), dtype=tf.float32),\n            'item_sigma': tf.Variable(tf.random.uniform((vocab_size,), 0.0, 1.0), dtype=tf.float32),\n            'global_alpha': tf.Variable(tf.random.uniform((), 0.0, 1.0), dtype=tf.float32),\n        }\n\n        test_cases.append((items, eps, inf, weights))\n\n    return test_cases"}
{"problem_id": "tensorflow_104", "library": "tensorflow", "code_problem": "The task is to implement a function that performs knowledge graph inference using embeddings for entities and relations. The function will take in several parameters, including head entities, relations, positive and negative tail entities, the dimension of the knowledge graph embeddings, and a dictionary of weights containing the embeddings and transformation matrices.\n\nFunction signature:\n```python\ndef _get_kg_inference(h, r, pos_t, neg_t, kge_dim, weights):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `kge_dim`, which represents the dimensionality of the knowledge graph embeddings.\n\nInput format:\n- The function takes the following inputs:\n  - `h`: A tensor representing the indices of the head entities.\n  - `r`: A tensor representing the indices of the relations.\n  - `pos_t`: A tensor representing the indices of the positive tail entities.\n  - `neg_t`: A tensor representing the indices of the negative tail entities.\n  - `kge_dim`: An integer representing the dimensionality of the knowledge graph embeddings.\n  - `weights`: A dictionary containing the embeddings and transformation matrices.\n\nOutput format:\n- The function returns a tuple containing four tensors:\n  - The normalized embeddings for the head entities.\n  - The normalized embeddings for the relations.\n  - The normalized embeddings for the positive tail entities.\n  - The normalized embeddings for the negative tail entities.\n\n**Input:**\n```python\nh = tf.constant([42], dtype=tf.int32)  # Head entity index\nr = tf.constant([15], dtype=tf.int32)  # Relation index\npos_t = tf.constant([78], dtype=tf.int32)  # Positive tail entity index\nneg_t = tf.constant([23], dtype=tf.int32)  # Negative tail entity index\nkge_dim = 32  # Dimension of the embeddings\nweights = {\n    'kg_entity_embed': tf.random.uniform((1000, kge_dim), minval=-1, maxval=1),\n    'kg_relation_embed': tf.random.uniform((300, kge_dim), minval=-1, maxval=1),\n    'trans_W': tf.random.uniform((300, kge_dim, kge_dim), minval=-1, maxval=1)\n}\n```\n\n**Output:**\n```python\n(h_e, r_e, pos_t_e, neg_t_e) = _get_kg_inference(h, r, pos_t, neg_t, kge_dim, weights)\n\n# Example output:\n# h_e\ntf.Tensor(\n[[-0.05206288 -0.02305384  0.22101389 -0.0617439  -0.15618567 -0.07876038\n   0.0977604   0.00738001 -0.07553721 -0.01893019 -0.21031192  0.23073447\n  -0.04142554 -0.03728482  0.06386872  0.06293005  0.11140612  0.16509658\n  -0.03499934 -0.00947081  0.12616464 -0.4341191   0.47297305  0.18943027\n   0.05579613 -0.01313144  0.21442686  0.11031614 -0.00106049  0.10792647\n   0.35991344 -0.28573084]], shape=(1, 32), dtype=float32)\n# r_e\ntf.Tensor(\n[[-0.2147479  -0.20961466  0.21101622 -0.06846092  0.27166072 -0.12672983\n  -0.10074262 -0.18128957  0.14638959  0.22092195 -0.0894967   0.18885483\n   0.183411    0.01038465 -0.05768324  0.21090595  0.18606958  0.21800141\n  -0.2757075  -0.11228076 -0.07362837  0.18190105  0.10842066 -0.24461946\n  -0.11970235  0.21715993  0.23959132 -0.22187082  0.08845563  0.04746012\n   0.16023292 -0.21828145]], shape=(1, 32), dtype=float32)\n# pos_t_e\ntf.Tensor(\n[[ 1.9985686e-01  3.1545624e-01  1.7480236e-01 -2.2541411e-04\n  -1.3211016e-01  1.6237924e-01  1.8196276e-01  1.0801387e-01\n   3.1556100e-01 -1.3275562e-01 -2.8865084e-01  1.1129802e-01\n   2.7670885e-02  8.3751820e-02  2.0799935e-01  9.2461184e-02\n  -3.7223015e-02  1.4021850e-01  3.4278074e-01  3.0378419e-01\n   3.0204864e-02 -2.1128273e-01 -4.5134906e-02  1.2868869e-01\n  -8.5308433e-02  2.8879277e-02 -5.8177717e-02  2.9744904e-02\n  -2.9404736e-01  2.4215585e-01 -8.4077053e-02 -9.6719526e-02]], shape=(1, 32), dtype=float32)\n# neg_t_e\n[[-0.04143738  0.41981497  0.00286185 -0.02157069  0.03672566 -0.14508677\n  -0.08818621  0.18267888  0.06805992 -0.12741278  0.03419629 -0.12912327\n   0.05942336  0.24584405  0.08225327 -0.19801284 -0.2274762  -0.42896506\n   0.00483869  0.2120086   0.13208729  0.00962501 -0.19036308  0.24878852\n   0.16781138 -0.16684784  0.103181   -0.1285704   0.2310026   0.11432981\n  -0.1250725  -0.21842785]], shape=(1, 32), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef _get_kg_inference(h, r, pos_t, neg_t, kge_dim, weights):\n    h_e = tf.nn.embedding_lookup(weights['kg_entity_embed'], h)\n    pos_t_e = tf.nn.embedding_lookup(weights['kg_entity_embed'], pos_t)\n    neg_t_e = tf.nn.embedding_lookup(weights['kg_entity_embed'], neg_t)\n    r_e = tf.nn.embedding_lookup(weights['kg_relation_embed'], r)\n    trans_M = tf.nn.embedding_lookup(weights['trans_W'], r)\n    h_e = tf.reshape(tf.matmul(h_e, trans_M), [-1, kge_dim])\n    pos_t_e = tf.reshape(tf.matmul(pos_t_e, trans_M), [-1, kge_dim])\n    neg_t_e = tf.reshape(tf.matmul(neg_t_e, trans_M), [-1, kge_dim])\n    h_e = tf.nn.l2_normalize(h_e, axis=1)\n    r_e = tf.nn.l2_normalize(r_e, axis=1)\n    pos_t_e = tf.nn.l2_normalize(pos_t_e, axis=1)\n    neg_t_e = tf.nn.l2_normalize(neg_t_e, axis=1)\n    return (h_e, r_e, pos_t_e, neg_t_e)", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_entities = np.random.randint(500, 1000)\n        num_relations = np.random.randint(100, 500)\n        kge_dim = np.random.randint(32, 64)\n\n        weights = {\n            'kg_entity_embed': tf.random.uniform((num_entities, kge_dim), minval=-1, maxval=1),\n            'kg_relation_embed': tf.random.uniform((num_relations, kge_dim), minval=-1, maxval=1),\n            'trans_W': tf.random.uniform((num_relations, kge_dim, kge_dim), minval=-1, maxval=1)\n        }\n\n        h = tf.constant(np.random.randint(0, num_entities, size=(1,)), dtype=tf.int32)\n        r = tf.constant(np.random.randint(0, num_relations, size=(1,)), dtype=tf.int32)\n        pos_t = tf.constant(np.random.randint(0, num_entities, size=(1,)), dtype=tf.int32)\n        neg_t = tf.constant(np.random.randint(0, num_entities, size=(1,)), dtype=tf.int32)\n        test_cases.append((h, r, pos_t, neg_t, kge_dim, weights))\n\n    return test_cases\n"}
{"problem_id": "tensorflow_105", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that normalizes a set of embeddings based on their corresponding vocabulary frequencies. The normalization process involves adjusting the embeddings so that they have a mean of zero and a standard deviation of one, weighted by the frequency of each vocabulary item.\n\nFunction signature:\n```python\ndef _normalize(emb: tf.Tensor, vocab_freqs: tf.Tensor) -> tf.Tensor:\n```\n\nConstant used in the main code:\n- `1e-06`: This constant is added to the variance before taking the square root to prevent division by zero.\n\nInput format:\n- `emb`: A TensorFlow tensor representing the embeddings, where each row corresponds to an embedding vector.\n- `vocab_freqs`: A TensorFlow tensor representing the frequencies of the vocabulary items associated with the embeddings.\n\nOutput format:\n- The function returns a TensorFlow tensor containing the normalized embeddings.\n\nInput:\n```python\nemb = tf.constant([[0.1, 0.2, 0.3], \n                   [0.4, 0.5, 0.6], \n                   [0.7, 0.8, 0.9]], dtype=tf.float32)\n\nvocab_freqs = tf.constant([0.1, 0.3, 0.6], dtype=tf.float32)\n```\n\nOutput:\n```python\nnormalized_emb = tf.Tensor(\n[[-2.2360406  -2.2360404  -2.2360406 ]\n [-0.74534684 -0.7453469  -0.7453467 ]\n [ 0.74534667  0.7453466   0.7453467 ]], shape=(3, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef _normalize(emb, vocab_freqs):\n    weights = vocab_freqs / tf.reduce_sum(vocab_freqs)\n    weights = tf.reshape(weights, [-1, 1])\n\n    mean = tf.reduce_sum(weights * emb, axis=0, keepdims=True)\n    var = tf.reduce_sum(weights * tf.pow(emb - mean, 2.0), axis=0, keepdims=True)\n    stddev = tf.sqrt(1e-06 + var)\n\n    return (emb - mean) / stddev", "test_script": "import tensorflow as tf\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(5, 100)\n        embedding_dim = np.random.randint(10, 512)\n\n        emb = tf.constant(np.random.randn(batch_size, embedding_dim).astype(np.float32))\n        vocab_freqs = tf.constant(np.random.rand(batch_size).astype(np.float32))\n\n        test_cases.append((emb, vocab_freqs))\n    return test_cases"}
{"problem_id": "tensorflow_106", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that calculates the Intersection over Union (IoU) between ground truth bounding boxes and predicted bounding boxes. The function should take two sets of bounding boxes, convert them from center-width-height format to corner coordinates, and then compute the IoU for each pair of bounding boxes.\n\nFunction signature:\n```python\ndef calculate_iou(gt_bb, pred_bb):\n```\n\nConstant used in the main code:\n- `tf.keras.backend.epsilon()`: This constant is used to prevent division by zero when calculating the union area.\n\nInput format:\n- `gt_bb`: A tensor of shape (N, 4) representing N ground truth bounding boxes, where each bounding box is defined by its center coordinates (x, y) and dimensions (width, height).\n- `pred_bb`: A tensor of shape (N, 4) representing N predicted bounding boxes, defined in the same format as `gt_bb`.\n\nOutput format:\n- A tensor of shape (N,) containing the IoU values for each pair of ground truth and predicted bounding boxes. Each value represents the IoU for the corresponding bounding boxes.\n\n```python\n# Input\ngt_bb = tf.convert_to_tensor([5.0, 5.0, 4.0, 4.0], dtype=tf.float32)  # Ground truth bounding box (center_x, center_y, width, height)\npred_bb = tf.convert_to_tensor([6.0, 6.0, 4.0, 4.0], dtype=tf.float32)  # Predicted bounding box (center_x, center_y, width, height)\n\n# Output\niou = tf.Tensor(0.39130434, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef calculate_iou(gt_bb, pred_bb):\n    def convert_to_corners(bbox):\n        x_min = bbox[..., 0] - bbox[..., 2] / 2.0\n        y_min = bbox[..., 1] - bbox[..., 3] / 2.0\n        x_max = bbox[..., 0] + bbox[..., 2] / 2.0\n        y_max = bbox[..., 1] + bbox[..., 3] / 2.0\n        return tf.stack([x_min, y_min, x_max, y_max], axis=-1)\n    gt_bb = convert_to_corners(gt_bb)\n    pred_bb = convert_to_corners(pred_bb)\n\n    min_coords = tf.minimum(gt_bb[..., 2:], pred_bb[..., 2:])\n    max_coords = tf.maximum(gt_bb[..., :2], pred_bb[..., :2])\n    intersection_dims = tf.maximum(0.0, min_coords - max_coords)\n    intersection_area = intersection_dims[..., 0] * intersection_dims[..., 1]\n    gt_area = (gt_bb[..., 2] - gt_bb[..., 0]) * (gt_bb[..., 3] - gt_bb[..., 1])\n    pred_area = (pred_bb[..., 2] - pred_bb[..., 0]) * (pred_bb[..., 3] - pred_bb[..., 1])\n    union_area = tf.maximum(gt_area + pred_area - intersection_area, tf.keras.backend.epsilon())\n    iou = tf.clip_by_value(intersection_area / union_area, 0.0, 1.0)\n\n    return iou", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        gt_bb = np.random.rand(4).astype(np.float32) * 10\n        pred_bb = np.random.rand(4).astype(np.float32) * 10\n        gt_bb_tensor = tf.convert_to_tensor(gt_bb, dtype=tf.float32)\n        pred_bb_tensor = tf.convert_to_tensor(pred_bb, dtype=tf.float32)\n\n        test_cases.append((gt_bb_tensor, pred_bb_tensor))\n\n    return test_cases"}
{"problem_id": "tensorflow_107", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that creates a mask indicating which pixels in a flow field are valid based on their computed positions after applying the flow. The function will take a tensor representing the flow field and return a mask tensor that indicates whether each pixel is within the valid bounds of the image dimensions.\n\nFunction signature:\n```python\ndef create_outgoing_mask(flow):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to define the shape of the grid for the x and y coordinates.\n\nInput format:\n- The input to the function is a 4D tensor `flow` with shape `[num_batch, height, width, 2]`, where the last dimension contains the flow vectors.\n\nOutput format:\n- The output of the function is a 4D tensor with shape `[num_batch, height, width, 1]`, where each element is a float indicating whether the corresponding pixel's new position is valid (1.0) or invalid (0.0).\n\nInput:\n```python\nnp.array([[[[1.5, -2.3],\n             [0.0, 1.0],\n             [-1.0, 0.5]],\n\n            [[2.0, 3.0],\n             [-1.5, -1.0],\n             [0.0, 0.0]],\n\n            [[-0.5, 1.5],\n             [1.0, -1.0],\n             [2.5, 2.0]]]], dtype=np.float32)\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[[0.]\n   [1.]\n   [1.]]\n  [[0.]\n   [0.]\n   [1.]]\n  [[0.]\n   [1.]\n   [0.]]]], shape=(1, 3, 3, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef create_outgoing_mask(flow):\n    (num_batch, height, width, _) = tf.unstack(tf.shape(flow))\n    grid_x = tf.reshape(tf.range(width), [1, 1, width])\n    grid_x = tf.tile(grid_x, [num_batch, height, 1])\n    grid_y = tf.reshape(tf.range(height), [1, height, 1])\n    grid_y = tf.tile(grid_y, [num_batch, 1, width])\n    (flow_u, flow_v) = tf.unstack(flow, 2, 3)\n    pos_x = tf.cast(grid_x, dtype=tf.float32) + flow_u\n    pos_y = tf.cast(grid_y, dtype=tf.float32) + flow_v\n    inside_x = tf.logical_and(pos_x <= tf.cast(width - 1, tf.float32), pos_x >= 0.0)\n    inside_y = tf.logical_and(pos_y <= tf.cast(height - 1, tf.float32), pos_y >= 0.0)\n    inside = tf.logical_and(inside_x, inside_y)\n    return tf.expand_dims(tf.cast(inside, tf.float32), 3)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_batch = np.random.randint(1, 11)\n        height = np.random.randint(16, 257)\n        width = np.random.randint(16, 257)\n        flow = np.random.uniform(-10, 10, size=(num_batch, height, width, 2)).astype(np.float32)\n\n        test_cases.append(flow)\n\n    return test_cases"}
{"problem_id": "tensorflow_108", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that retrieves specific values from a 4D tensor (voxel) based on given indices. The function should be able to handle batches of data and return the corresponding values from the voxel tensor.\n\nFunction signature:\n```python\ndef get_voxel_value(voxel, z, y, x):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `tf.constant([])`, which is returned when the voxel tensor is empty.\n\nInput format:\n- `voxel`: A 4D tensor of shape (B, D1, D2, D3).\n- `z`: A 1D tensor of indices for the first dimension of the voxel.\n- `y`: A 1D tensor of indices for the second dimension of the voxel.\n- `x`: A 1D tensor of indices for the third dimension of the voxel.\n\nOutput format:\n- The function returns a tensor containing the values from the `voxel` tensor at the specified indices, or an empty tensor if the `voxel` tensor is empty.\n\n**Input:**\n```python\nvoxel = tf.convert_to_tensor([[[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], \n                                [[0.7, 0.8, 0.9], [1.0, 1.1, 1.2]]], \n                               [[[1.3, 1.4, 1.5], [1.6, 1.7, 1.8]], \n                                [[1.9, 2.0, 2.1], [2.2, 2.3, 2.4]]]]], dtype=tf.float32)\n\nz = tf.convert_to_tensor([[0], [1]], dtype=tf.int32)  # Shape: [2, 1]\ny = tf.convert_to_tensor([[0], [1]], dtype=tf.int32)  # Shape: [2, 1]\nx = tf.convert_to_tensor([[1], [2]], dtype=tf.int32)  # Shape: [2, 1]\n```\n\n**Output:**\n```python\noutput = tf.Tensor(\n[[0.2]\n [2.4]], shape=(2, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef get_voxel_value(voxel, z, y, x):\n    B = tf.shape(z)[0]\n    S = z.shape[1:]\n    S = S.as_list() if S.is_fully_defined() else [tf.shape(z)[i] for i in range(1, tf.rank(z))]\n\n    b = tf.range(0, B)\n    for _ in S:\n        b = tf.expand_dims(b, -1)\n    b = tf.tile(b, [1] + S)\n\n    indices = tf.stack([b, z, y, x], -1)\n    indices = tf.stop_gradient(indices)\n\n    return tf.gather_nd(voxel, indices) if tf.size(voxel) > 0 else tf.constant([])", "test_script": "import tensorflow as tf\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        B = np.random.randint(1, 10)\n        D = np.random.randint(5, 20)\n        H = np.random.randint(5, 20)\n        W = np.random.randint(5, 20)\n        S = np.random.randint(1, 5, size=(np.random.randint(1, 4),)).tolist()\n\n        voxel = tf.convert_to_tensor(np.random.rand(B, D, H, W), dtype=tf.float32)\n        z = tf.convert_to_tensor(np.random.randint(0, D, size=[B] + S), dtype=tf.int32)\n        y = tf.convert_to_tensor(np.random.randint(0, H, size=[B] + S), dtype=tf.int32)\n        x = tf.convert_to_tensor(np.random.randint(0, W, size=[B] + S), dtype=tf.int32)\n\n        test_cases.append((voxel, z, y, x))\n\n    return test_cases"}
{"problem_id": "tensorflow_109", "library": "tensorflow", "code_problem": "You are tasked with implementing a function that computes the classification loss for a machine learning model using TensorFlow. The function will handle both binary and multi-class classification scenarios based on the shape of the input logits. \n\nFunction signature:\n```python\ndef classification_loss(logits, labels, weights):\n```\n\nIn this function, the following constant is used:\n- `inner_dim`: This variable represents the size of the last dimension of the `logits` tensor, which indicates the number of classes in the classification problem.\n\nInput format:\n- `logits`: A tensor of shape (N, C) where N is the number of samples and C is the number of classes.\n- `labels`: A tensor of shape (N,) for binary classification or (N,) for multi-class classification.\n- `weights`: A tensor of shape (N,) representing the weights for each sample.\n\nOutput format:\n- A scalar tensor representing the computed classification loss.\n\n**Input:**\n```python\nlogits = tf.convert_to_tensor([[0.5, 1.5, -1.0], [1.0, 0.0, 0.5]], dtype=tf.float32)  # Shape: (2, 3)\nlabels = tf.convert_to_tensor([1, 0], dtype=tf.int32)  # Shape: (2,)\nweights = tf.convert_to_tensor([1.0, 0.0], dtype=tf.float32)  # Shape: (2,)\n```\n\n**Output:**\n```python\nloss = classification_loss(logits, labels, weights)\n# tf.Tensor(0.371539, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n\ndef _num_labels(weights):\n    return tf.where(tf.equal(tf.reduce_sum(weights), 0.0), 1.0, tf.reduce_sum(weights))\n\n# main code\ndef classification_loss(logits, labels, weights):\n    inner_dim = tf.shape(logits)[-1]\n\n    if tf.equal(inner_dim, 1):\n        loss = tf.nn.sigmoid_cross_entropy_with_logits(\n            logits=tf.reshape(logits, tf.shape(labels)),\n            labels=tf.cast(labels, tf.float32),\n        )\n    else:\n        loss = tf.nn.sparse_softmax_cross_entropy_with_logits(\n            logits=logits, labels=labels\n        )\n\n    return tf.reduce_sum(weights * loss) / _num_labels(weights)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_classes = np.random.randint(1, 10)\n\n        logits = tf.convert_to_tensor(\n            np.random.randn(batch_size, num_classes).astype(np.float32)\n        )\n\n        if num_classes == 1:\n            labels = tf.convert_to_tensor(\n                np.random.randint(0, 2, size=(batch_size, 1)).astype(np.float32)\n            )\n        else:\n            labels = tf.convert_to_tensor(\n                np.random.randint(0, num_classes, size=(batch_size,)).astype(np.int32)\n            )\n\n        weights = tf.convert_to_tensor(\n            np.random.choice([0.0, 1.0], size=(batch_size,)).astype(np.float32)\n        )\n\n        test_cases.append((logits, labels, weights))\n\n    return test_cases"}
{"problem_id": "pytorch_0", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the contrastive loss between two sets of embeddings. The function should normalize the input embeddings, compute the logits using the dot product of the normalized embeddings, and then apply the cross-entropy loss to obtain the final loss value. The function signature is as follows:\n\n```python\ndef contrastive_loss(q: torch.Tensor, k: torch.Tensor, T: float) -> torch.Tensor:\n```\n\nIn this function:\n- `q` is a tensor representing the first set of embeddings.\n- `k` is a tensor representing the second set of embeddings.\n- `T` is a float constant that acts as a temperature parameter for scaling the logits.\n\nThe constant used in the main code is `2 * T`, which is used to scale the final loss value.\n\nInput format:\n- `q`: A tensor of shape (N, D) where N is the number of samples and D is the dimensionality of the embeddings.\n- `k`: A tensor of shape (N, D) where N is the number of samples and D is the dimensionality of the embeddings.\n- `T`: A float representing the temperature parameter.\n\nOutput format:\n- Returns a tensor representing the scaled contrastive loss value.\n\nInput:\n```python\nq = torch.tensor([[ 0.5, -0.2,  0.1],\n                  [ 0.3,  0.4, -0.6],\n                  [-0.1,  0.8,  0.2]])\nk = torch.tensor([[ 0.4, -0.1,  0.3],\n                  [ 0.2,  0.5, -0.7],\n                  [-0.3,  0.6,  0.1]])\nT = 0.5\n```\n\nOutput:\n```python\nloss = contrastive_loss(q, k, T)\nloss = tensor(0.2475)\n```", "ground_truth_code": "import torch\nimport torch.nn as nn\n\n# main code\ndef contrastive_loss(q, k, T):\n    q = nn.functional.normalize(q, dim=1)\n    k = nn.functional.normalize(k, dim=1)\n    logits = torch.einsum('nc,mc->nm', [q, k]) / T\n    N = logits.shape[0]\n    labels = torch.arange(N, dtype=torch.long)\n    return nn.CrossEntropyLoss()(logits, labels) * (2 * T)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(2, 128)  # Random batch size between 2 and 128\n        feature_dim = random.randint(16, 512)  # Random feature dimension between 16 and 512\n        T = random.uniform(0.01, 1.0)  # Random temperature in range (0.01, 1.0)\n\n        q = torch.randn(batch_size, feature_dim)\n        k = torch.randn(batch_size, feature_dim)\n\n        test_cases.append((q, k, T))\n\n    return test_cases"}
{"problem_id": "pytorch_1", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs matrix multiplication on a list of input matrices, applies a bias (if provided), and then applies the hyperbolic tangent activation function. The function should also handle varying column sizes by padding the resulting matrices to ensure they can be concatenated.\n\nFunction signature:\n```python\ndef matrix_mul(input: List[torch.Tensor], weight: torch.Tensor, bias: Optional[torch.Tensor]) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `None`, which is checked to determine if a bias should be applied.\n\n\nInput format:\n- `input`: A list of tensors, where each tensor represents a matrix to be processed.\n- `weight`: A tensor representing the weight matrix to be used in the multiplication.\n- `bias`: An optional tensor representing the bias to be added after multiplication.\n\nOutput format:\n- The function returns a single tensor that is the concatenation of all processed and padded feature matrices.\n\nInput:\n```python\ninput_tensor = [torch.randn(15, 5), torch.randn(20, 5)]\nweight = torch.randn(5, 3)\nbias = torch.nn.Parameter(torch.randn(1, 3))\n```\n\nOutput:\n```python\noutput = matrix_mul(input_tensor, weight, bias)\n```", "ground_truth_code": "import torch\n\n# main code\ndef matrix_mul(input, weight, bias):\n    feature_list = []\n    for feature in input:\n        feature = torch.mm(feature, weight)\n        if bias is not None:\n            feature = feature + bias.expand(feature.size(0), bias.size(1))\n        feature = torch.tanh(feature)\n        feature_list.append(feature)\n    max_columns = max((f.size(1) for f in feature_list))\n    padded_features = [torch.nn.functional.pad(f, (0, max_columns - f.size(1))) for f in feature_list]\n    return torch.cat(padded_features, dim=0).squeeze()", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        input_dim = random.randint(2, 20)\n        output_dim = random.randint(2, 20)\n        input_tensor = [torch.randn(random.randint(10, 100), input_dim) for _ in range(batch_size)]\n        weight = torch.randn(input_dim, output_dim)\n        bias = torch.nn.Parameter(torch.randn(1, output_dim)) if random.choice([True, False]) else None\n        test_cases.append((input_tensor, weight, bias))\n    return test_cases\n"}
{"problem_id": "pytorch_2", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a batch of audio signals and their corresponding token sequences. The function should pad the audio signals and token sequences to ensure they all have the same length within the batch. This is essential for preparing the data for training machine learning models, particularly in natural language processing and audio processing tasks.\n\nFunction signature:\n```python\ndef seq_collate_fn(batch, token_pad_value):\n```\n\nConstant used in the main code:\n- `token_pad_value`: This is the value used to pad the token sequences to ensure they are of uniform length.\n\nInput format:\n- `batch`: A list of tuples, where each tuple contains:\n  - An audio signal tensor\n  - A tensor representing the length of the audio signal\n  - A token sequence tensor\n  - A tensor representing the length of the token sequence\n- `token_pad_value`: A scalar value used for padding token sequences.\n\nOutput format:\n- A tuple containing:\n  - A tensor of padded audio signals (or `None` if no audio signals are present)\n  - A tensor of audio lengths (or `None` if no audio signals are present)\n  - A tensor of padded token sequences\n  - A tensor of token lengths\n\n**Input:**\n```python\nbatch = [\n    (torch.rand(10), torch.tensor(10), torch.tensor([1, 2, 3]), torch.tensor(3)),\n    (torch.rand(15), torch.tensor(15), torch.tensor([4, 5]), torch.tensor(2)),\n    (torch.rand(5), torch.tensor(5), torch.tensor([6, 7, 8, 9]), torch.tensor(4))\n]\ntoken_pad_value = 0\n```\n\n**Output:**\n```python\n(\n    tensor([[0.7351, 0.9564, 0.0296, 0.3950, 0.3662, 0.8538, 0.4638, 0.5632, 0.6816,\n         0.3703, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.8300, 0.1902, 0.6691, 0.6524, 0.3843, 0.7732, 0.0094, 0.6362, 0.8162,\n         0.2683, 0.1986, 0.1075, 0.0091, 0.1741, 0.0255],\n        [0.8590, 0.7948, 0.0542, 0.2993, 0.3810, 0.0000, 0.0000, 0.0000, 0.0000,\n         0.0000, 0.0000, 0.0000, 0.0000, 0.0000, 0.0000]]),\n    tensor([10, 15,  5]),\n    tensor([[1, 2, 3, 0],\n           [4, 5, 0, 0],\n           [6, 7, 8, 9]]),\n    tensor([3, 2, 4])\n)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef seq_collate_fn(batch, token_pad_value):\n    audio_signals, audio_lengths, tokens, tokens_lengths = zip(*batch)\n\n    # Determine max lengths\n    has_audio = audio_lengths[0] is not None\n    max_audio_len = max(audio_lengths).item() if has_audio else 0\n    max_tokens_len = max(tokens_lengths).item()\n\n    padded_audio, padded_tokens = [], []\n\n    for sig, sig_len, tok, tok_len in batch:\n        if has_audio:\n            sig_len = sig_len.item()\n            sig = F.pad(sig, (0, max_audio_len - sig_len)) if sig_len < max_audio_len else sig\n            padded_audio.append(sig)\n\n        tok_len = tok_len.item()\n        tok = F.pad(tok, (0, max_tokens_len - tok_len), value=token_pad_value) if tok_len < max_tokens_len else tok\n        padded_tokens.append(tok)\n\n    # Convert lists to tensors\n    audio_signal = torch.stack(padded_audio) if has_audio else None\n    audio_lengths = torch.stack(audio_lengths) if has_audio else None\n    tokens = torch.stack(padded_tokens)\n    tokens_lengths = torch.stack(tokens_lengths)\n\n    return audio_signal, audio_lengths, tokens, tokens_lengths", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        batch_size = random.randint(1, 10)\n        token_pad_value = random.randint(0, 9)\n\n        has_audio = random.choice([True, False])\n\n        batch = []\n        for _ in range(batch_size):\n            if has_audio:\n                audio_len = random.randint(5, 100)\n                audio_signal = torch.rand(audio_len)\n                audio_length = torch.tensor(audio_len)\n            else:\n                audio_signal, audio_length = None, None\n\n            token_len = random.randint(5, 50)\n            tokens = torch.randint(0, 100, (token_len,))  # Random token values between 0 and 99\n            token_length = torch.tensor(token_len)\n\n            batch.append((audio_signal, audio_length, tokens, token_length))\n        test_cases.append((batch, token_pad_value))\n    return test_cases"}
{"problem_id": "pytorch_3", "library": "pytorch", "code_problem": "You are tasked with implementing a function that generates synthetic labels for a zero-shot learning (ZSL) scenario based on given training labels and attributes. The function will create a new set of labels that includes seen classes, unseen classes, and a combination of both, based on specified proportions.\n\nFunction Signature:\n```python\ndef generate_fake_test_from_train_labels(train_seen_label: torch.Tensor, attribute: torch.Tensor, seenclasses: list, unseenclasses: list, num: int, per_seen: float, per_unseen: float, per_seen_unseen: float) -> torch.Tensor:\n```\n\nConstants Used:\n- The constant `0.5` is used to determine the proportion of seen classes to be randomly selected when generating seen-unseen labels.\n\n\nInput Format:\n- `train_seen_label`: A tensor of shape (N, C) where N is the number of samples and C is the number of classes, containing binary labels for seen classes.\n- `attribute`: A tensor of shape (C, A) where C is the number of classes and A is the number of attributes, containing the attribute representation for each class.\n- `seenclasses`: A list of indices representing the seen classes.\n- `unseenclasses`: A list of indices representing the unseen classes.\n- `num`: An integer representing the number of synthetic label sets to generate.\n- `per_seen`: A float representing the proportion of seen labels to include in each synthetic set.\n- `per_unseen`: A float representing the proportion of unseen labels to include in each synthetic set.\n- `per_seen_unseen`: A float representing the proportion of seen-unseen labels to include in each synthetic set.\n\nOutput Format:\n- The function returns a tensor of shape (M, C) where M is the total number of generated labels across all iterations and C is the number of classes, containing the synthetic labels for the seen, unseen, and seen-unseen classes.\n\n**Input:**\n```python\ntrain_seen_label = torch.tensor([[1, 0, 0], [0, 1, 0], [1, 0, 0], [0, 1, 0]])\nattribute = torch.tensor([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8]])\nseenclasses = torch.tensor([0, 1])\nunseenclasses = torch.tensor([2, 3])\nnum = 4\nper_seen = 0.5\nper_unseen = 0.5\nper_seen_unseen = 0.5\n```\n\n**Output:**\n```python\ntensor([[0, 1, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [0, 1, 0, 1],\n        [1, 0, 0, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 1],\n        [1, 0, 0, 0],\n        [1, 0, 0, 1],\n        [0, 0, 1, 1],\n        [0, 0, 1, 0],\n        [0, 0, 1, 1],\n        [0, 0, 1, 0],\n        [0, 1, 0, 0],\n        [0, 1, 0, 0],\n        [0, 0, 1, 0],\n        [0, 0, 1, 1],\n        [0, 0, 1, 0],\n        [0, 0, 1, 1]])\n```", "ground_truth_code": "import torch\nimport numpy as np\nfrom sklearn.neighbors import NearestNeighbors\n\n# main code\ndef generate_fake_test_from_train_labels(train_seen_label, attribute, seenclasses, unseenclasses, num, per_seen, per_unseen, per_seen_unseen):\n    if train_seen_label.min() != 0:\n        train_seen_label = torch.clamp(train_seen_label, 0, 1)\n    train_seen_label = train_seen_label[(train_seen_label.sum(1) != 0).nonzero().flatten()]\n    seen_attributes = attribute[seenclasses]\n    unseen_attributes = attribute[unseenclasses]\n    (seen_percent, unseen_percent, seen_unseen_percent) = (per_seen, per_unseen, per_seen_unseen)\n    gzsl = []\n    for i in range(0, num):\n        new_gzsl_syn_list = []\n        seen_unseen_label_pairs = {}\n        nbrs = NearestNeighbors(n_neighbors=1, algorithm='auto').fit(unseen_attributes)\n        for (seen_idx, seen_att) in zip(seenclasses, seen_attributes):\n            (_, indices) = nbrs.kneighbors(seen_att[None, :])\n            seen_unseen_label_pairs[seen_idx.tolist()] = unseenclasses[indices[0][0]].tolist()\n        idx = torch.randperm(len(train_seen_label))[0:int(len(train_seen_label) * seen_percent)]\n        seen_labels = train_seen_label[idx]\n        _new_gzsl_syn_list = torch.zeros(seen_labels.shape[0], attribute.shape[0])\n        _new_gzsl_syn_list[:, :len(seenclasses)] = seen_labels\n        new_gzsl_syn_list.append(_new_gzsl_syn_list)\n        idx = torch.randperm(len(train_seen_label))[0:int(len(train_seen_label) * unseen_percent)]\n        temp_label = train_seen_label[idx]\n        _new_gzsl_syn_list = torch.zeros(temp_label.shape[0], attribute.shape[0])\n        for (m, lab) in enumerate(temp_label):\n            new_lab = torch.zeros(attribute.shape[0])\n            unseen_lab = lab.nonzero().flatten()\n            u = []\n            for i in unseen_lab:\n                u.append(seen_unseen_label_pairs[i.tolist()])\n            new_lab[u] = 1\n            _new_gzsl_syn_list[m, :] = new_lab\n        unseen_labels = _new_gzsl_syn_list\n        new_gzsl_syn_list.append(unseen_labels)\n        idx = torch.randperm(len(train_seen_label))[0:int(len(train_seen_label) * seen_unseen_percent)]\n        temp_label = train_seen_label[idx]\n        _new_gzsl_syn_list = torch.zeros(temp_label.shape[0], attribute.shape[0])\n        for (m, lab) in enumerate(temp_label):\n            u = []\n            new_lab = torch.zeros(attribute.shape[0])\n            seen_unseen_lab = lab.nonzero().flatten()\n            temp_seen_label = np.random.choice(seen_unseen_lab, int(len(seen_unseen_lab) * 0.5))\n            u.extend(temp_seen_label)\n            rem_seen_label = np.setxor1d(temp_seen_label, seen_unseen_lab)\n            for i in rem_seen_label:\n                u.append(seen_unseen_label_pairs[i.tolist()])\n            new_lab[u] = 1\n            _new_gzsl_syn_list[m, :] = new_lab\n        seen_unseen_labels = _new_gzsl_syn_list\n        new_gzsl_syn_list.append(seen_unseen_labels)\n        new_gzsl_syn_list = torch.cat(new_gzsl_syn_list)\n        gzsl.append(new_gzsl_syn_list)\n    gzsl = torch.cat(gzsl)\n    tmp_list = gzsl.sum(0)\n    empty_lab = torch.arange(tmp_list.numel())[tmp_list == 0]\n    min_uc = int(tmp_list[len(seenclasses):][tmp_list[len(seenclasses):] > 0].min().item())\n    for el in empty_lab:\n        idx = torch.randperm(gzsl.size(0))[:min_uc]\n        gzsl[idx, el] = 1\n    gzsl = gzsl.long()\n    return gzsl", "test_script": "import torch\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_seen = np.random.randint(20, 30)\n        num_unseen = np.random.randint(10, 20)\n        num_attributes = np.random.randint(2, 10)\n        num_samples = num_seen + num_unseen\n\n        train_seen_label = torch.randint(0, 2, (num_samples, num_seen))\n        attribute = torch.rand(num_seen + num_unseen, num_attributes)\n        seenclasses = torch.arange(num_seen)\n        unseenclasses = torch.arange(num_seen, num_seen + num_unseen)\n        per_seen, per_unseen, per_seen_unseen = np.random.rand(3)\n        test_cases.append(\n            (train_seen_label, attribute, seenclasses, unseenclasses, num_samples, per_seen, per_unseen, per_seen_unseen))\n    return test_cases"}
{"problem_id": "pytorch_4", "library": "pytorch", "code_problem": "You are tasked with implementing a function that projects data onto a specified space using a projection matrix. The function should also have the option to normalize the projected data using the softmax function.\n\nFunction signature:\n```python\ndef prm_projection(data: torch.Tensor, projection_matrix: torch.Tensor, normalize: bool) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `2.0`, which is used in the calculation of the normalization term.\n\n\nInput format:\n- `data`: A tensor of shape (..., n, d) where `...` represents any number of leading dimensions, `n` is the number of data points, and `d` is the dimensionality of each data point.\n- `projection_matrix`: A tensor of shape (..., m, d) where `m` is the dimensionality of the projected space.\n- `normalize`: A boolean value indicating whether to apply normalization to the projected data.\n\nOutput format:\n- The function returns a tensor of shape (..., n, m) representing the projected data, which may be normalized based on the `normalize` parameter.\n\nInput:\n```python\ndata = torch.tensor([[0.5, -1.2, 0.3], [1.0, 0.0, -0.5]])\nprojection_matrix = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\nnormalize = True\n```\n\nOutput:\n```python\ntensor([[0.4547, 0.5453],\n        [0.4164, 0.5836]])\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef prm_projection(data, projection_matrix, normalize):\n    data_normalizer = data.shape[-1] ** (-0.5)\n    data_dash = torch.einsum('...nd,...md->...nm', projection_matrix, data_normalizer * data)\n    norm = data_normalizer * torch.sum(data ** 2, dim=-1).unsqueeze(-2) / 2.0\n    if normalize:\n        proj_data = F.softmax(data_dash - norm, dim=-1)\n    else:\n        proj_data = data_dash - norm\n    return proj_data", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    min_dim = 2\n    max_dim = 128\n    for _ in range(n):\n        batch_size = random.randint(1, 8)\n        feature_dim = random.randint(min_dim, max_dim)\n        proj_dim = random.randint(min_dim, max_dim)\n\n        data = torch.randn(batch_size, feature_dim)\n        projection_matrix = torch.randn(batch_size, proj_dim, feature_dim)\n        normalize = random.choice([True, False])\n\n        test_cases.append((data, projection_matrix, normalize))\n\n    return test_cases\n"}
{"problem_id": "pytorch_5", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a batch of 3D positions and corresponding quaternions into homogeneous transformation matrices. The function should be able to handle multiple poses in a single call, returning a tensor of transformation matrices.\n\nFunction Signature:\n```python\ndef batched_pose2mat(pos: torch.Tensor, quat: torch.Tensor) -> torch.Tensor:\n```\n\nConstant Used:\n- The constant `1.0` is used to set the last element of the homogeneous transformation matrix.\n\nInput Format:\n- The input consists of two tensors:\n  - `pos`: A tensor of shape `(N, 3)` where `N` is the number of poses.\n  - `quat`: A tensor of shape `(N, 4)` where each quaternion is represented as a 4-element vector.\n\nOutput Format:\n- The output is a tensor of shape `(N, 4, 4)` representing the homogeneous transformation matrices for the `N` poses. Each matrix includes both rotation (from the quaternion) and translation (from the position).\n\nInput:\n```python\npos = torch.tensor([[1.0, 2.0, 3.0]])\nquat = torch.tensor([[0.7071, 0.0, 0.7071, 0.0]])\n```\n\nOutput:\n```python\nhomo_pose_mat = tensor([[[ 0.,  0.,  1.,  1.],\n         [ 0.,  1.,  0.,  2.],\n         [-1.,  0.,  0.,  3.],\n         [ 0.,  0.,  0.,  1.]]])\n```", "ground_truth_code": "import torch\n\ndef quaternion_to_matrix(quaternions: torch.Tensor) -> torch.Tensor:\n    (r, i, j, k) = torch.unbind(quaternions, -1)\n    two_s = 2.0 / (quaternions * quaternions).sum(-1)\n    mat = torch.stack((\n        1 - two_s * (j * j + k * k), two_s * (i * j - k * r), two_s * (i * k + j * r),\n        two_s * (i * j + k * r), 1 - two_s * (i * i + k * k), two_s * (j * k - i * r),\n        two_s * (i * k - j * r), two_s * (j * k + i * r), 1 - two_s * (i * i + j * j)\n    ), -1)\n    return mat.reshape(quaternions.shape[:-1] + (3, 3))\n\n# main code\ndef batched_pose2mat(pos: torch.Tensor, quat: torch.Tensor) -> torch.Tensor:\n    batch_shape = pos.shape[:-1]\n    homo_pose_mat = torch.zeros(batch_shape + (4, 4))  # Removed device argument\n    homo_pose_mat[..., :3, :3] = quaternion_to_matrix(quat)\n    homo_pose_mat[..., :3, 3] = pos\n    homo_pose_mat[..., 3, 3] = 1.0\n    return homo_pose_mat", "test_script": "import torch\n\ndef generate_random_quaternion(batch_size=1):\n    rand_quat = torch.randn(batch_size, 4)\n    rand_quat = rand_quat / rand_quat.norm(dim=-1, keepdim=True)\n    return rand_quat\n\n\ndef generate_random_position(batch_size=1, range_min=-10, range_max=10):\n    return torch.FloatTensor(batch_size, 3).uniform_(range_min, range_max)\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        pos = generate_random_position()\n        quat = generate_random_quaternion()\n        test_cases.append((pos, quat))\n\n    return test_cases"}
{"problem_id": "pytorch_6", "library": "pytorch", "code_problem": "```python\ndef quad_kl_div(pi, gamma, ref):\n```\n\nIn this code, the function `quad_kl_div` computes a specific form of the Kullback-Leibler (KL) divergence between two probability distributions represented by the tensors `pi` and `gamma`, with respect to a reference distribution `ref`. The constant used in the main code is `1e-10`, which is added to avoid logarithm of zero during calculations.\n\n### Input and Output Format:\n- **Input**: The function takes three tensors `pi`, `gamma`, and `ref` as input.\n- **Output**: The function returns a single scalar value representing the computed KL divergence.\n\nInput:\n```python\npi = torch.tensor([[0.1, 0.2], [0.3, 0.4]])\ngamma = torch.tensor([[0.2, 0.1], [0.4, 0.3]])\nref = torch.tensor([[0.5, 0.5], [0.5, 0.5]])\n```\n\nOutput:\n```python\noutput = quad_kl_div(pi, gamma, ref)\n# output = tensor(1.8266)\n```", "ground_truth_code": "import torch\n\n# main code\ndef quad_kl_div(pi, gamma, ref):\n    (massp, massg) = (pi.sum(), gamma.sum())\n    div = massg * torch.sum(pi * (pi / ref + 1e-10).log()) + massp * torch.sum(gamma * (gamma / ref + 1e-10).log()) - massp * massg + ref.sum() ** 2\n    return div", "test_script": "import torch\nimport random\n\ndef generate_test_case():\n    \"\"\"Generate a random test case with valid input tensors.\"\"\"\n    shape = (random.randint(2, 10), random.randint(2, 10))  # Random matrix size\n    pi = torch.rand(shape)  # Random non-negative values\n    gamma = torch.rand(shape)  # Random non-negative values\n    ref = torch.rand(shape) + 1e-5  # Ensure ref is strictly positive to avoid division errors\n    return pi, gamma, ref\n\ndef test_case_input_generator(n=200):\n    \"\"\"Generate n test cases and store them in a list.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        pi, gamma, ref = generate_test_case()\n        test_cases.append((pi, gamma, ref))\n    return test_cases"}
{"problem_id": "pytorch_7", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the online mean and standard deviation of a dataset that is provided in batches. The function will process the data in a streaming fashion, allowing it to handle large datasets that may not fit into memory all at once.\n\nFunction signature:\n```python\ndef online_mean_and_sd(loader):\n```\n\nIn this function, the following constant is used:\n- `3`: This constant represents the number of channels in the input data, which is assumed to be a 5-dimensional tensor with shape `(batch_size, channels, depth, height, width)`.\n\nInput format:\n- The input to the function is a `loader`, which is expected to yield batches of data in the form of tuples containing the data tensor and its corresponding target.\n\nOutput format:\n- The output of the function is a tuple containing:\n  - A tensor representing the mean of the data across all batches.\n  - A tensor representing the standard deviation of the data across all batches.\n\n**Input:**\n```python\n# Test case setup\nimport torch\nfrom torch.utils.data import DataLoader, TensorDataset\n\n# Desired shape\nbatch_size = 2\nchannels = 3\nsequence = 2\nheight = 4\nwidth = 4\n\n# Total elements = 2*3*2*4*4 = 192\nnum_elements = batch_size * channels * sequence * height * width\n\n# Create data with exactly 192 elements\ndata = torch.linspace(0.1, 0.1 * num_elements, steps=num_elements).float()\ndata = data.view(batch_size, channels, sequence, height, width)\n\n# Create dummy targets (length must match batch size)\ntargets = torch.tensor([1, 0])\n\n# Dataset and DataLoader\ndataset = TensorDataset(data, targets)\nloader = DataLoader(dataset, batch_size=batch_size, shuffle=False)\n\n# Run your function\nmean, std = online_mean_and_sd(loader)\n```\n\n**Output:**\n```python\n# Expected output\nmean = tensor([ 6.4500,  9.6500, 12.8500])\nstd = tensor([4.8880, 4.8880, 4.8880])\n```", "ground_truth_code": "import torch\n\n# main code\ndef online_mean_and_sd(loader):\n    cnt = 0\n    fst_moment = torch.empty(3)\n    snd_moment = torch.empty(3)\n    for (batch_idx, (data, target)) in enumerate(loader):\n        (b, c, s, h, w) = data.size()\n        nb_pixels = b * h * w * s\n        sum_ = torch.sum(data, dim=[0, 2, 3, 4])\n        sum_of_square = torch.sum(data ** 2, dim=[0, 2, 3, 4])\n        fst_moment = (cnt * fst_moment + sum_) / (cnt + nb_pixels)\n        snd_moment = (cnt * snd_moment + sum_of_square) / (cnt + nb_pixels)\n        cnt += nb_pixels\n    return (fst_moment, torch.sqrt(snd_moment - fst_moment ** 2))", "test_script": "import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nimport random\n\ndef generate_test_loader(batch_size, channels, sequence, height, width, num_batches):\n    \"\"\"Generate a DataLoader with random tensors mimicking the expected input format.\"\"\"\n    data = torch.randn(num_batches * batch_size, channels, sequence, height, width)\n    targets = torch.randint(0, 10, (num_batches * batch_size,))  # Dummy target values\n    dataset = TensorDataset(data, targets)\n    return DataLoader(dataset, batch_size=batch_size, shuffle=False)\n\ndef test_case_input_generator(n=200):\n    \"\"\"Generate `n` test cases with varied input dimensions.\"\"\"\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        channels = 3  # Fixed to match the function's torch.empty(3)\n        sequence = random.randint(1, 5)\n        height = random.randint(8, 64)\n        width = random.randint(8, 64)\n        num_batches = random.randint(1, 20)\n        loader = generate_test_loader(batch_size, channels, sequence, height, width, num_batches)\n        test_cases.append(loader)\n    return test_cases"}
{"problem_id": "pytorch_8", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the CORAL (Correlation Alignment) loss between two sets of feature representations: a source domain and a target domain. The CORAL loss is used in domain adaptation tasks to minimize the distributional discrepancy between the source and target domains.\n\nFunction signature:\n```python\ndef get_CORAL_loss(source: torch.Tensor, target: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant `batch_size` is derived from the first dimension of the `source` tensor, representing the number of samples in the batch.\n\nInput format:\n- The function accepts two input parameters:\n  - `source`: A PyTorch tensor of shape (N, D), where N is the number of samples and D is the number of features.\n  - `target`: A PyTorch tensor of shape (N, D), where N is the number of samples and D is the number of features.\n\nOutput format:\n- The function returns a single PyTorch tensor representing the CORAL loss between the source and target tensors.\n\nInput:\n```python\nsource = torch.tensor([[ 0.5, -1.2],\n                       [ 1.0,  0.3],\n                       [-0.7,  0.8]])\ntarget = torch.tensor([[ 0.1, -0.5],\n                       [ 0.4,  1.2],\n                       [-1.0,  0.0]])\n```\n\nOutput:\n```python\nloss = get_CORAL_loss(source, target)  # Expected output: tensor(0.2758)\n``` \n", "ground_truth_code": "import torch\n\n# main code\ndef get_CORAL_loss(source, target):\n    batch_size = source.data.shape[0]\n    xm = torch.mean(source, 0, keepdim=True) - source\n    xc = xm.t() @ xm / (batch_size - 1)\n    xmt = torch.mean(target, 0, keepdim=True) - target\n    xct = xmt.t() @ xmt / (batch_size - 1)\n    loss = torch.mean(torch.mul(xc - xct, xc - xct))\n    return loss", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    min_batch_size = 2\n    max_batch_size = 100\n    min_dim = 2\n    max_dim = 50\n    for _ in range(n):\n        batch_size = random.randint(min_batch_size, max_batch_size)\n        dim = random.randint(min_dim, max_dim)\n\n        source = torch.randn(batch_size, dim)\n        target = torch.randn(batch_size, dim)\n        test_cases.append((source, target))\n\n    return test_cases"}
{"problem_id": "pytorch_9", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the nullspace torques for a robotic joint system based on the provided mass matrix, nullspace matrix, initial joint positions, current joint positions, joint velocities, and joint stiffness coefficients. The function will utilize the principles of control theory to compute the required torques to maintain the desired joint positions while considering the dynamics of the system.\n\nFunction signature:\n```python\ndef nullspace_torques(mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp):\n```\n\nConstant used in the main code:\n- `joint_kv` is calculated as `torch.sqrt(joint_kp) * 2`, which represents the velocity gain based on the stiffness coefficients.\n\n\nInput format:\n- `mass_matrix`: A tensor representing the mass matrix of the robotic system.\n- `nullspace_matrix`: A tensor representing the nullspace matrix.\n- `initial_joint`: A tensor representing the initial joint positions.\n- `joint_pos`: A tensor representing the current joint positions.\n- `joint_vel`: A tensor representing the current joint velocities.\n- `joint_kp`: A tensor representing the joint stiffness coefficients.\n\nOutput format:\n- The function returns a tensor representing the computed nullspace torques.\n\n**Input:**\n```python\nmass_matrix = torch.tensor([[2.0, 0.5], [0.5, 1.0]])\nnullspace_matrix = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\ninitial_joint = torch.tensor([1.0, 2.0])\njoint_pos = torch.tensor([0.5, 1.5])\njoint_vel = torch.tensor([0.1, 0.2])\njoint_kp = torch.tensor(10.0)\n```\n\n**Output:**\n```python\nnullspace_torques(mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp)\n# Output: tensor([10.6026,  5.9189])\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef nullspace_torques(mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp):\n    joint_kv = torch.sqrt(joint_kp) * 2\n    pose_torques = torch.matmul(mass_matrix, joint_kp * (initial_joint - joint_pos) - joint_kv * joint_vel)\n    nullspace_torques = torch.matmul(nullspace_matrix.t(), pose_torques)\n    return nullspace_torques", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_joints = random.randint(2, 10)  # Number of joints (variable size for diversity)\n\n        mass_matrix = torch.randn(num_joints, num_joints)  # Random mass matrix\n        mass_matrix = torch.matmul(mass_matrix, mass_matrix.t())  # Make it symmetric positive semi-definite\n\n        nullspace_matrix = torch.randn(num_joints, num_joints)  # Random nullspace matrix\n\n        initial_joint = torch.randn(num_joints)\n        joint_pos = torch.randn(num_joints)\n        joint_vel = torch.randn(num_joints)\n        joint_kp = torch.tensor(random.uniform(0.1, 50))\n\n        test_cases.append((mass_matrix, nullspace_matrix, initial_joint, joint_pos, joint_vel, joint_kp))\n\n    return test_cases"}
{"problem_id": "pytorch_10", "library": "pytorch", "code_problem": "You are tasked with implementing a function that categorizes relative positions into discrete buckets based on their values. This function is particularly useful in scenarios involving attention mechanisms in neural networks, where understanding the relative positions of tokens is crucial.\n\nFunction signature:\n```python\ndef _relative_position_bucket(relative_position: torch.Tensor, causal: bool, num_buckets: int, max_distance: int) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- `math.log`: This constant is used to compute the logarithm of a number.\n\nInput format:\n- `relative_position`: A tensor of integers representing the relative positions.\n- `causal`: A boolean indicating whether the positions are causal or not.\n- `num_buckets`: An integer representing the total number of buckets to categorize the positions.\n- `max_distance`: An integer representing the maximum distance for scaling.\n\nOutput format:\n- The function returns a tensor of integers, where each integer corresponds to the bucket index assigned to the respective relative position.\n\nInput:\n```python\nrelative_position = torch.tensor([-5, 3, 10, -1])\ncausal = True\nnum_buckets = 16\nmax_distance = 100\n```\n\nOutput:\n```python\ntensor([5, 0, 0, 1])\n```", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef _relative_position_bucket(relative_position, causal, num_buckets, max_distance):\n    bucket_indices = torch.zeros_like(relative_position)\n    n = -relative_position\n\n    if not causal:\n        num_buckets //= 2\n        bucket_indices += (n < 0).long() * num_buckets\n        n = torch.abs(n)\n    else:\n        n = torch.clamp(n, min=0)\n\n    max_exact = num_buckets // 2\n    is_small = n < max_exact\n\n    log_val = torch.log(n.float() / max_exact) / math.log(max_distance / max_exact)\n    large_val = max_exact + (log_val * (num_buckets - max_exact)).long()\n    large_val = torch.clamp(large_val, max=num_buckets - 1)\n\n    bucket_indices += torch.where(is_small, n, large_val)\n    return bucket_indices", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        relative_position = torch.randint(-100, 100, (random.randint(1, 10),))\n        causal = random.choice([True, False])\n        num_buckets = random.choice([8, 16, 32, 64, 128])\n        max_distance = random.choice([10, 50, 100, 500, 1000])\n\n        test_cases.append((relative_position, causal, num_buckets, max_distance))\n\n    return test_cases"}
{"problem_id": "pytorch_11", "library": "pytorch", "code_problem": "You are tasked with implementing a loss function used in a machine learning model, specifically for a variational autoencoder. The function computes a combination of binary cross-entropy loss and Kullback-Leibler divergence. \n\nThe function signature is as follows:\n```python\ndef loss_function(input_tensor, generated_tensor, mean, std_dev):\n```\n\nIn this function, the following constant is used:\n- The constant `784` represents the number of features in the input tensor, which is assumed to be flattened from a 28x28 image.\n\nInput format:\n- `input_tensor`: A tensor of shape (N, 28, 28) representing the original input images.\n- `generated_tensor`: A tensor of the same shape as `input_tensor`, representing the generated images from the model.\n- `mean`: A tensor of shape (N,) representing the mean of the latent variables.\n- `std_dev`: A tensor of shape (N,) representing the standard deviation of the latent variables.\n\nOutput format:\n- The function returns a single scalar value representing the total loss, which is the sum of the binary cross-entropy loss and the Kullback-Leibler divergence.\n\nInput:\n```python\ninput_tensor = torch.tensor([[0.1] * 784])  # Example normalized input\ngenerated_tensor = torch.tensor([[0.2] * 784])  # Example generated output\nmean = torch.tensor([[0.5] * 20])  # Example mean for latent space\nstd_dev = torch.tensor([[1.0] * 20])  # Example standard deviation for latent space\n```\n\nOutput:\n```python\nloss = loss_function(input_tensor, generated_tensor, mean, std_dev)\n# tensor(286.1300)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef loss_function(input_tensor, generated_tensor, mean, std_dev):\n    input_tensor = input_tensor.view(-1, 784)\n    generated_tensor = torch.nan_to_num(generated_tensor, nan=0.0)\n    bce_loss = F.binary_cross_entropy(generated_tensor, input_tensor, reduction='sum')\n    kl_divergence = -0.5 * torch.sum(1 + torch.log(std_dev ** 2) - mean ** 2 - std_dev ** 2)\n\n    return bce_loss + kl_divergence", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        input_tensor = torch.rand((1, 784))  # Normalized input\n        generated_tensor = torch.rand((1, 784))\n        mean = torch.randn((1, 20))  # Assuming latent space of 20 dimensions\n        std_dev = torch.rand((1, 20)) + 1e-6  # Ensure std_dev is positive\n\n        test_cases.append((input_tensor, generated_tensor, mean, std_dev))\n    return test_cases"}
{"problem_id": "pytorch_12", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts color values from the CIELAB color space to the CIE XYZ color space. The function should take a tensor representing LAB color values and return a tensor representing the corresponding XYZ color values.\n\nFunction signature:\n```python\ndef lab2xyz(lab):\n```\n\nConstant used in the main code:\n- The scale factors for the conversion from the LAB color space to the XYZ color space are defined as a tensor: `scale_factors = torch.tensor([0.95047, 1.0, 1.08883]).view(1, 3, 1, 1)`.\n\nInput format:\n- The input to the function is a tensor `lab` of shape (N, 3, H, W), where N is the number of color samples, 3 corresponds to the LAB components (L, A, B), and H and W are the height and width of the image or data grid.\n\nOutput format:\n- The output of the function is a tensor of the same shape (N, 3, H, W) representing the converted XYZ color values.\n\n**Input:**\n```python\ntensor([[[[ 50.0,  20.0],\n          [ 70.0, -30.0]],\n\n         [[ 10.0,  50.0],\n          [ 90.0,  10.0]],\n\n         [[  5.0, -20.0],\n          [ 60.0,  80.0]]]])\n```\n\n**Output:**\n```python\ntensor([[[[ 0.1942,  0.0657],\n          [ 0.7435, -0.0291]],\n         [[ 0.1842,  0.0299],\n          [ 0.4075, -0.0332]],\n         [[ 0.1753,  0.0752],\n          [ 0.0936, -0.0193]]]])\n```", "ground_truth_code": "import torch\n# main code\ndef lab2xyz(lab):\n    y_int = (lab[:, 0, :, :] + 16.0) / 116.0\n    x_int = lab[:, 1, :, :] / 500.0 + y_int\n    z_int = y_int - lab[:, 2, :, :] / 200.0\n\n    z_int = torch.max(torch.tensor(0.0), z_int)\n    out = torch.stack((x_int, y_int, z_int), dim=1)\n    mask = (out > 0.2068966).float()\n    out = out ** 3 * mask + (out - 16.0 / 116.0) / 7.787 * (1 - mask)\n    scale_factors = torch.tensor([0.95047, 1.0, 1.08883]).view(1, 3, 1, 1)\n\n    return out * scale_factors", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate random LAB values\n        batch_size = random.randint(1, 10)  # Random batch size between 1 and 10\n        height = random.randint(1, 256)  # Random height between 1 and 256\n        width = random.randint(1, 256)  # Random width between 1 and 256\n\n        # L (0 to 100), a (-128 to 127), b (-128 to 127) in the LAB color space\n        lab_tensor = torch.empty((batch_size, 3, height, width)).uniform_(-128, 127)\n        lab_tensor[:, 0, :, :] = torch.empty((batch_size, height, width)).uniform_(0, 100)  # L-channel should be 0-100\n\n        test_cases.append(lab_tensor)\n    return test_cases"}
{"problem_id": "pytorch_13", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes user data through a series of transformations using matrix operations. The function will take in user information and several weight matrices, applying activation functions and combining the results to produce a final output.\n\nFunction signature:\n```python\ndef forward(user, activation, Wh, Wns, Wpn, fc, Wn, Wp, Wsp, Ws):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the activation function `torch.tanh`, which is applied to various intermediate results.\n\nInput format:\n- The function takes the following parameters:\n  - `user`: A dictionary containing 'semantic', 'property', and 'neighbor' matrices.\n  - `activation`: An activation function to be applied to the neighbor data.\n  - `Wh`, `Wns`, `Wpn`, `Wn`, `Wp`, `Wsp`, `Ws`: Weight matrices used in the transformations.\n  - `fc`: A function to process the 'neighbor' data.\n\nOutput format:\n- The function returns a tensor that represents the final transformed output after applying the series of matrix operations and activations.\n\n**Input:**\n```python\nuser = {\n    'semantic': torch.tensor([[[ 0.5, -0.2], [ 0.1,  0.3]], [[-0.4,  0.6], [ 0.2, -0.1]]]),  # Shape: (2, 2, 2)\n    'property': torch.tensor([[[-0.1,  0.4], [ 0.3, -0.5]], [[ 0.2, -0.3], [-0.6,  0.1]]]),  # Shape: (2, 2, 2)\n    'neighbor': torch.tensor([[[ 0.3, -0.1], [ 0.2,  0.4]], [[-0.2,  0.5], [ 0.1, -0.3]]])   # Shape: (2, 2, 2)\n}\n\nactivation = torch.tanh\nfc = torch.nn.Linear(2, 2)  # Input and output dimension is 2\n\nWsp = torch.tensor([[ 0.1, -0.2], [ 0.3,  0.4]])  # Shape: (2, 2)\nWpn = torch.tensor([[ 0.5, -0.1], [-0.3,  0.2]])  # Shape: (2, 2)\nWns = torch.tensor([[ 0.2,  0.3], [-0.4,  0.1]])  # Shape: (2, 2)\n\nWs = torch.tensor([[ 0.1, -0.3], [ 0.4,  0.2]])  # Shape: (2, 2)\nWp = torch.tensor([[ 0.2,  0.1], [-0.5,  0.3]])  # Shape: (2, 2)\nWn = torch.tensor([[ 0.3, -0.4], [ 0.1,  0.2]])  # Shape: (2, 2)\n\nWh = torch.tensor([[ 0.1, -0.2], [ 0.3,  0.4], [-0.1,  0.5], [ 0.2, -0.3], [ 0.4,  0.1], [-0.5,  0.2]])  # Shape: (6, 2)\n\noutput = forward(user, activation, Wh, Wns, Wpn, fc, Wn, Wp, Wsp, Ws)\n```\n\n**Output:**\n```python\ntensor([[[ 0.1957, -0.0339],\n         [-0.0021,  0.1320]],\n        [[-0.0991,  0.0798],\n         [ 0.1538, -0.1523]]], grad_fn=<TanhBackward0>)\n```", "ground_truth_code": "import torch\n\n# main code\ndef forward(user, activation, Wh, Wns, Wpn, fc, Wn, Wp, Wsp, Ws):\n    Vs = user['semantic'].transpose(1, 2)\n    Vp = user['property'].transpose(1, 2)\n    Vn = activation(fc(user['neighbor'])).transpose(1, 2)\n    Fsp = torch.tanh(Vs.transpose(1, 2) @ Wsp @ Vp)\n    Fpn = torch.tanh(Vp.transpose(1, 2) @ Wpn @ Vn)\n    Fns = torch.tanh(Vn.transpose(1, 2) @ Wns @ Vs)\n    Hs = torch.tanh(Ws @ Vs + (Wp @ Vp) * Fsp + (Wn @ Vn) * Fns)\n    Hp = torch.tanh(Wp @ Vp + (Ws @ Vs) * Fsp + (Wn @ Vn) * Fpn)\n    Hn = torch.tanh(Wn @ Vn + (Ws @ Vs) * Fns + (Wp @ Vp) * Fpn)\n    H = torch.cat((Hs, Hp, Hn), dim=1)\n    result = torch.tanh(H.transpose(1, 2) @ Wh)\n\n    return result\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        dim1 = random.randint(5, 20)  # Common dimension across semantic, property, and neighbor\n        dim2 = random.randint(5, 20)  # Variable dimension\n\n        user = {\n            'semantic': torch.randn(batch_size, dim1, dim2),\n            'property': torch.randn(batch_size, dim1, dim2),\n            'neighbor': torch.randn(batch_size, dim1, dim2)\n        }\n\n        activation = torch.tanh\n        fc = torch.nn.Linear(dim2, dim2)  # Ensure the same last dimension\n\n        Wsp = torch.randn(dim2, dim2)  # Adjusted dimensions for correct multiplication\n        Wpn = torch.randn(dim2, dim2)\n        Wns = torch.randn(dim2, dim2)\n\n        Ws = torch.randn(dim1, dim2)  # Adjusted to match transformations\n        Wp = torch.randn(dim1, dim2)\n        Wn = torch.randn(dim1, dim2)\n\n        Wh = torch.randn(dim1 * 3, dim2)  # Final concatenated transformation\n\n        test_cases.append((user, activation, Wh, Wns, Wpn, fc, Wn, Wp, Wsp, Ws))\n\n    return test_cases"}
{"problem_id": "pytorch_14", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a batch of axis-angle representations into quaternion representations. The function should handle both zero and non-zero rotation vectors appropriately.\n\nFunction signature:\n```python\ndef batch_axisangle2quat(vecs: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- A tensor representing zero, specifically `torch.tensor([0.0], dtype=vecs.dtype)`.\n\nInput format:\n- A 2D tensor `vecs` of shape (n, 3), where each row represents a 3D vector in axis-angle format.\n\nOutput format:\n- A 2D tensor of shape (n, 4), where each row represents the corresponding quaternion in the format [x, y, z, w].\n\n**Input:**\n```python\ntensor([[0.0000, 0.0000, 0.0000],\n        [1.0000, 0.0000, 0.0000],\n        [0.0000, 1.0000, 0.0000]])\n```\n\n**Output:**\n```python\ntensor([[0.0000, 0.0000, 0.0000, 1.0000],\n        [0.4794, 0.0000, 0.0000, 0.8776],\n        [0.0000, 0.4794, 0.0000, 0.8776]])\n```", "ground_truth_code": "import torch\n\n\n# main code\ndef batch_axisangle2quat(vecs):\n    n = vecs.shape[0]\n    angle = torch.norm(vecs, dim=1)\n    q = torch.zeros((n, 4), dtype=vecs.dtype)  # No device specification\n    zero_rot_mask = torch.isclose(angle, torch.tensor([0.0], dtype=vecs.dtype))\n    q[zero_rot_mask] = torch.tensor([0.0, 0.0, 0.0, 1.0], dtype=vecs.dtype)\n\n    non_zero_rot_mask = ~zero_rot_mask\n    angle = angle.unsqueeze(-1)\n    axis = vecs / angle\n    q[non_zero_rot_mask, 3:4] = torch.cos(angle[non_zero_rot_mask] / 2.0)\n    q[non_zero_rot_mask, :3] = axis[non_zero_rot_mask] * torch.sin(angle[non_zero_rot_mask] / 2.0)\n\n    return q", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a batch size between 1 and 10\n        batch_size = random.randint(1, 10)\n\n        # Generate random axis-angle vectors\n        vecs = torch.randn(batch_size, 3) * random.uniform(0.1, 10.0)\n\n        # Introduce edge cases\n        if random.random() < 0.1:\n            vecs = torch.zeros(batch_size, 3)  # Zero rotation case\n\n        if random.random() < 0.1:\n            vecs *= 1e-6  # Very small angles\n\n        if random.random() < 0.1:\n            vecs *= 1e6  # Very large angles\n\n        test_cases.append(vecs)\n\n    return test_cases"}
{"problem_id": "pytorch_15", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a set of angles into a corresponding 2D rotation matrix. The function will take a tensor of angles (in radians) and return a tensor representing the rotation matrix for each angle.\n\nFunction signature:\n```python\ndef angles_to_rotation_matrix(angles: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The function uses the mathematical constants for cosine and sine, which are computed using the `torch.cos` and `torch.sin` functions.\n\nInput format:\n- The input to the function is a tensor of angles, where each angle is represented in radians.\n\nOutput format:\n- The output of the function is a tensor containing the corresponding 2D rotation matrices for each angle provided in the input tensor. Each rotation matrix is a 2x2 tensor.\n\nInput: `torch.tensor([1.5708])`  # Approximately \u03c0/2 radians\n\nOutput: \n```\ntensor([[[-3.6200e-06,  1.0000e+00],\n         [-1.0000e+00, -3.6200e-06]]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef angles_to_rotation_matrix(angles: torch.Tensor) -> torch.Tensor:\n    cos_vals = torch.cos(angles).unsqueeze(-1).unsqueeze(-1)\n    sin_vals = torch.sin(angles).unsqueeze(-1).unsqueeze(-1)\n\n    rotation_matrix = torch.cat([\n        torch.cat([cos_vals, sin_vals], dim=2),\n        torch.cat([-sin_vals, cos_vals], dim=2)\n    ], dim=1)\n\n    return rotation_matrix", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a random tensor of angles\n        angle_tensor = torch.tensor([random.uniform(-3.1416, 3.1416)])  # Range [-pi, pi]\n\n        test_cases.append(angle_tensor)\n    return test_cases"}
{"problem_id": "pytorch_16", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a pixel assignment map and a set of superpixel IDs to generate a new superpixel map. The function will identify the most significant assignment for each pixel and create a new map that reflects these assignments based on the provided superpixel IDs.\n\nFunction signature:\n```python\ndef split_spixels(assign_map: torch.Tensor, spixel_ids: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used in the `torch.where` function to create a binary assignment map.\n\nInput format:\n- `assign_map`: A tensor of shape `(N, C, H, W)` where `N` is the number of images, `C` is the number of classes, `H` is the height, and `W` is the width of the images.\n- `spixel_ids`: A tensor of shape `(C, H, W)` containing the superpixel IDs corresponding to each pixel.\n\nOutput format:\n- The function returns a tensor of shape `(N, 1, H, W)` representing the new superpixel map based on the strongest pixel assignments.\n\n**Input:**\n```python\nassign_map = torch.tensor([[[[0.1, 0.2, 0.7],\n                             [0.4, 0.5, 0.1]],\n\n                            [[0.3, 0.6, 0.1],\n                             [0.2, 0.1, 0.7]]]])\n\nspixel_ids = torch.tensor([[[[1, 2, 3],\n                              [4, 5, 6]]]])\n```\n\n**Output:**\n```python\ntensor([[[[1, 2, 3],\n          [4, 5, 6]]]], dtype=torch.int32)\n```", "ground_truth_code": "import torch\n\n# main code\ndef split_spixels(assign_map, spixel_ids):\n    (N, C, H, W) = assign_map.shape\n    spixel_id_map = spixel_ids.expand(N, -1, -1, -1)\n    (assig_max, _) = torch.max(assign_map, dim=1, keepdim=True)\n    assignment_ = torch.where(assign_map == assig_max, torch.ones(assign_map.shape), torch.zeros(assign_map.shape))\n    new_spixl_map_ = spixel_id_map * assignment_\n    new_spixl_map = torch.sum(new_spixl_map_, dim=1, keepdim=True).type(torch.int)\n    return new_spixl_map", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly generate the shape for assign_map (N, C, H, W)\n        N = random.randint(1, 10)  # Batch size\n        C = random.randint(1, 5)  # Number of classes/channels\n        H = random.randint(5, 50)  # Height\n        W = random.randint(5, 50)  # Width\n\n        # Generate random tensor for assign_map\n        assign_map = torch.rand((N, C, H, W))\n\n        # Generate sequential spixel_ids (randomly initialized)\n        spixel_ids = torch.randint(1, 100, (1, 1, H, W))\n\n        test_cases.append((assign_map, spixel_ids))\n\n    return test_cases"}
{"problem_id": "pytorch_17", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the values of cubic B-spline basis functions based on given input parameters. The function will take in a tensor of parameter values and an integer indicating which B-spline basis function to evaluate.\n\nFunction Signature:\n```python\ndef torch_Bspline(uv: torch.Tensor, kl: int) -> torch.Tensor:\n```\n\nConstant Used:\n- The constant `2/3` is used in the calculation of the first B-spline basis function.\n\nInput Format:\n- The input consists of a tensor `uv` of parameter values and an integer `kl`.\n\nOutput Format:\n- The output is a tensor containing the computed B-spline values corresponding to the specified `kl`.\n\n```python\nInput: (tensor(0.25), tensor(1))\nOutput: tensor(0.6120)\n```", "ground_truth_code": "import torch\n\n# main code\ndef torch_Bspline(uv, kl):\n    bspline_values = {\n        0: (1 - uv) ** 3 / 6,\n        1: uv ** 3 / 2 - uv ** 2 + 2 / 3,\n        2: (-3 * uv ** 3 + 3 * uv ** 2 + 3 * uv + 1) / 6,\n        3: uv ** 3 / 6\n    }\n\n    return torch.where(\n        kl == 0, bspline_values[0],\n        torch.where(\n            kl == 1, bspline_values[1],\n            torch.where(\n                kl == 2, bspline_values[2],\n                torch.where(kl == 3, bspline_values[3], torch.zeros_like(uv))\n            )\n        )\n    )", "test_script": "import random\nimport torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        uv = torch.tensor(random.uniform(0, 1), dtype=torch.float32)\n        kl = torch.tensor(random.randint(0, 3), dtype=torch.int32)\n\n\n        test_cases.append((uv, kl))\n    return test_cases"}
{"problem_id": "pytorch_18", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a quaternion representation of a rotation into a corresponding rotation matrix. The function should handle cases where the quaternion may be close to zero, ensuring that it returns a valid identity matrix in such scenarios.\n\nFunction signature:\n```python\ndef quat2mat(quaternion):\n```\n\nConstant used in the main code:\n- `EPS = 1e-8`: This constant is used as a threshold to determine if the quaternion is effectively zero.\n\nInput format:\n- The input to the function is a tensor of shape (4,) representing the quaternion.\n\nOutput format:\n- The output of the function is a tensor of shape (3, 3) representing the rotation matrix corresponding to the input quaternion.\n\nInput: \n```python\ntorch.tensor([0.7071, 0.0, 0.7071, 0.0])\n```\n\nOutput: \n```python\ntorch.tensor([[ 0.,  0.,  1.],\n        [ 0., -1.,  0.],\n        [ 1.,  0.,  0.]])\n```", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef quat2mat(quaternion):\n    EPS = 1e-8\n    inds = torch.tensor([3, 0, 1, 2])\n    q = quaternion.clone().detach().float()[inds]\n\n    n = torch.dot(q, q)\n    if n < EPS:\n        return torch.eye(3)\n\n    q *= math.sqrt(2.0 / n)\n    q_outer = torch.outer(q, q)\n\n    return torch.tensor([\n        [1.0 - q_outer[2, 2] - q_outer[3, 3], q_outer[1, 2] - q_outer[3, 0], q_outer[1, 3] + q_outer[2, 0]],\n        [q_outer[1, 2] + q_outer[3, 0], 1.0 - q_outer[1, 1] - q_outer[3, 3], q_outer[2, 3] - q_outer[1, 0]],\n        [q_outer[1, 3] - q_outer[2, 0], q_outer[2, 3] + q_outer[1, 0], 1.0 - q_outer[1, 1] - q_outer[2, 2]]\n    ])", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate random quaternion components\n        quaternion = torch.randn(4)  # Random numbers from a normal distribution\n\n        # Normalize the quaternion to ensure it represents a valid rotation\n        quaternion /= quaternion.norm() + 1e-8\n\n        test_cases.append(quaternion)\n    return test_cases"}
{"problem_id": "pytorch_19", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs farthest point sampling on a set of keypoints. The function should select a specified number of points from a given set of points in a way that maximizes the minimum distance between the selected points. This is useful in various applications such as point cloud processing and computer graphics.\n\nFunction signature:\n```python\ndef farthest_point_sampling(kpts: torch.Tensor, num_points: int):\n```\n\nConstant used in the main code:\n- The constant `float('inf')` is used to initialize the distances tensor, representing an infinitely large distance.\n\n\nInput format:\n- `kpts`: A tensor of shape (B, N, C) where B is the number of batches, N is the number of points in each batch, and C is the number of dimensions for each point.\n- `num_points`: An integer representing the number of points to sample from each batch.\n\nOutput format:\n- The function returns a tuple containing:\n  - `sampled_points`: A tensor of shape (B, num_points, C) representing the sampled points.\n  - `indices`: A tensor of shape (B, num_points) containing the indices of the sampled points in the original `kpts` tensor.\n\n**Input:**\n```python\nkpts = torch.tensor([[[0.1, 0.2], [0.4, 0.5], [0.3, 0.8], [0.9, 0.1], [0.6, 0.4]]])  # Shape (1, 5, 2)\nnum_points = 3\n```\n\n**Output:**\n```python\nsampled_points = torch.tensor([[[0.6000, 0.4000],\n         [0.1000, 0.2000],\n         [0.3000, 0.8000]]])\nindices = torch.tensor([[4, 0, 2]])\n```\n\n", "ground_truth_code": "import torch\n\n# main code\ndef farthest_point_sampling(kpts: torch.Tensor, num_points: int):\n    B, N, C = kpts.shape\n\n    indices = torch.zeros((B, num_points), dtype=torch.long)\n    distances = torch.full((B, N), float('inf'))\n\n    indices[:, 0] = torch.randint(0, N, (B,), dtype=torch.long)\n\n    for i in range(1, num_points):\n        last_selected = kpts[torch.arange(B), indices[:, i - 1]].unsqueeze(1)\n        dist_to_last = torch.sum((kpts - last_selected) ** 2, dim=2)\n        distances = torch.min(distances, dist_to_last)\n        indices[:, i] = torch.argmax(distances, dim=1)\n    sampled_points = kpts[torch.arange(B).unsqueeze(1), indices]\n    return sampled_points, indices", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate random values for kpts tensor of shape (B, N, C)\n        B = torch.randint(1, 5, (1,)).item()  # Batch size between 1 and 5\n        N = torch.randint(10, 20, (1,)).item()  # Number of keypoints between 10 and 20\n        C = torch.randint(2, 6, (1,)).item()  # Number of coordinates between 2 and 5\n\n        kpts = torch.rand((B, N, C))  # Random tensor for keypoints\n        num_points = torch.randint(1, N + 1, (1,)).item()  # Random number of points to sample between 1 and N\n\n        test_cases.append((kpts, num_points))\n\n    return test_cases\n"}
{"problem_id": "pytorch_20", "library": "pytorch", "code_problem": "```python\ndef Eval(model, dataloader):\n```\n\nIn this code, the function `Eval` is designed to evaluate a given machine learning model on a dataset provided through a dataloader. The evaluation is performed by calculating the F1 score, which is a measure of a model's accuracy that considers both precision and recall.\n\n\n### Input and Output Format:\n- **Input**: The function takes two parameters:\n  - `model`: A trained machine learning model that is to be evaluated.\n  - `dataloader`: A PyTorch DataLoader object that provides batches of data for evaluation.\n\n- **Output**: The function returns a single floating-point number representing the F1 score of the model on the provided dataset.\n\n```python\n# Input\nmodel = MockModel()\ndataloader = [\n    (torch.randint(0, 1000, (16, 32)),  # tok\n     torch.randint(0, 3, (16,)),        # lab\n     torch.randint(0, 2, (16, 32)))     # att\n]\n\n# Output\nacc = Eval(model, dataloader)  # Example output could be a float value like 0.125\n```", "ground_truth_code": "import torch\nfrom sklearn.metrics import f1_score\n\n# main code\ndef Eval(model, dataloader):\n    model.eval()\n    with torch.no_grad():\n        output = None\n        label = None\n        for (idx, batch) in enumerate(dataloader):\n            (tok, lab, att) = batch\n            typ = torch.zeros(tok.shape, dtype=torch.long)  # No .cuda()\n            logits = model(tok, token_type_ids=typ, attention_mask=att)  # No .cuda()\n            logits = logits[0]\n            if output is None:\n                output = torch.argmax(logits, axis=1)\n                label = lab # Ensure label is also on CPU\n            else:\n                output = torch.cat((output, torch.argmax(logits, axis=1)), axis=-1)\n                label = torch.cat((label, lab), axis=-1)  # Ensure concatenation on CPU\n        acc = f1_score(output.numpy(), label.squeeze().numpy(), average='micro')  # Convert tensors to numpy\n    return acc", "test_script": "import random\nimport torch\n\ndef test_case_input_generator(n=200):\n    def MockModel():\n        class Model(torch.nn.Module):\n            def forward(self, tok, token_type_ids=None, attention_mask=None):\n                batch_size, seq_length = tok.shape\n                num_classes = random.randint(2, 5)\n                logits = torch.randn(batch_size, num_classes)\n                return (logits,)\n\n        return Model()\n\n    def generate_mock_dataloader(batch_size=16, seq_length=32, num_classes=3, num_batches=10):\n        dataloader = []\n        for _ in range(num_batches):\n            tok = torch.randint(0, 1000, (batch_size, seq_length))\n            lab = torch.randint(0, num_classes, (batch_size,))\n            att = torch.randint(0, 2, (batch_size, seq_length))\n            dataloader.append((tok, lab, att))\n        return dataloader\n\n    test_cases = []\n    for _ in range(n):\n        model = MockModel()\n        dataloader = generate_mock_dataloader()\n        test_cases.append((model, dataloader))\n    return test_cases\n"}
{"problem_id": "pytorch_21", "library": "pytorch", "code_problem": "You are tasked with implementing a training routine for a neural network using PyTorch. The main function, `trainBP`, is designed to train a Backpropagation Neural Network (BPNN) using a series of Restricted Boltzmann Machines (RBMs) as feature extractors. The training process involves iterating over a dataset, performing forward passes through the network, calculating the loss, and updating the model parameters using stochastic gradient descent.\n\nFunction signature:\n```python\ndef trainBP(trainloader, BPNN, rbm_layers, epochs):\n```\n\nConstant used in the main code:\n- The learning rate is set to `0.005`, and the momentum for the optimizer is set to `0.7`.\n\n\nInput format:\n- `trainloader`: A PyTorch DataLoader object that provides batches of training data and labels.\n- `BPNN`: An instance of a neural network model that will be trained.\n- `rbm_layers`: A list of RBM layer instances used for feature extraction.\n- `epochs`: An integer representing the number of epochs to train the model.\n\nOutput format:\n- The function returns a float representing the final loss value after training.\n\n**Input:**\n```python\n# Test case input\nimport torch\nfrom torch.utils.data import DataLoader, TensorDataset\n\n# Create a simple dataset\nx_data = torch.tensor([[0.5, 0.2, 0.1], [0.1, 0.4, 0.6], [0.9, 0.8, 0.7], [0.3, 0.5, 0.2]])\ny_data = torch.tensor([0, 1, 1, 0])  # Binary classification\ntrain_dataset = TensorDataset(x_data, y_data)\ntrainloader = DataLoader(train_dataset, batch_size=2, shuffle=True)\n\n# Define RBM layers\nclass SimpleRBMLayer(torch.nn.Module):\n    def __init__(self, in_features, out_features):\n        super(SimpleRBMLayer, self).__init__()\n        self.linear = torch.nn.Linear(in_features, out_features)\n\n    def forward(self, v):\n        return self.linear(v), torch.sigmoid(self.linear(v))\n\nrbm_layers = [SimpleRBMLayer(3, 2)]  # One RBM layer\n\n# Define a simple BPNN model\nclass SimpleBPNN(torch.nn.Module):\n    def __init__(self, input_size, num_classes):\n        super(SimpleBPNN, self).__init__()\n        self.fc = torch.nn.Linear(input_size, num_classes)\n\n    def forward(self, x):\n        return self.fc(x)\n\nBPNN = SimpleBPNN(2, 2)  # Output size matches number of classes\n\n# Number of epochs\nepochs = 5\n```\n\n**Output:**\n```python\n# Expected output after training\nfinal_loss = trainBP(trainloader, BPNN, rbm_layers, epochs)\n# 0.6877685785293579\n```", "ground_truth_code": "import torch\nfrom torch.autograd import Variable\n\n\ndef forward(input_data, rbm_layers, BPNN):\n    v = input_data\n    for layer in rbm_layers:\n        v = v.view((v.shape[0], -1)).float()\n        p_v, v = layer.forward(v)\n    out = BPNN(p_v)\n    return out\n\n# main code\ndef trainBP(trainloader, BPNN, rbm_layers, epochs):\n    optimizer = torch.optim.SGD(BPNN.parameters(), lr=0.005, momentum=0.7)\n    loss_func = torch.nn.CrossEntropyLoss()\n    final_loss = None\n    for epoch in range(epochs):\n        for step, (x, y) in enumerate(trainloader):\n            bx, by = Variable(x), Variable(y)\n            out = forward(bx, rbm_layers, BPNN)\n            loss = loss_func(out, by)\n            optimizer.zero_grad()\n            loss.backward()\n            optimizer.step()\n            final_loss = loss.item()\n\n    return final_loss", "test_script": "import torch\nfrom torch.utils.data import DataLoader, TensorDataset\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate random training data\n        batch_size = random.randint(8, 64)  # Random batch size\n        input_dim = random.randint(10, 100)  # Random input dimension\n        num_classes = random.randint(2, 10)  # Random number of output classes\n        num_samples = batch_size * 5  # Total dataset size\n\n        x_data = torch.randn(num_samples, input_dim)\n        y_data = torch.randint(0, num_classes, (num_samples,))\n        train_dataset = TensorDataset(x_data, y_data)\n        trainloader = DataLoader(train_dataset, batch_size=batch_size, shuffle=True)\n\n        # Define random RBM layers\n        class SimpleRBMLayer(torch.nn.Module):\n            def __init__(self, in_features, out_features):\n                super(SimpleRBMLayer, self).__init__()\n                self.linear = torch.nn.Linear(in_features, out_features)\n\n            def forward(self, v):\n                return self.linear(v), torch.sigmoid(self.linear(v))\n\n        # rbm_layers = [SimpleRBMLayer(input_dim, random.randint(10, 50)) for _ in range(random.randint(1, 3))]\n        rbm_layers = []\n        prev_dim = input_dim  # Start with original input dimension\n        for _ in range(random.randint(1, 3)):  # Create 1 to 3 RBM layers\n            out_dim = random.randint(10, 50)  # Choose a random output size\n            rbm_layers.append(SimpleRBMLayer(prev_dim, out_dim))\n            prev_dim = out_dim  # Update previous dimension for next layer\n\n        # Define a simple BPNN model\n        class SimpleBPNN(torch.nn.Module):\n            def __init__(self, input_size, num_classes):\n                super(SimpleBPNN, self).__init__()\n                self.fc = torch.nn.Linear(input_size, num_classes)\n\n            def forward(self, x):\n                return self.fc(x)\n\n        final_input_size = rbm_layers[-1].linear.out_features if rbm_layers else input_dim\n        BPNN = SimpleBPNN(final_input_size, num_classes)\n\n        # Random number of epochs\n        epochs = random.randint(5, 10)\n\n        test_cases.append((trainloader, BPNN, rbm_layers, epochs))\n\n    return test_cases"}
{"problem_id": "pytorch_22", "library": "pytorch", "code_problem": "You are tasked with implementing a function that generates session embeddings from a sequence of hidden states. The function will utilize various operations such as summation, activation functions, and matrix multiplication to compute the final session embedding.\n\nFunction signature:\n```python\ndef generate_sess_emb(seq_h: torch.Tensor, seq_len: torch.Tensor, mask: torch.Tensor, glu1: torch.nn.Module, w_2: torch.Tensor, glu2: torch.nn.Module) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant `1` is used in the `unsqueeze` and `repeat` methods to manipulate tensor dimensions.\n\nInput format:\n- `seq_h`: A tensor of shape (batch_size, sequence_length, hidden_size).\n- `seq_len`: A tensor of shape (batch_size) containing the lengths of each sequence.\n- `mask`: A tensor of shape (batch_size, sequence_length) used for masking.\n- `glu1`: A Gated Linear Unit layer (torch.nn.Module).\n- `w_2`: A tensor of shape (hidden_size, output_size) for the final transformation.\n- `glu2`: Another Gated Linear Unit layer (torch.nn.Module).\n\nOutput format:\n- The function returns a tensor of shape (batch_size, output_size) representing the session embeddings.\n\n**Input:**\n```python\nimport torch\n\n# Test case input\nseq_h = torch.tensor([[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]], \n                       [[0.7, 0.8], [0.9, 1.0], [1.1, 1.2]]])  # Shape: (2, 3, 2)\nseq_len = torch.tensor([[3], [3]], dtype=torch.float)  # Shape: (2, 1)\nmask = torch.tensor([[1, 1, 1], [1, 1, 1]])  # Shape: (2, 3)\nglu1 = torch.nn.Linear(2, 2)  # Input dimension = 2, Output dimension = 2\nw_2 = torch.tensor([[0.5], [0.5]])  # Shape: (2, 1)\nglu2 = torch.nn.Linear(2, 2)  # Input dimension = 2, Output dimension = 2\n\n# Call the function\noutput = generate_sess_emb(seq_h, seq_len, mask, glu1, w_2, glu2)\n```\n\n**Output:**\n```python\ntensor([[0.3711, 0.4942],\n        [1.0927, 1.2139]], grad_fn=<SumBackward1>)\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef generate_sess_emb(seq_h, seq_len, mask, glu1, w_2, glu2):\n    hs = torch.div(torch.sum(seq_h, 1), seq_len)\n    len = seq_h.shape[1]\n    hs = hs.unsqueeze(-2).repeat(1, len, 1)\n    nh = seq_h\n    nh = torch.tanh(nh)\n    nh = torch.sigmoid(glu1(nh) + glu2(hs))\n    beta = torch.matmul(nh, w_2)\n    mask = mask.float().unsqueeze(-1)\n    sess = beta * mask\n    sess_emb = torch.sum(sess * seq_h, 1)\n    return sess_emb", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 32)  # Random batch size between 1 and 32\n        seq_len = random.randint(5, 50)  # Random sequence length between 5 and 50\n        emb_dim = random.randint(16, 128)  # Random embedding dimension between 16 and 128\n\n        seq_h = torch.rand(batch_size, seq_len, emb_dim)  # Random tensor for seq_h\n        seq_len_tensor = torch.randint(1, seq_len + 1, (batch_size, 1), dtype=torch.float)  # seq_len tensor\n        mask = torch.randint(0, 2, (batch_size, seq_len))  # Random binary mask\n\n        glu1 = torch.nn.Linear(emb_dim, emb_dim)  # Random linear transformation for glu1\n        w_2 = torch.rand(emb_dim, 1)  # Random weight matrix w_2\n        glu2 = torch.nn.Linear(emb_dim, emb_dim)  # Random linear transformation for glu2\n\n        test_cases.append((seq_h, seq_len_tensor, mask, glu1, w_2, glu2))\n\n    return test_cases"}
{"problem_id": "pytorch_23", "library": "pytorch", "code_problem": "```python\ndef quat_to_angle_axis(q):\n```\n\nThe function `quat_to_angle_axis` takes a tensor `q` representing a batch of quaternions and converts them into angle-axis representation. The quaternions are expected to be in the format `[qx, qy, qz, qw]`, where `qx`, `qy`, and `qz` are the vector components and `qw` is the scalar component.\n\n### Input and Output Format:\n- **Input**: A tensor `q` of shape `(N, 4)` where `N` is the number of quaternions.\n- **Output**: A tuple containing:\n  - A tensor of angles of shape `(N,)`.\n  - A tensor of axes of shape `(N, 3)`.\n\nInput: \n```python\ntorch.tensor([[0.0, 0.0, 0.0, 1.0],  # Identity quaternion\n               [0.0, 1.0, 0.0, 0.0],  # 180 degrees around x-axis\n               [0.0, 0.0, 1.0, 0.0]]) # 180 degrees around y-axis\n```\n\nOutput: \n```python\n(\n   tensor([ 0.0000, -3.1416, -3.1416]), \n   tensor([[0., 0., 1.],\n        [0., 1., 0.],\n        [0., 0., 1.]])\n)\n```", "ground_truth_code": "import torch\n\n# main code\ndef quat_to_angle_axis(q):\n    min_theta = 1e-5\n    qx, qy, qz, qw = 0, 1, 2, 3\n    sin_theta = torch.sqrt(1 - q[..., qw] ** 2)\n    angle = 2 * torch.acos(q[..., qw])\n    angle = torch.atan2(torch.sin(angle), torch.cos(angle))\n    sin_theta_expand = sin_theta.unsqueeze(-1)\n    axis = q[..., qx:qw] / sin_theta_expand\n    mask = sin_theta > min_theta\n    default_axis = torch.zeros_like(axis)\n    default_axis[..., -1] = 1\n    angle = torch.where(mask, angle, torch.zeros_like(angle))\n    axis = torch.where(mask.unsqueeze(-1), axis, default_axis)\n\n    return angle, axis", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a random quaternion\n        q = torch.randn(4)  # Random values\n        q = q / torch.norm(q)  # Normalize to make it a valid quaternion\n\n        test_cases.append(q)  # Convert to list for storage\n\n    return test_cases"}
{"problem_id": "pytorch_24", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes data through a model and retrieves the corresponding labels. The function signature is as follows:\n\n```python\ndef get_model_features(loader_name, model, arg, data_loader):\n```\n\n### Constants Used:\n- The constant `torch.device(\"cpu\")` is used to specify that the model and data should be processed on the CPU.\n\n### Input and Output Format:\n- **Input**: \n  - `loader_name`: A list of strings representing the names of the data loaders.\n  - `model`: The model to be used for inference.\n  - `arg`: An object containing various arguments, including feature combination settings and model parameters.\n  - `data_loader`: A dictionary where keys are loader names and values are data loaders that yield batches of data, labels, and indices.\n\n- **Output**: \n  - A tuple containing:\n    - `output_list`: A tensor of model outputs after processing all batches.\n    - `rtn_labels`: A tensor of labels corresponding to the processed data.\n\n**Input:**\n```python\nloader_name = ['loader_1']\nmodel = DummyModel()  # Assuming DummyModel is defined as in the input generation script\narg = SimpleNamespace(\n    train_feeder_args={'data_path': 'ntu_sample_path'},\n    feature_combo='joint+angular',\n    to_add_onehot=True,\n    model_args={'num_point': 25, 'num_person': 2}\n)\ndummy_data = torch.randn(2, 10, 50, 25, 2)  # Batch size of 2\ndummy_label = torch.randint(0, 10, (2,))\ndummy_index = torch.arange(2)\ndata_loader = {loader_name[0]: [(dummy_data, dummy_label, dummy_index)]}\n```\n\n**Output:**\n```python\noutput_list, rtn_labels = get_model_features(loader_name, model, arg, data_loader)\n```\n", "ground_truth_code": "import torch\n\ndef get_feature_combo_data(data, arg):\n    if 'ntu' in arg.train_feeder_args['data_path']:\n        datatype = 'ntu'\n    elif 'kinetics' in arg.train_feeder_args['data_path']:\n        datatype = 'kinetics'\n    else:\n        return data\n\n    if datatype == 'ntu':\n        if arg.feature_combo == 'angular':\n            data = data[:, 6:, :, :, :]\n        elif arg.feature_combo == 'joint':\n            data = data[:, :3, :, :, :]\n        elif arg.feature_combo == 'bone':\n            data = data[:, 3:6, :, :, :]\n        elif arg.feature_combo == 'joint+angular':\n            data = torch.cat((data[:, :3, :, :, :], data[:, 6:, :, :, :]), dim=1)\n        elif arg.feature_combo == 'bone+angular':\n            data = torch.cat((data[:, 3:6, :, :, :], data[:, 6:, :, :, :]), dim=1)\n        elif arg.feature_combo == 'no_head':\n            data = data[:, :15, :, :, :]\n        elif arg.feature_combo == 'joint+bone':\n            data = data[:, :6, :, :, :]\n        elif arg.feature_combo == 'local_bone_angle':\n            data = torch.cat((data[:, :6, :, :, :], data[:, 6:7, :, :, :]), dim=1)\n        elif arg.feature_combo == 'central_angle':\n            data = torch.cat((data[:, :6, :, :, :], data[:, 7:9, :, :, :]), dim=1)\n\n    elif datatype == 'kinetics':\n        if arg.feature_combo == 'joint':\n            data = torch.cat((data[:, :2, :, :, :], data[:, -1:, :, :, :]), dim=1)\n        elif arg.feature_combo == 'bone':\n            data = torch.cat((data[:, 2:4, :, :, :], data[:, -1:, :, :, :]), dim=1)\n        elif arg.feature_combo == 'joint+angle':\n            data = torch.cat((data[:, :2, :, :, :], data[:, 4:, :, :, :]), dim=1)\n        elif arg.feature_combo == 'bone+angle':\n            data = torch.cat((data[:, 2:4, :, :, :], data[:, 4:, :, :, :]), dim=1)\n\n    return data\n\n# main code\ndef get_model_features(loader_name, model, arg, data_loader):\n    rtn_labels = []\n\n    with torch.no_grad():\n        model.to_fc_last = False\n        model = model.to(torch.device(\"cpu\"))\n        model.eval()\n        output_list = []\n\n        for ln in loader_name:\n            for batch_idx, (data, label, index) in enumerate(data_loader[ln]):\n                rtn_labels.append(label)\n                data = data.float().to(torch.device(\"cpu\"))\n                data = get_feature_combo_data(data, arg)\n\n                if arg.to_add_onehot:\n                    one_hot = torch.eye(arg.model_args['num_point']).unsqueeze(1).unsqueeze(-1).unsqueeze(0)\n                    one_hot = one_hot.repeat(data.shape[0], 1, data.shape[2], 1, arg.model_args['num_person'])\n                    data = torch.cat((data, one_hot), dim=1)\n\n                output = model(data, set_to_fc_last=False)\n                output_list.append(output.cpu())\n\n    output_list = torch.cat(output_list, dim=0)\n    rtn_labels = torch.cat(rtn_labels, dim=0)\n\n    return output_list, rtn_labels", "test_script": "import torch\nimport random\nfrom types import SimpleNamespace\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        # Generate a random loader_name list\n        loader_name = [f'loader_{random.randint(1, 5)}']\n\n        # Simulate model with a dummy forward method\n        class DummyModel(torch.nn.Module):\n            def forward(self, x, set_to_fc_last=False):\n                return torch.randn(x.shape[0], 10)  # Example output shape\n\n        model = DummyModel()\n\n        # Generate random argument namespace\n        feature_combos = ['angular', 'joint', 'bone', 'joint+angular', 'bone+angular', 'no_head', 'joint+bone',\n                          'local_bone_angle', 'central_angle',\n                          'joint+angle', 'bone+angle']\n        data_paths = ['ntu_sample_path', 'kinetics_sample_path', 'other_path']\n        arg = SimpleNamespace(\n            train_feeder_args={'data_path': random.choice(data_paths)},\n            feature_combo=random.choice(feature_combos),\n            to_add_onehot=random.choice([True, False]),\n            model_args={'num_point': 25, 'num_person': 2}\n        )\n\n        # Generate random data loader\n        batch_size = random.randint(1, 5)\n        channels, frames, height, width = 10, 50, 25, 2  # Example shape\n        dummy_data = torch.randn(batch_size, channels, frames, height, width)\n        dummy_label = torch.randint(0, 10, (batch_size,))\n        dummy_index = torch.arange(batch_size)\n\n        data_loader = {loader_name[0]: [(dummy_data, dummy_label, dummy_index)]}\n\n        test_cases.append((loader_name, model, arg, data_loader))\n\n    return test_cases"}
{"problem_id": "pytorch_25", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the negative log-likelihood loss for a set of observations in a probabilistic model. The function will take into account a mask that can be applied to the loss values, allowing for selective computation based on the provided mask.\n\nFunction signature:\n```python\ndef likelihood_loss(y: torch.Tensor, n: torch.Tensor, p: torch.Tensor, y_mask: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the mathematical constant `e`, which is implicitly used in the logarithmic calculations.\n\nInput format:\n- The function expects four input tensors: `y`, `n`, `p`, and `y_mask`, all of which should be of compatible shapes.\n\nOutput format:\n- The function returns a single tensor representing the total negative log-likelihood loss.\n\nInput:\n```python\ny = torch.tensor([10, 5, 20])\nn = torch.tensor([15, 10, 25])\np = torch.tensor([0.8, 0.6, 0.9])\ny_mask = torch.tensor([1.0, 1.0, 1.0])\n```\n\nOutput:\n```python\noutput = likelihood_loss(y, n, p, y_mask)\n# tensor(27.5290)\n```", "ground_truth_code": "import torch\n\n# main code\ndef likelihood_loss(y, n, p, y_mask):\n    nll = torch.lgamma(n) + torch.lgamma(y + 1) - torch.lgamma(n + y) - n * torch.log(p) - y * torch.log(1 - p)\n    if y_mask is not None:\n        nll = nll * y_mask\n    return torch.sum(nll)", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a batch size\n        batch_size = random.randint(1, 100)  # Random batch size between 1 and 100\n\n        # Generate y and n as integer tensors with positive values\n        y = torch.randint(0, 100, (batch_size,))  # Random count values for y\n        n = torch.randint(1, 100, (batch_size,))  # n should be at least 1\n\n        # Generate p as a tensor with values in range (0,1)\n        p = torch.rand(batch_size) * 0.99 + 0.01  # Avoid exactly 0 or 1\n\n        # Generate y_mask with probability of being None\n        y_mask = None if random.random() < 0.2 else torch.randint(0, 2, (batch_size,)).float()\n\n        test_cases.append((y, n, p, y_mask))\n\n    return test_cases"}
{"problem_id": "pytorch_26", "library": "pytorch", "code_problem": "You are tasked with implementing a function that applies a stochastic masking operation to a given tensor during training. The function should randomly select elements from the input tensor based on a specified probability and return a modified version of the tensor. The function signature is as follows:\n\n```python\ndef forward(x: torch.Tensor, p: float, training: bool) -> torch.Tensor:\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used in the expression `(1 - p)` to determine the threshold for masking.\n\n### Input and Output Format:\n- **Input**:\n  - `x`: A PyTorch tensor of arbitrary shape.\n  - `p`: A float value representing the probability of retaining an element (0 < p < 1).\n  - `training`: A boolean indicating whether the function is in training mode.\n\n- **Output**:\n  - A PyTorch tensor of the same shape as `x`, modified according to the stochastic masking operation if `training` is `True`, or the original tensor `x` if `training` is `False`.\n\nInput:\n```python\nx = torch.tensor([[0.5, -1.2, 3.0], [4.5, 2.1, -0.3]])\np = 0.5\ntraining = True\n```\n\nOutput:\n```python\ntensor([[ 4.5000, -1.2000,  3.0000],\n        [ 0.5000,  2.1000, -0.3000]])\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef forward(x, p, training):\n    if training:\n        mask = torch.rand_like(x) > (1 - p)\n        random_offsets = torch.randint(x.size(0), x.shape, dtype=torch.long) * x.size(1) * mask.to(dtype=torch.long)\n        indices = torch.arange(x.numel(), dtype=torch.long) + random_offsets.view(-1)\n        indices %= x.numel()\n        return x.flatten()[indices].view_as(x)\n    return x", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        feature_dim = random.randint(1, 50)\n        x = torch.randn(batch_size, feature_dim)\n        p = round(random.uniform(0.0, 1.0), 2)\n        training = random.choice([True, False])\n\n        test_cases.append((x, p, training))\n\n    return test_cases"}
{"problem_id": "pytorch_27", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes a finer Lipschitz bound for a given image based on specified angles. The function will analyze the image to determine the maximum and minimum values in a neighborhood around each pixel, and then calculate the distance from the center of the image to points defined by the angles provided. The function will return the maximum differences in the neighborhood and the distance matrix.\n\nFunction signature:\n```python\ndef get_finer_lipschitz_bound(img: torch.Tensor, anglel: float, angler: float) -> tuple:\n```\n\nConstants used in the main code:\n- The angles `anglel` and `angler` are converted from degrees to radians using the `math.radians` function.\n\nInput format:\n- `img`: A 3D tensor of shape (c, h, w) representing the image.\n- `anglel`: A float representing the left angle in degrees.\n- `angler`: A float representing the right angle in degrees.\n\nOutput format:\n- A tuple containing:\n  - `None`\n  - A 3D tensor representing the maximum differences in the neighborhood.\n  - A 2D tensor representing the distance matrix from the center of the image.\n\n**Input:**\n```python\nimg = torch.tensor([[[0.1, 0.2, 0.3],\n                      [0.4, 0.5, 0.6],\n                      [0.7, 0.8, 0.9]]])  # Shape: (1, 3, 3)\n\nanglel = 30.0\nangler = 60.0\n```\n\n**Output:**\n```python\n# The output will vary due to the random nature of the input image.\n# Here is a hypothetical output based on the input provided.\n(\n   None,\n   tensor([[[0.4000, 0.4000, 0.4000],\n            [0.4000, 0.4000, 0.4000],\n            [0.4000, 0.4000, 0.4000]]]),\n   tensor([[1.4142, 1.0000, 1.4142],\n        [1.0000, 0.0000, 1.0000],\n        [1.4142, 1.0000, 1.4142]])\n)\n```", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef get_finer_lipschitz_bound(img, anglel, angler):\n    c, h, w = img.shape\n    radl, radr = math.radians(anglel), math.radians(angler)\n    cy, cx = (h - 1) / 2.0, (w - 1) / 2.0\n    map_maxv = img.clone().detach()\n    map_maxv[:, :-1, :] = torch.max(map_maxv[:, :-1, :], img[:, 1:, :])\n    map_maxv[:, :, :-1] = torch.max(map_maxv[:, :, :-1], img[:, :, 1:])\n    map_maxv[:, :-1, :-1] = torch.max(map_maxv[:, :-1, :-1], img[:, 1:, 1:])\n    map_minv = img.clone().detach()\n    map_minv[:, :-1, :] = torch.min(map_minv[:, :-1, :], img[:, 1:, :])\n    map_minv[:, :, :-1] = torch.min(map_minv[:, :, :-1], img[:, :, 1:])\n    map_minv[:, :-1, :-1] = torch.min(map_minv[:, :-1, :-1], img[:, 1:, 1:])\n    map_maxd = map_maxv - map_minv\n    map_nb_maxd = map_maxd.clone().detach()\n    for dy in [-1, 0, 1]:\n        for dx in [-1, 0, 1]:\n            if dy == 0 and dx == 0:\n                continue\n            shifted = torch.roll(map_maxd, shifts=(dy, dx), dims=(1, 2))\n            map_nb_maxd = torch.max(map_nb_maxd, shifted)\n    rows = torch.linspace(0.0, h - 1, steps=h)\n    cols = torch.linspace(0.0, w - 1, steps=w)\n    rows_mat = rows.unsqueeze(1).expand(-1, w)\n    cols_mat = cols.expand(h, -1)\n    dist_mat = torch.sqrt((rows_mat - cy) ** 2 + (cols_mat - cx) ** 2)\n    alpha_mat = torch.atan2(rows_mat - cy, cols_mat - cx)\n    betal_mat, betar_mat = alpha_mat + radl, alpha_mat + radr\n    nyl_mat = torch.clamp(torch.floor(dist_mat * torch.sin(betal_mat) + cy).long(), 0, h - 1)\n    nxl_mat = torch.clamp(torch.floor(dist_mat * torch.cos(betal_mat) + cx).long(), 0, w - 1)\n    nyr_mat = torch.clamp(torch.floor(dist_mat * torch.sin(betar_mat) + cy).long(), 0, h - 1)\n    nxr_mat = torch.clamp(torch.floor(dist_mat * torch.cos(betar_mat) + cx).long(), 0, w - 1)\n    nyl_cell, nxl_cell = torch.flatten(nyl_mat), torch.flatten(nxl_mat)\n    nyr_cell, nxr_cell = torch.flatten(nyr_mat), torch.flatten(nxr_mat)\n    maxd_pl_mat = torch.gather(\n        torch.index_select(map_nb_maxd, dim=1, index=nyl_cell),\n        dim=2, index=nxl_cell.repeat(c, 1).unsqueeze(2)\n    ).reshape(c, h, w)\n    maxd_pr_mat = torch.gather(\n        torch.index_select(map_nb_maxd, dim=1, index=nyr_cell),\n        dim=2, index=nxr_cell.repeat(c, 1).unsqueeze(2)\n    ).reshape(c, h, w)\n\n    return None, torch.max(maxd_pl_mat, maxd_pr_mat), dist_mat\n", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        c = random.choice([1, 3])\n        h = random.randint(5, 256)\n        w = random.randint(5, 256)\n\n        img = torch.rand((c, h, w))\n        anglel = random.uniform(-180, 180)\n        angler = random.uniform(-180, 180)\n\n        if anglel > angler:\n            anglel, angler = angler, anglel\n\n        test_cases.append((img, anglel, angler))\n\n    return test_cases"}
{"problem_id": "pytorch_28", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a sampling operation based on a given probability matrix and an initial status matrix. The function will utilize a Metropolis sampling technique to update the status of a set of chains over a specified number of transfer times.\n\nFunction signature:\n```python\ndef metro_sampling(probs: torch.Tensor, start_status: torch.Tensor, max_transfer_time: int) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant `5` is used to multiply the `max_transfer_time` to determine the number of iterations for the sampling process.\n\nInput format:\n- `probs`: A 2D tensor of shape (num_node, num_chain) containing probabilities.\n- `start_status`: A 2D tensor of shape (num_node, num_chain) containing the initial boolean status of the chains.\n- `max_transfer_time`: An integer representing the maximum number of transfer times.\n\nOutput format:\n- A 2D tensor of shape (num_node, num_chain) containing the final sampled states as float values.\n\nInput:\n```python\nprobs = torch.tensor([[0.1, 0.9],\n                      [0.8, 0.2],\n                      [0.5, 0.5]])\nstart_status = torch.tensor([[1, 0],\n                             [0, 1],\n                             [1, 1]], dtype=torch.int32)\nmax_transfer_time = 3\n```\n\nOutput:\n```python\ntensor([[0., 0.],\n        [1., 0.],\n        [0., 1.]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef metro_sampling(probs, start_status, max_transfer_time):\n    num_node = len(probs)\n    num_chain = start_status.shape[1]\n    index_col = torch.arange(num_chain)\n    probs = probs.detach()\n    samples = start_status.bool()\n    count = 0\n\n    for t in range(max_transfer_time * 5):\n        if count >= num_chain * max_transfer_time:\n            break\n        index_row = torch.randint(low=0, high=num_node, size=[num_chain])\n        chosen_probs_base = probs[index_row, index_col]\n        chosen_value = samples[index_row, index_col]\n        chosen_probs = torch.where(chosen_value, chosen_probs_base, 1 - chosen_probs_base)\n        accept_rate = (1 - chosen_probs) / chosen_probs\n        r = torch.rand(num_chain)\n        is_accept = r < accept_rate\n        samples[index_row, index_col] = torch.where(is_accept, ~chosen_value, chosen_value)\n        count += is_accept.sum().item()\n\n    return samples.float()\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_node = random.randint(2, 100)\n        num_chain = random.randint(1, 50)\n        max_transfer_time = random.randint(1, 20)\n        probs = torch.rand((num_node, num_chain))\n        start_status = torch.randint(0, 2, (num_node, num_chain), dtype=torch.int32)\n\n        test_cases.append((probs, start_status, max_transfer_time))\n\n    return test_cases"}
{"problem_id": "pytorch_29", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a batch of images using affine transformations. The function will take an input tensor representing images and apply a series of transformations defined by affine matrices. The output will consist of transformed images, a tensor representing the output grid, and the inverse of the affine transformations.\n\nFunction signature:\n```python\ndef forward(x: torch.Tensor, init_affine: torch.Tensor, inv_aff: Callable[[torch.Tensor], torch.Tensor]) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor]:\n```\n\n### Constants:\n- The constant used in the main code is `3`, which represents the number of color channels in the input images.\n\n### Input and Output Format:\n- **Input**:\n  - `x`: A tensor of shape `(b, 3, ho, wo)` representing a batch of images.\n  - `init_affine`: A tensor of shape `(b, n, 2, 3)` representing the initial affine transformation matrices.\n  - `inv_aff`: A callable function that takes a tensor of affine matrices and returns their inverses.\n\n- **Output**:\n  - A tuple containing:\n    - `x`: A tensor of shape `(b, n, 3, ho, wo)` representing the transformed images.\n    - `o`: A tensor of shape `(b, n, 1, ho, wo)` representing the output grid.\n    - `z`: A tensor of shape `(b, n, 2, 3)` representing the affine matrices.\n    - `inv_z`: A tensor of shape `(b, n, 2, 3)` representing the inverse affine matrices.\n\nInput:\n```python\nx = torch.randn(2, 3, 32, 32)  # Batch size 2, 3 channels, 32x32 image\ninit_affine = torch.randn(2, 3, 2, 3)  # 2 batches, 3 transformations\ndef inv_aff(affine_params):\n    return -affine_params\n```\n\nOutput:\n```python\nx, o, z, inv_z = forward(x, init_affine, inv_aff)\n``` \n", "ground_truth_code": "import torch.nn.functional as F\nimport torch\n\n# main code\ndef forward(x, init_affine, inv_aff):\n    (b, _, ho, wo) = list(x.size())\n    (_, n, _, _) = list(init_affine.size())\n    o = torch.ones(b, n, ho, wo)\n    z = init_affine.view(-1, 2, 3)\n    target_size = list(x.size())\n    target_size[0] = target_size[0] * n\n    grid = F.affine_grid(z, target_size, align_corners=False)\n    x = x.unsqueeze(dim=1).expand(-1, n, -1, -1, -1)\n    x = x.reshape(-1, 3, ho, wo)\n    x = F.grid_sample(x, grid, align_corners=False)\n    o = o.view(-1, 1, ho, wo)\n    grid = F.affine_grid(z, o.size(), align_corners=False)\n    o = F.grid_sample(o, grid, align_corners=False)\n    inv_z = inv_aff(z)\n    x = x.view(-1, n, 3, ho, wo)\n    o = o.view(-1, n, 1, ho, wo)\n    z = z.view(-1, n, 2, 3)\n    inv_z = inv_z.view(-1, n, 2, 3)\n    return (x, o, z, inv_z)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        b = random.randint(1, 8)  # Batch size\n        n = random.randint(1, 5)  # Number of transformations\n        ho = random.randint(16, 128)  # Height\n        wo = random.randint(16, 128)  # Width\n\n        x = torch.randn(b, 3, ho, wo)\n        init_affine = torch.randn(b, n, 2, 3)\n\n        def inv_aff(affine_params):\n\n            return -affine_params\n\n        test_cases.append((x, init_affine, inv_aff))\n\n    return test_cases"}
{"problem_id": "pytorch_30", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs edge-guided sampling from input images based on edge information and orientation angles. The function will extract samples from the input data using the locations of significant edges and their corresponding angles, allowing for a more focused sampling strategy that leverages the structure of the image.\n\nFunction signature:\n```python\ndef edgeGuidedSampling(inputs: torch.Tensor, targets: torch.Tensor, edges_img: torch.Tensor, thetas_img: torch.Tensor, masks: torch.Tensor, h: int, w: int) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, torch.Tensor, int]:\n```\n\nConstants used in the main code:\n- A constant value of `0.1` is used to determine the threshold for significant edges in the `edges_img`.\n\nInput format:\n- `inputs`: A tensor of shape (N,) representing the input data.\n- `targets`: A tensor of shape (N,) representing the target data.\n- `edges_img`: A tensor of shape (H, W) representing the edge information of the image.\n- `thetas_img`: A tensor of shape (H, W) representing the orientation angles corresponding to the edges.\n- `masks`: A tensor of shape (N,) representing the masks for the input data.\n- `h`: An integer representing the height of the image.\n- `w`: An integer representing the width of the image.\n\nOutput format:\n- Returns a tuple containing:\n  - `inputs_A`: A tensor containing the sampled input values corresponding to indices A.\n  - `inputs_B`: A tensor containing the sampled input values corresponding to indices B.\n  - `targets_A`: A tensor containing the sampled target values corresponding to indices A.\n  - `targets_B`: A tensor containing the sampled target values corresponding to indices B.\n  - `masks_A`: A tensor containing the sampled mask values corresponding to indices A.\n  - `masks_B`: A tensor containing the sampled mask values corresponding to indices B.\n  - `sample_num`: An integer representing the number of samples taken.\n\n**Input:**\n```python\ninputs = torch.tensor([0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0])\ntargets = torch.tensor([0, 1, 2, 3, 4, 5, 6, 7, 8, 9])\nedges_img = torch.tensor([0.0, 0.0, 0.0, 0.0, 0.5, 0.0, 0.0, 0.0, 0.0, 0.0])\nthetas_img = torch.tensor([0.0, 0.0, 0.0, 0.0, 1.57, 0.0, 0.0, 0.0, 0.0, 0.0])\nmasks = torch.tensor([0, 0, 0, 0, 1, 0, 0, 0, 0, 0])\nh = 2\nw = 5\n```\n\n**Output:**\n```python\n(tensor([0.5000, 0.5000, 1.0000]), tensor([0.5000, 1.0000, 1.0000]), tensor([4, 4, 9]), tensor([4, 9, 9]), tensor([1, 1, 0]), tensor([1, 0, 0]), 1)\n```", "ground_truth_code": "import torch\n\n\ndef ind2sub(idx, cols):\n    r = idx // cols\n    c = idx - r * cols\n    return (r, c)\n\n\ndef sub2ind(r, c, cols):\n    idx = r * cols + c\n    return idx\n\n\n# main code\ndef edgeGuidedSampling(inputs, targets, edges_img, thetas_img, masks, h, w):\n    edges_max = edges_img.max()\n    edges_mask = edges_img.ge(edges_max * 0.1)\n    edges_loc = edges_mask.nonzero()\n    inputs_edge = torch.masked_select(inputs, edges_mask)\n\n    thetas_edge = torch.masked_select(thetas_img, edges_mask)\n    minlen = inputs_edge.size()[0]\n    sample_num = minlen\n\n    index_anchors = torch.randint(0, minlen, (sample_num,), dtype=torch.long)\n\n    theta_anchors = torch.gather(thetas_edge, 0, index_anchors)\n\n    row_anchors, col_anchors = ind2sub(edges_loc[index_anchors].squeeze(1), w)\n\n    distance_matrix = torch.randint(2, 31, (4, sample_num))\n    pos_or_neg = torch.ones(4, sample_num)\n    pos_or_neg[:2, :] = -pos_or_neg[:2, :]\n    distance_matrix = distance_matrix.float() * pos_or_neg\n\n    col = col_anchors.unsqueeze(0).expand(4, sample_num).long() + torch.round(\n        distance_matrix.double() * torch.cos(theta_anchors).unsqueeze(0)).long()\n    row = row_anchors.unsqueeze(0).expand(4, sample_num).long() + torch.round(\n        distance_matrix.double() * torch.sin(theta_anchors).unsqueeze(0)).long()\n\n    col[col < 0] = 0\n    col[col > w - 1] = w - 1\n    row[row < 0] = 0\n    row[row > h - 1] = h - 1\n\n    a = sub2ind(row[0, :], col[0, :], w)\n    b = sub2ind(row[1, :], col[1, :], w)\n    c = sub2ind(row[2, :], col[2, :], w)\n    d = sub2ind(row[3, :], col[3, :], w)\n\n    A = torch.cat((a, b, c), 0)\n    B = torch.cat((b, c, d), 0)\n\n    inputs_A = torch.gather(inputs, 0, A.long())\n    inputs_B = torch.gather(inputs, 0, B.long())\n    targets_A = torch.gather(targets, 0, A.long())\n    targets_B = torch.gather(targets, 0, B.long())\n    masks_A = torch.gather(masks, 0, A.long())\n    masks_B = torch.gather(masks, 0, B.long())\n\n    return inputs_A, inputs_B, targets_A, targets_B, masks_A, masks_B, sample_num", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        h = torch.randint(10, 100, (1,)).item()\n        w = torch.randint(10, 100, (1,)).item()\n        size = h * w\n\n\n        inputs = torch.rand(size)\n        targets = torch.randint(0, 10, (size,))\n        edges_img = torch.rand(size)\n        thetas_img = torch.rand(size) * 2 * torch.pi\n        masks = torch.randint(0, 2, (size,))\n\n        test_cases.append((inputs, targets, edges_img, thetas_img, masks, h, w))\n\n    return test_cases"}
{"problem_id": "pytorch_31", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the minimum area of a bounding box that can enclose a set of 2D points representing the vertices of a convex hull. The function will take a tensor of 2D points as input and return the minimum area of the bounding box after rotating the points.\n\nFunction signature:\n```python\ndef forward(hull_points_2d: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `PI_OVER_2`: This constant is defined as `3.1415926 / 2.0`, which represents 90 degrees in radians.\n\nInput format:\n- A tensor `hull_points_2d` of shape (N, 2), where N is the number of points in the convex hull.\n\nOutput format:\n- A tensor representing the minimum area of the bounding box that can enclose the given convex hull points.\n\nInput:\n```python\ntensor([[ 0.5000, -0.5000],\n        [ 1.0000,  0.0000],\n        [ 0.0000,  1.0000],\n        [-0.5000,  0.5000]])\n```\n\nOutput:\n```python\ntensor(1.)\n```", "ground_truth_code": "import torch\n\n\n# main code\ndef forward(hull_points_2d):\n    N = hull_points_2d.shape[0]\n    edges = hull_points_2d[1:N, :].add(-hull_points_2d[0:N - 1, :])\n    edge_angles = torch.atan2(edges[:, 1], edges[:, 0])\n    edge_angles = torch.fmod(edge_angles, 3.1415926 / 2.0)\n    edge_angles = torch.abs(edge_angles)\n\n    a = torch.stack((torch.cos(edge_angles), torch.cos(edge_angles - 3.1415926 / 2.0)), 1)\n    a = torch.unsqueeze(a, 1)\n    b = torch.stack((torch.cos(edge_angles + 3.1415926 / 2.0), torch.cos(edge_angles)), 1)\n    b = torch.unsqueeze(b, 1)\n\n    R_tensor = torch.cat((a, b), 1)\n    hull_points_2d_ = torch.unsqueeze(torch.transpose(hull_points_2d, 0, 1), 0)\n    rot_points = R_tensor.matmul(hull_points_2d_)\n\n    min_x = torch.min(rot_points, 2)[0]\n    max_x = torch.max(rot_points, 2)[0]\n\n    areas = (max_x[:, 0] - min_x[:, 0]).mul(max_x[:, 1] - min_x[:, 1])\n\n    return torch.min(areas)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Generate a random number of points (at least 2 to form an edge)\n        N = random.randint(2, 50)  # Keeping it within a reasonable range\n\n        # Generate random points ensuring shape (N, 2)\n        hull_points_2d = torch.randn(N, 2)  # Random values from normal distribution\n\n        test_cases.append(hull_points_2d)\n\n    return test_cases\n"}
{"problem_id": "pytorch_32", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the log-sum-exponential of two input tensors, `x` and `y`. The function should be able to handle tensors of any shape and return a tensor of the same shape as the input tensors.\n\nFunction signature:\n```python\ndef logsumexp_nx_ny_xy(x, y):\n```\n\nIn the main code, a constant `1e-8` is used to prevent numerical instability during the computation.\n\nInput format:\n- The function takes two input tensors, `x` and `y`, which can be of any shape.\n\nOutput format:\n- The function returns a tensor of the same shape as the input tensors, containing the computed log-sum-exponential values.\n\n```python\nInput: (tensor([[ 0.1234, -1.2345], [ 2.3456,  0.5678]]), tensor([[ 0.5678, -0.1234], [ 1.2345,  0.6789]]))\nOutput: tensor([[1.0632, 0.1612], [2.6302, 1.3180]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef logsumexp_nx_ny_xy(x, y):\n    max_val = torch.maximum(x, y)\n    return max_val + torch.log(torch.exp(x - max_val) + torch.exp(y - max_val) + 1e-8)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly choose dimensions for the tensors\n        dims = random.randint(1, 4)  # Up to 4D tensors\n        shape = tuple(random.randint(1, 10) for _ in range(dims))  # Random shape (1-10 elements per dim)\n\n        # Generate random tensors with the chosen shape\n        x = torch.randn(shape)\n        y = torch.randn(shape)\n\n        test_cases.append((x, y))\n    return test_cases"}
{"problem_id": "pytorch_33", "library": "pytorch", "code_problem": "You are tasked with implementing a function that generates a session embedding from a sequence of items. The function will utilize various neural network components to compute the final embedding based on the input item sequence and associated parameters.\n\nFunction signature:\n```python\ndef generate_session_embedding(item_sequence, sequence_length, mask, glu1_hot, glu2_hot, embedding, weight_hot):\n```\n\nConstants used in the main code:\n- None specified.\n\nInput format:\n- `item_sequence`: A tensor representing the sequence of item indices.\n- `sequence_length`: An integer representing the length of the item sequence.\n- `mask`: A tensor used to indicate valid items in the sequence.\n- `glu1_hot`: A linear transformation function for the first gating mechanism.\n- `glu2_hot`: A linear transformation function for the second gating mechanism.\n- `embedding`: A function that retrieves embeddings for the item indices.\n- `weight_hot`: A tensor used for computing attention weights.\n\nOutput format:\n- The function returns a tensor representing the session embedding for the input item sequence.\n\n**Input:**\n```python\nitem_sequence = torch.tensor([[1, 2, 3, 4, 5], [6, 7, 8, 9, 0]])\nsequence_length = torch.tensor([[5.0], [5.0]])\nmask = torch.tensor([[1, 1, 1, 1, 1], [1, 1, 1, 1, 1]])\nembedding = torch.nn.Embedding(100, 16)  # 100 possible items, 16-dimensional embeddings\nglu1_hot = torch.nn.Linear(16, 16, bias=False)\nglu2_hot = torch.nn.Linear(16, 16, bias=False)\nweight_hot = torch.nn.Parameter(torch.randn(16, 16))\n```\n\n**Output:**\n```python\nsession_embedding = generate_session_embedding(item_sequence, sequence_length, mask, glu1_hot, glu2_hot, embedding, weight_hot)\n```\n\n**Expected Output (example values):**\n```python\ntensor([[ -0.0240,  -1.3051,   2.3919,  -1.6826,  -0.5230,   0.2630,  -1.9644,\n          -0.7987,   0.1303,  -0.3207,   0.0925,  12.2483, -17.5749,  -4.5638,\n          -0.3542,  -0.5577],\n        [  2.7811,   8.5399,   3.6592,   0.5420,  -2.5770,   0.8035,  -0.4671,\n          -1.5444,  -1.3715,   3.8504,   1.3149,   9.5301,   4.1245,  -2.8860,\n          -1.6015,  -0.2811]], grad_fn=<SumBackward1>)\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef generate_session_embedding(item_sequence, sequence_length, mask, glu1_hot, glu2_hot, embedding, weight_hot):\n    item_embeddings = embedding(item_sequence)\n    avg_embedding = torch.sum(item_embeddings, dim=1) / sequence_length\n    seq_length = item_embeddings.shape[1]\n    avg_embedding = avg_embedding.unsqueeze(1).expand(-1, seq_length, -1)\n    transformed_embeddings = torch.tanh(item_embeddings.float())\n    gated_activations = torch.sigmoid(glu1_hot(transformed_embeddings) + glu2_hot(avg_embedding))\n    attention_weights = torch.matmul(gated_activations, weight_hot)\n    mask = mask.float().unsqueeze(-1)\n    weighted_sequence = attention_weights * mask\n    session_embedding = torch.sum(weighted_sequence * item_embeddings, dim=1)\n\n    return session_embedding", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)  # Random batch size between 1 and 10\n        seq_length = random.randint(5, 20)  # Random sequence length between 5 and 20\n        embedding_dim = random.randint(16, 64)  # Random embedding dimension between 16 and 64\n\n        item_sequence = torch.randint(0, 100, (batch_size, seq_length))  # Simulating item indices\n        sequence_length = torch.randint(1, seq_length + 1, (batch_size, 1)).float()  # Ensuring valid sequence lengths\n        mask = torch.randint(0, 2, (batch_size, seq_length))  # Binary mask for active elements\n\n        # Simulated embedding layer and transformations\n        embedding = torch.nn.Embedding(100, embedding_dim)  # 100 possible items, embedding_dim-dimensional\n        glu1_hot = torch.nn.Linear(embedding_dim, embedding_dim, bias=False)\n        glu2_hot = torch.nn.Linear(embedding_dim, embedding_dim, bias=False)\n        weight_hot = torch.nn.Parameter(torch.randn(embedding_dim, embedding_dim))\n\n        test_cases.append((item_sequence, sequence_length, mask, glu1_hot, glu2_hot, embedding, weight_hot))\n\n    return test_cases"}
{"problem_id": "pytorch_34", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes grayscale images and their corresponding color information based on certain gate maps. The function will mark specific regions of the grayscale images and color information based on a threshold and a dilation operation.\n\nFunction signature:\n```python\ndef mark_color_hints(input_grays: torch.Tensor, target_ABs: torch.Tensor, gate_maps: torch.Tensor, kernel_size: int, base_ABs: torch.Tensor) -> torch.Tensor:\n```\n\n### Constants:\n- A threshold constant of `0.7` is used to create a binary map from the gate maps.\n- A small constant of `1e-5` is used to determine significant values in the margin and center masks.\n\n### Input and Output Format:\n- **Input**: \n  - `input_grays`: A tensor of shape (N, 1, H, W) where N is the batch size, H is the height, and W is the width.\n  - `target_ABs`: A tensor of shape (N, 2, H, W) representing the target color information.\n  - `gate_maps`: A tensor of shape (N, C, H, W) used for marking.\n  - `kernel_size`: An integer specifying the size of the kernel for dilation.\n  - `base_ABs`: A tensor of shape (N, 2, H, W) or None.\n\n- **Output**: \n  - A tensor of shape (N, 3, H, W) containing the marked grayscale and color information.\n\n**Input:**\n```python\ninput_grays = torch.tensor([[[[0.1, 0.2],\n                              [0.3, 0.4]]]])  # Shape: (1, 1, 2, 2)\n\ntarget_ABs = torch.tensor([[[[0.5, 0.6],\n                              [0.7, 0.8]],\n\n                             [[0.9, 1.0],\n                              [1.1, 1.2]]]])  # Shape: (1, 2, 2, 2)\n\ngate_maps = torch.tensor([[[[0.8, 0.6],\n                             [0.4, 0.9]]]])  # Shape: (1, 1, 2, 2)\n\nkernel_size = 3\n\nbase_ABs = None  # Shape: None\n```\n\n**Output:**\n```python\noutput = torch.tensor([[[[0.1000, 0.2000],\n                      [0.3000, 0.4000]],\n                     [[0.5000, 0.6000],\n                      [0.7000, 0.8000]],\n                     [[0.9000, 1.0000],\n                      [1.1000, 1.2000]]]])\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n\ndef dilate_seeds(gate_maps, kernel_size):\n    N, C, H, W = gate_maps.shape\n    input_unf = F.unfold(gate_maps, kernel_size, padding=kernel_size // 2)\n    dilated_seeds = input_unf.max(dim=1, keepdim=True).values\n    return F.fold(dilated_seeds, output_size=(H, W), kernel_size=1)\n\n\n# main code\ndef mark_color_hints(input_grays, target_ABs, gate_maps, kernel_size,base_ABs):\n    binary_map = (gate_maps > 0.7).float()\n    center_mask = dilate_seeds(binary_map, kernel_size)\n    margin_mask = dilate_seeds(binary_map, kernel_size + 2) - center_mask\n\n    marked_grays = torch.where(margin_mask > 1e-5, torch.ones_like(gate_maps), input_grays)\n\n    if base_ABs is None:\n        marked_ABs = torch.where(center_mask > 1e-5, target_ABs, torch.zeros_like(gate_maps))\n    else:\n        marked_ABs = torch.where(margin_mask > 1e-5, torch.zeros_like(gate_maps), base_ABs)\n        marked_ABs = torch.where(center_mask > 1e-5, target_ABs, marked_ABs)\n\n    return torch.cat((marked_grays, marked_ABs), dim=1)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        N = random.randint(1, 8)\n        C_gray = 1\n        C_ab = 2\n        H = random.randint(16, 128)\n        W = random.randint(16, 128)\n\n        input_grays = torch.rand(N, C_gray, H, W)\n        target_ABs = torch.rand(N, C_ab, H, W)\n        gate_maps = torch.rand(N, 1, H, W)\n\n        kernel_size = random.choice([3, 5, 7])\n\n        if random.random() > 0.5:\n            base_ABs = None\n        else:\n            base_ABs = torch.rand(N, C_ab, H, W)\n\n        test_cases.append((input_grays, target_ABs, gate_maps, kernel_size, base_ABs))\n\n    return test_cases"}
{"problem_id": "pytorch_35", "library": "pytorch", "code_problem": "You are tasked with implementing a beam search algorithm for generating sequences based on encoded contexts and style identifiers. The function signature for the main code is as follows:\n\n```python\ndef beam_search(enc_contexts, style_ids, beam_size, max_seq_len, transformer_module, tokenizer):\n```\n\n### Constants:\n- `tokenizer.bos_token_id`: The token ID representing the beginning of a sequence.\n- `tokenizer.eos_token_id`: The token ID representing the end of a sequence.\n\n### Input Format:\n- `enc_contexts`: A list of tuples, where each tuple contains encoded context tensors.\n- `style_ids`: A tensor of shape (batch_size, num_styles) representing the style identifiers for each sequence.\n- `beam_size`: An integer representing the number of beams to maintain during the search.\n- `max_seq_len`: An integer representing the maximum length of the generated sequences.\n- `transformer_module`: A transformer model used for generating the next token predictions.\n- `tokenizer`: A tokenizer object that provides token IDs for the beginning and end of sequences.\n\n### Output Format:\n- A list of lists, where each inner list contains the generated token IDs for the sequences corresponding to each input in the batch.\n\n```python\n# Input\nenc_contexts = [\n    (\n        torch.randn(2, 15, 128),  # Context tensor\n        torch.randn(2, 15)  # Positional encoding tensor\n    )\n]\nstyle_ids = torch.tensor([3, 5])  # Style IDs for the batch\nbeam_size = 3\nmax_seq_len = 10\n\n# Mock transformer module\nclass MockTransformerModule:\n    def __call__(self, *args, **kwargs):\n        batch_size_times_beam = kwargs['input_ids'].shape[0]\n        vocab_size = 100  # Assume a vocabulary size of 100\n        return (torch.randn(batch_size_times_beam, 1, vocab_size),)\n\ntransformer_module = MockTransformerModule()\n\n# Mock tokenizer\nclass MockTokenizer:\n    bos_token_id = 0\n    eos_token_id = 1\n\ntokenizer = MockTokenizer()\n\n# Output\nresults = beam_search(enc_contexts, style_ids, beam_size, max_seq_len, transformer_module, tokenizer)\n# results = [[29, 0, 41, 13, 54, 75, 62, 51, 98, 23], [89, 28, 28, 62, 35, 70, 25, 37, 63, 36]]\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n\ndef get_mask(seq_lens):\n    max_len = seq_lens.max().item()\n    return torch.arange(max_len)[None, :] < seq_lens[:, None]\n\n# main code\ndef beam_search(enc_contexts, style_ids, beam_size, max_seq_len, transformer_module, tokenizer):\n    if not enc_contexts:\n        return []\n\n    batch_size = style_ids.shape[0]\n    beam_style_ids = style_ids.unsqueeze(1).repeat(1, beam_size).view(-1)\n\n    beam_scores = torch.zeros(batch_size, beam_size, device=style_ids.device)\n    beam_lens = torch.ones(batch_size, beam_size, dtype=torch.long, device=style_ids.device)\n    is_end = torch.zeros(batch_size, beam_size, dtype=torch.bool, device=style_ids.device)\n\n    beam_enc_contexts = []\n    for c, p in enc_contexts:\n        c = c.unsqueeze(1).repeat(1, beam_size, 1, 1).view(-1, c.shape[-2], c.shape[-1])\n        p = p.unsqueeze(1).repeat(1, beam_size, 1).view(-1, p.shape[-1])\n        beam_enc_contexts.append((c, p))\n\n    prev_tokens = torch.full((batch_size * beam_size, 1), tokenizer.bos_token_id, dtype=torch.long, device=style_ids.device)\n\n    for _ in range(max_seq_len):\n        mask = get_mask(beam_lens.view(-1))\n        logits = transformer_module(None, attention_mask=mask, enc_contexts=beam_enc_contexts, input_ids=prev_tokens,\n                                    style_ids=beam_style_ids)[0][:, -1, :]\n        log_probs = F.log_softmax(logits, dim=-1)\n\n        log_probs = log_probs.view(batch_size, beam_size, -1)\n\n        beam_scores = beam_scores.unsqueeze(-1) + log_probs * (~is_end).float().unsqueeze(-1)\n        beam_scores = beam_scores.view(batch_size, -1)\n        top_scores, top_indices = beam_scores.topk(beam_size, dim=-1)\n\n        beam_scores = top_scores\n        beam_idxs = (top_indices // log_probs.shape[-1]).long()\n        token_indices = top_indices % log_probs.shape[-1]\n\n        is_end = torch.gather(is_end, 1, beam_idxs)\n        beam_lens = torch.gather(beam_lens, 1, beam_idxs)\n\n        token_indices[is_end] = 0\n        beam_lens[~is_end] += 1\n        is_end[token_indices == tokenizer.eos_token_id] = True\n\n        prev_tokens = torch.cat([torch.gather(prev_tokens.view(batch_size, beam_size, -1), 1,\n                                              beam_idxs.unsqueeze(-1).expand(-1, -1, prev_tokens.shape[-1])).view(\n            batch_size * beam_size, -1), token_indices.view(-1, 1)], dim=1)\n\n        if is_end.all():\n            break\n\n    best_beams = beam_scores.argmax(dim=-1)\n    results = [prev_tokens[i * beam_size + best_beams[i], 1:beam_lens[i, best_beams[i]]].tolist() for i in\n               range(batch_size)]\n\n    return results", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        beam_size = random.randint(2, 5)\n        max_seq_len = random.randint(5, 50)\n\n        # Randomly generated encoder context\n        enc_contexts = [\n            (\n                torch.randn(batch_size, random.randint(10, 100), random.randint(64, 512)),  # Context tensor\n                torch.randn(batch_size, random.randint(10, 100))  # Positional encoding tensor\n            )\n            for _ in range(random.randint(1, 3))  # Number of encoder context tuples\n        ]\n\n        # Randomly generated style IDs\n        style_ids = torch.randint(0, 10, (batch_size,))\n\n        # Mock transformer module\n        class MockTransformerModule:\n            def __call__(self, *args, **kwargs):\n                batch_size_times_beam = kwargs['input_ids'].shape[0]\n                vocab_size = 100  # Assume a vocabulary size of 100\n                return (torch.randn(batch_size_times_beam, 1, vocab_size),)\n\n        transformer_module = MockTransformerModule()\n\n        # Mock tokenizer\n        class MockTokenizer:\n            bos_token_id = 0\n            eos_token_id = 1\n\n        tokenizer = MockTokenizer()\n\n        test_cases.append((enc_contexts, style_ids, beam_size, max_seq_len, transformer_module, tokenizer))\n\n    return test_cases"}
{"problem_id": "pytorch_36", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the training loss for a model that encodes queries and documents. The function will utilize two encoding functions to generate embeddings for queries and documents, and then calculate the loss based on the similarity of these embeddings. The function signature is as follows:\n\n```python\ndef inbatch_train(query_encode_func, doc_encode_func, input_query_ids, query_attention_mask, input_doc_ids,\n                  doc_attention_mask, other_doc_ids, other_doc_attention_mask, rel_pair_mask, hard_pair_mask):\n```\n\n### Constants:\n- The constant used in the main code is the value `1`, which is used to create a mask for the relevant pairs when `rel_pair_mask` is `None`.\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `query_encode_func`: A function to encode queries.\n  - `doc_encode_func`: A function to encode documents.\n  - `input_query_ids`: Tensor of input query IDs.\n  - `query_attention_mask`: Tensor for attention masking of queries.\n  - `input_doc_ids`: Tensor of input document IDs.\n  - `doc_attention_mask`: Tensor for attention masking of documents.\n  - `other_doc_ids`: Tensor of other document IDs (optional).\n  - `other_doc_attention_mask`: Tensor for attention masking of other documents (optional).\n  - `rel_pair_mask`: Tensor indicating relevant pairs.\n  - `hard_pair_mask`: Tensor indicating hard pairs (optional).\n\n- **Output**: The function returns a tuple containing a single float value representing the computed loss.\n\n**Input:**\n```python\nimport torch\n\ndef dummy_encode_func(ids, attention_mask):\n    return torch.randn(ids.shape[0], 128)\n\ninput_query_ids = torch.tensor([[1, 2, 3], [4, 5, 6]])\nquery_attention_mask = torch.tensor([[1, 1, 1], [1, 1, 1]])\ninput_doc_ids = torch.tensor([[7, 8, 9], [10, 11, 12]])\ndoc_attention_mask = torch.tensor([[1, 1, 1], [1, 1, 1]])\nother_doc_ids = torch.tensor([[[13, 14, 15], [16, 17, 18]], [[19, 20, 21], [22, 23, 24]]])\nother_doc_attention_mask = torch.tensor([[[1, 1, 1], [1, 1, 1]], [[1, 1, 1], [1, 1, 1]]])\nrel_pair_mask = torch.tensor([[0, 1], [1, 0]])\nhard_pair_mask = torch.tensor([[1, 0], [0, 1]]).reshape(-1)\n\n# Call the function\noutput = inbatch_train(dummy_encode_func, dummy_encode_func, input_query_ids, query_attention_mask,\n                       input_doc_ids, doc_attention_mask, other_doc_ids, other_doc_attention_mask,\n                       rel_pair_mask, hard_pair_mask)\n```\n\n**Output:**\n```python\n(tensor(3.1620),)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef inbatch_train(query_encode_func, doc_encode_func, input_query_ids, query_attention_mask, input_doc_ids,\n                  doc_attention_mask, other_doc_ids, other_doc_attention_mask, rel_pair_mask, hard_pair_mask):\n\n    query_embs = query_encode_func(input_query_ids, query_attention_mask)\n    doc_embs = doc_encode_func(input_doc_ids, doc_attention_mask)\n    batch_size = query_embs.shape[0]\n\n    batch_scores = torch.matmul(query_embs, doc_embs.T)\n    single_positive_scores = torch.diagonal(batch_scores)\n\n    if rel_pair_mask is None:\n        rel_pair_mask = 1 - torch.eye(batch_size, device=batch_scores.device)\n\n    logit_matrix = torch.cat([single_positive_scores.unsqueeze(1), batch_scores], dim=1)\n    lsm = F.log_softmax(logit_matrix, dim=1)\n    first_loss = (-lsm[:, 0] * rel_pair_mask).sum()\n    first_num = rel_pair_mask.sum()\n    if other_doc_ids is None:\n        return (first_loss / first_num,)\n\n    other_doc_embs = doc_encode_func(other_doc_ids.view(-1, other_doc_ids.shape[-1]),\n                                     other_doc_attention_mask.view(-1, other_doc_attention_mask.shape[-1]))\n\n    other_batch_scores = torch.matmul(query_embs, other_doc_embs.T)\n    other_logit_matrix = torch.cat([single_positive_scores.unsqueeze(1), other_batch_scores], dim=1)\n    other_lsm = F.log_softmax(other_logit_matrix, dim=1)\n    other_loss = -other_lsm[:, 0]\n\n\n    if hard_pair_mask is not None:\n        hard_pair_mask = hard_pair_mask.view(-1)[:other_loss.shape[0]]  # Ensure matching shape\n        other_loss *= hard_pair_mask\n        second_loss, second_num = other_loss.sum(), hard_pair_mask.sum()\n    else:\n        second_loss, second_num = other_loss.sum(), other_loss.numel()\n\n    return ((first_loss + second_loss) / (first_num + second_num),)", "test_script": "import torch\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    def dummy_encode_func(ids, attention_mask):\n        return torch.randn(ids.shape[0], 128)\n\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(2, 10)  # Ensuring batch size is at least 2\n        seq_len = np.random.randint(5, 20)  # Sequence length for queries and docs\n        doc_count = np.random.randint(2, 5)  # Number of other docs per query\n\n        input_query_ids = torch.randint(0, 100, (batch_size, seq_len))\n        query_attention_mask = torch.randint(0, 2, (batch_size, seq_len))\n\n        input_doc_ids = torch.randint(0, 100, (batch_size, seq_len))\n        doc_attention_mask = torch.randint(0, 2, (batch_size, seq_len))\n\n        if np.random.rand() > 0.2:\n            other_doc_ids = torch.randint(0, 100, (batch_size, doc_count, seq_len))\n            other_doc_attention_mask = torch.randint(0, 2, (batch_size, doc_count, seq_len))\n            hard_pair_mask = torch.randint(0, 2, (batch_size, doc_count), dtype=torch.float32).reshape(-1)\n        else:\n            other_doc_ids = None\n            other_doc_attention_mask = None\n            hard_pair_mask = None\n\n        rel_pair_mask = torch.randint(0, 2, (batch_size, batch_size)) if np.random.rand() > 0.2 else None\n\n        test_cases.append((\n            dummy_encode_func,\n            dummy_encode_func,\n            input_query_ids,\n            query_attention_mask,\n            input_doc_ids,\n            doc_attention_mask,\n            other_doc_ids,\n            other_doc_attention_mask,\n            rel_pair_mask,\n            hard_pair_mask\n        ))\n\n    return test_cases"}
{"problem_id": "pytorch_37", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the cumulative sum of a tensor while ensuring numerical stability. The function should be able to handle multi-dimensional tensors and provide an alternative output if the cumulative sum is not stable within specified relative and absolute tolerances.\n\nFunction signature:\n```python\ndef stable_cumsum(arr: torch.Tensor, dim: Optional[int], rtol: float, atol: float) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- `dtype`: The data type used for calculations, which is set to `torch.float64` for increased precision.\n\nInput format:\n- `arr`: A tensor of any shape.\n- `dim`: An optional integer specifying the dimension along which to compute the cumulative sum.\n- `rtol`: A float representing the relative tolerance for stability checking.\n- `atol`: A float representing the absolute tolerance for stability checking.\n\nOutput format:\n- The function returns a tensor that represents either the stable cumulative sum or the expected sum, depending on the stability check.\n\nInput:\n```python\narr = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0]])\ndim = 0\nrtol = 1e-5\natol = 1e-5\n```\n\nOutput:\n```python\ntensor([[1., 2., 3.],\n        [5., 7., 9.]], dtype=torch.float64)\n```", "ground_truth_code": "import torch\n\n# main code\ndef stable_cumsum(arr, dim, rtol, atol):\n    if dim is None:\n        arr = arr.flatten()\n        dim = 0\n\n    out = torch.cumsum(arr, dim=dim, dtype=torch.float64)\n    expected = torch.sum(arr, dim=dim, dtype=torch.float64)\n\n    last_value = out.select(dim, -1)\n    is_stable = torch.all(torch.isclose(last_value, expected, rtol=rtol, atol=atol, equal_nan=True))\n\n    return out if is_stable else expected.expand_as(out)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_dims = random.randint(1, 4)\n        shape = tuple(random.randint(1, 10) for _ in range(num_dims))\n        arr = torch.randn(shape) * 100\n        dim = random.randint(0, num_dims - 1)\n        rtol = 10 ** random.uniform(-5, -1)\n        atol = 10 ** random.uniform(-5, -1)\n\n        test_cases.append((arr, dim, rtol, atol))\n\n    return test_cases\n"}
{"problem_id": "pytorch_38", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the output of a neural network model and optionally calculates the loss based on the provided labels. The function will handle different types of labels and apply the appropriate loss function based on the data type of the labels.\n\nFunction signature:\n```python\ndef forward(input_ids, labels, model, num_labels):\n```\n\nConstant used in the main code:\n- `num_labels`: This constant represents the number of distinct labels in the classification task.\n\nInput format:\n- `input_ids`: A tensor containing the input data for the model.\n- `labels`: A tensor containing the true labels for the input data, which can be of type `torch.long`, `torch.half`, or `torch.float`.\n- `model`: An instance of a neural network model that takes `input_ids` and produces logits.\n- `num_labels`: An integer representing the number of distinct labels for the classification task.\n\nOutput format:\n- If `labels` is provided, the output will be a tensor representing the computed loss.\n- If `labels` is not provided, the output will be a tensor containing the logits produced by the model.\n\n**Input:**\n```python\ninput_ids = torch.tensor([[12, 34, 56]], dtype=torch.long)  # A sequence of length 3\nlabels = torch.tensor([1], dtype=torch.long)  # A single label for classification\nmodel = SimpleModel(input_dim=100, hidden_dim=32, num_labels=5)  # Model with 100 input dim, 32 hidden dim, 5 labels\nnum_labels = 5\n```\n\n**Output:**\n```python\nloss = forward(input_ids, labels, model, num_labels)  # tensor(1.5026, grad_fn=<NllLossBackward0>)\n```", "ground_truth_code": "import torch\nimport torch.nn as nn\n\n# main code\ndef forward(input_ids, labels, model, num_labels):\n    logits = model(input_ids)\n    if labels is not None:\n        if labels.dtype == torch.long:\n            loss_fct = nn.CrossEntropyLoss()\n            loss = loss_fct(logits.view(-1, num_labels), labels.view(-1))\n        elif labels.dtype in {torch.half, torch.float}:\n            loss_fct = nn.MSELoss()\n            loss = loss_fct(logits.view(-1), labels.view(-1))\n        else:\n            loss = None\n        return loss\n    else:\n        return logits", "test_script": "import torch\nimport torch.nn as nn\nimport random\n\n\ndef test_case_input_generator(n=200):\n    class SimpleModel(nn.Module):\n        def __init__(self, input_dim, hidden_dim, num_labels):\n            super(SimpleModel, self).__init__()\n            self.embedding = nn.Embedding(input_dim, hidden_dim)  # Random embeddings\n            self.fc = nn.Linear(hidden_dim, num_labels)  # Fully connected classifier\n            self.dropout = nn.Dropout(0.1)  # Dropout layer\n\n        def forward(self, input_ids):\n            embedded = self.embedding(input_ids).mean(dim=1)  # Mean pooling over sequence\n            embedded = self.dropout(embedded)\n            logits = self.fc(embedded)\n            return logits\n\n    test_cases = []\n    input_dim = random.randint(50, 150)\n    hidden_dim = random.randint(16, 64)\n    num_labels = random.randint(2, 10)\n    max_seq_len = random.randint(5, 15)\n    model = SimpleModel(input_dim, hidden_dim, num_labels)\n\n    for _ in range(n):\n        seq_len = random.randint(1, max_seq_len)\n        input_ids = torch.randint(0, input_dim, (1, seq_len), dtype=torch.long)\n\n        if random.random() < 0.5:\n            labels = torch.randint(0, num_labels, (1,), dtype=torch.long)\n        else:\n            labels = torch.randn((1,), dtype=torch.float)\n\n        test_cases.append((input_ids, labels, model, num_labels))\n\n    return test_cases"}
{"problem_id": "pytorch_39", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes probabilities, regularization, and loss based on given inputs. The function will utilize PyTorch for tensor operations and will return a dictionary containing the computed probabilities, regularization value, and loss.\n\nFunction Signature:\n```python\ndef forward(alpha: float, start_samples: Optional[torch.Tensor], value: List[float], lin: Optional[Callable], sigmoid: Callable) -> Dict[str, List[Union[torch.Tensor, str]]]:\n```\n\nConstant Used:\n- The constant `0.5` is used in the computation of probabilities.\n\nInput Format:\n- `alpha`: A float representing the scaling factor for the regularization term.\n- `start_samples`: An optional tensor that may contain starting sample values.\n- `value`: A list of float values that will be used in loss computation.\n- `lin`: An optional callable that applies a linear transformation to the input.\n- `sigmoid`: A callable that applies the sigmoid activation function.\n\nOutput Format:\n- The function returns a dictionary with the following keys:\n  - `'output'`: A list containing the computed probabilities and the string 'hist'.\n  - `'reg'`: A list containing the regularization value and the string 'sequence'.\n  - `'loss'`: A list containing the computed loss and the string 'sequence'.\n\n**Input:**\n```python\nalpha = torch.tensor(1.5)\nstart_samples = torch.tensor([[1.0, 0.0], [0.0, 1.0]])\nvalue = torch.tensor([[0.2, 0.8], [0.5, 0.5]])\nlin = torch.nn.Linear(1, 1)\nsigmoid = torch.nn.Sigmoid()\n```\n\n**Output:**\n```python\n{\n   'output': [tensor(0.3389, grad_fn=<SqueezeBackward0>), 'hist'], \n    'reg': [tensor(-0.6403, grad_fn=<MeanBackward0>), 'sequence'], \n    'loss': [tensor(-1.7084, grad_fn=<AddBackward0>), 'sequence']\n}\n```", "ground_truth_code": "import torch\n\n# main code\ndef forward(alpha, start_samples, value, lin, sigmoid):\n    x = torch.ones(1)\n    if lin is not None:\n        x = lin(x)\n    x = sigmoid(x)\n    x = (x - 0.5) * 0.6 + 0.5\n    probs = x.squeeze()\n\n    retdict = {}\n    reg = probs * torch.log(probs) + (1 - probs) * torch.log(1 - probs)\n    reg = torch.mean(reg)\n\n    if start_samples is None:\n        retdict['output'] = [probs, 'hist']\n        retdict['reg'] = [reg, 'sequence']\n        retdict['loss'] = [alpha * reg, 'sequence']\n        return retdict\n\n    res_samples = torch.tensor(value).t().detach()\n    start_samples_idx = start_samples * probs + (1 - start_samples) * (1 - probs)\n    log_start_samples_idx = torch.log(start_samples_idx)\n    log_start_samples = log_start_samples_idx.sum(dim=1)\n    loss_ls = torch.mean(log_start_samples * res_samples)\n    loss = loss_ls + alpha * reg\n\n    retdict['output'] = [probs, 'hist']\n    retdict['reg'] = [reg, 'sequence']\n    retdict['loss'] = [loss, 'sequence']\n\n    return retdict", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        alpha = torch.tensor(random.uniform(0.1, 2.0))\n\n        if random.choice([True, False]):\n            start_samples = None\n            value = None\n        else:\n            batch_size = random.randint(1, 10)\n            feature_dim = random.randint(1, 5)\n            start_samples = torch.randint(0, 2, (batch_size, feature_dim)).float()\n            value = torch.randn(batch_size, feature_dim)\n\n        lin = torch.nn.Linear(1, 1) if random.choice([True, False]) else None\n        sigmoid = torch.nn.Sigmoid()\n\n        test_cases.append((alpha, start_samples, value, lin, sigmoid))\n\n    return test_cases\n"}
{"problem_id": "pytorch_40", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a list of samples, each containing word indices, and retrieves their corresponding word embeddings. The function should compute the average embedding for each word index in the sample, handling cases where no valid indices are found by using the closest available embedding. \n\nFunction signature:\n```python\ndef get_embedding(sample, word_embeddings, word_embeddings_size, max_len):\n```\n\nConstants used in the main code:\n- `max_len`: This constant represents the maximum length of the word indices that can be processed.\n\nInput format:\n- `sample`: A list of dictionaries, where each dictionary contains a key `word_indices` that maps word positions to lists of indices.\n- `word_embeddings`: A dictionary mapping indices to their corresponding word embeddings (as NumPy arrays).\n- `word_embeddings_size`: A tuple representing the shape of the `word_embeddings` (number of embeddings, embedding dimension).\n- `max_len`: An integer representing the maximum length of the word indices to be processed.\n\nOutput format:\n- The function returns a NumPy array containing the average embeddings for each sample, where each element corresponds to the embeddings of a sample in the input list.\n\n**Input:**\n```python\nsample = [\n    {'word_indices': {0: [1, 2], 1: [3], 2: [4, 5]}},\n    {'word_indices': {0: [0, 6], 1: [7], 2: [8, 9]}}\n]\nword_embeddings = {\n    0: np.array([0.1, 0.2, 0.3]),\n    1: np.array([0.4, 0.5, 0.6]),\n    2: np.array([0.7, 0.8, 0.9]),\n    3: np.array([1.0, 1.1, 1.2]),\n    4: np.array([1.3, 1.4, 1.5]),\n    5: np.array([1.6, 1.7, 1.8]),\n    6: np.array([1.9, 2.0, 2.1]),\n    7: np.array([2.2, 2.3, 2.4]),\n    8: np.array([2.5, 2.6, 2.7]),\n    9: np.array([2.8, 2.9, 3.0])\n}\nword_embeddings_size = (3, 3)  # embedding_dim = 3, num_aspects = 3\nmax_len = 10\n```\n\n**Output:**\n```python\narray([[[0.55, 0.65, 0.75],\n        [1.  , 1.1 , 1.2 ],\n        [1.45, 1.55, 1.65]],\n       [[1.  , 1.1 , 1.2 ],\n        [2.2 , 2.3 , 2.4 ],\n        [2.65, 2.75, 2.85]]])\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef get_embedding(sample, word_embeddings, word_embeddings_size, max_len):\n    aspect_word_embeddings = []\n\n    for j in range(len(sample)):\n        sample_embeddings = []\n        word_indices = sample[j]['word_indices']\n\n        for k in range(word_embeddings_size[1]):\n            valid_indices = [idx for idx in word_indices.get(k, []) if idx < max_len and idx in word_embeddings]\n\n            if valid_indices:\n                word_embeds = [word_embeddings[idx] for idx in valid_indices]\n                avg_embedding = np.mean(word_embeds, axis=0)\n            else:\n                # If no valid indices are found, use the closest available embedding in word_embeddings\n                closest_idx = min(word_embeddings.keys(), key=lambda x: abs(x - k), default=None)\n                avg_embedding = word_embeddings[closest_idx] if closest_idx is not None else np.zeros(\n                    word_embeddings_size[0])\n\n            sample_embeddings.append(avg_embedding)\n\n        aspect_word_embeddings.append(np.array(sample_embeddings))\n\n    return np.array(aspect_word_embeddings)", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        max_len = random.randint(5, 50)\n        embedding_dim = random.randint(10, 300)\n        num_words = random.randint(50, 500)\n        num_samples = random.randint(1, 10)\n        num_aspects = random.randint(1, 5)\n\n        word_embeddings = {i: np.random.randn(embedding_dim) for i in range(num_words)}\n        word_embeddings_size = (embedding_dim, num_aspects)\n\n        sample = []\n        for _ in range(num_samples):\n            word_indices = {}\n            for aspect in range(num_aspects):\n                word_indices[aspect] = [random.randint(0, num_words - 1) for _ in range(random.randint(1, 5))]\n\n                if random.random() < 0.7:\n                    word_indices[aspect] = [idx for idx in word_indices[aspect] if idx in word_embeddings]\n                if not word_indices[aspect]:\n                    word_indices[aspect].append(random.randint(0, num_words - 1))\n\n            sample.append({'word_indices': word_indices})\n\n        test_cases.append((sample, word_embeddings, word_embeddings_size, max_len))\n\n    return test_cases"}
{"problem_id": "pytorch_41", "library": "pytorch", "code_problem": "You are tasked with implementing a function that builds a neural network architecture using PyTorch. The function should allow for the configuration of various parameters such as input dimensions, latent dimensions, the number of layers, dropout ratio, and whether to apply a spatial transformation.\n\nFunction signature:\n```python\ndef build_network(input_dim: int, latent_dim: int, layers_num: int, dropout_ratio: float, apply_spatial: bool) -> Tuple[Optional[nn.Sequential], nn.Sequential]:\n```\n\nConstant used in the main code:\n- The kernel size for the convolutional layer is set to 7.\n\nInput format:\n- The function accepts five parameters: `input_dim`, `latent_dim`, `layers_num`, `dropout_ratio`, and `apply_spatial`.\n\nOutput format:\n- The function returns a tuple containing two elements: the first element is either a spatial model (of type `nn.Sequential` or `None`), and the second element is the main network model (of type `nn.Sequential`).\n\n```python\nInput: (64, 128, 3, 0.2, True)\nOutput: (Sequential(\n  (0): Conv2d(64, 64, kernel_size=(7, 7), stride=(1, 1), bias=False)\n  (1): BatchNorm2d(64, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n), Sequential(\n  (0): Linear(in_features=128, out_features=128, bias=True)\n  (1): LeakyReLU(negative_slope=0.2, inplace=True)\n  (2): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (3): Linear(in_features=128, out_features=128, bias=True)\n  (4): LeakyReLU(negative_slope=0.2, inplace=True)\n  (5): Dropout(p=0.2, inplace=False)\n  (6): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (7): Linear(in_features=128, out_features=128, bias=True)\n  (8): LeakyReLU(negative_slope=0.2, inplace=True)\n  (9): Dropout(p=0.2, inplace=False)\n  (10): BatchNorm1d(128, eps=1e-05, momentum=0.1, affine=True, track_running_stats=True)\n  (11): Linear(in_features=128, out_features=128, bias=True)\n  (12): LeakyReLU(negative_slope=0.2, inplace=True)\n  (13): Dropout(p=0.2, inplace=False)\n  (14): Linear(in_features=128, out_features=3136, bias=True)\n))\n```", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef build_network(input_dim, latent_dim, layers_num, dropout_ratio, apply_spatial):\n    output_dim = input_dim\n\n    spatial = None\n    if apply_spatial:\n        spatial = nn.Sequential(\n            nn.Conv2d(input_dim, input_dim, kernel_size=7, stride=1, padding=0, bias=False),\n            nn.BatchNorm2d(input_dim)\n        )\n        output_dim = output_dim * 7 * 7\n\n    layers = [nn.Linear(2 * input_dim, latent_dim), nn.LeakyReLU(0.2, inplace=True)]\n\n    for _ in range(layers_num):\n        layers.extend([\n            nn.BatchNorm1d(latent_dim),\n            nn.Linear(latent_dim, latent_dim),\n            nn.LeakyReLU(0.2, inplace=True)\n        ])\n        if dropout_ratio > 0:\n            layers.append(nn.Dropout(p=dropout_ratio))\n\n    layers.append(nn.Linear(latent_dim, output_dim))\n    net = nn.Sequential(*layers)\n\n    return spatial, net", "test_script": "import torch.nn as nn\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        input_dim = random.choice([16, 32, 64, 128, 256])  # Common input dimensions\n        latent_dim = random.choice([32, 64, 128, 256, 512])  # Common latent dimensions\n        layers_num = random.randint(1, 5)  # Number of hidden layers between 1 and 5\n        dropout_ratio = random.choice([0.0, 0.1, 0.2, 0.3, 0.5])  # Dropout probability\n        apply_spatial = random.choice([True, False])  # Whether to apply spatial module\n\n        test_cases.append((input_dim, latent_dim, layers_num, dropout_ratio, apply_spatial))\n\n    return test_cases"}
{"problem_id": "pytorch_42", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes a diversity training term for a given model based on the gradients of its predictions. The function will utilize various loss functions and similarity measures to evaluate the diversity of the gradients obtained from the model's predictions.\n\nFunction Signature:\n```python\ndef get_diversity_training_term(model, batch, logsumexp=False):\n```\n\nConstant Used:\n- `eps`: A small constant value set to `1e-08` used in the cosine similarity calculation to avoid division by zero.\n\nInput Format:\n- `model`: An object that contains the necessary attributes and methods for making predictions and calculating gradients.\n- `batch`: A dictionary containing at least the key 'labels' which holds the true labels for the current batch of data.\n- `logsumexp`: A boolean flag indicating whether to compute the log-sum-exp of the total costs.\n\nOutput Format:\n- Returns a tuple of two tensors:\n  - The first tensor represents the computed diversity training term.\n  - The second tensor represents the mean L2 distance of the gradients.\n\n**Input:**\n```python\n# Model and batch generation\nclass DummyModel:\n    def __init__(self, N, emb_dim, num_classes, batch_size):\n        self.N = N\n        self.emb1 = torch.randn(batch_size, num_classes, requires_grad=True)  # Match shape with pred_heads\n        self.pred_heads = [torch.randn(batch_size, num_classes, requires_grad=True) for _ in range(N)]\n        self.random_key = torch.randn(batch_size, N)\n\n# Create a specific test case\nmodel = DummyModel(N=3, emb_dim=10, num_classes=5, batch_size=4)\nbatch = {\n    'labels': torch.tensor([1, 0, 4, 2])  # Example labels\n}\n\n# Call the function\noutput = get_diversity_training_term(model, batch, logsumexp=False)\n```\n\n**Output:**\n```python\n(tensor(0.3100, grad_fn=<MeanBackward1>), tensor(0.0298, grad_fn=<MeanBackward1>))\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef get_diversity_training_term(model, batch, logsumexp=False):\n    l2_distance = torch.nn.MSELoss()\n    loss_func = torch.nn.CrossEntropyLoss()\n    cos = torch.nn.CosineSimilarity(dim=0, eps=1e-08)\n    label = batch['labels']\n    grads = []\n\n    for i in range(model.N):\n        loss = loss_func((model.pred_heads[i] + model.emb1) * model.random_key[:, i].unsqueeze(1), label)\n        grad = torch.autograd.grad(loss, model.emb1, create_graph=True)[0]\n        grads.append(grad)\n\n    total_cost = []\n    total_cost_l2 = []\n\n    for i in range(len(grads)):\n        for j in range(len(grads)):\n            if j > i:\n                cost = cos(grads[i].contiguous().view(-1), grads[j].contiguous().view(-1))\n                cost_l2 = l2_distance(grads[i].contiguous().view(-1), grads[j].contiguous().view(-1))\n                total_cost.append(cost.unsqueeze(0))\n                total_cost_l2.append(cost_l2.unsqueeze(0))\n\n    total_cost = torch.cat(total_cost) if total_cost else torch.tensor([0.0])\n    total_cost_l2 = torch.cat(total_cost_l2) if total_cost_l2 else torch.tensor([0.0])\n\n    if logsumexp:\n        out = torch.logsumexp(total_cost, 0)\n    else:\n        out = torch.mean(total_cost, 0)\n\n    out_l2 = torch.mean(total_cost_l2, 0)\n    return (out, out_l2)", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    class DummyModel:\n        def __init__(self, N, emb_dim, num_classes, batch_size):\n            self.N = N\n            self.emb1 = torch.randn(batch_size, num_classes, requires_grad=True)  # Match shape with pred_heads\n            self.pred_heads = [torch.randn(batch_size, num_classes, requires_grad=True) for _ in range(N)]\n            self.random_key = torch.randn(batch_size, N)\n\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = random.randint(1, 32)  # Random batch size\n        emb_dim = random.randint(8, 256)  # Random embedding dimension\n        num_classes = random.randint(2, 20)  # Random number of classes\n        N = random.randint(1, 5)  # Random number of prediction heads\n\n        model = DummyModel(N, emb_dim, num_classes, batch_size)\n        batch = {\n            'labels': torch.randint(0, num_classes, (batch_size,))  # Labels tensor\n        }\n\n        test_cases.append((model, batch))\n\n    return test_cases"}
{"problem_id": "pytorch_43", "library": "pytorch", "code_problem": "You are tasked with implementing a function that generates a specific matrix based on the provided measure type, the number of rows (N), the desired rank of the output matrix, and the data type for the elements of the matrix. The function should handle different types of measures and return a matrix that adheres to the specified rank.\n\nFunction signature:\n```python\ndef rank_correction(measure, N, rank, dtype):\n```\n\nConstant used in the main code:\n- The constant `0.5` is used in the calculation of the 'legs' measure.\n\nInput format:\n- `measure`: A string indicating the type of measure ('legs', 'legt', 'fourier', 'fout', 'fourier_diag', 'foud', 'legsd').\n- `N`: An integer representing the number of columns in the output matrix.\n- `rank`: An integer representing the desired number of rows in the output matrix.\n- `dtype`: A data type for the elements of the output matrix (e.g., `torch.float32`).\n\nOutput format:\n- The function returns a tensor of shape `(rank, N)` containing the calculated values based on the specified measure and parameters.\n\n**Input:**\n```python\nmeasure = 'legs'\nN = 5\nrank = 3\ndtype = torch.float\n```\n\n**Output:**\n```python\ntensor([[0.7071, 1.2247, 1.5811, 1.8708, 2.1213],\n        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000],\n        [0.0000, 0.0000, 0.0000, 0.0000, 0.0000]])\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef rank_correction(measure, N, rank, dtype):\n    if measure == 'legs':\n        P = torch.sqrt(0.5 + torch.arange(N, dtype=dtype)).unsqueeze(0)\n    elif measure == 'legt':\n        P = torch.sqrt(1 + 2 * torch.arange(N, dtype=dtype))\n        P0 = P.clone()\n        P0[0::2] = 0.0\n        P1 = P.clone()\n        P1[1::2] = 0.0\n        P = torch.stack([P0, P1], dim=0)\n        P *= 2 ** (-0.5)\n    elif measure in ['fourier', 'fout']:\n        P = torch.zeros(N)\n        P[0::2] = 2 ** 0.5\n        P[0] = 1\n        P = P.unsqueeze(0)\n    elif measure in ['fourier_diag', 'foud', 'legsd']:\n        P = torch.zeros(1, N, dtype=dtype)\n    else:\n        pass\n    d = P.size(0)\n    if rank > d:\n        P = torch.cat([P, torch.zeros(rank - d, N, dtype=dtype)], dim=0)\n    return P", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    measures = ['legs', 'legt', 'fourier', 'fout', 'fourier_diag', 'foud', 'legsd']\n\n    for _ in range(n):\n        measure = random.choice(measures)\n        N = random.randint(1, 100)  # Random matrix size N between 1 and 100\n        rank = random.randint(1, 5)  # Random rank between 1 and 5\n        dtype = random.choice([torch.float, torch.double])  # Randomly choose float or double\n\n        if measure == 'legs' and rank < 1:\n            rank = 1  # Ensure rank >= 1\n        elif measure == 'legt' and rank < 2:\n            rank = 2  # Ensure rank >= 2\n\n        test_cases.append((measure, N, rank, dtype))\n\n    return test_cases"}
{"problem_id": "pytorch_44", "library": "pytorch", "code_problem": "```python\ndef mle_loss(z, m, logs, logdet, mask):\n```\n\nIn this code, the function `mle_loss` computes the maximum likelihood estimation (MLE) loss for a given set of parameters. The function takes five arguments:\n\n1. `z`: A tensor representing the predicted values.\n2. `m`: A tensor representing the mean values.\n3. `logs`: A tensor representing the logarithm of the variance values.\n4. `logdet`: A tensor representing the logarithm of the determinant of the covariance matrix.\n5. `mask`: A tensor used to indicate which elements should be considered in the loss calculation.\n\nThe constant used in the main code is:\n- `math.log(2 * math.pi)`: This constant represents the logarithm of \\(2\\pi\\), which is used in the calculation of the Gaussian distribution.\n\nInput format:\n- The function expects five tensors: `z`, `m`, `logs`, `logdet`, and `mask`.\n\nOutput format:\n- The function returns a single scalar value representing the MLE loss.\n\nInput:\n```python\nz = torch.tensor([[0.5, -1.2], [1.0, 0.0]])\nm = torch.tensor([[0.0, 0.0], [0.0, 0.0]])\nlogs = torch.tensor([[0.1, 0.2], [0.1, 0.2]])\nlogdet = torch.tensor([0.5, 0.5])\nmask = torch.tensor([[1.0, 0.0], [1.0, 1.0]])\n```\n\nOutput:\n```python\noutput = mle_loss(z, m, logs, logdet, mask)\n# Expected output value: tensor(1.1171)\n```", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef mle_loss(z, m, logs, logdet, mask):\n    l = torch.sum(logs) + 0.5 * torch.sum(torch.exp(-2 * logs) * (z - m) ** 2)\n    l = l - torch.sum(logdet)\n    l = l / torch.sum(torch.ones_like(z) * mask)\n    l = l + 0.5 * math.log(2 * math.pi)\n    return l", "test_script": "import torch\nimport math\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly choose tensor shape (batch_size, feature_dim)\n        batch_size = torch.randint(1, 10, (1,)).item()\n        feature_dim = torch.randint(1, 10, (1,)).item()\n\n        # Generate tensors with appropriate shapes\n        z = torch.randn(batch_size, feature_dim)\n        m = torch.randn(batch_size, feature_dim)\n        logs = torch.randn(batch_size, feature_dim)\n        logdet = torch.randn(batch_size)\n        mask = torch.randint(0, 2, (batch_size, feature_dim), dtype=torch.float32)\n\n        test_cases.append((z, m, logs, logdet, mask))\n\n    return test_cases"}
{"problem_id": "pytorch_45", "library": "pytorch", "code_problem": "The task is to implement a function that computes a specific loss value based on the embeddings of queries and documents. The function is designed to facilitate training in a neural network context, particularly for tasks involving information retrieval or ranking.\n\nFunction signature:\n```python\ndef randneg_train(query_encode_func, doc_encode_func, input_query_ids, query_attention_mask, input_doc_ids,\n                  doc_attention_mask, other_doc_ids, other_doc_attention_mask):\n```\n\nConstant used in the main code:\n- The constant `-1.0` is used to negate the log softmax values to compute the loss.\n\nInput format:\n- `query_encode_func`: A function that encodes query IDs into embeddings.\n- `doc_encode_func`: A function that encodes document IDs into embeddings.\n- `input_query_ids`: A tensor containing the IDs of the input queries.\n- `query_attention_mask`: A tensor indicating which tokens in the query should be attended to.\n- `input_doc_ids`: A tensor containing the IDs of the input documents.\n- `doc_attention_mask`: A tensor indicating which tokens in the document should be attended to.\n- `other_doc_ids`: A tensor containing the IDs of other documents for negative sampling.\n- `other_doc_attention_mask`: A tensor indicating which tokens in the other documents should be attended to.\n\nOutput format:\n- The function returns a single scalar value representing the average loss computed from the positive and other document scores.\n\n**Input:**\n```python\nimport torch\n\n# Sample input data\ninput_query_ids = torch.tensor([[1, 2, 3], [4, 5, 6]])\nquery_attention_mask = torch.tensor([[1, 1, 1], [1, 1, 1]])\ninput_doc_ids = torch.tensor([[7, 8, 9], [10, 11, 12]])\ndoc_attention_mask = torch.tensor([[1, 1, 1], [1, 1, 1]])\nother_doc_ids = torch.tensor([[[13, 14, 15], [16, 17, 18]], [[19, 20, 21], [22, 23, 24]]])\nother_doc_attention_mask = torch.tensor([[[1, 1, 1], [1, 1, 1]], [[1, 1, 1], [1, 1, 1]]])\n\n# Assuming query_encode_func and doc_encode_func are defined and return fixed embeddings\ndef mock_encode(input_ids, attention_mask):\n    return torch.sum(input_ids * attention_mask, dim=1, keepdim=True).float()\n\n# Call the function\nloss = randneg_train(mock_encode, mock_encode, input_query_ids, query_attention_mask,\n                     input_doc_ids, doc_attention_mask, other_doc_ids, other_doc_attention_mask)\n```\n\n**Output:**\n```python\ntensor(263.2500)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef randneg_train(query_encode_func, doc_encode_func, input_query_ids, query_attention_mask, input_doc_ids,\n                  doc_attention_mask, other_doc_ids, other_doc_attention_mask):\n\n    query_embs = query_encode_func(input_query_ids, query_attention_mask)\n    doc_embs = doc_encode_func(input_doc_ids, doc_attention_mask)\n\n    batch_scores = torch.matmul(query_embs, doc_embs.T)\n    single_positive_scores = torch.diagonal(batch_scores, 0)\n\n    other_doc_num = other_doc_ids.shape[0] * other_doc_ids.shape[1]\n    other_doc_ids = other_doc_ids.reshape(other_doc_num, -1)\n    other_doc_attention_mask = other_doc_attention_mask.reshape(other_doc_num, -1)\n\n    other_doc_embs = doc_encode_func(other_doc_ids, other_doc_attention_mask)\n    other_batch_scores = torch.matmul(query_embs, other_doc_embs.T)\n    other_batch_scores = other_batch_scores.reshape(-1)\n\n    positive_scores = single_positive_scores.reshape(-1, 1).repeat(1, other_doc_num).reshape(-1)\n    other_logit_matrix = torch.cat([positive_scores.unsqueeze(1), other_batch_scores.unsqueeze(1)], dim=1)\n\n    other_lsm = F.log_softmax(other_logit_matrix, dim=1)\n    other_loss = -1.0 * other_lsm[:, 0]\n\n    second_loss, second_num = other_loss.sum(), len(other_loss)\n\n    return second_loss / second_num", "test_script": "import torch\nimport torch.nn as nn\n\n\ndef test_case_input_generator(n=200):\n    class SimpleEncoder(nn.Module):\n        def __init__(self, vocab_size=100, embed_dim=64, hidden_dim=128):\n            super(SimpleEncoder, self).__init__()\n            self.embedding = nn.Embedding(vocab_size, embed_dim)\n            self.fc = nn.Linear(embed_dim, hidden_dim)\n            self.activation = nn.ReLU()\n\n        def forward(self, input_ids, attention_mask):\n            embeddings = self.embedding(input_ids)\n            masked_embeddings = embeddings * attention_mask.unsqueeze(-1)\n            pooled_output = masked_embeddings.mean(dim=1)\n            return self.activation(self.fc(pooled_output))\n\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = torch.randint(2, 10, (1,)).item()\n        seq_length = torch.randint(5, 20, (1,)).item()\n        vocab_size = 100\n        embed_dim = torch.randint(16, 64, (1,)).item()\n        hidden_dim = torch.randint(32, 128, (1,)).item()\n        num_other_docs = torch.randint(2, 5, (1,)).item()\n\n        input_query_ids = torch.randint(0, vocab_size, (batch_size, seq_length))\n        query_attention_mask = torch.randint(0, 2, (batch_size, seq_length))\n\n        input_doc_ids = torch.randint(0, vocab_size, (batch_size, seq_length))\n        doc_attention_mask = torch.randint(0, 2, (batch_size, seq_length))\n\n        other_doc_ids = torch.randint(0, vocab_size, (batch_size, num_other_docs, seq_length))\n        other_doc_attention_mask = torch.randint(0, 2, (batch_size, num_other_docs, seq_length))\n\n\n        query_encoder = SimpleEncoder(vocab_size, embed_dim, hidden_dim)\n        doc_encoder = SimpleEncoder(vocab_size, embed_dim, hidden_dim)\n\n        test_cases.append((query_encoder, doc_encoder, input_query_ids, query_attention_mask,\n                           input_doc_ids, doc_attention_mask, other_doc_ids, other_doc_attention_mask))\n\n    return test_cases"}
{"problem_id": "pytorch_46", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs random masking on a 3D tensor. The function will take a tensor and a mask ratio as inputs, and it will return a masked version of the tensor along with a mask and the indices used to restore the original order of the tensor.\n\nFunction signature:\n```python\ndef random_masking(x: torch.Tensor, mask_ratio: float) -> Tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n```\n\nConstant used in the main code:\n- The constant used in the main code is derived from the input `mask_ratio`, which determines the proportion of elements to be masked in the input tensor.\n\nInput format:\n- The input consists of a 3D tensor `x` of shape `(N, L, D)` and a float `mask_ratio`.\n\nOutput format:\n- The output is a tuple containing:\n  - A 3D tensor `x_masked` of shape `(N, len_keep, D)`,\n  - A 2D tensor `mask` of shape `(N, L)`,\n  - A 2D tensor `ids_restore` of shape `(N, L)`.\n\nInput:\n```python\nx = torch.tensor([[[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0]], \n                   [[1.1, 1.2], [1.3, 1.4], [1.5, 1.6], [1.7, 1.8], [1.9, 2.0]]])\nmask_ratio = 0.4\n```\n\nOutput:\n```python\nx_masked = torch.tensor([[[0.9000, 1.0000],\n                           [0.7000, 0.8000],\n                           [0.3000, 0.4000]],\n                          [[1.3000, 1.4000],\n                           [1.1000, 1.2000],\n                           [1.9000, 2.0000]]])\nmask = torch.tensor([[1., 0., 1., 0., 0.],\n                    [0., 0., 1., 1., 0.]])\nids_restore = torch.tensor([[4, 2, 3, 1, 0],\n                            [1, 0, 3, 4, 2]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef random_masking(x, mask_ratio):\n    (N, L, D) = x.shape\n    len_keep = int(L * (1 - mask_ratio))\n\n    noise = torch.rand(N, L)\n    ids_shuffle = torch.argsort(noise, dim=1)\n    ids_restore = torch.argsort(ids_shuffle, dim=1)\n    ids_keep = ids_shuffle[:, :len_keep]\n\n    x_masked = torch.gather(x, dim=1, index=ids_keep.unsqueeze(-1).repeat(1, 1, D))\n\n    mask = torch.ones([N, L])\n    mask[:, :len_keep] = 0\n    mask = torch.gather(mask, dim=1, index=ids_restore)\n\n    return (x_masked, mask, ids_restore)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        N = random.randint(1, 10)\n        L = random.randint(5, 100)\n        D = random.randint(1, 50)\n        mask_ratio = round(random.uniform(0.1, 0.9), 2)\n        x = torch.rand(N, L, D)\n        test_cases.append((x, mask_ratio))\n\n    return test_cases"}
{"problem_id": "pytorch_47", "library": "pytorch", "code_problem": "The task is to implement a function that computes a cost based on two probability distributions and their associated transformations. The function signature is as follows:\n\n```python\ndef compute_ugw_cost(pi, gamma, a, dx, b, dy, eps, rho, rho2):\n```\n\n### Constants Used:\n- A small constant `1e-10` is used in the computation of the Kullback-Leibler divergence to prevent division by zero.\n\n### Input Format:\n- The function takes the following inputs:\n  - `pi`: A tensor of shape (m, n) representing the first probability distribution.\n  - `gamma`: A tensor of shape (m, n) representing the second probability distribution.\n  - `a`: A tensor of shape (m,) used for Kullback-Leibler divergence.\n  - `dx`: A tensor of shape (m, n) representing the transformation of `pi`.\n  - `b`: A tensor of shape (n,) used for Kullback-Leibler divergence.\n  - `dy`: A tensor of shape (m, n) representing the transformation of `gamma`.\n  - `eps`: A scalar value.\n  - `rho`: A scalar value.\n  - `rho2`: A scalar value.\n\n### Output Format:\n- The function returns a single scalar value representing the computed cost based on the input parameters.\n\n**Input:**\n```python\nimport torch\n\npi = torch.tensor([[0.1, 0.2], [0.3, 0.4]])\ngamma = torch.tensor([[0.2, 0.1], [0.4, 0.3]])\na = torch.tensor([0.5, 0.5])\nb = torch.tensor([0.5, 0.5])\ndx = torch.tensor([[0.0, 1.0], [1.0, 0.0]])\ndy = torch.tensor([[0.0, 1.0], [1.0, 0.0]])\neps = 0.1\nrho = float('inf')\nrho2 = float('inf')\n```\n\n**Output:**\n```python\ncost = compute_ugw_cost(pi, gamma, a, dx, b, dy, eps, rho, rho2)\n# tensor(0.5213)\n```\n", "ground_truth_code": "import torch\n\n\ndef compute_l2_distortion(pi, gamma, dx, dy):\n    dist_xx = torch.einsum('jk,j,k', dx ** 2, pi.sum(dim=1), gamma.sum(dim=1))\n    dist_yy = torch.einsum('jk,j,k', dy ** 2, pi.sum(dim=0), gamma.sum(dim=0))\n    dist_xy = torch.sum(torch.einsum('ij,jl->il', dx, pi) * torch.einsum('ij,jl->il', gamma, dy))\n\n    return dist_xx + dist_yy - 2 * dist_xy\n\n\ndef compute_quad_kl_divergence(pi, gamma, reference):\n    mass_pi, mass_gamma = pi.sum(), gamma.sum()\n    kl_term_pi = torch.sum(pi * (pi / reference + 1e-10).log())\n    kl_term_gamma = torch.sum(gamma * (gamma / reference + 1e-10).log())\n\n    return mass_gamma * kl_term_pi + mass_pi * kl_term_gamma - mass_pi * mass_gamma + reference.sum() ** 2\n\n# main code\ndef compute_ugw_cost(pi, gamma, a, dx, b, dy, eps, rho, rho2):\n    cost = compute_l2_distortion(pi, gamma, dx, dy) \\\n           + eps * compute_quad_kl_divergence(pi, gamma, a[:, None] * b[None, :])\n    if rho < float('inf'):\n        cost += rho * compute_quad_kl_divergence(torch.sum(pi, dim=1), torch.sum(gamma, dim=1), a)\n    if rho2 < float('inf'):\n        cost += rho2 * compute_quad_kl_divergence(torch.sum(pi, dim=0), torch.sum(gamma, dim=0), b)\n    return cost\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = random.randint(5, 20)  # Random size for axis 1\n        n = random.randint(5, 20)  # Random size for axis 2\n\n        pi = torch.rand((m, n))\n        gamma = torch.rand((m, n))\n        a = torch.rand(m)\n        b = torch.rand(n)\n        dx = torch.rand((m, m))  # Distance matrix for x\n        dy = torch.rand((n, n))  # Distance matrix for y\n        eps = torch.rand(1).item() * 10  # Small positive value\n        rho = random.choice([float('inf'), torch.rand(1).item() * 10])\n        rho2 = random.choice([float('inf'), torch.rand(1).item() * 10])\n\n        test_cases.append((pi, gamma, a, dx, b, dy, eps, rho, rho2))\n\n    return test_cases"}
{"problem_id": "pytorch_48", "library": "pytorch", "code_problem": "You are tasked with implementing a function that rectifies an affine transformation matrix to ensure that the \"up\" direction remains consistent. The function will take a batch of affine transformation matrices and return a modified version of these matrices that preserves the upward direction.\n\nFunction signature:\n```python\ndef rectifyAffineTransformationUpIsUp(A: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `1e-10`: This small constant is added to the determinant calculation to prevent division by zero and ensure numerical stability.\n\nInput format:\n- The input to the function is a 3-dimensional tensor `A` of shape `(N, 2, 2)`, where `N` is the number of affine transformation matrices.\n\nOutput format:\n- The output of the function is a 3-dimensional tensor of the same shape `(N, 2, 2)`, representing the rectified affine transformation matrices.\n\nInput:\n```python\ntensor([[[-0.1234,  0.5678],\n         [ 0.9101, -0.2345]],\n\n        [[ 0.3456, -0.7890],\n         [ 0.1234,  0.5678]]])\n```\n\nOutput:\n```python\ntensor([[[ 0.8319,  0.0000],\n         [-0.6048,  1.2020]],\n        [[ 1.5897,  0.0000],\n         [-0.8685,  0.6290]]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef rectifyAffineTransformationUpIsUp(A):\n    det = torch.sqrt(torch.abs(A[:, 0, 0] * A[:, 1, 1] - A[:, 1, 0] * A[:, 0, 1] + 1e-10))\n    norm_col1 = torch.sqrt(A[:, 0, 0] ** 2 + A[:, 0, 1] ** 2)\n    row1 = torch.cat([(norm_col1 / det).view(-1, 1, 1), torch.zeros_like(det).view(-1, 1, 1)], dim=2)\n    row2 = torch.cat([\n        ((A[:, 1, 1] * A[:, 0, 1] + A[:, 1, 0] * A[:, 0, 0]) / (norm_col1 * det)).view(-1, 1, 1),\n        (det / norm_col1).view(-1, 1, 1)\n    ], dim=2)\n    return torch.cat([row1, row2], dim=1)", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        A = torch.randn(batch_size, 2, 2)\n        test_cases.append(A)\n    return test_cases"}
{"problem_id": "pytorch_49", "library": "pytorch", "code_problem": "You are tasked with implementing a function that categorizes relative positions into discrete buckets based on their values. The function should take into account whether the positions are bidirectional and should handle a maximum distance for scaling the bucket assignment.\n\nFunction signature:\n```python\ndef relative_position_bucket(relative_position: torch.Tensor, bidirectional: bool, num_buckets: int, max_distance: int) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- `math.log`: This constant is used to compute the logarithm for scaling the bucket assignment based on the maximum distance.\n\nInput format:\n- `relative_position`: A tensor of integers representing the relative positions.\n- `bidirectional`: A boolean indicating whether the positions are bidirectional.\n- `num_buckets`: An integer representing the total number of buckets to categorize the positions.\n- `max_distance`: An integer representing the maximum distance for scaling.\n\nOutput format:\n- A tensor of integers representing the bucket assignments corresponding to the input `relative_position`.\n\nInput:\n```python\nrelative_position = torch.tensor([[0, -1, 2], [3, 0, -4], [-5, 6, 0]])\nbidirectional = True\nnum_buckets = 16\nmax_distance = 100\n```\n\nOutput:\n```python\ntensor([[ 0,  1, 10],\n        [11,  0,  4],\n        [ 4, 12,  0]])\n```", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef relative_position_bucket(relative_position, bidirectional, num_buckets, max_distance):\n    ret = 0\n    if bidirectional:\n        num_buckets //= 2\n        ret += (relative_position > 0).long() * num_buckets\n        n = torch.abs(relative_position)\n    else:\n        n = torch.max(-relative_position, torch.zeros_like(relative_position))\n    max_exact = num_buckets // 2\n    is_small = n < max_exact\n    val_if_large = max_exact + (torch.log(n.float() / max_exact) / math.log(max_distance / max_exact) * (num_buckets - max_exact)).to(torch.long)\n    val_if_large = torch.min(val_if_large, torch.full_like(val_if_large, num_buckets - 1))\n    ret += torch.where(is_small, n, val_if_large)\n    return ret", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        seq_len = random.randint(1, 512)\n        shape = (seq_len, seq_len)\n        relative_position = torch.randint(-seq_len, seq_len, shape)\n        bidirectional = random.choice([True, False])\n        num_buckets = random.choice([8, 16, 32, 64, 128])\n        max_distance = random.choice([10, 50, 100, 200, 500])\n        test_cases.append((relative_position, bidirectional, num_buckets, max_distance))\n\n    return test_cases"}
{"problem_id": "pytorch_50", "library": "pytorch", "code_problem": "```python\ndef mask_tokens(inputs: torch.Tensor, special_tokens_mask: torch.Tensor, config: Any, tokenizer: Any) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nIn this code, the function `mask_tokens` is designed to randomly mask tokens in a given input tensor, which is typically used in training language models. The function takes four parameters: `inputs`, `special_tokens_mask`, `config`, and `tokenizer`. \n\n### Constant Used:\n- `config.mlm_prob`: This constant represents the probability of masking a token in the input tensor.\n\n### Input and Output Format:\n- **Input**: \n  - `inputs`: A tensor of shape (batch_size, sequence_length) containing token IDs.\n  - `special_tokens_mask`: A tensor of shape (batch_size, sequence_length) indicating special tokens (optional).\n  - `config`: An object containing configuration parameters, including `mlm_prob`.\n  - `tokenizer`: An object that provides methods for tokenization and special token handling.\n\n- **Output**: \n  - A tuple containing:\n    - `inputs`: The modified tensor with some tokens masked or replaced.\n    - `labels`: The tensor indicating which tokens were masked, with unmasked tokens set to `-100`.\n\n**Input:**\n```python\ninputs = torch.tensor([[5, 0, 12, 101, 34], [2, 15, 102, 8, 0]])\nspecial_tokens_mask = None\nconfig = MockConfig(mlm_prob=0.15)\ntokenizer = MockTokenizer()\n```\n\n**Output:**\n```python\nmasked_inputs, labels = mask_tokens(inputs, special_tokens_mask, config, tokenizer)\n\n# Example Output (actual values may vary due to randomness):\nmasked_inputs = tensor([[  5,   0,  12, 101,  34],\n        [  2,  15, 102,   8,   0]])\nlabels = tensor([[-100, -100, -100, -100, -100],\n        [-100, -100, -100, -100, -100]])\n```\n", "ground_truth_code": "import torch\n\n# main code \ndef mask_tokens(inputs, special_tokens_mask, config, tokenizer):\n    labels = inputs.clone()\n    probability_matrix = torch.full(labels.shape, config.mlm_prob)\n\n    if special_tokens_mask is None:\n        special_tokens_mask = [\n            tokenizer.get_special_tokens_mask(val, already_has_special_tokens=True)\n            for val in labels.tolist()\n        ]\n        special_tokens_mask = torch.tensor(special_tokens_mask, dtype=torch.bool)\n    else:\n        special_tokens_mask = special_tokens_mask.bool()\n\n    probability_matrix.masked_fill_(special_tokens_mask, value=0.0)\n    probability_matrix[torch.where(inputs == 0)] = 0.0\n    masked_indices = torch.bernoulli(probability_matrix).bool()\n    labels[~masked_indices] = -100\n\n    indices_replaced = torch.bernoulli(torch.full(labels.shape, 0.8)).bool() & masked_indices\n    inputs[indices_replaced] = tokenizer.mask_token_id\n\n    indices_random = torch.bernoulli(\n        torch.full(labels.shape, 0.5)).bool() & masked_indices & ~indices_replaced\n    random_words = torch.randint(len(tokenizer), labels.shape, dtype=torch.long)\n\n    inputs[indices_random] = random_words[indices_random]\n\n    return inputs, labels", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    class MockTokenizer:\n        def __init__(self, vocab_size=30522, mask_token_id=103):\n            self.vocab_size = vocab_size\n            self.mask_token_id = mask_token_id\n\n        def get_special_tokens_mask(self, val, already_has_special_tokens=True):\n            return [1 if x in {0, 101, 102} else 0 for x in val]\n\n        def __len__(self):\n            return self.vocab_size\n\n    class MockConfig:\n        def __init__(self, mlm_prob=0.15):\n            self.mlm_prob = mlm_prob\n\n    test_cases = []\n    tokenizer = MockTokenizer()\n    config = MockConfig()\n\n    for _ in range(n):\n        seq_length = random.randint(5, 128)\n        batch_size = random.randint(1, 16)\n\n        inputs = torch.randint(0, tokenizer.vocab_size, (batch_size, seq_length), dtype=torch.long)\n        special_tokens_mask = torch.randint(0, 2, (batch_size, seq_length),\n                                            dtype=torch.long) if random.random() > 0.5 else None\n\n        test_cases.append((inputs, special_tokens_mask, config, tokenizer))\n\n    return test_cases"}
{"problem_id": "pytorch_51", "library": "pytorch", "code_problem": "You are tasked with implementing a function that aggregates clusters of data based on their scores. The function will utilize a scoring mechanism defined by a neural network module to evaluate the data points. The aggregation will be performed using a maximum pooling operation.\n\nFunction signature:\n```python\ndef agg_k_cluster_by_score(data: torch.Tensor, score_fc: nn.Module, k_agg: int) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `k_agg`: This is the number of clusters to aggregate the data into.\n\nInput format:\n- `data`: A PyTorch tensor of shape (N, D), where N is the number of data points and D is the dimensionality of each data point.\n- `score_fc`: A neural network module that takes in a tensor of shape (N, D) and outputs a tensor of shape (N, 1) representing the scores.\n- `k_agg`: An integer representing the number of clusters to aggregate.\n\nOutput format:\n- The function returns a PyTorch tensor of shape (k_agg, D), representing the aggregated clusters based on the top scores.\n\nInput:\n```python\ndata = torch.tensor([[0.5, 0.2, 0.1],\n                     [0.1, 0.4, 0.3],\n                     [0.3, 0.8, 0.6],\n                     [0.9, 0.7, 0.5],\n                     [0.2, 0.3, 0.4]])\nscore_fc = nn.Linear(3, 1)\nk_agg = 2\n```\n\nOutput:\n```python\ntensor([[0.5000, 0.8000, 0.6000],\n        [0.9000, 0.7000, 0.5000]])\n``` \n", "ground_truth_code": "import torch\nimport torch.nn as nn\n\n# main code\ndef agg_k_cluster_by_score(data: torch.Tensor, score_fc: nn.Module, k_agg):\n    num_elements = data.shape[0]\n    score = score_fc(data)\n    (top_score, top_idx) = torch.topk(score, k=num_elements, dim=0)\n    data_sorted = torch.zeros_like(data)\n    data_sorted.index_copy_(dim=0, index=top_idx[:, 0], source=data)\n    data_sorted = torch.transpose(data_sorted, 1, 0)\n    data_sorted = data_sorted.unsqueeze(1)\n    agg_result = nn.functional.adaptive_max_pool1d(data_sorted, k_agg)\n    agg_result = agg_result.squeeze(1)\n    agg_result = torch.transpose(agg_result, 1, 0)\n    return agg_result", "test_script": "import torch\nimport torch.nn as nn\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_elements = random.randint(5, 50)\n        feature_dim = random.randint(3, 20)\n        data = torch.randn(num_elements, feature_dim)\n        score_fc = nn.Linear(feature_dim, 1)\n        k_agg = random.randint(1, num_elements)\n        test_cases.append((data, score_fc, k_agg))\n\n    return test_cases"}
{"problem_id": "pytorch_52", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a relative shift on a 4-dimensional tensor. The function should allow for an optional parameter that determines whether to zero out the upper triangular part of the resulting tensor.\n\nFunction signature:\n```python\ndef rel_shift(x: torch.Tensor, zero_triu: bool) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to create a zero-padding tensor and to slice the tensor.\n\nInput format:\n- The function takes a 4-dimensional tensor `x` of shape (batch_size, channels, height, width) and a boolean `zero_triu`.\n\nOutput format:\n- The function returns a 4-dimensional tensor of the same shape as the input tensor `x`, with the relative shift applied and optionally zeroed out in the upper triangular part if `zero_triu` is `True`.\n\n```python\n# Input\nx = torch.tensor([[[[ 0.1234, -0.5678,  0.9101],\n                    [ 0.2345,  0.6789, -0.1234]],\n                   [[-0.3456,  0.4567,  0.7890],\n                    [ 0.8901, -0.2345,  0.3456]]]], dtype=torch.float32)\nzero_triu = True\n\n# Output\ntensor([[[[-0.5678,  0.9101,  0.0000],\n          [ 0.2345,  0.6789, -0.1234]],\n         [[ 0.4567,  0.7890,  0.0000],\n          [ 0.8901, -0.2345,  0.3456]]]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef rel_shift(x, zero_triu):\n    zero_pad = torch.zeros((x.size()[0], x.size()[1], x.size()[2], 1), device=x.device, dtype=x.dtype)\n    x_padded = torch.cat([zero_pad, x], dim=-1)\n    x_padded = x_padded.view(x.size()[0], x.size()[1], x.size(3) + 1, x.size(2))\n    x = x_padded[:, :, 1:].view_as(x)\n    if zero_triu:\n        ones = torch.ones((x.size(2), x.size(3)))\n        x = x * torch.tril(ones, x.size(3) - x.size(2))[None, None, :, :]\n    return x", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        num_heads = random.randint(1, 16)\n        seq_len_q = random.randint(1, 128)\n        seq_len_k = random.randint(1, 128)\n        zero_triu = random.choice([True, False])\n\n        x = torch.randn(batch_size, num_heads, seq_len_q, seq_len_k)\n        test_cases.append((x, zero_triu))\n    return test_cases"}
{"problem_id": "pytorch_53", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates two types of similarity measures between two sets of vectors. The first measure is the average reflection similarity within the first set of vectors, and the second measure is the average distance between the two sets of vectors.\n\nFunction signature:\n```python\ndef calculate_distance(z1: torch.Tensor, z2: torch.Tensor) -> tuple\n```\n\nConstant used in the main code:\n- The constant used in the main code is `num_nodes`, which represents the number of vectors in the first set `z1`.\n\nInput format:\n- The function takes two inputs:\n  - `z1`: A 2D tensor of shape (num_nodes, vector_dimension) representing the first set of vectors.\n  - `z2`: A 2D tensor of shape (num_nodes, vector_dimension) representing the second set of vectors.\n\nOutput format:\n- The function returns a tuple containing:\n  - `refl_sim`: A float representing the average reflection similarity within the first set of vectors.\n  - `between_sim`: A float representing the average distance between the two sets of vectors.\n\nInput:\n```python\nz1 = torch.tensor([[0.1, 0.2, 0.3],\n                   [0.4, 0.5, 0.6],\n                   [0.7, 0.8, 0.9]])\nz2 = torch.tensor([[0.9, 0.8, 0.7],\n                   [0.6, 0.5, 0.4],\n                   [0.3, 0.2, 0.1]])\n```\n\nOutput:\n```python\n(refl_sim, between_sim) = calculate_distance(z1, z2)\n# (tensor(0.6928), tensor(0.8123))\n``` \n", "ground_truth_code": "import torch\n\ndef sim_d(z1, z2):\n    return torch.sqrt(torch.sum(torch.pow(z1 - z2, 2), 1))\n\n# main code\ndef calculate_distance(z1, z2):\n    num_nodes = z1.size(0)\n    refl_sim = 0\n    for i in range(num_nodes):\n        refl_sim += (torch.sum(sim_d(z1[i:i + 1], z1)) - torch.squeeze(sim_d(z1[i:i + 1], z1[i:i + 1]))) / (num_nodes - 1)\n    refl_sim = refl_sim / num_nodes\n    between_sim = torch.sum(sim_d(z1, z2)) / num_nodes\n    return (refl_sim, between_sim)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_nodes = random.randint(5, 50)  # Random number of nodes\n        feature_dim = random.randint(3, 100)  # Random feature dimension\n\n        z1 = torch.rand((num_nodes, feature_dim))  # Generate random tensor\n        z2 = torch.rand((num_nodes, feature_dim))  # Generate random tensor\n\n        test_cases.append((z1, z2))\n    return test_cases"}
{"problem_id": "pytorch_54", "library": "pytorch", "code_problem": "You are tasked with implementing the Viterbi algorithm, which is used for finding the most probable sequence of hidden states in a hidden Markov model (HMM) given a sequence of observed events. The algorithm utilizes dynamic programming to efficiently compute the best path through the state space.\n\nFunction signature:\n```python\ndef viterbi_decode(logits: torch.Tensor, transitions: torch.Tensor) -> Tuple[float, List[int]]:\n```\n\nIn this function, `logits` is a tensor representing the log probabilities of the observed events at each time step for each state, and `transitions` is a tensor representing the log probabilities of transitioning from one state to another.\n\n### Input and Output Format:\n- **Input**:\n  - `logits`: A tensor of shape (T, N) where T is the number of time steps and N is the number of states.\n  - `transitions`: A tensor of shape (N, N) representing the transition probabilities between states.\n\n- **Output**:\n  - A tuple containing:\n    - A float representing the maximum Viterbi score.\n    - A list of integers representing the indices of the most probable sequence of states.\n\nInput:\n```python\nlogits = torch.tensor([[0.5, 1.0], \n                       [1.5, 0.5], \n                       [0.0, 2.0]])\ntransitions = torch.tensor([[0.2, 0.8], \n                            [0.6, 0.4]])\n```\n\nOutput:\n```python\nviterbi_score = 5.899999618530273\nviterbi_path = [0, 1, 1]\n```", "ground_truth_code": "import torch\n\n# main code\ndef viterbi_decode(logits, transitions):\n    T, N = logits.shape\n    trellis = torch.zeros_like(logits)\n    backpointers = torch.zeros((T, N), dtype=torch.long)\n    trellis[0] = logits[0]\n    for t in range(1, T):\n        scores = trellis[t - 1].unsqueeze(1) + transitions\n        trellis[t], backpointers[t] = torch.max(scores, dim=0)\n        trellis[t] += logits[t]\n    viterbi_path = [torch.argmax(trellis[-1]).item()]\n    for t in range(T - 1, 0, -1):\n        viterbi_path.append(backpointers[t, viterbi_path[-1]].item())\n\n    viterbi_path.reverse()\n    viterbi_score = trellis[-1, viterbi_path[-1]].item()\n\n    return viterbi_score, viterbi_path", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        T = random.randint(2, 50)\n        N = random.randint(2, 20)\n        logits = torch.randn(T, N)\n        transitions = torch.randn(N, N)\n        test_cases.append((logits, transitions))\n\n    return test_cases"}
{"problem_id": "pytorch_55", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a single optimization step for a set of parameters using the Adam optimization algorithm with optional AMSBound. The function will update the parameters based on their gradients and various hyperparameters provided in the input.\n\nFunction signature:\n```python\ndef step(closure, param_groups, base_lrs):\n```\n\n### Constants Used:\n- `eps`: A small constant added to the denominator to prevent division by zero.\n- `beta1`: The exponential decay rate for the first moment estimates.\n- `beta2`: The exponential decay rate for the second moment estimates.\n- `gamma`: A hyperparameter that controls the learning rate adjustment.\n- `final_lr`: The final learning rate to be used in the update.\n\n### Input Format:\n- `closure`: A callable that returns the loss value (optional).\n- `param_groups`: A list of dictionaries, each containing:\n  - `params`: A list of parameters to be optimized.\n  - `amsbound`: A boolean indicating whether to use AMSBound.\n  - `betas`: A tuple of two floats for the decay rates (beta1, beta2).\n  - `weight_decay`: A float for weight decay.\n  - `lr`: A float for the learning rate.\n  - `final_lr`: A float for the final learning rate.\n  - `gamma`: A float for the gamma parameter.\n- `base_lrs`: A list of base learning rates corresponding to each parameter group.\n\n### Output Format:\n- Returns the computed loss value (if closure is provided) or `None`.\n\n**Input:**\n```python\nimport torch\n\n# Closure function\ndef closure():\n    return torch.tensor(5.0)\n\n# Parameter groups\nparam_groups = [{\n    'params': [torch.tensor([1.0, 2.0], requires_grad=True)],\n    'lr': 0.01,\n    'betas': (0.9, 0.999),\n    'eps': 1e-8,\n    'weight_decay': 0.01,\n    'gamma': 1.0,\n    'final_lr': 0.01,\n    'amsbound': False,\n    'state': {}\n}]\n\n# Base learning rates\nbase_lrs = [0.01]\n\n# Call the step function\nloss = step(closure, param_groups, base_lrs)\n```\n\n**Output:**\n```python\nloss = tensor(5.)\n```\n", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef step(closure, param_groups, base_lrs):\n    loss = None\n    if closure is not None:\n        loss = closure()\n\n    for (group, base_lr) in zip(param_groups, base_lrs):\n        for p in group['params']:\n            if p.grad is None:\n                continue\n\n            grad = p.grad.data\n            amsbound = group['amsbound']\n\n            if p not in group['state']:\n                group['state'][p] = {}\n                group['state'][p]['step'] = 0\n                group['state'][p]['exp_avg'] = torch.zeros_like(p.data)\n                group['state'][p]['exp_avg_sq'] = torch.zeros_like(p.data)\n                if amsbound:\n                    group['state'][p]['max_exp_avg_sq'] = torch.zeros_like(p.data)\n\n            state = group['state'][p]\n            exp_avg, exp_avg_sq = state['exp_avg'], state['exp_avg_sq']\n\n            if amsbound:\n                max_exp_avg_sq = state['max_exp_avg_sq']\n\n            beta1, beta2 = group['betas']\n            state['step'] += 1\n\n            if group['weight_decay'] != 0:\n                grad = grad.add(group['weight_decay'], p.data)\n\n            exp_avg.mul_(beta1).add_(grad, alpha=1 - beta1)\n            exp_avg_sq.mul_(beta2).addcmul_(grad, grad, value=1 - beta2)\n\n            if amsbound:\n                torch.max(max_exp_avg_sq, exp_avg_sq, out=max_exp_avg_sq)\n                denom = max_exp_avg_sq.sqrt().add_(group['eps'])\n            else:\n                denom = exp_avg_sq.sqrt().add_(group['eps'])\n\n            bias_correction1 = 1 - beta1 ** state['step']\n            bias_correction2 = 1 - beta2 ** state['step']\n\n            step_size = group['lr'] * math.sqrt(bias_correction2) / bias_correction1\n\n            final_lr = group['final_lr'] * group['lr'] / base_lr\n            lower_bound = final_lr * (1 - 1 / (group['gamma'] * state['step'] + 1))\n            upper_bound = final_lr * (1 + 1 / (group['gamma'] * state['step']))\n\n            step_size_tensor = torch.full_like(denom, step_size)\n            step_size_tensor.div_(denom).clamp_(lower_bound, upper_bound).mul_(exp_avg)\n\n            p.data.add_(-step_size_tensor)\n\n    return loss", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(random.randint(1, 10) for _ in range(random.randint(1, 4)))\n        params = [torch.randn(shape, requires_grad=True) for _ in range(random.randint(1, 3))]\n        for p in params:\n            p.grad = torch.randn_like(p)\n        param_groups = [{\n            'params': params,\n            'lr': random.uniform(0.001, 0.1),\n            'betas': (random.uniform(0.8, 0.999), random.uniform(0.8, 0.999)),\n            'eps': random.uniform(1e-8, 1e-4),\n            'weight_decay': random.uniform(0, 0.1),\n            'gamma': random.uniform(0.9, 1.1),\n            'final_lr': random.uniform(0.001, 0.1),\n            'amsbound': random.choice([True, False]),\n            'state': {}\n        }]\n        base_lrs = [group['lr'] for group in param_groups]\n        def closure():\n            return sum(p.sum() for p in params)\n        test_cases.append((closure, param_groups, base_lrs))\n    return test_cases"}
{"problem_id": "pytorch_56", "library": "pytorch", "code_problem": "You are tasked with implementing a function that generates a binary mask based on input data. The function processes the input tensor through a series of operations, including pooling, convolution, and weight manipulation, to create a mask that indicates which elements should be excluded.\n\nFunction signature:\n```python\ndef get_mask(data: torch.Tensor, mask_num: int) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `16`, which is the kernel size and stride for the average pooling operation.\n\nInput format:\n- `data`: A 4D tensor of shape (N, C, H, W), where N is the batch size, C is the number of channels, H is the height, and W is the width.\n- `mask_num`: An integer representing the number of elements to mask.\n\nOutput format:\n- A 2D boolean tensor of shape (1, 196), where each element indicates whether the corresponding index is included (True) or masked (False).\n\n**Input:**\n```python\ndata = torch.rand(1, 5, 224, 224)  # Random tensor with 5 channels\nmask_num = 10  # Number of elements to mask\n```\n\n**Output:**\n```python\nmask = tensor([[ True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True, False,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True, False,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True, False,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n         False,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True, False,  True,  True,  True,  True,\n          True,  True,  True, False,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True, False,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True, False,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True,  True,  True,  True,  True,\n          True, False, False,  True,  True,  True,  True,  True,  True,  True,\n          True,  True,  True,  True,  True,  True]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef get_mask(data, mask_num):\n    sumpool = torch.nn.AvgPool2d(16, stride=16, divisor_override=1)\n    data = sumpool(data)\n    data = data.sum(dim=1).unsqueeze(0)\n    conv2d = torch.nn.Conv2d(in_channels=1, out_channels=1, kernel_size=[3, 3], padding=1)\n    conv2d.weight.data = torch.Tensor([[[[-1, -1, -1], [-1, 8, -1], [-1, -1, -1]]]])\n    data_f = conv2d(data.to(torch.float32))\n    data_f[torch.where(data_f < 0)] = 0\n    weights = (data_f + data).squeeze().reshape(196)\n    output = torch.multinomial(weights, mask_num, replacement=False)\n    mask = torch.ones(196)\n    for i in range(mask_num):\n        mask[output[i]] = 0\n    return mask.unsqueeze(0).bool()", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        C = random.randint(1, 10)\n        data = torch.rand(1, C, 224, 224)\n        mask_num = random.randint(1, 196)\n\n        test_cases.append((data, mask_num))\n\n    return test_cases"}
{"problem_id": "pytorch_57", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes a specific logarithmic mask based on given shapes and presence values. The function will take in a shape tensor and a presence tensor, apply a series of transformations, and return a cumulative sum of logarithmic values.\n\nFunction signature:\n```python\ndef compute_log_mask(shp, pres, eps=1e-5):\n```\n\nConstant used in the main code:\n- `eps`: A small constant value set to `1e-5` to prevent numerical instability during logarithmic calculations.\n\nInput format:\n- The function takes two tensors: `shp` and `pres`, and an optional float `eps`.\n\nOutput format:\n- The function returns a tensor that represents the computed logarithmic mask.\n\nInput:\n```python\nshp = torch.tensor([[[0.5, 0.2], [0.3, 0.7]], [[0.1, 0.4], [0.6, 0.9]]])\npres = torch.tensor([[0.8, 0.6], [0.4, 0.2]])\neps = 1e-5\n```\n\nOutput:\n```python\ntensor([[[-0.9163, -1.8325],\n         [-1.7148, -0.8675]],\n        [[-3.7295, -2.0069],\n         [-2.3187, -2.2595]],\n        [[-0.5517, -0.3487],\n         [-0.3263, -0.7432]]])\n``` \n", "ground_truth_code": "import torch\n\n# main code\ndef compute_log_mask(shp, pres, eps=1e-5):\n    x = shp * pres[..., None] * (1 - 2 * eps) + eps\n    log_x = torch.log(x)\n    log1m_x = torch.log(1 - x)\n    zeros = torch.zeros([1, *x.shape[1:]], device=x.device)\n    return torch.cat([log_x, zeros]) + torch.cat([zeros, log1m_x]).cumsum(0)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly generate shape for `shp`\n        batch_size = random.randint(1, 10)  # Random batch size\n        seq_length = random.randint(1, 20)  # Random sequence length\n        feature_dim = random.randint(1, 10)  # Random feature dimension\n\n        shp = torch.rand(batch_size, seq_length, feature_dim)\n        pres = torch.rand(batch_size, seq_length)  # Matching first two dimensions of `shp`\n        eps = 1e-5\n\n        test_cases.append((shp, pres, eps))\n    return test_cases"}
{"problem_id": "pytorch_58", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes audio features using a neural network architecture. The function takes in several tensors representing audio features and model parameters, and it computes a prediction based on these inputs.\n\nFunction signature:\n```python\ndef forward(mel: torch.Tensor, positive: torch.Tensor, negative: torch.Tensor, res: Callable[[torch.Tensor], torch.Tensor], psi: Callable[[torch.Tensor], torch.Tensor], phi: Callable[[torch.Tensor], torch.Tensor]) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- There are no explicit constants defined in the code, but the operations performed are based on the dimensions of the input tensors.\n\nInput format:\n- `mel`: A tensor of shape (batch_size, mel_features).\n- `positive`: A tensor of shape (batch_size, positive_features).\n- `negative`: A tensor of shape (batch_size, negative_features).\n- `res`: A callable function that takes a tensor and returns a tensor.\n- `psi`: A callable function that takes a tensor and returns a tensor.\n- `phi`: A callable function that takes a tensor and returns a tensor.\n\nOutput format:\n- The function returns a tensor of shape (batch_size,).\n\nInput:\nmel = tensor([[-0.5766,  0.0568, -1.5580,  0.2072, -0.5188,  0.5632,  0.5075, -0.5978,\n          0.8095, -1.6190, -0.1106, -0.0883,  0.6376, -1.3206,  0.9506, -1.5893]])\npositive = tensor([[ 0.5974,  2.1417, -1.1396, -0.5232]])\nnegative = tensor([[0.7878, 0.0204, 0.5207, 0.9698]])\nres = Linear(in_features=4, out_features=4, bias=False)\npsi = Linear(in_features=4, out_features=4, bias=False)\nphi = Linear(in_features=16, out_features=4, bias=False)\n\nOutput:\ntensor([[-0.5379, -0.8833, -0.8011, -0.8011]], grad_fn=<SqueezeBackward1>)", "ground_truth_code": "import torch\n\n# main code\ndef forward(mel, positive, negative, res, psi, phi):\n    pred1 = psi(phi(mel))\n    pred = res(phi(mel)).unsqueeze(2)  # Ensure pred is 3D\n    pred2 = torch.bmm(positive.unsqueeze(1), pred)  # [batch_size, 1, 1]\n    pred3 = torch.bmm(negative.unsqueeze(1), pred)  # [batch_size, 1, 1]\n    result = pred1 + pred2 - pred3\n    result = result.squeeze(1)  # Remove unnecessary dimension\n    return result", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 16)  # Random batch size\n        mel_dim = random.randint(64, 128)  # Mel spectrogram feature dimension\n        hidden_dim = random.randint(32, 64)  # Hidden dimension for transformations\n\n        # Generate random tensors with matching dimensions\n        mel = torch.randn(batch_size, mel_dim)  # Input mel spectrogram\n        positive = torch.randn(batch_size, hidden_dim)  # Positive sample\n        negative = torch.randn(batch_size, hidden_dim)  # Negative sample\n        res = torch.nn.Linear(hidden_dim, hidden_dim, bias=False)  # Residual function\n        psi = torch.nn.Linear(hidden_dim, hidden_dim, bias=False)  # Transformation psi\n        phi = torch.nn.Linear(mel_dim, hidden_dim, bias=False)  # Transformation phi\n\n        test_cases.append((mel, positive, negative, res, psi, phi))\n\n    return test_cases"}
{"problem_id": "pytorch_59", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes a loss weight based on various types of actions and specified parameters. The function will take in a tensor of target actions and return a tensor of computed weights based on the specified loss weight type.\n\nFunction signature:\n```python\ndef compute_loss_weight(target_actions, loss_weight_max, loss_weight_min, loss_weight_type, out_final):\n```\n\nConstants used in the main code:\n- `TH = 0.3`: This constant is used in the 'nonlinear' loss weight type to define a threshold for action values.\n\nInput format:\n- `target_actions`: A 3D tensor of shape (batch_size, num_actions, 2) where the last dimension contains steering and throttle actions.\n- `loss_weight_max`: A float value.\n- `loss_weight_min`: A float value.\n- `loss_weight_type`: A string indicating the type of weight calculation.\n- `out_final`: An integer indicating the desired output dimension.\n\nOutput format:\n- The function returns a tensor of weights with shape (batch_size, num_actions, out_final).\n\nInput:\n```python\ntarget_actions = torch.tensor([[[ 0.3, 0.7],\n                                 [-0.5, 0.2],\n                                 [ 0.1, -0.9]]])  # Shape: (1, 3, 2)\n\nloss_weight_max = 1.5\nloss_weight_min = 0.3\nloss_weight_type = 'med'\nout_final = 2\n```\n\nOutput:\n```python\nweight = torch.tensor([[[1.1000, 1.1000],\n                        [0.7000, 0.7000],\n                        [1.2000, 1.2000]]])\n\n```", "ground_truth_code": "import torch\n\n# main code\ndef compute_loss_weight(target_actions, loss_weight_max, loss_weight_min, loss_weight_type, out_final):\n    abs_actions = torch.abs(target_actions)\n    weight = None\n    if loss_weight_type == 'max':\n        scale = (loss_weight_max - loss_weight_min) / 2.0\n        sum_abs_actions = (abs_actions[:, :, 0] + abs_actions[:, :, 1]) * scale\n        weight = sum_abs_actions + loss_weight_min\n\n    elif loss_weight_type == 'med':\n        abs_steering = 1.0 - torch.abs(0.5 - abs_actions[:, :, 0])\n        abs_throttle = (abs_actions[:, :, 1] > 0.5).float() * 0.5\n        abs_throttle = torch.max(abs_actions[:, :, 1], abs_throttle) * 2.0\n        weight = 0.5 * (abs_throttle + abs_steering)\n\n    elif loss_weight_type == 'throttle':\n        scale = loss_weight_max - loss_weight_min\n        weight = abs_actions[:, :, 1]* scale + loss_weight_min\n\n    elif loss_weight_type == 'nonlinear':\n        TH = 0.3\n        scale = (loss_weight_max - loss_weight_min) / TH\n        fmask1 = (abs_actions[:, :, 1] >= TH).float()\n        fmask2 = (abs_actions[:, :, 1] < TH).float()\n        weight = torch.max(fmask1 * TH, abs_actions[:, :, 1] * fmask2) * scale + loss_weight_min\n\n    elif loss_weight_type == 'steer':\n        weight = torch.ones_like(abs_actions)\n        weight[:, :, 1] = 0.0\n\n    else:\n        pass\n\n    if loss_weight_type != 'steer':\n        weight = weight.unsqueeze(-1).expand(-1, -1, out_final)\n\n    return weight\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        seq_len = random.randint(1, 10)\n        out_final = random.randint(1, 5)\n        target_actions = torch.rand(batch_size, seq_len, 2) * 2 - 1\n        loss_weight_max = random.uniform(0.5, 2.0)\n        loss_weight_min = random.uniform(0.1, 0.5)\n        loss_weight_type = random.choice(['max', 'med', 'throttle', 'nonlinear', 'steer'])\n\n        test_case = (target_actions, loss_weight_max, loss_weight_min, loss_weight_type, out_final)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "pytorch_60", "library": "pytorch", "code_problem": "You are tasked with implementing a function that evaluates a machine learning model on a test dataset. The function will compute the average loss and accuracy of the model over the test dataset, which is provided in batches. The function signature is as follows:\n\n```python\ndef evaluate(model, test_iter, loss_fn):\n```\n\nIn this function, the constant used is `32`, which represents the expected batch size for the inputs.\n\nInput format:\n- `model`: A PyTorch model that takes input tensors and produces output predictions.\n- `test_iter`: An iterable that yields batches of data, where each batch contains a tuple of `text` (input features) and `label` (true labels).\n- `loss_fn`: A loss function that computes the loss between the model's predictions and the true labels.\n\nOutput format:\n- A tuple containing two float values: the average loss and the average accuracy of the model over the evaluated batches.\n\nInput:\n```python\nmodel = MockModel(input_dim=300, output_dim=2)\ntest_iter = [BatchWrapper(torch.randn(32, 300), torch.randint(0, 2, (32,)))]\nloss_fn = nn.CrossEntropyLoss()\n```\n\nOutput:\n```python\n(epoch_loss, epoch_accuracy) = evaluate(model, test_iter, loss_fn)\n(epoch_loss, epoch_accuracy) = (0.760284960269928, 56.25)\n```", "ground_truth_code": "import torch\n\n# main code\ndef evaluate(model, test_iter, loss_fn):\n    epoch_loss, epoch_accuracy = 0.0, 0.0\n    model.eval()\n    steps = 0\n    with torch.no_grad():\n        for idx, batch in enumerate(test_iter):\n            inputs, targets = batch.text[0], batch.label\n            if inputs.size(0) != 32:\n                continue\n            likelihood = model(inputs)\n            loss = loss_fn(likelihood, targets)\n            epoch_loss += loss.item()\n            num_corrects = (torch.max(likelihood, 1)[1].view(targets.size()) == targets).float().sum()\n            acc = 100.0 * num_corrects / len(batch)\n            epoch_accuracy += acc.item()\n            steps += 1\n    return (epoch_loss / steps, epoch_accuracy / steps) if steps > 0 else (0.0, 0.0)", "test_script": "import torch\nimport torch.nn as nn\n\ndef test_case_input_generator(n=200):\n    embedding_dim = 300\n    num_classes = 2\n\n    class MockModel(nn.Module):\n        def __init__(self, input_dim, output_dim):\n            super(MockModel, self).__init__()\n            self.fc = nn.Linear(input_dim, output_dim)\n\n        def forward(self, x):\n            return self.fc(x)\n\n    class BatchWrapper:\n        def __init__(self, text, label):\n            self.text = (text,)\n            self.label = label\n            self.batch_size = text.size(0)\n        def __len__(self):\n            return self.batch_size\n    test_cases = []\n    for _ in range(n):\n        batch_size = 32\n        inputs = torch.randn(batch_size, embedding_dim)\n        targets = torch.randint(0, num_classes, (batch_size,))\n        batch = BatchWrapper(inputs, targets)\n        model = MockModel(input_dim=embedding_dim, output_dim=num_classes)\n        loss_fn = nn.CrossEntropyLoss()\n        test_cases.append((model, [batch], loss_fn))\n    return test_cases"}
{"problem_id": "pytorch_61", "library": "pytorch", "code_problem": "You are tasked with implementing a function that creates a convolutional block for a neural network using PyTorch. The function should allow for the configuration of various parameters, including the number of input channels, the number of output channels, the kernel size, stride, padding, and the activation function type (Leaky ReLU or ReLU).\n\nThe function signature is as follows:\n```python\ndef Conv2dBlock1(c_in: int, c_out: int, k_size: int, stride: int, padding: int, leaky: bool) -> nn.Sequential:\n```\n\nIn this function, the following constant is used:\n- The Leaky ReLU activation function has a negative slope of 0.1 when the `leaky` parameter is set to `True`.\n\nInput format:\n- The function accepts six parameters: `c_in`, `c_out`, `k_size`, `stride`, `padding`, and `leaky`.\n\nOutput format:\n- The function returns an instance of `nn.Sequential` containing the convolutional layer and the specified activation function.\n\nInput: (32, 64, 3, 1, 1, True)  \nOutput: Sequential(\n  (0): Conv2d(32, 64, kernel_size=(3, 3), stride=(1, 1), padding=(1, 1))\n  (1): LeakyReLU(negative_slope=0.1)\n)", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef Conv2dBlock1(c_in, c_out, k_size, stride, padding, leaky):\n    if leaky:\n        return nn.Sequential(nn.Conv2d(c_in, c_out, k_size, stride, padding), nn.LeakyReLU(0.1))\n    else:\n        return nn.Sequential(nn.Conv2d(c_in, c_out, k_size, stride, padding), nn.ReLU(inplace=True))", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        # Randomly select input channels, output channels, kernel size, stride, and padding\n        c_in = random.randint(1, 128)  # Input channels\n        c_out = random.randint(1, 256)  # Output channels\n        k_size = random.choice([1, 3, 5, 7])  # Kernel size\n        stride = random.choice([1, 2])  # Stride\n        padding = random.choice([0, 1, 2])  # Padding\n        leaky = random.choice([True, False])  # Leaky or not\n\n        # Append test case (input tensor, layer parameters)\n        test_cases.append((c_in, c_out, k_size, stride, padding, leaky))\n\n    return test_cases\n"}
{"problem_id": "pytorch_62", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a 3D pose, represented by a position vector and a quaternion, into a homogeneous transformation matrix. The function should be able to handle the conversion of the quaternion to a rotation matrix and then combine it with the position vector to form a 4x4 transformation matrix.\n\nFunction signature:\n```python\ndef pose2mat(pos: torch.Tensor, quat: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `EPS = 1e-8`: This constant is used to determine if the quaternion is close to zero, which would indicate that it does not represent a valid rotation.\n\nInput format:\n- `pos`: A 1D tensor of shape (3,) representing the position in 3D space.\n- `quat`: A 1D tensor of shape (4,) representing the quaternion that defines the rotation.\n\nOutput format:\n- Returns a 2D tensor of shape (4, 4) representing the homogeneous transformation matrix that combines both the rotation and translation.\n\nInput:\n```python\npos = torch.tensor([-2.3, 1.5, 0.7])\nquat = torch.tensor([0.0, 0.0, 0.0, 1.0])  # Identity quaternion\n```\n\nOutput:\n```python\nhomo_pose_mat = torch.tensor([[ 1.0000,  0.0000,  0.0000, -2.3000],\n                             [ 0.0000,  1.0000,  0.0000,  1.5000],\n                             [ 0.0000,  0.0000,  1.0000,  0.7000],\n                             [ 0.0000,  0.0000,  0.0000,  1.0000]])\n\n```", "ground_truth_code": "import math\nimport torch\n\ndef quat2mat(quaternion):\n    EPS = 1e-8\n    inds = torch.tensor([3, 0, 1, 2])\n    q = quaternion.clone().detach().float()[inds]\n    n = torch.dot(q, q)\n    if n < EPS:\n        return torch.eye(3)\n    q *= math.sqrt(2.0 / n)\n    q2 = torch.outer(q, q)\n    return torch.tensor([\n        [1.0 - q2[2, 2] - q2[3, 3], q2[1, 2] - q2[3, 0], q2[1, 3] + q2[2, 0]],\n        [q2[1, 2] + q2[3, 0], 1.0 - q2[1, 1] - q2[3, 3], q2[2, 3] - q2[1, 0]],\n        [q2[1, 3] - q2[2, 0], q2[2, 3] + q2[1, 0], 1.0 - q2[1, 1] - q2[2, 2]]\n    ])\n\n# main code\ndef pose2mat(pos, quat):\n    homo_pose_mat = torch.eye(4)\n    homo_pose_mat[:3, :3] = quat2mat(quat)\n    homo_pose_mat[:3, 3] = pos\n    return homo_pose_mat", "test_script": "import torch\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        pos = torch.rand(3) * 10 - 5\n\n        quat = torch.rand(4) * 2 - 1\n        quat = quat / torch.norm(quat)\n\n        test_cases.append((pos, quat))\n\n    return test_cases\n"}
{"problem_id": "pytorch_63", "library": "pytorch", "code_problem": "```python\ndef get_projected_angle(R_ab: torch.Tensor, P_n: torch.Tensor, eps: float) -> torch.Tensor:\n```\n\nIn this code, the function `get_projected_angle` computes the angle between a vector `R_ab` and its projection onto a plane defined by the normal vector `P_n`. The function takes three parameters: \n\n1. `R_ab`: A tensor representing a vector in 3D space.\n2. `P_n`: A tensor representing the normal vector of the plane onto which `R_ab` is projected.\n3. `eps`: A small float value used to determine when to treat certain angles as zero.\n\nThe constant used in the main code is `1e-09`, which is used to clamp the values to avoid division by zero when calculating angles.\n\n### Input and Output Format:\n- **Input**: \n  - `R_ab`: A tensor of shape (N, 3) representing N vectors in 3D space.\n  - `P_n`: A tensor of shape (N, 3) representing N normal vectors of the planes.\n  - `eps`: A float value representing a small threshold.\n\n- **Output**: \n  - A tensor of shape (N,) containing the computed angles between `R_ab` and its projection onto the plane defined by `P_n`.\n\n**Input:**\n```python\nR_ab = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\nP_n = torch.tensor([[0.0, 1.0, 0.0], [1.0, 0.0, 0.0]])\neps = torch.tensor(1e-6)\n```\n\n**Output:**\n```python\nangle = get_projected_angle(R_ab, P_n, eps)\n# tensor([-1.2490,  0.8761])\n```", "ground_truth_code": "import torch\n\ndef get_angle(R_ac, R_ab):\n    x = torch.sum(R_ac * R_ab, dim=-1)\n    y = torch.cross(R_ac, R_ab, dim=-1).norm(dim=-1)\n    y = y.clamp(min=1e-09)\n    angle = torch.atan2(y, x)\n    return angle\n\n# main code\ndef get_projected_angle(R_ab, P_n, eps):\n    R_ab_proj = torch.cross(R_ab, P_n, dim=-1)\n    x = P_n.new_tensor([[1, 0, 0]]).expand_as(P_n)\n    zero_angle = torch.cross(x, P_n, dim=-1)\n    use_y = torch.norm(zero_angle, dim=-1) < eps\n    P_n_y = P_n[use_y]\n    y = P_n_y.new_tensor([[0, 1, 0]]).expand_as(P_n_y)\n    y_cross = torch.cross(y, P_n_y, dim=-1)\n    zero_angle[use_y] = y_cross\n    angle = get_angle(zero_angle, R_ab_proj)\n    cross = torch.cross(zero_angle, R_ab_proj, dim=-1)\n    flip_sign = torch.sum(cross * P_n, dim=-1) < 0\n    angle[flip_sign] = -angle[flip_sign]\n    return angle", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        R_ab = torch.randn(batch_size, 3)\n        P_n = torch.randn(batch_size, 3)\n        eps = torch.tensor(random.uniform(1e-9, 1e-3))\n\n        test_cases.append((R_ab, P_n, eps))\n\n    return test_cases"}
{"problem_id": "pytorch_64", "library": "pytorch", "code_problem": "```python\ndef get_dynamics_losses(s, s_hat, s_prime, s_prime_hat, z_prime, z_prime_hat, a_hat, curr_actions, discrete):\n```\n\nIn this function, the constant used is the Mean Squared Error (MSE) loss, which is a common loss function in regression tasks.\n\nInput format:\n- The function takes in multiple tensors: `s`, `s_hat`, `s_prime`, `s_prime_hat`, `z_prime`, `z_prime_hat`, `a_hat`, `curr_actions`, and a boolean `discrete`.\n\nOutput format:\n- The function returns a tuple of five loss values: `(recon_loss, model_loss, dec_loss, inv_loss, forward_loss)`, each representing a different aspect of the model's performance.\n\nInput:\n```python\ns = torch.tensor([[0.5, -0.2], [0.1, 0.3]])\ns_hat = torch.tensor([[0.4, -0.1], [0.2, 0.2]])\ns_prime = torch.tensor([[0.6, -0.3], [0.0, 0.4]])\ns_prime_hat = torch.tensor([[0.5, -0.2], [0.1, 0.5]])\nz_prime = torch.tensor([[0.7, -0.1], [0.2, 0.3]])\nz_prime_hat = torch.tensor([[0.6, 0.0], [0.3, 0.4]])\na_hat = torch.tensor([[0.1, 0.9], [0.8, 0.2]])\ncurr_actions = torch.tensor([[0.0, 1.0], [1.0, 0.0]])\ndiscrete = True\n```\n\nOutput:\n```python\n(tensor(0.0100), tensor(0.0100), tensor(0.0200), tensor(1.5985), tensor(0.0100))\n``` \n", "ground_truth_code": "import torch.nn.functional as F\n\n# main code\ndef get_dynamics_losses(s, s_hat, s_prime, s_prime_hat, z_prime, z_prime_hat, a_hat, curr_actions, discrete):\n    recon_loss = F.mse_loss(s_hat, s)\n    model_loss = F.mse_loss(s_prime_hat, s_prime)\n    dec_loss = F.mse_loss(s_hat, s) + F.mse_loss(s_prime_hat, s_prime)\n    if discrete:\n        a_hat = F.log_softmax(a_hat)\n    inv_loss = F.mse_loss(a_hat, curr_actions)\n    forward_loss = F.mse_loss(z_prime_hat, z_prime.detach())\n    return (recon_loss, model_loss, dec_loss, inv_loss, forward_loss)", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = torch.randint(1, 10, (1,)).item()\n        feature_dim = torch.randint(2, 20, (1,)).item()\n        s = torch.randn(batch_size, feature_dim)\n        s_hat = torch.randn(batch_size, feature_dim)\n        s_prime = torch.randn(batch_size, feature_dim)\n        s_prime_hat = torch.randn(batch_size, feature_dim)\n        z_prime = torch.randn(batch_size, feature_dim)\n        z_prime_hat = torch.randn(batch_size, feature_dim)\n        action_dim = torch.randint(2, 10, (1,)).item()\n        a_hat = torch.randn(batch_size, action_dim)\n        curr_actions = torch.randn(batch_size, action_dim)\n        discrete = torch.rand(1).item() > 0.5\n        test_cases.append((s, s_hat, s_prime, s_prime_hat, z_prime, z_prime_hat, a_hat, curr_actions, discrete))\n\n    return test_cases"}
{"problem_id": "pytorch_65", "library": "pytorch", "code_problem": "You are tasked with implementing a beam search algorithm for sequence generation. The function signature for the main code is as follows:\n\n```python\ndef beam_search(input_dict, end_idx, vocab_size):\n```\n\n### Constants:\n- `end_idx`: An integer representing the index that signifies the end of a sequence.\n- `vocab_size`: An integer representing the size of the vocabulary from which words can be generated.\n\n### Input Format:\n- `input_dict`: A dictionary containing `max_length`, `beam_size`, `batch_size`, and optionally `temp`.\n- `end_idx`: An integer indicating the end of a sequence.\n- `vocab_size`: An integer representing the size of the vocabulary.\n\n### Output Format:\n- Returns a tuple containing:\n  - A tensor of shape `(batch_size, beam_size, max_length)` representing the generated sequences.\n  - A tensor of shape `(batch_size, beam_size)` representing the log probabilities of the sequences.\n\nInput:\n```python\ninput_dict = {\n    'max_length': 10,\n    'beam_size': 3,\n    'batch_size': 2,\n    'temp': 1.0\n}\nend_idx = 5\nvocab_size = 20\n```\n\nOutput:\n```python\ntensor([[[ 5,  7,  7, 12, 12, 15,  1,  6, 17,  4],\n         [ 5,  7,  7, 12, 12, 15,  1,  6, 17,  1],\n         [ 5,  7,  7, 12, 12, 15,  1,  6, 17,  1]],\n        [[ 5,  1, 15, 18,  4, 17, 17, 14,  7,  8],\n         [ 5,  1, 15, 18,  4, 17, 17, 14,  4, 12],\n         [ 5,  1, 15, 18,  4, 17, 17, 10, 13,  9]]])\n\ntensor([[-1015.3412, -1015.4299, -1015.5098],\n        [-1013.8677, -1014.3429, -1014.4036]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef beam_search(input_dict, end_idx, vocab_size):\n    max_length = input_dict['max_length']\n    beam_size = input_dict['beam_size']\n    batch_size = input_dict['batch_size']\n    temp = input_dict.get('temp', 1.0)\n    sequences = torch.full((batch_size, beam_size, max_length), end_idx, dtype=torch.long)\n    log_probs = torch.zeros((batch_size, beam_size))\n\n    for i in range(batch_size):\n        seqs = torch.full((beam_size, 1), end_idx, dtype=torch.long)\n        topk_log_probs = torch.zeros(beam_size)\n        done_beams = []\n\n        for t in range(max_length):\n            logits = torch.randn(beam_size, vocab_size)\n            log_probs_t = torch.log_softmax(logits / temp, dim=1)\n            log_probs_t = topk_log_probs.unsqueeze(1) + log_probs_t\n\n            topk_log_probs, topk_indices = log_probs_t.view(-1).topk(beam_size, 0, True, True)\n            prev_beams = topk_indices // vocab_size\n            next_words = topk_indices % vocab_size\n\n            seqs = torch.cat([seqs[prev_beams], next_words.unsqueeze(1)], dim=1)\n            is_end = next_words == end_idx\n\n            if t == max_length - 1:\n                is_end.fill_(1)\n            for beam_idx in range(beam_size):\n                if is_end[beam_idx]:\n                    done_beams.append(\n                        {'seq': seqs[beam_idx].clone(), 'score': topk_log_probs[beam_idx].item() / (t + 1)})\n            topk_log_probs[is_end] -= 1000\n\n            if len(done_beams) == beam_size:\n                break\n        seq_length = min(seqs.shape[1], max_length)\n        sequences[i, :, :seq_length] = seqs[:, :seq_length]\n        log_probs[i] = topk_log_probs\n\n    return sequences, log_probs", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        max_length = random.randint(5, 50)  # Ensure reasonable sequence lengths\n        beam_size = random.randint(1, 10)  # Beam size between 1 and 10\n        batch_size = random.randint(1, 16)  # Batch size between 1 and 16\n        vocab_size = random.randint(10, 1000)  # Vocabulary size between 10 and 1000\n        temp = round(random.uniform(0.5, 2.0), 2)  # Temperature for logits scaling\n        end_idx = random.randint(0, vocab_size - 1)  # Random end token index\n\n        input_dict = {\n            'max_length': max_length,\n            'beam_size': beam_size,\n            'batch_size': batch_size,\n            'temp': temp\n        }\n\n        test_cases.append((input_dict, end_idx, vocab_size))\n\n    return test_cases"}
{"problem_id": "pytorch_66", "library": "pytorch", "code_problem": "Implement a function that normalizes a given tensor to produce a unit vector. The function should handle both 1-dimensional and multi-dimensional tensors. The normalization process involves dividing the tensor by its length, which is calculated as the square root of the sum of the squares of its elements.\n\nFunction signature:\n```python\ndef unit_vector(data: torch.Tensor):\n```\n\nConstant used in the main code:\n- `math.sqrt`: This constant is used to compute the square root of a number.\n\nInput format:\n- The input to the function is a single argument `data`, which is a PyTorch tensor.\n\nOutput format:\n- The output of the function is a PyTorch tensor that represents the normalized unit vector of the input tensor.\n\nInput: `torch.tensor([3.0, 4.0], dtype=torch.float32)`\n\nOutput: `tensor([0.6000, 0.8000])`", "ground_truth_code": "import torch\nimport math\n\n# main code\ndef unit_vector(data: torch.Tensor):\n    data = torch.clone(data)\n    if data.ndim == 1:\n        data /= math.sqrt(torch.dot(data, data))\n        return data\n    length = torch.atleast_1d(torch.sum(data * data))\n    length = torch.sqrt(length)\n    data /= length\n    return data", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        if random.choice([True, False]):\n            shape = (random.randint(2, 10),)\n        else:\n            shape = (random.randint(2, 10), random.randint(2, 10))\n        tensor = torch.randn(shape, dtype=torch.float32)\n\n        test_cases.append(tensor)\n\n    return test_cases"}
{"problem_id": "pytorch_67", "library": "pytorch", "code_problem": "```python\ndef imgrad(img: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nIn this code, the function `imgrad` computes the gradients of a given image tensor using convolutional filters. The function takes a single input parameter:\n\n- `img`: A 4D tensor representing a batch of images with shape (N, C, H, W), where N is the batch size, C is the number of channels, H is the height, and W is the width of the images.\n\nThe function uses the following constant:\n- The convolutional kernels `fx` and `fy` are defined as:\n  - `fx`: A Sobel filter for detecting horizontal gradients.\n  - `fy`: A Sobel filter for detecting vertical gradients.\n\nInput and output format:\n- Input: A 4D tensor `img` of shape (N, C, H, W).\n- Output: A tuple of two tensors, `(grad_y, grad_x)`, where both tensors have the same shape as the input image tensor (N, 1, H, W).\n\nInput:\n```python\ntensor([[[[0.1234, 0.5678, 0.9101, 0.2345],\n          [0.6789, 0.3456, 0.7890, 0.4567],\n          [0.2345, 0.8901, 0.1234, 0.6789],\n          [0.4567, 0.0123, 0.3456, 0.7890]]]])\n```\n\nOutput:\n```python\n( \n  tensor([[[[-1.7034, -2.1591, -2.3803, -1.7024],\n          [-0.5445,  0.0310,  0.8067, -0.1021],\n          [ 0.7777,  1.3322,  0.8878, -0.2212],\n          [ 1.3591,  2.1381,  1.8158,  1.4812]]]],\n       grad_fn=<ConvolutionBackward0>)\n  tensor([[[[-1.4812, -1.6835,  0.5555,  2.6092],\n          [-2.1491, -0.8958,  0.3223,  2.6115],\n          [-2.1381,  0.2232, -0.4654,  1.3814],\n          [-0.9147,  0.3333, -1.3422,  0.8146]]]],\n       grad_fn=<ConvolutionBackward0>)\n)\n```", "ground_truth_code": "import torch\nimport numpy as np\nimport torch.nn as nn\n\n# main code\ndef imgrad(img):\n    img = torch.mean(img, dim=1, keepdim=True)\n    fx = np.array([[1, 0, -1], [2, 0, -2], [1, 0, -1]], dtype=np.float32)\n    conv1 = nn.Conv2d(1, 1, kernel_size=3, stride=1, padding=1, bias=False)\n    weight_x = torch.from_numpy(fx).unsqueeze(0).unsqueeze(0)\n    conv1.weight = nn.Parameter(weight_x)\n    grad_x = conv1(img)\n    fy = np.array([[1, 2, 1], [0, 0, 0], [-1, -2, -1]], dtype=np.float32)\n    conv2 = nn.Conv2d(1, 1, kernel_size=3, stride=1, padding=1, bias=False)\n    weight_y = torch.from_numpy(fy).unsqueeze(0).unsqueeze(0)\n    conv2.weight = nn.Parameter(weight_y)\n    grad_y = conv2(img)\n\n    return grad_y, grad_x", "test_script": "import torch\nimport random\n\n# Test case generator\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 8)\n        height = random.randint(16, 128)\n        width = random.randint(16, 128)\n\n        img_tensor = torch.rand(batch_size, 1, height, width)\n        test_cases.append(img_tensor)\n\n    return test_cases"}
{"problem_id": "pytorch_68", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the attention mechanism for a given query and context using a specific smoothing factor. The function should normalize the attention scores and return the weighted context along with the attention scores.\n\nFunction signature:\n```python\ndef SCAN_attention(query: torch.Tensor, context: torch.Tensor, smooth: int = 9) -> tuple:\n```\n\nConstant used in the main code:\n- `smooth`: This constant is set to `9` by default and is used to scale the attention scores before applying the softmax function.\n\nInput format:\n- `query`: A PyTorch tensor of shape (batch_size, query_length, feature_dim).\n- `context`: A PyTorch tensor of shape (batch_size, context_length, feature_dim).\n- `smooth`: An optional integer that defaults to 9, used for scaling the attention scores.\n\nOutput format:\n- A tuple containing:\n  - `weightedContext`: A PyTorch tensor of shape (batch_size, context_length, feature_dim) representing the context weighted by the attention scores.\n  - `attn`: A PyTorch tensor of shape (batch_size, context_length, query_length) representing the normalized attention scores.\n\nInput:\n```python\nquery = torch.tensor([[[0.1, 0.2, 0.3], \n                        [0.4, 0.5, 0.6]]])  # Shape: (1, 2, 3)\n\ncontext = torch.tensor([[[0.7, 0.8, 0.9], \n                          [0.1, 0.2, 0.3], \n                          [0.4, 0.5, 0.6]]])  # Shape: (1, 3, 3)\n```\n\nOutput:\n```python\nweightedContext, attn = SCAN_attention(query, context)\n# weightedContext \ntensor([[[0.4507, 0.5692, 0.6877],\n         [0.4579, 0.5700, 0.6822]]])\n# attn\ntensor([[[0.3071, 0.3730, 0.3199],\n         [0.3443, 0.3171, 0.3386]]])\n``` \n", "ground_truth_code": "import torch\nimport torch.nn.functional as F\nimport torch.nn as nn\n\ndef l2norm(X, dim, eps=1e-08):\n    X = X / (torch.norm(X, p=2, dim=dim, keepdim=True) + eps)\n    return X\n\n# main code\ndef SCAN_attention(query, context, smooth=9):\n    queryT = torch.transpose(query, 1, 2)\n    attn = torch.bmm(context, queryT)\n    attn = nn.LeakyReLU(0.1)(attn)\n    attn = l2norm(attn, 2)\n    attn = torch.transpose(attn, 1, 2).contiguous()\n    attn = F.softmax(attn * smooth, dim=2)\n    attnT = torch.transpose(attn, 1, 2).contiguous()\n    contextT = torch.transpose(context, 1, 2)\n    weightedContext = torch.bmm(contextT, attnT)\n    weightedContext = torch.transpose(weightedContext, 1, 2)\n    weightedContext = l2norm(weightedContext, dim=-1)\n    return (weightedContext, attn)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        seq_len_q = random.randint(1, 50)\n        seq_len_c = random.randint(1, 50)\n        feature_dim = random.randint(8, 128)\n\n        query = torch.rand(batch_size, seq_len_q, feature_dim)\n        context = torch.rand(batch_size, seq_len_c, feature_dim)\n\n        test_cases.append((query, context))\n    return test_cases"}
{"problem_id": "pytorch_69", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the corners of rotated bounding boxes given their parameters. The function will take a tensor of bounding box parameters and return the coordinates of the corners of each bounding box.\n\nFunction signature:\n```python\ndef compute_rotated_bbox_corners(rbbox: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant `2.0` is used to calculate half the width and half the height of the bounding boxes.\n\nInput format:\n- A tensor of shape `(N, 5)` where `N` is the number of bounding boxes. Each row contains five values: `cx`, `cy`, `w`, `h`, and `theta`.\n\nOutput format:\n- A tensor of shape `(N, 8)` where each row contains the x and y coordinates of the corners of the corresponding bounding box in the order: bottom-left, top-left, top-right, bottom-right.\n\nInput:\n```python\ntensor([[ 1.2345, -2.3456,  5.6789,  3.4567,  0.7854],\n        [-3.4567,  4.5678,  2.3456,  1.2345, -1.5708]])\n```\n\nOutput:\n```python\ntensor([[-1.9954, -1.5599,  0.4488,  0.8843,  4.4644, -3.1313,  2.0202, -5.5755],\n        [-2.8394,  3.3950, -4.0739,  3.3950, -4.0740,  5.7406, -2.8395,  5.7406]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef compute_rotated_bbox_corners(rbbox):\n    num_boxes = rbbox.shape[0]\n    corners = torch.zeros((num_boxes, 8), dtype=torch.float32)\n    cx, cy, w, h, theta = rbbox[:, 0], rbbox[:, 1], rbbox[:, 2], rbbox[:, 3], rbbox[:, 4]\n    half_w = w / 2.0\n    half_h = h / 2.0\n    cos_theta = torch.cos(theta)\n    sin_theta = torch.sin(theta)\n    dx_cos = half_w * cos_theta\n    dx_sin = half_w * sin_theta\n    dy_cos = half_h * cos_theta\n    dy_sin = half_h * sin_theta\n    corners[:, 0] = cx - dx_cos - dy_sin\n    corners[:, 1] = cy + dx_sin - dy_cos\n    corners[:, 2] = cx - dx_cos + dy_sin\n    corners[:, 3] = cy + dx_sin + dy_cos\n    corners[:, 4] = cx + dx_cos + dy_sin\n    corners[:, 5] = cy - dx_sin + dy_cos\n    corners[:, 6] = cx + dx_cos - dy_sin\n    corners[:, 7] = cy - dx_sin - dy_cos\n\n    return corners", "test_script": "import torch\nimport random\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_boxes = random.randint(1, 10)\n        cx = torch.randn(num_boxes) * 10\n        cy = torch.randn(num_boxes) * 10\n        w = torch.rand(num_boxes) * 20 + 1\n        h = torch.rand(num_boxes) * 20 + 1\n        theta = torch.rand(num_boxes) * 2 * np.pi - np.pi\n        rbbox = torch.stack((cx, cy, w, h, theta), dim=1)\n        test_cases.append(rbbox)\n\n    return test_cases"}
{"problem_id": "pytorch_70", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes model predictions and features to generate pseudo-labels for semi-supervised learning. The function will filter out predictions based on their entropy, which measures the uncertainty of the predictions. The function signature is as follows:\n\n```python\ndef pseudo_label(logit, feat, log_var, entropy_thr):\n```\n\n### Constants:\n- `entropy_thr`: A threshold value for entropy, used to determine which predictions are considered reliable.\n\n### Input and Output Format:\n- **Input**:\n  - `logit`: A tensor of shape (N, C) where N is the number of samples and C is the number of classes, representing the raw model predictions.\n  - `feat`: A tensor of shape (N, D) where D is the dimensionality of the features for each sample.\n  - `log_var`: A tensor of shape (N,) representing the log variances associated with each sample.\n  - `entropy_thr`: A float value representing the threshold for entropy.\n\n- **Output**:\n  - A tuple containing:\n    - A tensor of shape (M, D) where M is the number of reliable samples, representing the filtered features.\n    - A tensor of shape (M,) representing the filtered labels.\n    - A tensor of shape (M,) representing the filtered log variances.\n\nInput:\n```python\nlogit = torch.tensor([[0.2, 0.5, 0.3], [0.1, 0.1, 0.8], [0.6, 0.2, 0.2]])\nfeat = torch.tensor([[1.0, 2.0, 3.0], [4.0, 5.0, 6.0], [7.0, 8.0, 9.0]])\nlog_var = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nentropy_thr = 0.5\n```\n\nOutput:\n```python\n(tensor([], size=(0, 3)), tensor([], dtype=torch.int64), tensor([], size=(0, 3)))\n```", "ground_truth_code": "import torch.nn.functional as F\nimport torch\n\n# main code\ndef pseudo_label(logit, feat, log_var, entropy_thr):\n    pred = F.softmax(logit, dim=1)\n    entropy = (-pred * torch.log(pred)).sum(-1)\n    label = torch.argmax(logit, dim=-1).long()\n    mask = (entropy < entropy_thr).float()\n    index = torch.nonzero(mask).squeeze(-1)\n    feat = torch.index_select(feat, 0, index)\n    label = torch.index_select(label, 0, index)\n    log_var = torch.index_select(log_var, 0, index)\n    return (feat, label, log_var)", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 100)\n        num_classes = random.randint(2, 20)\n        feat_dim = random.randint(5, 50)\n\n        logit = torch.randn(batch_size, num_classes)\n        feat = torch.randn(batch_size, feat_dim)\n        log_var = torch.randn(batch_size, feat_dim)\n        entropy_thr = random.uniform(0.1, 2.0)\n\n        test_cases.append((logit, feat, log_var, entropy_thr))\n    return test_cases"}
{"problem_id": "pytorch_71", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes input sequences for a transformer model, specifically for a BERT-like architecture. The function will prepare the input by creating a new tensor that combines two sequences, adds special tokens, and generates type IDs for the input. The function will also apply a dropout layer and a linear transformation to produce logits for classification tasks.\n\nFunction signature:\n```python\ndef forward(a: torch.Tensor, b: torch.Tensor, D: dict, lin: torch.nn.Module, oldD2D: dict, bert: callable, pad_id: int, dropout: callable) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- The constant `pad_id` is used to fill the new input tensor with padding values.\n\nInput format:\n- `a`: A tensor of shape `(batch_size, seq_len_a)` containing token indices for the first sequence.\n- `b`: A tensor of shape `(batch_size, seq_len_b)` containing token indices for the second sequence.\n- `D`: A dictionary mapping special token strings to their corresponding token IDs.\n- `lin`: A linear layer for transforming the pooled output.\n- `oldD2D`: A dictionary mapping token indices to their corresponding word pieces.\n- `bert`: A callable representing the BERT model.\n- `pad_id`: An integer representing the padding token ID.\n- `dropout`: A callable representing the dropout layer.\n\nOutput format:\n- The function returns a tensor containing the logits for each input in the batch, which can be used for classification tasks.\n\n**Input:**\n```python\na = torch.tensor([[5, 12, 7], [3, 8, 15]])\nb = torch.tensor([[9, 14], [6, 11]])\nD = {'[CLS]': 101, '[SEP]': 102}\noldD2D = {i: [i] for i in range(30522)}\npad_id = 0\n\nclass MockBert:\n    def __call__(self, newinp, typeids, padmask):\n        return None, torch.randn(newinp.shape[0], 768)\n\nlin = torch.nn.Linear(768, 2)\ndropout = torch.nn.Dropout(p=0.1)\nbert = MockBert()\n```\n\n**Output:**\n```python\nlogits = forward(a, b, D, lin, oldD2D, bert, pad_id, dropout)\n# Example output (the actual values will vary due to randomness):\ntensor([[-0.3793,  0.1055],\n        [-0.3924,  0.4504]], grad_fn=<AddmmBackward0>)\n```", "ground_truth_code": "import torch\n\n# main code\ndef forward(a, b, D, lin, oldD2D, bert, pad_id, dropout):\n    batch_size, seq_len_a = a.shape\n    _, seq_len_b = b.shape\n    max_seq_len = 2 + 2 * max(seq_len_a, seq_len_b)\n    newinp = torch.full((batch_size, max_seq_len), pad_id, dtype=torch.long)\n    typeflip = []\n\n    for i in range(batch_size):\n        k = 0\n        newinp[i, k] = D['[CLS]']\n        k += 1\n        last_nonpad = k\n        for j in range(seq_len_a):\n            wordpieces = oldD2D[a[i, j].item()]\n            for wordpiece in wordpieces:\n                if k < max_seq_len - 1:\n                    newinp[i, k] = wordpiece\n                    k += 1\n            last_nonpad = k\n        if last_nonpad < max_seq_len:\n            newinp[i, last_nonpad] = D['[SEP]']\n            last_nonpad += 1\n        typeflip.append(last_nonpad)\n        for j in range(seq_len_b):\n            wordpieces = oldD2D[b[i, j].item()]\n            for wordpiece in wordpieces:\n                if last_nonpad < max_seq_len - 1:\n                    newinp[i, last_nonpad] = wordpiece\n                    last_nonpad += 1\n        if last_nonpad < max_seq_len:\n            newinp[i, last_nonpad] = D['[SEP]']\n            last_nonpad += 1\n    maxlen = max(typeflip) + 1 if typeflip else max_seq_len\n    newinp = newinp[:, :maxlen]\n    typeids = torch.zeros_like(newinp, dtype=torch.long)\n    for i, flip in enumerate(typeflip):\n        typeids[i, flip:] = 1\n    padmask = newinp != pad_id\n    _, poolout = bert(newinp, typeids, padmask)\n    poolout = dropout(poolout)\n    logits = lin(poolout)\n\n    return logits", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    vocab_size = 30522\n    max_seq_len = 128\n    batch_size = 8\n\n    D = {'[CLS]': 101, '[SEP]': 102}\n    oldD2D = {i: [i] for i in range(vocab_size)}\n    pad_id = 0\n\n    class MockBert:\n        def __call__(self, newinp, typeids, padmask):\n            batch_size, seq_len = newinp.shape\n            return None, torch.randn(batch_size, 768)\n    lin = torch.nn.Linear(768, 2)\n    dropout = torch.nn.Dropout(p=0.1)\n    bert = MockBert()\n\n    for _ in range(n):\n        seq_len_a = random.randint(1, max_seq_len // 2)\n        seq_len_b = random.randint(1, max_seq_len // 2)\n\n        a = torch.randint(1, vocab_size, (batch_size, seq_len_a))\n        b = torch.randint(1, vocab_size, (batch_size, seq_len_b))\n\n        test_cases.append((a, b, D, lin, oldD2D, bert, pad_id, dropout))\n\n    return test_cases"}
{"problem_id": "pytorch_72", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a series of mathematical transformations on three input parameters using PyTorch. The function will compute new values based on the relationships between the inputs and return the transformed values.\n\nFunction signature:\n```python\ndef invSqrtTorch(a: torch.Tensor, b: torch.Tensor, c: torch.Tensor) -> tuple[torch.Tensor, torch.Tensor, torch.Tensor]:\n```\n\nConstant used in the main code:\n- `eps = 1e-12`: This small constant is used to prevent division by zero when `b` is zero.\n\nInput format:\n- The function takes three input parameters: `a`, `b`, and `c`, which are all tensors of the same shape.\n\nOutput format:\n- The function returns a tuple of three tensors: `(new_a, new_b, new_c)`, each representing the transformed values based on the input tensors.\n\nInput:\n```python\na = torch.tensor([[1.0, 2.0], [3.0, 4.0]])\nb = torch.tensor([[0.5, 0.0], [1.5, 2.0]])\nc = torch.tensor([[2.0, 3.0], [4.0, 5.0]])\n```\n\nOutput:\n```python\n(new_a, new_b, new_c) = invSqrtTorch(a, b, c)\n# Example output values (actual values may vary due to randomness in input)\nnew_a = tensor([[1.2159, 1.1067], [1.1075, 1.0914]])\nnew_b = tensor([[-0.1830,  0.0000], [-0.2332, -0.2425]])\nnew_c = tensor([[0.8500, 0.9036], [0.9520, 0.9701]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef invSqrtTorch(a, b, c):\n    eps = 1e-12\n    mask = (b != 0).float()\n    r1 = mask * (c - a) / (2.0 * b + eps)\n    t1 = torch.sign(r1) / (torch.abs(r1) + torch.sqrt(1.0 + r1 * r1))\n    r = 1.0 / torch.sqrt(1.0 + t1 * t1)\n    t = t1 * r\n    r = r * mask + 1.0 * (1.0 - mask)\n    t = t * mask\n    x = 1.0 / torch.sqrt(r * r * a - 2.0 * r * t * b + t * t * c)\n    z = 1.0 / torch.sqrt(t * t * a + 2.0 * r * t * b + r * r * c)\n    d = torch.sqrt(x * z)\n    x = x / d\n    z = z / d\n    new_a = r * r * x + t * t * z\n    new_b = -r * t * x + t * r * z\n    new_c = t * t * x + r * r * z\n    return (new_a, new_b, new_c)", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(torch.randint(1, 5, (2,)).tolist())\n        a = torch.randn(shape)\n        b = torch.randn(shape)\n        c = torch.randn(shape)\n\n        test_cases.append((a, b, c))\n    return test_cases"}
{"problem_id": "pytorch_73", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates a specific type of loss based on the difference between two tensors. The function should support different reduction methods and optional weighting for the loss calculation.\n\nFunction signature:\n```python\ndef forward(x: torch.Tensor, y: torch.Tensor, weight: torch.Tensor, reduction: str, eps: float) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `eps`: A small constant added to avoid numerical instability when calculating the square root.\n\nInput format:\n- `x`: A tensor of shape (N, D) where N is the number of samples and D is the number of features.\n- `y`: A tensor of the same shape as `x`.\n- `weight`: An optional tensor of shape (N,) that provides weights for each sample.\n- `reduction`: A string that can be either 'sum' or 'mean' indicating how to reduce the loss.\n- `eps`: A small float value to ensure numerical stability.\n\nOutput format:\n- The function returns a tensor representing the computed loss, which is either a scalar value (if reduction is 'mean' or 'sum') or a tensor of shape (N,) if weights are applied and reduction is not specified.\n\nInput:\n```python\nx = torch.tensor([[0.5, 1.0], [1.5, 2.0]])\ny = torch.tensor([[0.0, 1.0], [1.0, 2.0]])\nweight = None\nreduction = 'mean'\neps = 1e-6\n```\n\nOutput:\n```python\nloss = tensor(0.2505)\n```", "ground_truth_code": "import torch\n\n# main code\ndef forward(x, y, weight, reduction, eps):\n    diff = x - y\n    loss = None\n    if reduction == 'sum':\n        if weight is None:\n            loss = torch.sum(torch.sqrt(diff * diff + eps))\n        else:\n            loss = torch.sum(torch.sqrt(diff * diff + eps) * weight)\n        loss /= x.shape[0]\n    elif reduction == 'mean':\n        if weight is None:\n            loss = torch.mean(torch.sqrt(diff * diff + eps))\n        else:\n            loss = torch.mean(torch.sqrt(diff * diff + eps) * weight)\n    return loss", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 100)\n        feature_size = random.randint(1, 50)\n\n        x = torch.randn(batch_size, feature_size)\n        y = torch.randn(batch_size, feature_size)\n\n        if random.random() > 0.5:\n            weight = torch.randn(batch_size, feature_size)\n        else:\n            weight = None\n\n        reduction = random.choice(['sum', 'mean'])\n        eps = random.uniform(1e-6, 1e-3)\n\n        test_cases.append((x, y, weight, reduction, eps))\n\n    return test_cases"}
{"problem_id": "pytorch_74", "library": "pytorch", "code_problem": "You are tasked with creating a function that constructs a neural network model using PyTorch. The function should allow for a customizable architecture based on the number of layers, number of units per layer, and the type of non-linear activation function to be used.\n\nFunction signature:\n```python\ndef create_net(n_inputs: int, n_outputs: int, n_layers: int, n_units: int, nonlinear: callable) -> nn.Sequential:\n```\n\nConstant used in the main code:\n- There are no constants defined in the main code.\n\nInput format:\n- The function accepts five parameters: `n_inputs`, `n_outputs`, `n_layers`, `n_units`, and `nonlinear`.\n\nOutput format:\n- The function returns an instance of `nn.Sequential`, which represents the constructed neural network model.\n\nInput: (32, 10, 3, 64, nn.ReLU)  \nOutput: Sequential(\n  (0): Linear(in_features=32, out_features=64, bias=True)\n  (1): ReLU()\n  (2): Linear(in_features=64, out_features=64, bias=True)\n  (3): ReLU()\n  (4): Linear(in_features=64, out_features=64, bias=True)\n  (5): ReLU()\n  (6): Linear(in_features=64, out_features=10, bias=True)\n)", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef create_net(n_inputs, n_outputs, n_layers, n_units, nonlinear):\n    if n_layers == 0:\n        return nn.Linear(n_inputs, n_outputs)\n    layers = [nn.Linear(n_inputs, n_units)]\n    for i in range(n_layers - 1):\n        layers.append(nonlinear())\n        layers.append(nn.Linear(n_units, n_units))\n    layers.append(nonlinear())\n    layers.append(nn.Linear(n_units, n_outputs))\n    return nn.Sequential(*layers)", "test_script": "import torch.nn as nn\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_inputs = random.randint(1, 256)\n        n_outputs = random.randint(1, 256)\n        n_layers = random.randint(0, 10)\n        n_units = random.randint(1, 512)\n        nonlinear = random.choice([nn.ReLU, nn.Tanh, nn.Sigmoid])\n\n        test_cases.append((n_inputs, n_outputs, n_layers, n_units, nonlinear))\n\n    return test_cases"}
{"problem_id": "pytorch_75", "library": "pytorch", "code_problem": "```python\ndef get_r_adv(x, it, xi, eps):\n```\n\nIn this code, the function `get_r_adv` is designed to compute an adversarial perturbation for a given input tensor `x`. The function takes four parameters: \n\n- `x`: a tensor representing the input data.\n- `it`: an integer representing the number of iterations for the optimization process.\n- `xi`: a scalar that scales the direction of the perturbation.\n- `eps`: a scalar that defines the maximum allowable perturbation magnitude.\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A tensor of shape (N, C, H, W) where N is the batch size, C is the number of channels, and H and W are the height and width of the input images.\n  - `it`: An integer representing the number of iterations for the optimization process.\n  - `xi`: A float representing the scaling factor for the perturbation direction.\n  - `eps`: A float representing the maximum allowable perturbation magnitude.\n\n- **Output**: \n  - Returns a tensor of the same shape as `x`, representing the computed adversarial perturbation `r_adv`.\n\nInput:\n```python\nx = torch.tensor([[0.1, 0.2, 0.7], [0.3, 0.4, 0.3]])\nit = 5\nxi = 0.01\neps = 0.1\n```\n\nOutput\n```python\ntensor([[ 0.0412,  0.0404, -0.0816],\n        [ 0.0429, -0.0816,  0.0387]])\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\ndef _l2_normalize(d):\n    d_reshaped = d.view(d.shape[0], -1, *(1 for _ in range(d.dim() - 2)))\n    d /= torch.norm(d_reshaped, dim=1, keepdim=True) + 1e-08\n    return d\n\n# main code\ndef get_r_adv(x, it, xi, eps):\n    x_detached = x.detach()\n    with torch.no_grad():\n        pred = F.softmax(x_detached, dim=1)\n    d = torch.rand(x.shape).sub(0.5)\n    d = _l2_normalize(d)\n    for _ in range(it):\n        d.requires_grad_()\n        pred_hat = x_detached + xi * d\n        logp_hat = F.log_softmax(pred_hat, dim=1)\n        adv_distance = F.kl_div(logp_hat, pred, reduction='batchmean')\n        adv_distance.backward()\n        d = _l2_normalize(d.grad)\n    r_adv = d * eps\n    return r_adv", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 64)\n        num_classes = random.randint(2, 1000)\n        input_shape = (batch_size, num_classes)\n        x = torch.randn(input_shape)\n        it = random.randint(1, 10)\n        xi = random.uniform(1e-5, 1e-1)\n        eps = random.uniform(1e-3, 1.0)\n\n        test_cases.append((x, it, xi, eps))\n    return test_cases"}
{"problem_id": "pytorch_76", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the loss for a contrastive learning task using PyTorch. The function will take in a set of query vectors, key vectors, and negative key vectors, and it will calculate the cross-entropy loss based on the similarity between the query and key vectors, as well as the negative samples.\n\nFunction signature:\n```python\ndef compute_loss(q: torch.Tensor, k: torch.Tensor, k_negs: torch.Tensor, T: float) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- The constant `T` represents the temperature parameter used to scale the logits before applying the softmax function in the cross-entropy loss calculation.\n\nInput format:\n- `q`: A tensor of shape (n, c) representing n query vectors, each of dimension c.\n- `k`: A tensor of shape (n, c) representing n key vectors, each of dimension c.\n- `k_negs`: A tensor of shape (n, m, c) representing n sets of m negative key vectors, each of dimension c.\n- `T`: A float representing the temperature parameter.\n\nOutput format:\n- The function returns a tensor representing the computed loss, which is a scalar value.\n\nInput:\n```python\nq = torch.tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]])\nk = torch.tensor([[0.1, 0.2, 0.3], [0.7, 0.8, 0.9]])\nk_negs = torch.tensor([[0.1, 0.4], [0.2, 0.5], [0.3, 0.6]])\nT = 0.5\n```\n\nOutput:\n```python\nloss = compute_loss(q, k, k_negs, T)\n# loss = tensor(0.8429)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef compute_loss(q, k, k_negs, T):\n    l_pos = torch.einsum('nc,nc->n', [q, k]).unsqueeze(-1)\n    l_neg = torch.einsum('nc,ck->nk', [q, k_negs])\n    logits = torch.cat([l_pos, l_neg], dim=1)\n    logits /= T\n    labels = torch.zeros(logits.shape[0], dtype=torch.long)\n    loss = F.cross_entropy(logits, labels)\n    return loss", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = torch.randint(1, 100, (1,)).item()\n        feature_dim = torch.randint(1, 512, (1,)).item()\n        num_negatives = torch.randint(1, 100, (1,)).item()\n\n        q = torch.rand(batch_size, feature_dim)\n        k = torch.rand(batch_size, feature_dim)\n        k_negs = torch.rand(feature_dim, num_negatives)\n        T = torch.rand(1).item() + 0.1\n\n        test_cases.append((q, k, k_negs, T))\n\n    return test_cases"}
{"problem_id": "pytorch_77", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a specific matrix-vector operation. The function signature is as follows:\n\n```python\ndef _matvec(v: torch.Tensor, _n: int, _p: float, X: torch.Tensor, _q: float) -> torch.Tensor:\n```\n\nIn this function, the following constant is used:\n- `_k`: This represents the number of rows in the input tensor `X`.\n\nInput format:\n- `v`: A tensor of shape `(k * m,)` where `k` is the number of rows in `X` and `m` is the number of columns in `v`.\n- `_n`: An integer representing the number of columns to be used from the top part of `v`.\n- `_p`: A float scalar that is used to scale the `vtop` part.\n- `X`: A tensor of shape `(k, d)` where `k` is the number of rows and `d` is the number of columns.\n- `_q`: A float scalar that is used to scale the `vbottom` part.\n\nOutput format:\n- The function returns a tensor of shape `(k * (m - n + d),)` which is the flattened result of the matrix-vector operation.\n\nInput:\n```python\nv = torch.tensor([-0.5, 0.3, 0.1,\n                  0.2, -0.1, 0.4,\n                  0.6, -0.2, 0.0,\n                  0.5, 0.7, -0.9])  # total 12 elements\n\n_n = 3\n_p = 0.7\nX = torch.tensor([[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]],\n                  [[1.0, 1.1, 1.2], [1.3, 1.4, 1.5], [1.6, 1.7, 1.8]],\n                  [[2.0, 2.1, 2.2], [2.3, 2.4, 2.5], [2.6, 2.7, 2.8]]])\n_q = 0.9\n```\n\nOutput:\n```python\ntensor([-0.2300,  0.5100,  0.5500,  0.3200,  0.3100,  0.3000, -0.7300, -0.5600,\n        -0.6000,  1.2000,  1.2900,  1.3800, -5.6700, -6.1300, -6.8000,  2.1600,\n         2.2800,  2.4000])\n```", "ground_truth_code": "import torch\n\ndef _matvec(v, _n, _p, X, _q):\n    _k = X.shape[0]\n    v = v.reshape(_k, -1)\n    vtop, vbottom = v[:, :_n], v[:, _n:]\n    Avtop = vtop * _p + torch.sum(X * vbottom[:, None, :], dim=2)\n    Avbottom = torch.sum(X * vtop[:, :, None], dim=1) + vbottom * _q\n    return torch.hstack((Avtop, Avbottom)).ravel()", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        _k = random.randint(1, 10)\n        _n = random.randint(1, 10)\n        _m = random.randint(1, 10)\n\n        _p = torch.randn(1).item()\n        _q = torch.randn(1).item()\n        X = torch.randn(_k, _n, _m)\n\n        v_dim = _k * (_n + _m)\n        v = torch.randn(v_dim)\n\n        test_cases.append((v, _n, _p, X, _q))\n\n    return test_cases"}
{"problem_id": "pytorch_78", "library": "pytorch", "code_problem": "```python\ndef instance_contrastive_loss(z1, z2):\n```\n\nIn this function, the goal is to compute the instance contrastive loss between two sets of embeddings, `z1` and `z2`. The constant used in the main code is `B`, which represents the batch size, and `T`, which represents the number of time steps or features in each embedding.\n\n### Input and Output Format:\n- **Input**: The function takes two tensors `z1` and `z2`, both of shape `(B, T)`.\n- **Output**: The function returns a single scalar value representing the instance contrastive loss.\n\nInput:\n```python\nz1 = torch.tensor([[[-0.1234, 0.5678, -0.9101],\n                     [0.2345, -0.6789, 0.1234]]])  # Shape: (1, 2, 3)\n\nz2 = torch.tensor([[[-0.4321, 0.8765, -0.2109],\n                     [0.3456, -0.7890, 0.2345]]])  # Shape: (1, 2, 3)\n```\n\nOutput:\n```python\nloss = instance_contrastive_loss(z1, z2)\n# tensor(0.)\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef instance_contrastive_loss(z1, z2):\n    (B, T) = (z1.size(0), z1.size(1))\n    z = torch.cat([z1, z2], dim=0)\n    z = z.transpose(0, 1)\n    sim = torch.matmul(z, z.transpose(1, 2))\n    logits = torch.tril(sim, diagonal=-1)[:, :, :-1]\n    logits += torch.triu(sim, diagonal=1)[:, :, 1:]\n    logits = -F.log_softmax(logits, dim=-1)\n    i = torch.arange(B, device=z1.device)\n    loss = (logits[:, i, B + i - 1].mean() + logits[:, B + i, i].mean()) / 2\n    return loss", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        B = torch.randint(1, 100, (1,)).item()\n        T = torch.randint(1, 50, (1,)).item()\n        D = torch.randint(1, 128, (1,)).item()\n\n        z1 = torch.randn(B, T, D)\n        z2 = torch.randn(B, T, D)\n\n        test_cases.append((z1, z2))\n\n    return test_cases"}
{"problem_id": "pytorch_79", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a sequence of data using a Long Short-Term Memory (LSTM) network. The function will take in a sequence of input data, a batch size, hyperparameters, and the necessary LSTM and linear layers for processing. The function will return the output of the LSTM after applying a linear transformation if specified.\n\nFunction signature:\n```python\ndef forward(sequence, batch_size, hparams, lstm, linear, embedding):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which represents the number of layers in the LSTM.\n\nInput format:\n- `sequence`: A tensor representing the input sequence of indices.\n- `batch_size`: An integer representing the number of sequences to process in parallel.\n- `hparams`: A dictionary containing hyperparameters, including 'batch_size' and 'hidden_dim'.\n- `lstm`: An instance of an LSTM layer.\n- `linear`: An optional linear layer for transforming the output.\n- `embedding`: An embedding layer for converting input indices to dense vectors.\n\nOutput format:\n- The function returns a tensor representing the output of the LSTM after applying the linear transformation (if applicable).\n\n**Input:**\n```python\nsequence = torch.tensor([[1, 2, 3, 4, 5],\n                          [6, 7, 8, 9, 10]])\nbatch_size = 2\nhparams = {\n    \"batch_size\": batch_size,\n    \"hidden_dim\": 128\n}\nembedding = torch.nn.Embedding(20, 16)  # vocab_size = 20, embedding_dim = 16\nlstm = torch.nn.LSTM(16, 128, batch_first=False)  # embedding_dim = 16, hidden_dim = 128\nlinear = torch.nn.Linear(128, 128)  # linear layer\n```\n\n**Output:**\n```python\noutput = forward(sequence, batch_size, hparams, lstm, linear, embedding)\ntensor([[ 0.0272, -0.0138,  0.0007, -0.0845,  0.0997, -0.0245,  0.0009, -0.0409,\n          0.0104,  0.0571, -0.0647,  0.0074,  0.0313, -0.0032, -0.0100, -0.0859,\n          0.0530, -0.0676,  0.0726, -0.0867, -0.0890,  0.1178, -0.0279,  0.0175,\n          0.0545,  0.0688, -0.1117,  0.0567, -0.0530,  0.0417, -0.0362,  0.1115,\n         -0.0931, -0.0156, -0.0231,  0.0073,  0.0363, -0.0405, -0.0023, -0.0177,\n          0.0429, -0.0956,  0.0122, -0.1225,  0.0039, -0.0768, -0.0860, -0.1325,\n          0.0594,  0.0692,  0.0248,  0.0114,  0.0553,  0.1317,  0.0571,  0.0039,\n         -0.0105,  0.0567,  0.0362, -0.0626,  0.0864,  0.0695,  0.0119, -0.0286,\n          0.0461, -0.0113, -0.0413,  0.0177, -0.1562,  0.0484,  0.0998,  0.0412,\n          0.0628, -0.0345, -0.0687,  0.0897, -0.0734, -0.0012,  0.0363, -0.0025,\n         -0.0067,  0.0010,  0.0706, -0.1031,  0.0041,  0.0476,  0.0442, -0.0231,\n          0.1318, -0.1196, -0.0548, -0.0183,  0.0198,  0.1096, -0.0711,  0.0693,\n         -0.0568, -0.0280,  0.1268,  0.0237,  0.0397, -0.0954,  0.0375,  0.0676,\n          0.0936,  0.0370, -0.0606, -0.0690,  0.0620, -0.0884, -0.0440, -0.0103,\n          0.0945,  0.1220,  0.0568, -0.0133,  0.0503,  0.0051, -0.0422, -0.0342,\n         -0.0398,  0.0643,  0.0454, -0.0380,  0.0769, -0.0453, -0.0507,  0.0560],\n        [ 0.0888,  0.0327,  0.0354, -0.0294,  0.0983, -0.0821,  0.0261, -0.0882,\n          0.0185, -0.0429, -0.0039,  0.0282,  0.1028, -0.0642,  0.0220, -0.0993,\n          0.0664, -0.0606,  0.0061, -0.0027, -0.1586,  0.1196,  0.0245,  0.0850,\n          0.0336,  0.0003, -0.0648,  0.0463, -0.1440,  0.0221, -0.0693,  0.1899,\n         -0.0730, -0.0029,  0.0292, -0.0150,  0.0171, -0.0466, -0.0561, -0.0230,\n          0.0976, -0.0585,  0.0703, -0.0590,  0.0413, -0.0377, -0.0658, -0.0227,\n          0.0196,  0.0569,  0.0216, -0.0352,  0.0415,  0.0845,  0.0403, -0.0369,\n          0.0574, -0.0153,  0.0130,  0.0029,  0.1016,  0.1109, -0.0216, -0.0803,\n          0.0280,  0.0115, -0.0511,  0.0465, -0.1128,  0.1163,  0.0784,  0.0610,\n          0.0781,  0.0463,  0.0043,  0.0673, -0.0131, -0.0144,  0.0464, -0.0295,\n          0.0202,  0.0181,  0.0136, -0.0806, -0.0402, -0.0087,  0.0498, -0.0540,\n          0.1556, -0.1587, -0.0385,  0.0609, -0.0179,  0.1659, -0.0834,  0.0543,\n          0.0054, -0.0233,  0.0418,  0.0769,  0.0128, -0.0848, -0.0104,  0.1368,\n          0.0332,  0.0073, -0.0372, -0.1335,  0.0023, -0.0830, -0.0475,  0.0065,\n          0.0906,  0.0293,  0.0367, -0.0104,  0.0536,  0.0384, -0.0094, -0.1024,\n         -0.0895,  0.0496,  0.0599,  0.0274, -0.0007, -0.0642, -0.0056, -0.0014]],\n       grad_fn=<AddmmBackward0>)\n```\n", "ground_truth_code": "import torch\n\n# main code\ndef forward(sequence, batch_size, hparams, lstm, linear, embedding):\n    input = embedding(sequence)\n    input = input.permute(1, 0, 2)\n    batch_size = batch_size or hparams['batch_size']\n    hidden_dim = hparams['hidden_dim']\n    h0 = torch.zeros(1, batch_size, hidden_dim)\n    c0 = torch.zeros(1, batch_size, hidden_dim)\n    lstm.flatten_parameters()\n    lstm_out, (h, c) = lstm(input, (h0, c0))\n    h_last = h[-1]\n    linear_out = linear(h_last) if linear else h_last\n    return linear_out", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        sequence_length = random.randint(5, 50)\n        batch_size = random.randint(1, 16)\n        embedding_dim = random.choice([32, 64, 128])\n        hidden_dim = random.choice([64, 128, 256])\n        vocab_size = random.randint(500, 2000)\n        hparams = {\n            \"batch_size\": batch_size,\n            \"hidden_dim\": hidden_dim\n        }\n        embedding = torch.nn.Embedding(vocab_size, embedding_dim)\n        lstm = torch.nn.LSTM(embedding_dim, hidden_dim, batch_first=False)\n        linear = torch.nn.Linear(hidden_dim, hidden_dim) if random.choice([True, False]) else None\n        sequence = torch.randint(0, vocab_size, (batch_size, sequence_length))\n        test_cases.append((sequence, batch_size, hparams, lstm, linear, embedding))\n    return test_cases"}
{"problem_id": "pytorch_80", "library": "pytorch", "code_problem": "Implement a function that performs the K-means++ initialization algorithm for clustering. The function should select initial cluster centers in a way that speeds up convergence of the K-means algorithm. The function signature is as follows:\n\n```python\ndef _kmeans_plusplus(X: torch.Tensor, n_clusters: int, random_state: int, pairwise_similarity: callable, n_local_trials: int) -> tuple:\n```\n\n### Constants:\n- The constant used in the main code is `2`, which is part of the calculation for `n_local_trials` when it is not provided.\n\n### Input and Output Format:\n- **Input**: \n  - A 2D tensor `X` of shape `(n_samples, n_features)`.\n  - An integer `n_clusters`.\n  - An integer `random_state`.\n  - A callable `pairwise_similarity`.\n  - An integer `n_local_trials`.\n\n- **Output**: \n  - A tuple containing:\n    - A 2D tensor of shape `(n_clusters, n_features)` representing the cluster centers.\n    - A 1D tensor of shape `(n_clusters,)` containing the indices of the selected centers in the original dataset.\n\n**Input:**\n```python\nX = torch.tensor([[1.0, 2.0], [3.0, 4.0], [5.0, 6.0], [7.0, 8.0]], dtype=torch.float32)\nn_clusters = 2\nrandom_state = 42\n\ndef pairwise_similarity(a, b):\n    return torch.cdist(a, b) + 1e-6\n\nn_local_trials = None\n```\n\n**Output:**\n```python\n(tensor([[5., 6.], 5., 6.]]), tensor([2, 2], dtype=torch.int32))\n```", "ground_truth_code": "import torch\nimport numpy as np\n\ndef stable_cumsum(arr, dim=None):\n    if dim is None:\n        arr = arr.flatten()\n        dim = 0\n    out = torch.cumsum(arr, dim=dim, dtype=torch.float64)\n    return out\n\n# main code\ndef _kmeans_plusplus(X, n_clusters, random_state, pairwise_similarity, n_local_trials):\n    (n_samples, n_features) = X.shape\n    generator = torch.Generator(device=str(X.device))\n    generator.manual_seed(random_state)\n    centers = torch.empty((n_clusters, n_features), dtype=X.dtype, device=X.device)\n    if n_local_trials is None:\n        n_local_trials = 2 + int(np.log(n_clusters))\n    center_id = torch.randint(n_samples, (1,), generator=generator, device=X.device)\n    indices = torch.full((n_clusters,), -1, dtype=torch.int, device=X.device)\n    centers[0] = X[center_id]\n    indices[0] = center_id\n    closest_dist_sq = 1 / pairwise_similarity(centers[0, None], X)\n    current_pot = closest_dist_sq.sum()\n    for c in range(1, n_clusters):\n        rand_vals = torch.rand(n_local_trials, generator=generator, device=X.device) * current_pot\n        candidate_ids = torch.searchsorted(stable_cumsum(closest_dist_sq), rand_vals)\n        torch.clip(candidate_ids, None, closest_dist_sq.numel() - 1, out=candidate_ids)\n        distance_to_candidates = 1 / pairwise_similarity(X[candidate_ids], X)\n        torch.minimum(closest_dist_sq, distance_to_candidates, out=distance_to_candidates)\n        candidates_pot = distance_to_candidates.sum(dim=1)\n        best_candidate = torch.argmin(candidates_pot)\n        current_pot = candidates_pot[best_candidate]\n        closest_dist_sq = distance_to_candidates[best_candidate]\n        best_candidate = candidate_ids[best_candidate]\n        centers[c] = X[best_candidate]\n        indices[c] = best_candidate\n    return (centers, indices)", "test_script": "import torch\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(10, 500)\n        n_features = np.random.randint(2, 100)\n        X = torch.randn((n_samples, n_features), dtype=torch.float32)\n        n_clusters = np.random.randint(2, min(n_samples, 20))\n        random_state = np.random.randint(0, 10000)\n        def pairwise_similarity(a, b):\n            return torch.cdist(a, b) + 1e-6\n        n_local_trials = np.random.choice([None, np.random.randint(1, 10)])\n        test_cases.append((X, n_clusters, random_state, pairwise_similarity, n_local_trials))\n    return test_cases"}
{"problem_id": "pytorch_81", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes a log-translation potential based on given input tensors. The function will take in several parameters that influence the calculation of the potential and return updated values for two input tensors.\n\nFunction signature:\n```python\ndef log_translate_potential(u, v, lcost, a, b, mass, eps, rho, rho2):\n```\n\nConstants used in the main code:\n- The constant `2` is used in the calculation of `c1` and in the denominator of the expression for `z`.\n\nInput format:\n- The function accepts two 1D tensors `u` and `v`, a 2D tensor `lcost`, and two 1D tensors `a` and `b`. Additionally, it takes in four scalar values: `mass`, `eps`, `rho`, and `rho2`.\n\nOutput format:\n- The function returns a tuple containing two updated 1D tensors, which are the modified versions of `u` and `v`.\n\n**Input:**\n```python\nu = torch.tensor([0.5, -0.2])\nv = torch.tensor([0.3, 0.1])\nlcost = torch.tensor([[0.1, 0.2], [0.3, 0.4]])\na = torch.tensor([0.6, 0.4])\nb = torch.tensor([0.5, 0.7])\nmass = 0.8\neps = 0.1\nrho = 0.9\nrho2 = 0.95\n```\n\n**Output:**\n```python\noutput = log_translate_potential(u, v, lcost, a, b, mass, eps, rho, rho2)\n# (tensor([ 0.3539, -0.3461]), tensor([ 0.1539, -0.0461]))\n```", "ground_truth_code": "import torch\n\n# main code\ndef log_translate_potential(u, v, lcost, a, b, mass, eps, rho, rho2):\n    c1 = (-torch.cat((u, v), 0) / (mass * rho) + torch.cat((a, b), 0).log()).logsumexp(dim=0) - torch.log(2 * torch.ones([1]))\n    c2 = (a.log()[:, None] + b.log()[None, :] + (u[:, None] + v[None, :] - lcost) / (mass * eps)).logsumexp(dim=1).logsumexp(dim=0)\n    z = 0.5 * mass * eps / (2.0 + 0.5 * (eps / rho) + 0.5 * (eps / rho2))\n    k = z * (c1 - c2)\n    return (u + k, v + k)", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = torch.randint(1, 100, (1,)).item()\n        n = torch.randint(1, 100, (1,)).item()\n        u = torch.randn(m)\n        v = torch.randn(n)\n        lcost = torch.randn(m, n)\n        a = torch.rand(m) + 1e-3\n        b = torch.rand(n) + 1e-3\n        mass = torch.rand(1).item() + 1e-3\n        eps = torch.rand(1).item() + 1e-3\n        rho = torch.rand(1).item() + 1e-3\n        rho2 = torch.rand(1).item() + 1e-3\n\n        test_cases.append((u, v, lcost, a, b, mass, eps, rho, rho2))\n\n    return test_cases"}
{"problem_id": "pytorch_82", "library": "pytorch", "code_problem": "You are tasked with implementing a function that creates a transposed convolutional block using PyTorch's neural network module. The function should allow for the inclusion of an activation function, specifically either Leaky ReLU or ReLU, based on a boolean parameter. \n\nThe function signature is as follows:\n```python\ndef ConvTranspose2dBlock1(c_in: int, c_out: int, k_size: int, stride: int, padding: int, output_padding: int, leaky: bool) -> nn.Sequential:\n```\n\nIn this function, the following constant is used:\n- The Leaky ReLU negative slope is set to 0.1 when the `leaky` parameter is `True`.\n\nThe input format for the function is as follows:\n- `c_in`: Integer representing the number of input channels.\n- `c_out`: Integer representing the number of output channels.\n- `k_size`: Integer representing the size of the convolutional kernel.\n- `stride`: Integer representing the stride of the convolution.\n- `padding`: Integer representing the amount of padding.\n- `output_padding`: Integer representing the additional size added to the output.\n- `leaky`: Boolean indicating whether to use Leaky ReLU or ReLU.\n\nThe output format of the function is:\n- Returns an instance of `nn.Sequential` containing the transposed convolutional layer followed by the specified activation function.\n\n```python\nInput: (32, 64, 3, 2, 1, 0, True)\nOutput: Sequential(\n  (0): ConvTranspose2d(32, 64, kernel_size=(3, 3), stride=(2, 2), padding=(1, 1))\n  (1): LeakyReLU(negative_slope=0.1)\n)\n```", "ground_truth_code": "import torch.nn as nn\n\n# main code\ndef ConvTranspose2dBlock1(c_in, c_out, k_size, stride, padding, output_padding, leaky):\n    if leaky:\n        return nn.Sequential(nn.ConvTranspose2d(c_in, c_out, k_size, stride, padding, output_padding), nn.LeakyReLU(0.1))\n    else:\n        return nn.Sequential(nn.ConvTranspose2d(c_in, c_out, k_size, stride, padding, output_padding), nn.ReLU(inplace=True))", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        c_in = random.randint(1, 64)\n        c_out = random.randint(1, 64)\n        k_size = random.randint(2, 7)\n        stride = random.randint(1, 3)\n        padding = random.randint(0, (k_size - 1) // 2)\n        output_padding = random.randint(0, stride - 1)\n        leaky = random.choice([True, False])\n        test_cases.append((c_in, c_out, k_size, stride, padding, output_padding, leaky))\n\n    return test_cases"}
{"problem_id": "pytorch_83", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the rotation matrix corresponding to a set of Euler angles. The function will take a tensor of Euler angles as input and return the corresponding rotation matrices.\n\nFunction signature:\n```python\ndef R_euler_angle(theta_: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is the identity matrix of size 3x3, which is created using `torch.eye(3)`.\n\nInput format:\n- The input to the function is a tensor `theta_` of shape (n, 3), where `n` is the number of sets of Euler angles, and each set consists of three angles (roll, pitch, yaw).\n\nOutput format:\n- The output of the function is a tensor of shape (n, 3, 3), representing the rotation matrices corresponding to each set of Euler angles provided in the input.\n\n**Input:**\n```python\ntheta_ = torch.tensor([[0.0, 0.0, 0.0],\n                       [1.5708, 0.0, 0.0],\n                       [0.0, 1.5708, 0.0]])\n```\n\n**Output:**\n```python\nR = R_euler_angle(theta_)\ntensor([[[ 1.0000e+00,  0.0000e+00,  0.0000e+00],\n         [ 0.0000e+00,  1.0000e+00,  0.0000e+00],\n         [ 0.0000e+00,  0.0000e+00,  1.0000e+00]],\n        [[ 1.0000e+00,  0.0000e+00,  0.0000e+00],\n         [ 0.0000e+00, -3.6200e-06, -1.0000e+00],\n         [ 0.0000e+00,  1.0000e+00, -3.6200e-06]],\n        [[-3.6200e-06,  0.0000e+00,  1.0000e+00],\n         [ 0.0000e+00,  1.0000e+00,  0.0000e+00],\n         [-1.0000e+00,  0.0000e+00, -3.6200e-06]]])\n\n```", "ground_truth_code": "import torch\n\n# main code\ndef R_euler_angle(theta_):\n    theta = torch.stack([theta_[:, 0], -theta_[:, 1], theta_[:, 2]], dim=1)\n    n = theta.shape[0]\n    R1 = torch.eye(3).repeat(n, 1, 1).to(theta.device)\n    R2 = torch.eye(3).repeat(n, 1, 1).to(theta.device)\n    R3 = torch.eye(3).repeat(n, 1, 1).to(theta.device)\n    R1[:, 0, 0] = torch.cos(theta[:, 2])\n    R1[:, 0, 1] = -torch.sin(theta[:, 2])\n    R1[:, 1, 0] = torch.sin(theta[:, 2])\n    R1[:, 1, 1] = torch.cos(theta[:, 2])\n    R2[:, 0, 0] = torch.cos(theta[:, 1])\n    R2[:, 0, 2] = -torch.sin(theta[:, 1])\n    R2[:, 2, 0] = torch.sin(theta[:, 1])\n    R2[:, 2, 2] = torch.cos(theta[:, 1])\n    R3[:, 1, 1] = torch.cos(theta[:, 0])\n    R3[:, 1, 2] = -torch.sin(theta[:, 0])\n    R3[:, 2, 1] = torch.sin(theta[:, 0])\n    R3[:, 2, 2] = torch.cos(theta[:, 0])\n    return R3 @ R2 @ R1", "test_script": "import torch\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = random.randint(10, 50)\n        theta_ = torch.rand((m, 3)) * 2 * torch.pi - torch.pi\n        test_cases.append(theta_)\n    return test_cases"}
{"problem_id": "pytorch_84", "library": "pytorch", "code_problem": "You are tasked with implementing a function that performs a specific operation on a 4-dimensional tensor using PyTorch. The function is designed to apply a \"relative shift\" to the input tensor, which involves padding the tensor and rearranging its dimensions.\n\nFunction signature:\n```python\ndef rel_shift(x: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to create a zero-padding tensor.\n\nInput format:\n- The input to the function is a 4-dimensional tensor `x` of shape (batch_size, channels, height, width).\n\nOutput format:\n- The output of the function is a 4-dimensional tensor of the same shape as `x`, but with the last dimension adjusted according to the relative shift operation described.\n\nInput:\n```python\ntensor([[[[ 0.1234, -0.5678,  0.9101,  1.2345, -1.2345,  0.6789],\n          [ 0.2345,  0.6789, -0.1234,  0.4567,  1.3456, -0.7890]],\n\n         [[-0.3456,  0.4567,  1.2345, -0.6789,  0.1234,  0.5678],\n          [ 0.7890, -1.2345,  0.6789,  0.9101, -0.4567,  1.2345]]]])\n```\n\nOutput:\n```python\ntensor([[[[-0.5678,  0.9101,  1.2345, -1.2345],\n          [ 0.2345,  0.6789, -0.1234,  0.4567]],\n         [[ 0.4567,  1.2345, -0.6789,  0.1234],\n          [ 0.7890, -1.2345,  0.6789,  0.9101]]]])\n``` \n", "ground_truth_code": "import torch\n\n# main code\ndef rel_shift(x):\n    zero_pad = torch.zeros((x.size()[0], x.size()[1], x.size()[2], 1), dtype=x.dtype)\n    x_padded = torch.cat([zero_pad, x], dim=-1)\n    x_padded = x_padded.view(x.size()[0], x.size()[1], x.size(3) + 1, x.size(2))\n    x = x_padded[:, :, 1:].view_as(x)[:, :, :, :x.size(-1) // 2 + 1]\n    return x", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 16)\n        seq_len = random.randint(1, 128)\n        channel_size = random.randint(1, 64)\n        feature_size = random.randint(2, 128) * 2\n        x = torch.randn((batch_size, seq_len, channel_size, feature_size), dtype=torch.float32)\n        test_cases.append(x)\n    return test_cases"}
{"problem_id": "pytorch_85", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a 3D vector representing an axis of rotation and its angle into a quaternion representation. The quaternion is a four-dimensional vector that is commonly used in computer graphics and robotics to represent rotations in three-dimensional space.\n\nFunction signature:\n```python\ndef axisangle2quat(vec: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant used in the main code is `torch.tensor([0.0])`, which is used to check if the angle is close to zero.\n\nInput format:\n- The input to the function is a 1D tensor of size 3, representing the axis-angle rotation vector.\n\nOutput format:\n- The output of the function is a 1D tensor of size 4, representing the quaternion corresponding to the input axis-angle rotation.\n\n```python\nInput: tensor([-1.0, 2.0, 3.0])\nOutput: tensor([-0.2553,  0.5106,  0.7660, -0.2956])\n```", "ground_truth_code": "import torch\n\n# main code\ndef axisangle2quat(vec):\n    angle = torch.norm(vec)\n    if torch.isclose(angle, torch.tensor([0.0])):\n        return torch.tensor([0.0, 0.0, 0.0, 1.0])\n    axis = vec / angle\n    q = torch.zeros(4)\n    q[3] = torch.cos(angle / 2.0)\n    q[:3] = axis * torch.sin(angle / 2.0)\n    return q", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        vec = torch.tensor([random.uniform(-10, 10) for _ in range(3)], dtype=torch.float32)\n        test_cases.append(vec)\n    return test_cases"}
{"problem_id": "pytorch_86", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the loss for a discriminator in a Generative Adversarial Network (GAN) using binary cross-entropy. The function will take two images and a discriminator model as input, compute the predictions for both images, and calculate the loss based on these predictions.\n\nFunction signature:\n```python\ndef backward_contentD(imageA: torch.Tensor, imageB: torch.Tensor, disContent: nn.Module) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- The constant values `1` and `0` are used to create target tensors for the real and fake predictions, respectively.\n\nInput format:\n- `imageA`: A tensor representing the generated (fake) image.\n- `imageB`: A tensor representing the real image.\n- `disContent`: An instance of a neural network model (discriminator) that takes an image tensor as input and outputs predictions.\n\nOutput format:\n- The function returns a tensor representing the total loss for the discriminator, which is computed using binary cross-entropy.\n\n**Input:**\n```python\nimageA = torch.tensor([[[[ 0.5, -0.2,  0.1],\n                          [ 0.3,  0.4, -0.1],\n                          [-0.3,  0.2,  0.0]]]], dtype=torch.float32)\n\nimageB = torch.tensor([[[[ 0.6,  0.1, -0.3],\n                          [ 0.2,  0.5,  0.0],\n                          [-0.1,  0.3,  0.4]]]], dtype=torch.float32)\n\nclass SimpleDiscriminator(nn.Module):\n    def __init__(self, in_channels):\n        super(SimpleDiscriminator, self).__init__()\n        self.conv = nn.Conv2d(in_channels, 1, kernel_size=3, padding=1)\n        \n    def forward(self, x):\n        return [self.conv(x)]\n\ndisContent = SimpleDiscriminator(in_channels=1)\n\nloss_D = backward_contentD(imageA, imageB, disContent)\n```\n\n**Output:**\n```python\ntensor(1.3877, grad_fn=<AddBackward0>)\n```\n", "ground_truth_code": "import torch\nimport torch.nn as nn\n\n# main code\ndef backward_contentD(imageA, imageB, disContent):\n    pred_fake = disContent.forward(imageA.detach())\n    pred_real = disContent.forward(imageB.detach())\n\n    for (it, (out_a, out_b)) in enumerate(zip(pred_fake, pred_real)):\n        out_fake = torch.sigmoid(out_a)\n        out_real = torch.sigmoid(out_b)\n\n        all1 = torch.ones_like(out_real)\n        all0 = torch.zeros_like(out_fake)\n\n        ad_true_loss = nn.functional.binary_cross_entropy(out_real, all1)\n        ad_fake_loss = nn.functional.binary_cross_entropy(out_fake, all0)\n\n    loss_D = ad_true_loss + ad_fake_loss\n    loss_D.backward()\n\n    return loss_D", "test_script": "import torch\nimport torch.nn as nn\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = random.randint(1, 32)\n        channels = random.choice([1, 3, 16, 32, 64])\n        height = random.randint(16, 128)\n        width = random.randint(16, 128)\n\n        imageA = torch.randn(batch_size, channels, height, width)\n        imageB = torch.randn(batch_size, channels, height, width)\n\n        class SimpleDiscriminator(nn.Module):\n            def __init__(self, in_channels):\n                super(SimpleDiscriminator, self).__init__()\n                self.conv = nn.Conv2d(in_channels, 1, kernel_size=3, padding=1)\n            def forward(self, x):\n                return [self.conv(x)]\n        disContent = SimpleDiscriminator(channels)\n        test_cases.append((imageA, imageB, disContent))\n\n    return test_cases"}
{"problem_id": "pytorch_87", "library": "pytorch", "code_problem": "```python\ndef forward(q, rel1, rel1_rand, rel2, rel2_rand, softmax, left_encoder, right_encoder, linear):\n```\n\nIn this function, the main goal is to compute a similarity score between a query and two sets of relationships, which are represented by `rel1` and `rel2`, along with their randomized counterparts `rel1_rand` and `rel2_rand`. The function utilizes various neural network components to achieve this.\n\n### Constant Used:\n- The constant used in the main code is `math.sqrt`, which is employed to normalize the similarity score.\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `q`: A tensor representing the query.\n  - `rel1`: A tensor representing the first set of relationships.\n  - `rel1_rand`: A tensor representing randomized versions of the first set of relationships.\n  - `rel2`: A tensor representing the second set of relationships.\n  - `rel2_rand`: A tensor representing randomized versions of the second set of relationships.\n  - `softmax`: A softmax function for normalization.\n  - `left_encoder`: A neural network encoder for processing the query.\n  - `right_encoder`: A neural network encoder for processing the relationships.\n  - `linear`: A linear transformation layer.\n\n- **Output**: The function returns a tensor representing the similarity score between the query and the combined relationship encodings.\n\n**Input:**\n```python\nq = torch.tensor([[1, 2, 3, 4, 5]])\nrel1 = torch.tensor([[6, 7, 8, 9, 10]])\nrel1_rand = torch.tensor([[11, 12, 13, 14, 15]])\nrel2 = torch.tensor([[16, 17, 18, 19, 20]])\nrel2_rand = torch.tensor([[21, 22, 23, 24, 25]])\nsoftmax = torch.nn.Softmax(dim=-1)\nlinear = torch.nn.Linear(128, 1, bias=False)\n\nclass Encoder:\n    def __call__(self, x, ret_layer_outs=False):\n        encoded = torch.randn(1, 5, 128)  # Batch size 1, seq_len 5, hidden_dim 128\n        if ret_layer_outs:\n            return x, [encoded], torch.ones(1, 5)\n        return encoded\n\nleft_encoder = Encoder()\nright_encoder = Encoder()\n\nsimilarity_score = forward(q, rel1, rel1_rand, rel2, rel2_rand, softmax, left_encoder, right_encoder, linear)\n```\n\n**Output:**\n```python\ntensor([0.4683], grad_fn=<DivBackward0>)\n```\n", "ground_truth_code": "import torch\nimport math\n\n\ndef forward(q, rel1, rel1_rand, rel2, rel2_rand, softmax, left_encoder, right_encoder, linear):\n    _, q_layer_outs, q_mask = left_encoder(q, ret_layer_outs=True)\n    query_embedding = q_layer_outs[-1]\n    scores = softmax(linear(query_embedding) + torch.log(q_mask.float().unsqueeze(-1)))\n    query_summary = (query_embedding * scores).sum(dim=1)\n    rel1_enc = right_encoder(rel1)\n    rel2_enc = right_encoder(rel2)\n    rel1_rand_enc = right_encoder(rel1_rand)\n    rel2_rand_enc = right_encoder(rel2_rand)\n    rel1_mean = (rel1_enc + rel1_rand_enc) / 2\n    rel2_mean = (rel2_enc + rel2_rand_enc) / 2\n    rel_encoding = torch.cat([rel1_mean, rel2_mean], dim=1).mean(dim=1)\n\n    similarity_score = torch.einsum('bd,bd->b', query_summary, rel_encoding) / math.sqrt(query_summary.size(1))\n\n    return similarity_score", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    batch_size = random.randint(1, 32)\n    seq_len = random.randint(5, 50)\n    hidden_dim = 128\n\n    for _ in range(n):\n        q = torch.randint(0, 1000, (batch_size, seq_len))\n        rel1 = torch.randint(0, 1000, (batch_size, seq_len))\n        rel1_rand = torch.randint(0, 1000, (batch_size, seq_len))\n        rel2 = torch.randint(0, 1000, (batch_size, seq_len))\n        rel2_rand = torch.randint(0, 1000, (batch_size, seq_len))\n        softmax = torch.nn.Softmax(dim=-1)\n        linear = torch.nn.Linear(hidden_dim, 1, bias=False)\n        class Encoder:\n            def __call__(self, x, ret_layer_outs=False):\n                encoded = torch.randn(batch_size, seq_len, hidden_dim)\n                if ret_layer_outs:\n                    return x, [encoded], torch.ones(batch_size, seq_len)\n                return encoded\n\n        left_encoder = Encoder()\n        right_encoder = Encoder()\n\n        test_cases.append((q, rel1, rel1_rand, rel2, rel2_rand, softmax, left_encoder, right_encoder, linear))\n\n    return test_cases"}
{"problem_id": "pytorch_88", "library": "pytorch", "code_problem": "You are tasked with implementing a function that decodes a batch of quantized values into their corresponding color representations in the CIELAB color space. The function will utilize temperature scaling to adjust the probabilities of the quantized values.\n\nFunction signature:\n```python\ndef decode_ind2ab(batch_q: torch.Tensor, T: torch.Tensor, q_to_ab: torch.Tensor) -> torch.Tensor:\n```\n\nConstant used in the main code:\n- `q_to_ab`: A tensor that maps quantized values to their corresponding CIELAB color components.\n\nInput format:\n- `batch_q`: A 4D tensor of shape (N, C, H, W) where N is the batch size, C is the number of channels, and H and W are the height and width of the tensor.\n- `T`: A tensor representing the temperature, which can be a scalar or a tensor of shape (1).\n- `q_to_ab`: A tensor mapping quantized indices to CIELAB values.\n\nOutput format:\n- The function returns a 4D tensor of shape (N, 2, H, W) representing the decoded CIELAB color components, where the first channel corresponds to the 'a' component and the second channel corresponds to the 'b' component.\n\n**Input:**\n```python\nbatch_q = torch.tensor([[[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]]])\nT = torch.tensor(1.0, dtype=torch.float32)\nq_to_ab = torch.tensor([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8]])\n```\n\n**Output:**\n```python\ntensor([[[[0.0009, 0.0009],\n          [0.0009, 0.0009]],\n         [[0.0018, 0.0018],\n          [0.0018, 0.0018]]]])\n```", "ground_truth_code": "import torch\nimport torch.nn.functional as F\n\n# main code\ndef decode_ind2ab(batch_q, T, q_to_ab):\n    _, _, h, w = batch_q.shape\n    batch_q = F.softmax(batch_q, dim=1)\n\n    if T.item() % 1 == 0:\n        sorted_probs, batch_indices = torch.sort(batch_q, dim=1, descending=True)\n        batch_indices = batch_indices[:, int(T.item()):int(T.item()) + 1, :, :]\n        ab = torch.stack([\n            q_to_ab.index_select(0, q_i.flatten()).reshape(h, w, 2).permute(2, 0, 1)\n            for q_i in batch_indices\n        ])\n    else:\n        batch_q = torch.exp(batch_q / T)\n        batch_q /= batch_q.sum(dim=1, keepdim=True)\n\n        a = torch.tensordot(batch_q, q_to_ab[:, 0], dims=([1], [0])).unsqueeze(dim=1)\n        b = torch.tensordot(batch_q, q_to_ab[:, 1], dims=([1], [0])).unsqueeze(dim=1)\n        ab = torch.cat((a, b), dim=1)\n\n    return (ab / 110.0).type(batch_q.dtype)\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        num_q_levels = random.randint(2, 512)\n        height = random.randint(4, 128)\n        width = random.randint(4, 128)\n        batch_q = torch.randn(batch_size, num_q_levels, height, width)\n        if random.random() > 0.5:\n            T = torch.tensor(random.randint(1, num_q_levels - 1), dtype=torch.float32)\n        else:\n            T = torch.tensor(random.uniform(0.1, 10.0), dtype=torch.float32)\n        q_to_ab = torch.randn(num_q_levels, 2)\n\n        test_cases.append((batch_q, T, q_to_ab))\n\n    return test_cases"}
{"problem_id": "pytorch_89", "library": "pytorch", "code_problem": "```python\ndef get_mask(mask: torch.Tensor) -> Tuple[torch.Tensor, torch.Tensor]:\n```\n\nIn this code, the function `get_mask` takes a tensor `mask` as input, which is expected to be a binary tensor indicating the presence (1) or absence (0) of elements in a sequence for each item in a batch. The function processes this mask to create two output tensors: `permutation_mask` and `permutation_minimal`.\n\n### Input and Output Format:\n- **Input**: A binary tensor `mask` of shape `(batch_size, max_length)` where each element is either 0 or 1.\n- **Output**: A tuple containing:\n  - `permutation_mask`: A tensor of shape `(batch_size, max_length, max_length)`.\n  - `permutation_minimal`: A tensor of shape `(batch_size, max_length, max_length)`, filled with the constant value `-100000`.\n\nInput:\n```python\nmask = torch.tensor([[1, 1, 0, 0, 0],\n                     [1, 1, 1, 0, 0]])\n```\n\nOutput:\n```python\npermutation_mask = torch.tensor([[[1., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.]],\n                                [[1., 1., 0., 0., 0.],\n                                 [1., 1., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.],\n                                 [0., 0., 0., 0., 0.]]])\n\npermutation_minimal = torch.tensor([[[-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.]],\n                                   [[-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.],\n                                    [-100000., -100000., -100000., -100000., -100000.]]])\n```", "ground_truth_code": "import torch\n\n\n# main code\ndef get_mask(mask):\n    src_lengths = torch.sum(mask, dim=1).long()\n    max_length = mask.shape[1]\n    batch_size = mask.shape[0]\n    permutation_mask = torch.zeros((batch_size, max_length, max_length))\n\n    for i, src_length in enumerate(src_lengths):\n        src_len = src_length.item()\n        if src_len > 1:\n            perm_matrix = torch.ones((src_len - 1, src_len - 1))\n            padded_matrix = torch.zeros((max_length, max_length))\n            padded_matrix[: src_len - 1, : src_len - 1] = perm_matrix\n\n            permutation_mask[i] = padded_matrix\n\n    permutation_minimal = torch.ones_like(permutation_mask) * -100000\n\n    return permutation_mask, permutation_minimal", "test_script": "import torch\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        batch_size = torch.randint(1, 11, (1,)).item()\n        seq_length = torch.randint(1, 21, (1,)).item()\n        mask = torch.randint(0, 2, (batch_size, seq_length), dtype=torch.float32)\n\n        test_cases.append(mask)\n    return test_cases"}
{"problem_id": "pytorch_90", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the Euclidean distance between two sets of points represented as tensors. The function should take two input tensors, each containing multiple points in a multi-dimensional space, and return a tensor containing the distances between corresponding points in the two input tensors.\n\nFunction signature:\n```python\ndef sim_d(z1: torch.Tensor, z2: torch.Tensor):\n```\n\nIn this function, the constant used is `1`, which is utilized in the summation operation to specify the dimension along which the sum is computed.\n\nInput format:\n- The function accepts two input tensors, `z1` and `z2`, both of which are of type `torch.Tensor`.\n\nOutput format:\n- The function returns a tensor of type `torch.Tensor`, where each element represents the Euclidean distance between corresponding points in the input tensors.\n\n```python\n# Input\nz1 = torch.tensor([[0.1, 0.2], [0.3, 0.4]])\nz2 = torch.tensor([[0.5, 0.6], [0.7, 0.8]])\n\n# Output\noutput = sim_d(z1, z2)  # This will compute the Euclidean distance for each pair of rows\n# Expected Output\n# tensor([0.5657, 0.5657])\n```", "ground_truth_code": "import torch\n\n# main code\ndef sim_d(z1: torch.Tensor, z2: torch.Tensor):\n    return torch.sqrt(torch.sum(torch.pow(z1 - z2, 2), 1))", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        rows = random.randint(1, 100)\n        cols = random.randint(1, 512)\n        z1 = torch.randn(rows, cols)\n        z2 = torch.randn(rows, cols)\n        test_cases.append((z1, z2))\n\n    return test_cases"}
{"problem_id": "pytorch_91", "library": "pytorch", "code_problem": "You are tasked with implementing a function that calculates the cross-entropy loss between a given probability distribution and a uniform prior distribution over categories. The function should allow for different reduction methods to be applied to the computed loss.\n\nFunction signature:\n```python\ndef log_standard_categorical(p: torch.Tensor, reduction: str = 'mean') -> torch.Tensor:\n```\n\nConstant used in the main code:\n- A small constant `1e-08` is used to prevent taking the logarithm of zero.\n\nInput format:\n- `p`: A tensor of shape (N, C) where N is the number of samples and C is the number of categories, representing the predicted probabilities for each category.\n- `reduction`: A string that specifies the reduction method ('mean' or 'sum').\n\nOutput format:\n- A tensor representing the computed cross-entropy loss, either as a single value (if reduction is 'mean') or as the total loss (if reduction is 'sum').\n\nInput:\n```python\np = torch.tensor([[0.2, 0.3, 0.5], [0.1, 0.4, 0.5]])\nreduction = 'mean'\n```\n\nOutput:\n```python\ncross_entropy = tensor(1.0986)\n```", "ground_truth_code": "from torch.nn import functional as F\nimport torch\n\n# main code\ndef log_standard_categorical(p, reduction='mean'):\n    prior = F.softmax(torch.ones_like(p), dim=1)\n    prior.requires_grad = False\n    cross_entropy = -torch.sum(p * torch.log(prior + 1e-08), dim=1)\n    if reduction == 'mean':\n        cross_entropy = torch.mean(cross_entropy)\n    else:\n        cross_entropy = torch.sum(cross_entropy)\n    return cross_entropy", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 100)\n        num_classes = random.randint(2, 50)\n        p = torch.rand((batch_size, num_classes))\n        p = p / p.sum(dim=1, keepdim=True)\n        reduction = random.choice(['mean', 'sum'])\n\n        test_cases.append((p, reduction))\n\n    return test_cases"}
{"problem_id": "pytorch_92", "library": "pytorch", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model on a given training and testing dataset. The function will compute the accuracy of the model based on its predictions.\n\nFunction Signature:\n```python\ndef evaluate(model, train, test, K):\n```\n\n### Constants:\n- `K`: An integer representing the number of top predictions to consider for evaluation.\n\n### Input Format:\n- `model`: A PyTorch model that will be evaluated.\n- `train`: A dataset containing training data in the form of batches, where each batch consists of input data and corresponding target labels.\n- `test`: A dataset containing testing data in the same format as the training dataset.\n- `K`: An integer specifying the number of top predictions to consider.\n\n### Output Format:\n- The function returns a float representing the accuracy of the model on the test dataset.\n\n**Input:**\n```python\n# Model\nclass MockModel:\n    def eval(self):\n        pass\n    def __call__(self, x, mode='test'):\n        assert mode == 'test', \"Only 'test' mode is supported\"\n        return (\n            None,\n            None,\n            torch.tensor([[0.1, 0.2, 0.3, 0.4, 0.5], \n                           [0.5, 0.4, 0.3, 0.2, 0.1], \n                           [0.2, 0.3, 0.4, 0.5, 0.1], \n                           [0.3, 0.1, 0.2, 0.4, 0.5], \n                           [0.4, 0.5, 0.1, 0.2, 0.3]])\n        )\n\n# Train Data\ntrain_data = [\n    (torch.tensor([[0.1, 0.2, 0.3, 0.4, 0.5], \n                    [0.5, 0.4, 0.3, 0.2, 0.1]]), \n     torch.tensor([0, 1])),\n    (torch.tensor([[0.2, 0.3, 0.4, 0.5, 0.1], \n                    [0.3, 0.1, 0.2, 0.4, 0.5]]), \n     torch.tensor([1, 0])),\n]\n\n# Test Data\ntest_data = [\n    (torch.tensor([[0.1, 0.2, 0.3, 0.4, 0.5], \n                    [0.5, 0.4, 0.3, 0.2, 0.1]]), \n     torch.tensor([0, 1])),\n    (torch.tensor([[0.2, 0.3, 0.4, 0.5, 0.1], \n                    [0.3, 0.1, 0.2, 0.4, 0.5]]), \n     torch.tensor([1, 0])),\n]\n\n# K\nK = 5\n\naccuracy = evaluate(MockModel(), train_data, test_data, K)\n```\n\n**Output:**\n```python\naccuracy = 0.5\n```", "ground_truth_code": "import torch\nfrom torch.autograd import Variable\n\n\ndef evaluate(model, train, test, K):\n    model.eval()\n    with torch.no_grad():\n        prev_max = -1000000.0 * torch.ones(K)\n        prev_labels = -1 * torch.LongTensor(K).fill_(1)\n\n        for batch_idx, (x, target) in enumerate(train):\n            x = Variable(x)\n            target = Variable(target)\n            out = model(x, mode='test')\n            a_k = out[2].squeeze(-1)\n            max_act, max_ex = a_k.max(0)\n\n            if (max_act > prev_max).sum() != 0:\n                for i in range(K):\n                    if max_act[i] > prev_max[i]:\n                        prev_labels[i] = target[max_ex[i]]\n                        prev_max[i] = max_act[i]\n\n    count = 0\n    total_count = 0\n    with torch.no_grad():\n        for batch_idx, (x, target) in enumerate(test):\n            x = Variable(x)\n            target = Variable(target)\n            out = model(x, mode='test')\n            a_k = out[2].squeeze(-1)\n            max_act, max_ex = a_k.max(-1)\n            pred = prev_labels[max_ex]\n            count += (pred == target.data).sum().item()\n            total_count += x.size(0)\n\n    accuracy = count / total_count\n    return accuracy\n\n", "test_script": "import torch\nfrom torch.autograd import Variable\n\n\ndef test_case_input_generator(n=200, batch_size=32, input_dim=128, K=10, num_classes=5):\n    test_cases = []\n    for _ in range(n):\n        train_data = [\n            (\n                torch.randn(batch_size, input_dim),\n                torch.randint(0, num_classes, (batch_size,))\n            )\n            for _ in range(5)\n        ]\n        test_data = [\n            (\n                torch.randn(batch_size, input_dim),\n                torch.randint(0, num_classes, (batch_size,))\n            )\n            for _ in range(5)\n        ]\n        class MockModel:\n            def eval(self):\n                pass\n            def __call__(self, x, mode='test'):\n                assert mode == 'test', \"Only 'test' mode is supported\"\n                return (\n                    None,\n                    None,\n                    torch.randn(x.shape[0], K)\n                )\n        model = MockModel()\n        test_cases.append((model, train_data, test_data, K))\n    return test_cases"}
{"problem_id": "pytorch_93", "library": "pytorch", "code_problem": "Implement a function `atomic` that performs various operations on a randomly generated tensor based on the specified task. The function takes in three parameters: `L`, `task`, and `batch_shape`. The constant used in the main code is `1`, which is used to check if `L` is less than or equal to `1`.\n\n### Function Signature\n```python\ndef atomic(L=None, task=None, batch_shape=()):\n```\n\n### Input Format\n- `L`: An integer or `None` representing the length of the sequence.\n- `task`: A string that specifies the operation to perform ('cumsum', 'cummax', 'reverse', 'sort').\n- `batch_shape`: A tuple representing the shape of the batch.\n\n### Output Format\n- Returns a tuple `(x, y)` where:\n  - `x` is a tensor with positional encodings concatenated.\n  - `y` is a tensor containing the result of the specified operation. If the input conditions are not met, it returns `None`.\n\n**Input:**\n```python\n(L=5, task='cumsum', batch_shape=(2, 3))\n```\n\n**Output:**\n```python\n(tensor([[[[-0.2552,  1.0000,  0.0000],\n          [-0.7431,  0.3090,  0.9511],\n          [ 1.0000, -0.8090,  0.5878],\n          [-0.4301, -0.8090, -0.5878],\n          [ 0.2642,  0.3090, -0.9511]],\n         [[ 1.0000,  1.0000,  0.0000],\n          [-0.0912,  0.3090,  0.9511],\n          [ 0.4294, -0.8090,  0.5878],\n          [ 0.0772, -0.8090, -0.5878],\n          [ 0.2903,  0.3090, -0.9511]],\n         [[ 0.3917,  1.0000,  0.0000],\n          [-0.7613,  0.3090,  0.9511],\n          [-1.0000, -0.8090,  0.5878],\n          [-0.4969, -0.8090, -0.5878],\n          [-0.5138,  0.3090, -0.9511]]],\n        [[[ 0.2515,  1.0000,  0.0000],\n          [-0.6669,  0.3090,  0.9511],\n          [-1.0000, -0.8090,  0.5878],\n          [ 0.0561, -0.8090, -0.5878],\n          [ 0.3252,  0.3090, -0.9511]],\n         [[-1.0000,  1.0000,  0.0000],\n          [ 0.9077,  0.3090,  0.9511],\n          [ 0.8576, -0.8090,  0.5878],\n          [ 0.5719, -0.8090, -0.5878],\n          [ 0.3856,  0.3090, -0.9511]],\n         [[-1.0000,  1.0000,  0.0000],\n          [ 0.0697,  0.3090,  0.9511],\n          [ 0.4859, -0.8090,  0.5878],\n          [-0.3078, -0.8090, -0.5878],\n          [ 0.3013,  0.3090, -0.9511]]]]), \n tensor([[[[-2.5521e-01],\n          [-7.0593e-01],\n          [ 9.6328e-04],\n          [-2.1421e-01],\n          [-7.3467e-02]],\n         [[ 1.0000e+00],\n          [ 6.4259e-01],\n          [ 7.7257e-01],\n          [ 7.0766e-01],\n          [ 7.6277e-01]],\n         [[ 3.9172e-01],\n          [-2.6136e-01],\n          [-7.9075e-01],\n          [-9.3324e-01],\n          [-1.0645e+00]]],\n        [[[ 2.5146e-01],\n          [-2.9376e-01],\n          [-8.1721e-01],\n          [-6.7966e-01],\n          [-4.6245e-01]],\n         [[-1.0000e+00],\n          [-6.5277e-02],\n          [ 4.4183e-01],\n          [ 6.6857e-01],\n          [ 7.7044e-01]],\n         [[-1.0000e+00],\n          [-6.5782e-01],\n          [-2.5658e-01],\n          [-3.7612e-01],\n          [-2.0166e-01]]]]))\n```", "ground_truth_code": "import torch\nimport numpy as np\nimport torch.nn.functional as F\n\n\ndef concat_pos(x):\n    L = x.shape[-2]\n    if L <= 1:\n        return x\n\n    pos = (2 * np.pi * torch.arange(L) / L).view(-1, 1)\n    cos = torch.zeros_like(x[..., :1]) + pos.cos()\n    sin = torch.zeros_like(x[..., :1]) + pos.sin()\n    return torch.cat((x, cos, sin), dim=-1)\n\n# main code\ndef atomic(L=None, task=None, batch_shape=()):\n    if L is None or L <= 1:\n        return None\n    seq = torch.randn(size=batch_shape + (L,))\n    F.normalize(seq, p=np.inf, dim=-1, out=seq)\n    x = seq.clone()\n\n    if task == 'cumsum':\n        y = seq.cumsum(-1) / torch.sqrt(torch.arange(1, L + 1, dtype=torch.float32))\n    elif task == 'cummax':\n        y = seq.cummax(-1).values\n    elif task == 'reverse':\n        x = F.pad(seq, (0, L))\n        y = seq.flip(-1)\n    elif task == 'sort':\n        x = F.pad(seq, (0, L))\n        sorted_indices = (seq - seq[..., :1]).abs().sort(dim=-1, stable=True)[1]\n        y = seq.gather(-1, sorted_indices)\n    else:\n        return None\n    x = concat_pos(x.unsqueeze(-1))\n    y = y.unsqueeze(-1)\n\n    return (x, y)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    tasks = ['cumsum', 'cummax', 'reverse', 'sort']\n\n    for _ in range(n):\n        L = random.randint(2, 100)\n        batch_shape = tuple(random.choices(range(1, 5), k=random.randint(0, 2)))\n        task = random.choice(tasks)\n\n        test_cases.append((L, task, batch_shape))\n\n    return test_cases"}
{"problem_id": "pytorch_94", "library": "pytorch", "code_problem": "You are tasked with implementing a function that converts a set of ellipses into a set of Linear Affine Transformations (LAFs). The input to the function will be a tensor representing the parameters of the ellipses, and the output will be a tensor representing the corresponding LAFs.\n\nFunction Signature:\n```python\ndef ells2LAFsT(ells: torch.Tensor) -> torch.Tensor:\n```\n\n### Constants Used:\n- `eps = 1e-12`: A small constant used to prevent division by zero in calculations.\n\n### Input Format:\n- The input `ells` is a tensor of shape `(N, 5)`, where `N` is the number of ellipses. Each row contains the parameters of an ellipse in the format `[x_center, y_center, a, b, c]`.\n\n### Output Format:\n- The output is a tensor of shape `(N, 2, 3)`, where each entry represents a Linear Affine Transformation corresponding to the input ellipses. Each transformation is represented in a 2x3 matrix format.\n\nInput:\n```python\ntensor([[ 0.1234, -0.5678,  1.0005, -0.2000,  0.3001],\n        [ 0.9101,  0.2345,  1.5003,  0.1000,  0.4002]])\n```\n\nOutput:\n```python\ntensor([[[ 1.0738,  0.0000,  0.1234],\n         [ 0.7157,  1.8254, -0.5678]],\n        [[ 0.8233,  0.0000,  0.9101],\n         [-0.2057,  1.5807,  0.2345]]])\n```", "ground_truth_code": "import torch\nimport torch\n\ndef invSqrtTorch(a, b, c):\n    eps = 1e-12\n    mask = (b != 0).float()\n    r1 = mask * (c - a) / (2.0 * b + eps)\n    t1 = torch.sign(r1) / (torch.abs(r1) + torch.sqrt(1.0 + r1 * r1))\n    r = 1.0 / torch.sqrt(1.0 + t1 * t1)\n    t = t1 * r\n    r = r * mask + 1.0 * (1.0 - mask)\n    t = t * mask\n    x = 1.0 / torch.sqrt(r * r * a - 2.0 * r * t * b + t * t * c)\n    z = 1.0 / torch.sqrt(t * t * a + 2.0 * r * t * b + r * r * c)\n    d = torch.sqrt(x * z)\n    x = x / d\n    z = z / d\n    new_a = r * r * x + t * t * z\n    new_b = -r * t * x + t * r * z\n    new_c = t * t * x + r * r * z\n    return (new_a, new_b, new_c)\n\ndef rectifyAffineTransformationUpIsUp(A):\n    det = torch.sqrt(torch.abs(A[:, 0, 0] * A[:, 1, 1] - A[:, 1, 0] * A[:, 0, 1] + 1e-10))\n    b2a2 = torch.sqrt(A[:, 0, 1] * A[:, 0, 1] + A[:, 0, 0] * A[:, 0, 0])\n    A1_ell = torch.cat([(b2a2 / det).contiguous().view(-1, 1, 1), 0 * det.view(-1, 1, 1)], dim=2)\n    A2_ell = torch.cat([((A[:, 1, 1] * A[:, 0, 1] + A[:, 1, 0] * A[:, 0, 0]) / (b2a2 * det)).contiguous().view(-1, 1, 1), (det / b2a2).contiguous().view(-1, 1, 1)], dim=2)\n    return torch.cat([A1_ell, A2_ell], dim=1)\n\n# main code\ndef ells2LAFsT(ells):\n    LAFs = torch.zeros((len(ells), 2, 3))\n    LAFs[:, 0, 2] = ells[:, 0]\n    LAFs[:, 1, 2] = ells[:, 1]\n    a = ells[:, 2]\n    b = ells[:, 3]\n    c = ells[:, 4]\n    sc = torch.sqrt(torch.sqrt(a * c - b * b + 1e-12))\n    (ia, ib, ic) = invSqrtTorch(a, b, c)\n    A = torch.cat([torch.cat([(ia / sc).view(-1, 1, 1), (ib / sc).view(-1, 1, 1)], dim=2), torch.cat([(ib / sc).view(-1, 1, 1), (ic / sc).view(-1, 1, 1)], dim=2)], dim=1)\n    sc = torch.sqrt(torch.abs(A[:, 0, 0] * A[:, 1, 1] - A[:, 1, 0] * A[:, 0, 1]))\n    LAFs[:, 0:2, 0:2] = rectifyAffineTransformationUpIsUp(A / sc.view(-1, 1, 1).repeat(1, 2, 2)) * sc.view(-1, 1, 1).repeat(1, 2, 2)\n    return LAFs", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_ells = random.randint(1, 10)\n        ells = torch.randn((num_ells, 5))\n\n\n        ells[:, 2] = torch.abs(ells[:, 2]) + 1e-3\n        ells[:, 4] = torch.abs(ells[:, 4]) + 1e-3\n        ells[:, 3] = torch.clamp(ells[:, 3], -ells[:, 2] * 0.9, ells[:, 2] * 0.9)\n\n        test_cases.append(ells)\n    return test_cases"}
{"problem_id": "pytorch_95", "library": "pytorch", "code_problem": "You are tasked with implementing a function that transforms bounding box encodings into a format suitable for use with anchor boxes in a 3D space. The function will take in encoded box parameters and anchor box parameters, and it will compute the final positions, sizes, and orientations of the boxes based on the provided inputs.\n\nFunction signature:\n```python\ndef forward(box_encodings: torch.Tensor, anchors: torch.Tensor, encode_angle_to_vector: bool, smooth_dim: bool) -> torch.Tensor:\n```\n\nConstants used in the main code:\n- The constant `0.5` is used to adjust the z-coordinate of the anchor boxes.\n\nInput format:\n- `box_encodings`: A tensor of shape (N, 7) where N is the number of boxes, containing encoded box parameters.\n- `anchors`: A tensor of shape (N, 7) containing anchor box parameters.\n- `encode_angle_to_vector`: A boolean indicating whether the angle is encoded as a vector.\n- `smooth_dim`: A boolean indicating whether to use smooth dimensions for size calculations.\n\nOutput format:\n- A tensor of shape (N, 7) containing the transformed box parameters, including global positions, sizes, and rotation angles.\n\nInput:\n```python\nbox_encodings = torch.tensor([[[ 0.5, -0.2, 0.1, 0.3, 0.4, -0.1, 0.2, 0.5]]])\nanchors = torch.tensor([[[ 1.0, 1.0, 1.0, 2.0, 2.0, 2.0, 0.0]]])\nencode_angle_to_vector = True\nsmooth_dim = False\n```\n\nOutput:\n```python\ntensor([[[2.4142, 0.4343, 1.2952, 2.6997, 2.9836, 1.8097, 0.3948]]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef forward(box_encodings, anchors, encode_angle_to_vector, smooth_dim):\n    (xa, ya, za, wa, la, ha, ra) = torch.split(anchors, 1, dim=-1)\n    if encode_angle_to_vector:\n        (xt, yt, zt, wt, lt, ht, rtx, rty) = torch.split(box_encodings, 1, dim=-1)\n    else:\n        (xt, yt, zt, wt, lt, ht, rt) = torch.split(box_encodings, 1, dim=-1)\n    za = za + ha / 2.0\n    diagonal = torch.sqrt(la ** 2 + wa ** 2)\n    xg = xt * diagonal + xa\n    yg = yt * diagonal + ya\n    zg = zt * ha + za\n    if smooth_dim:\n        lg = (lt + 1) * la\n        wg = (wt + 1) * wa\n        hg = (ht + 1) * ha\n    else:\n        lg = torch.exp(lt) * la\n        wg = torch.exp(wt) * wa\n        hg = torch.exp(ht) * ha\n    if encode_angle_to_vector:\n        rax = torch.cos(ra)\n        ray = torch.sin(ra)\n        rgx = rtx + rax\n        rgy = rty + ray\n        rg = torch.atan2(rgy, rgx)\n    else:\n        rg = rt + ra\n    zg = zg - hg / 2.0\n    return torch.cat([xg, yg, zg, wg, lg, hg, rg], dim=-1)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = random.randint(1, 10)\n        num_anchors = random.randint(1, 5)\n\n        encode_angle_to_vector = random.choice([True, False])\n        smooth_dim = random.choice([True, False])\n\n        anchors = torch.randn(batch_size, num_anchors, 7)\n        if encode_angle_to_vector:\n            box_encodings = torch.randn(batch_size, num_anchors, 8)\n        else:\n            box_encodings = torch.randn(batch_size, num_anchors, 7)\n\n        test_cases.append((box_encodings, anchors, encode_angle_to_vector, smooth_dim))\n\n    return test_cases"}
{"problem_id": "pytorch_96", "library": "pytorch", "code_problem": "You are tasked with implementing a function that normalizes a given dataset by centering it and then whitening it. The function should compute the covariance matrix of the dataset, derive the whitening transformation, and apply it to the data. The function signature is as follows:\n\n```python\ndef normalize_cov(x):\n```\n\nIn this function, the constant used is `n - 1`, which is used in the calculation of the covariance matrix.\n\nInput format:\n- The input `x` is a 2D tensor of shape (n, d), where `n` is the number of samples and `d` is the number of features.\n\nOutput format:\n- The output is a 1D tensor of shape (n * d), which contains the whitened data.\n\nInput:\n```python\ntensor([[ 0.1234, -0.5678,  0.9101],\n        [ 1.2345,  0.6789, -1.2345],\n        [-0.9876,  0.5432,  0.1234]])\n```\n\nOutput:\n```python\ntensor([-2.9995e-05, -1.1490e+00,  9.0063e-01,  1.0000e+00,  6.7370e-01, -1.0761e+00, -9.9998e-01,  4.7530e-01,  1.7550e-01])\n```", "ground_truth_code": "import torch\n\n# main code\ndef normalize_cov(x):\n\n    (n, d) = x.size()\n    x = x.t()\n    x = x - torch.mean(x, 1).unsqueeze(1).repeat(1, x.size(1))\n    cov = torch.matmul(x, x.t()) / (n - 1)\n    whiten = torch.diag(torch.diag(cov) ** (-0.5))\n    return torch.matmul(whiten, x).t().contiguous().view(n * d)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = random.randint(2, 100)\n        d_features = random.randint(1, 50)\n\n        x = torch.randn(n_samples, d_features)\n\n        test_cases.append(x)\n    return test_cases"}
{"problem_id": "pytorch_97", "library": "pytorch", "code_problem": "You are tasked with implementing a function that preprocesses image data for further analysis or model input. The function should handle cropping and resizing of the input data based on the non-zero elements present in the image tensor. The function signature is as follows:\n\n```python\ndef data_precompute(data: torch.Tensor, type: int) -> tuple:\n```\n\n### Constants Used:\n- The constant `479` is used to ensure that the calculated indices do not exceed the dimensions of the input data, which is assumed to be 480x480.\n\n### Input and Output Format:\n- **Input**: \n  - `data`: A 3D tensor of shape (channels, height, width).\n  - `type`: An integer indicating the type of preprocessing.\n\n- **Output**: \n  - A tuple containing:\n    - `input_map`: A 3D tensor of shape (channels, 224, 224) representing the preprocessed image.\n    - A tuple `(x_min, y_min, wh)` where `x_min` and `y_min` are the coordinates of the top-left corner of the bounding box, and `wh` is the width/height of the bounding box.\n\n**Input:**\n```python\ndata = torch.tensor([[[0, 0, 0, ..., 0, 0, 0], \n                       [0, 0, 0, ..., 0, 0, 0], \n                       ...,\n                       [0, 0, 0, ..., 0, 0, 0]], \n                      [[0, 0, 0, ..., 0, 0, 0], \n                       [0, 0, 0, ..., 0, 0, 0], \n                       ...,\n                       [0, 0, 0, ..., 0, 0, 0]], \n                      ...,\n                      [[0, 0, 0, ..., 0, 0, 0], \n                       [0, 0, 0, ..., 0, 0, 0], \n                       ...,\n                       [0, 0, 0, ..., 0, 0, 0]]], dtype=torch.uint8)\n\ntype_value = 5\n```\n\n**Output:**\n```python\n(input_map.shape, (x_min, y_min, wh)) = (torch.Size([3, 224, 224]), (10, 10, 200))\n```\n", "ground_truth_code": "import torch\nimport torchvision.transforms.functional as F\nimport numpy as np\n\ndef min1(a, b):\n    if a < b:\n        return a\n    return b\n\ndef max1(a, b):\n    if a > b:\n        return a\n    return b\n\n# main code\ndef data_precompute(data, type):\n    nz_c = torch.nonzero(torch.sum(data, dim=0))\n    if nz_c.shape[0] == 0:\n        return (np.zeros([17, 480, 480]), (0, 0, 0))\n    (x_min, x_max, y_min, y_max) = (nz_c[:, 0].min(), nz_c[:, 0].max(), nz_c[:, 1].min(), nz_c[:, 1].max())\n    wh = min1(x_max - x_min, y_max - y_min)\n    if type == 0:\n        input_map = F.resize(F.crop(data, x_min, y_min, wh, wh), 224)\n    elif type > 0:\n        dwh = type\n        x_min1 = int(max1(0, x_min - dwh))\n        x_max1 = int(min1(x_max + dwh, 479))\n        y_min1 = int(max1(0, y_min - dwh))\n        y_max1 = int(min1(y_max + dwh, 479))\n        wh1 = min1(x_max1 - x_min1, y_max1 - y_min1)\n        input_map = F.resize(F.crop(data, x_min1, y_min1, wh1, wh1), 224)\n        x_min = x_min1\n        y_min = y_min1\n        wh = wh1\n    else:\n        dwh = type\n        x_min = int(x_min - dwh)\n        y_min = int(y_min - dwh)\n        wh = int(wh + 2 * dwh)\n        input_map = F.resize(F.crop(data, x_min, y_min, wh, wh), 224)\n    return (input_map, (x_min, y_min, wh))", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = torch.randint(0, 256, (17, 480, 480), dtype=torch.uint8)\n\n        if random.random() < 0.3:\n            data *= 0\n        type_value = random.choice([-random.randint(1, 20), 0, random.randint(1, 20)])\n\n        test_cases.append((data, type_value))\n\n    return test_cases"}
{"problem_id": "pytorch_98", "library": "pytorch", "code_problem": "You are tasked with implementing a function that applies a grid sampling operation to a batch of images using a specified grid. The function should handle the images and grids in a batched manner to optimize performance, especially when the number of patches exceeds a defined batch size.\n\nFunction signature:\n```python\ndef batched_grid_apply(img, grid, batch_size=32):\n```\n\nConstant used in the main code:\n- `batch_size`: This constant defines the maximum number of patches to process in a single batch. The default value is set to 32.\n\nInput format:\n- `img`: A tensor representing the batch of images, with shape (N, C, H, W), where N is the number of images, C is the number of channels, H is the height, and W is the width.\n- `grid`: A tensor representing the sampling grid, with shape (N, H_out, W_out, 2), where H_out and W_out are the output height and width, respectively.\n\nOutput format:\n- The function returns a tensor containing the sampled images, with shape (N, C, H_out, W_out), where N is the number of patches, C is the number of channels, and H_out and W_out are the output height and width, respectively.\n\n**Input:**\n```python\nimg = torch.tensor([[[[ 0.1,  0.2,  0.3],\n                      [ 0.4,  0.5,  0.6],\n                      [ 0.7,  0.8,  0.9]]]], dtype=torch.float32)  # Shape: (1, 1, 3, 3)\n\ngrid = torch.tensor([[[[ 0.0,  0.0],\n                       [ 0.5,  0.5]],\n                      \n                      [[ 1.0,  1.0],\n                       [ 0.5,  0.5]]]], dtype=torch.float32)  # Shape: (2, 2, 2)\n\nbatch_size = 1\n```\n\n**Output:**\n```python\noutput = batched_grid_apply(img, grid, batch_size)  \n# tensor([[[[0.5000, 0.8000], [0.2250, 0.8000]]]])\n```", "ground_truth_code": "import torch.nn.functional as F\nimport torch\n\n# main code\ndef batched_grid_apply(img, grid, batch_size=32):\n    n_patches = len(grid)\n    if n_patches > batch_size:\n        bs = batch_size\n        n_batches = int(n_patches / bs + 1)\n        for batch_idx in range(n_batches):\n            st = batch_idx * bs\n            if batch_idx == n_batches - 1:\n                if (batch_idx + 1) * bs > n_patches:\n                    end = n_patches\n                else:\n                    end = (batch_idx + 1) * bs\n            else:\n                end = (batch_idx + 1) * bs\n            if st >= end:\n                continue\n            if batch_idx == 0:\n                if img.size(0) != grid.size(0):\n                    first_batch_out = F.grid_sample(img.expand(end - st, img.size(1), img.size(2), img.size(3)), grid[st:end, :, :, :])\n                else:\n                    first_batch_out = F.grid_sample(img[st:end], grid[st:end, :, :, :])\n                out_size = torch.Size([n_patches] + list(first_batch_out.size()[1:]))\n                out = torch.zeros(out_size, dtype=first_batch_out.dtype)\n                out[st:end] = first_batch_out\n            elif img.size(0) != grid.size(0):\n                out[st:end] = F.grid_sample(img.expand(end - st, img.size(1), img.size(2), img.size(3)), grid[st:end, :, :, :])\n            else:\n                out[st:end] = F.grid_sample(img[st:end], grid[st:end, :, :, :])\n        return out\n    elif img.size(0) != grid.size(0):\n        return F.grid_sample(img.expand(grid.size(0), img.size(1), img.size(2), img.size(3)), grid)\n    else:\n        return F.grid_sample(img, grid)", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        C = random.randint(1, 10)\n        H = random.randint(10, 100)\n        W = random.randint(10, 100)\n        n_patches = random.randint(1, 50)\n        batch_size = random.randint(1, min(32, n_patches))\n        img_batch = random.choice([1, n_patches])\n        img = torch.randn(img_batch, C, H, W)\n        grid = torch.randn(n_patches, H, W, 2)\n        test_cases.append((img, grid, batch_size))\n\n    return test_cases"}
{"problem_id": "pytorch_99", "library": "pytorch", "code_problem": "You are tasked with implementing a function that processes a graph represented in a specific format. The function will extract and organize the neighbors of each node in the graph, along with the corresponding edge weights. The graph is defined by its nodes and edges, where each edge connects two nodes and has an associated weight.\n\nFunction Signature:\n```python\ndef append_neighbors(data: dict) -> dict:\n```\n\nConstant used in the main code:\n- `edge_number`: This constant represents the total number of edges in the graph, derived from the shape of the `edge_index` tensor.\n\nInput Format:\n- The input is a dictionary `data` with the following keys:\n  - `num_nodes`: An integer representing the total number of nodes in the graph.\n  - `edge_index`: A tensor of shape (2, E) where E is the number of edges, representing the connections between nodes.\n  - `edge_attr`: A tensor of shape (E, 1) representing the weights of the edges.\n\nOutput Format:\n- The output is a dictionary containing:\n  - `num_nodes`: The number of nodes in the graph.\n  - `edge_index`: The original edge index tensor.\n  - `edge_attr`: The original edge attributes tensor.\n  - `neighbors`: A list of tensors where each tensor contains the neighbors of each node.\n  - `neighbor_edges`: A list of tensors where each tensor contains the edge weights corresponding to the neighbors.\n  - `n0`: A list of tensors representing the neighbors of the source nodes for each edge.\n  - `n1`: A list of tensors representing the neighbors of the target nodes for each edge.\n  - `n0_edges`: A list of tensors representing the edge weights for the neighbors of the source nodes for each edge.\n  - `n1_edges`: A list of tensors representing the edge weights for the neighbors of the target nodes for each edge.\n\n**Input:**\n```python\n{\n    'num_nodes': 4,\n    'edge_index': torch.tensor([[0, 0, 1, 2],\n                                 [1, 2, 2, 3]], dtype=torch.long),\n    'edge_attr': torch.tensor([[0.5],\n                                [0.3],\n                                [0.2],\n                                [0.4]])\n}\n```\n\n**Output:**\n```python\n{\n   'num_nodes': 4, \n   'edge_index': tensor([[0, 0, 1, 2],\n        [1, 2, 2, 3]]), \n   'edge_attr': tensor([[0.5000],\n        [0.3000],\n        [0.2000],\n        [0.4000]]), \n   'neighbors': [tensor([1, 2]), tensor([0, 2]), tensor([0, 1, 3]), tensor([2])], \n   'neighbor_edges': [tensor([0.5000, 0.3000]), tensor([0.5000, 0.2000]), tensor([0.3000, 0.2000, 0.4000]), tensor([0.4000])], \n   'n0': [tensor([2]), tensor([1]), tensor([0]), tensor([0, 1])], \n   'n1': [tensor([2]), tensor([1, 3]), tensor([0, 3]), tensor([], dtype=torch.int64)], \n   'n0_edges': [tensor([[0.3000]]), tensor([[0.5000]]), tensor([[0.5000]]), tensor([[0.3000, 0.2000]])], \n   'n1_edges': [tensor([[0.2000]]), tensor([[0.2000, 0.4000]]), tensor([[0.3000, 0.4000]]), tensor([], size=(1, 0))]\n}\n\n```", "ground_truth_code": "import torch\n\n# main code\ndef append_neighbors(data):\n    neighbors = [[] for _ in range(data['num_nodes'])]\n    neighbor_edges = [[] for _ in range(data['num_nodes'])]\n\n    edge_number = data['edge_index'].shape[1]\n    for index in range(edge_number):\n        row = data['edge_index'][0][index].item()\n        col = data['edge_index'][1][index].item()\n        edge_weight = data['edge_attr'][index][0].item()\n        neighbors[row].append(col)\n        neighbor_edges[row].append(edge_weight)\n        neighbors[col].append(row)\n        neighbor_edges[col].append(edge_weight)\n\n    n0, n1, n0_edges, n1_edges = [], [], [], []\n    for index in range(edge_number):\n        row = data['edge_index'][0][index].item()\n        col = data['edge_index'][1][index].item()\n\n        n0.append(neighbors[row].copy())\n        n1.append(neighbors[col].copy())\n        n0_edges.append(neighbor_edges[row].copy())\n        n1_edges.append(neighbor_edges[col].copy())\n\n        for i, neighbor in enumerate(n0[index]):\n            if neighbor == col:\n                n0[index].pop(i)\n                n0_edges[index].pop(i)\n                break\n        for i, neighbor in enumerate(n1[index]):\n            if neighbor == row:\n                n1[index].pop(i)\n                n1_edges[index].pop(i)\n                break\n\n        n0[index] = torch.LongTensor(n0[index])\n        n1[index] = torch.LongTensor(n1[index])\n        n0_edges[index] = torch.tensor(n0_edges[index]).unsqueeze(0)\n        n1_edges[index] = torch.tensor(n1_edges[index]).unsqueeze(0)\n\n    for i in range(data['num_nodes']):\n        neighbors[i] = torch.LongTensor(neighbors[i])\n        neighbor_edges[i] = torch.tensor(neighbor_edges[i])\n\n    return {\n        'num_nodes': data['num_nodes'],\n        'edge_index': data['edge_index'],\n        'edge_attr': data['edge_attr'],\n        'neighbors': neighbors,\n        'neighbor_edges': neighbor_edges,\n        'n0': n0,\n        'n1': n1,\n        'n0_edges': n0_edges,\n        'n1_edges': n1_edges\n    }\n", "test_script": "import torch\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_nodes = random.randint(5, 50)\n        num_edges = random.randint(num_nodes, min(num_nodes * (num_nodes - 1) // 2, 200))\n        edges = set()\n        while len(edges) < num_edges:\n            u, v = random.sample(range(num_nodes), 2)\n            if (u, v) not in edges and (v, u) not in edges:\n                edges.add((u, v))\n        edge_index = torch.tensor(list(zip(*edges)), dtype=torch.long)\n        edge_attr = torch.rand((len(edges), 1))\n        data = {\n            'num_nodes': num_nodes,\n            'edge_index': edge_index,\n            'edge_attr': edge_attr\n        }\n        test_cases.append(data)\n    return test_cases"}
{"problem_id": "pytorch_100", "library": "pytorch", "code_problem": "You are tasked with implementing a function that computes the pairwise distance histograms between two sets of data points. The function will utilize tensor operations to efficiently calculate the distances based on the provided input tensors.\n\nFunction signature:\n```python\ndef compute_distance_histograms(a, dx, b, dy):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the number `2`, which is used in the calculation of the pairwise cost.\n\nInput format:\n- The function takes four parameters:\n  - `a`: A 2D tensor of shape (m, n) representing the first set of data points.\n  - `dx`: A 2D tensor of shape (m, n) representing the weights or features associated with the data points in `a`.\n  - `b`: A 2D tensor of shape (p, q) representing the second set of data points.\n  - `dy`: A 2D tensor of shape (p, q) representing the weights or features associated with the data points in `b`.\n\nOutput format:\n- The function returns a 2D tensor of shape (m, p) representing the pairwise distance histograms between the two sets of data points. Each element in the output tensor corresponds to the computed distance between a histogram from `a` and a histogram from `b`.\n\nInput:\n```python\na = torch.tensor([[0.5488, 0.7152, 0.6028], [0.5449, 0.4237, 0.6459]])\ndx = torch.tensor([[0.4376, 0.8918, 0.9637], [0.3834, 0.7917, 0.5289]])\nb = torch.tensor([[0.5680, 0.9256, 0.0710], [0.0871, 0.0202, 0.8326]])\ndy = torch.tensor([[0.7782, 0.8700, 0.9786], [0.7990, 0.4610, 0.7805]])\n```\n\nOutput:\n```python\ntensor([[3.6131e-03, 3.7670e-05],\n        [8.5756e-02, 5.1342e-02]])\n```", "ground_truth_code": "import torch\n\n# main code\ndef compute_distance_histograms(a, dx, b, dy):\n    h_x = torch.einsum('ij, ij->i', dx, a / a.sum(dim=1, keepdim=True))\n    h_y = torch.einsum('ij, ij->i', dy, b / b.sum(dim=1, keepdim=True))\n    lcost = (h_x ** 2)[:, None] + (h_y ** 2)[None, :]\n    lcost = lcost - 2 * h_x[:, None] * h_y[None, :]\n    return lcost", "test_script": "import torch\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        m = torch.randint(2, 20, (1,)).item()\n        n = torch.randint(2, 20, (1,)).item()\n        d = torch.randint(2, 10, (1,)).item()\n\n        a = torch.rand(m, d) + 1e-3\n        dx = torch.rand(m, d)\n\n        b = torch.rand(n, d) + 1e-3\n        dy = torch.rand(n, d)\n\n        test_cases.append((a, dx, b, dy))\n\n    return test_cases"}
{"problem_id": "keras_0", "library": "keras", "code_problem": "You are tasked with creating a simple neural network model using Keras for a reinforcement learning application. The model will take in a state representation and output action probabilities. Your implementation should include a function that builds this model based on the dimensions of the state and action spaces.\n\nFunction signature:\n```python\ndef build_simple_model(action_dim, state_dim):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the number of neurons in the hidden layers, which is set to 64.\n\nInput format:\n- The function takes two integer inputs: `action_dim` (the number of actions) and `state_dim` (the size of the input state).\n\nOutput format:\n- The function returns a tuple containing:\n  1. A Keras model object representing the constructed neural network.\n  2. A list of the model's trainable weights.\n\nInput: (5, 10)  \nOutput: (Model object, List of trainable weights)", "ground_truth_code": "from keras.layers import Input, Dense, Activation\nfrom keras.models import Model\nfrom keras import initializers\n\n# main code\ndef build_simple_model(action_dim, state_dim):\n    input_obs = Input(shape=(state_dim,))\n    h = Dense(64, activation='relu')(input_obs)\n    h = Dense(64, activation='relu')(h)\n    h = Dense(action_dim, kernel_initializer=initializers.RandomUniform(minval=-0.003, maxval=0.003))(h)\n    pred = Activation('tanh')(h)\n    model = Model(inputs=input_obs, outputs=pred)\n    model.compile(optimizer='Adam', loss='categorical_crossentropy')\n    return (model, model.trainable_weights)\n", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        action_dim = random.randint(1, 10)\n        state_dim = random.randint(1, 20)\n        test_cases.append((action_dim, state_dim))\n    return test_cases"}
{"problem_id": "keras_1", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the recall metric for evaluating the performance of a binary classification model. The recall metric is defined as the ratio of true positives to the sum of true positives and false negatives. This function will be used in the context of machine learning, specifically when working with Keras, a popular deep learning library.\n\nFunction signature:\n```python\ndef recall(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero in the recall calculation.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted binary labels (0 or 1).\n\nOutput format:\n- A scalar value representing the recall metric, which is a float between 0 and 1.\n\n```python\n# Input\ny_true = [[1, 0, 1], [0, 1, 0]]\ny_pred = [[0.9, 0.1, 0.8], [0.2, 0.7, 0.1]]\n\n# Output\nrecall_value = 1.0\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef recall(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    return true_positives / (possible_positives + K.epsilon())", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 20)\n        num_classes = np.random.randint(1, 10)\n        shape = (batch_size, num_classes)\n\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n        y_true_tensor = K.variable(y_true)\n        y_pred_tensor = K.variable(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases"}
{"problem_id": "keras_2", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the F1 score, which is a measure of a model's accuracy that considers both precision and recall. The F1 score is particularly useful in situations where the class distribution is imbalanced.\n\nFunction signature:\n```python\ndef f1(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K.epsilon()`: This is a small constant added to prevent division by zero during calculations.\n\nInput format:\n- The function takes two inputs: `y_true` and `y_pred`, which are both expected to be tensors of the same shape containing binary values (0s and 1s).\n\nOutput format:\n- The function returns a single tensor value representing the F1 score, which is a float between 0 and 1.\n\nInput:\n```python\ny_true = tf.convert_to_tensor([[1, 0, 1], [0, 1, 0]], dtype=tf.float32)\ny_pred = tf.convert_to_tensor([[1, 0, 0], [0, 1, 1]], dtype=tf.float32)\n```\n\nOutput:\n```python\nf1_score = f1(y_true, y_pred)  # This will compute the F1 score based on the input tensors\n# Expected output: f1_score will be a tensor representing the F1 score, which is approximately 0.6667\n```", "ground_truth_code": "import tensorflow as tf\n\ndef precision(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    return true_positives / (predicted_positives + K.epsilon())\n\ndef recall(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    return true_positives / (possible_positives + K.epsilon())\n\n# main code\ndef f1(y_true, y_pred):\n    K = tf.keras.backend\n    prec = precision(y_true, y_pred)\n    rec = recall(y_true, y_pred)\n    f1_score = 2 * (prec * rec / (prec + rec + K.epsilon()))\n    return f1_score", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_classes = np.random.randint(2, 20)\n        y_true = np.random.randint(0, 2, (batch_size, num_classes)).astype(np.float32)\n        y_pred = np.random.randint(0, 2, (batch_size, num_classes)).astype(np.float32)\n        y_true_tensor = tf.convert_to_tensor(y_true)\n        y_pred_tensor = tf.convert_to_tensor(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases"}
{"problem_id": "keras_3", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the R-squared (coefficient of determination) metric using Tensorflow Keras backend operations. The R-squared value is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model.\n\nThe function signature of the main code is:\n```python\ndef r2_keras(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K.epsilon()`: This is a small constant added to prevent division by zero in the calculation.\n\nInput format:\n- The function takes two arguments:\n  - `y_true`: A tensor representing the true values.\n  - `y_pred`: A tensor representing the predicted values.\n\nOutput format:\n- The function returns a single scalar value representing the R-squared metric.\n\n```python\n# Input\ny_true = tf.constant([[0.1], [0.2], [0.3], [0.4], [0.5]], dtype=tf.float32)\ny_pred = tf.constant([[0.1], [0.25], [0.35], [0.45], [0.55]], dtype=tf.float32)\n\n# Output\nr2_value = r2_keras(y_true, y_pred)\n# tf.Tensor(0.9000001, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef r2_keras(y_true, y_pred):\n    K = tf.keras.backend\n    SS_res = K.sum(K.square(y_true - y_pred))\n    SS_tot = K.sum(K.square(y_true - K.mean(y_true)))\n    return 1 - SS_res / (SS_tot + K.epsilon())", "test_script": "import numpy as np\nimport tensorflow as tf\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    possible_shapes = [(10,), (10, 1), (32,), (32, 1), (64,), (64, 1)]\n    for _ in range(n):\n        shape = random.choice(possible_shapes)\n        y_true = tf.constant(np.random.rand(*shape), dtype=tf.float32)\n        y_pred = tf.constant(np.random.rand(*shape), dtype=tf.float32)\n\n        test_cases.append((y_true, y_pred))\n    return test_cases"}
{"problem_id": "keras_4", "library": "keras", "code_problem": "You are tasked with implementing a function to compute the recall metric for a binary classification problem using Keras backend operations. The function will take two inputs: the true labels and the predicted labels, both represented as tensors. The recall metric is a crucial evaluation metric in classification tasks, particularly in scenarios where the positive class is of greater interest.\n\nFunction signature:\n```python\ndef compute_recall(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero when calculating the recall.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted binary labels (0 or 1).\n\nOutput format:\n- The function returns a tensor representing the recall value, which is a float between 0 and 1.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0], [1, 1, 0]], dtype='float32')\ny_pred = np.array([[1, 0, 0], [0, 1, 1], [1, 0, 0]], dtype='float32')\n\n# Output\nrecall = compute_recall(y_true, y_pred)  # Expected output: 0.6\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef compute_recall(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    recall = true_positives / (possible_positives + K.epsilon())\n    return recall", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_classes = np.random.randint(1, 20)\n\n        y_true = np.random.randint(0, 2, size=(batch_size, num_classes)).astype('float32')\n        y_pred = np.random.rand(batch_size, num_classes).astype('float32')\n        y_pred = np.round(y_pred)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_5", "library": "keras", "code_problem": "You are tasked with creating a function that builds a neural network model using Keras. The function should allow customization of the model's parameters, including the variance for weight initialization, whether the output layer should have one or three units, the depth of the hidden layers, and the shape of the input data.\n\nFunction signature:\n```python\ndef build_model(variance, bw=False, depth=32, input_shape=(4,)):\n```\n\nConstant used in the main code:\n- The constant used for the default depth of the hidden layers is `32`.\n- The default input shape is `(4,)`.\n\nInput format:\n- A float for `variance`.\n- A boolean for `bw`.\n- An integer for `depth`.\n- A tuple for `input_shape`.\n\nOutput format:\n- The function returns a Keras model object.\n\n```python\nInput: (0.5, True, 64, (5,))\nOutput: <keras.src.engine.sequential.Sequential object at 0x7061189aa9e0>\n```", "ground_truth_code": "from keras import initializers, models, layers\n\n\n# main code\ndef build_model(variance, bw=False, depth=32, input_shape=(4,)):\n    init = initializers.VarianceScaling(scale=variance)\n    model = models.Sequential()\n    model.add(layers.Dense(depth, kernel_initializer=init, activation='tanh', input_shape=input_shape))\n    model.add(layers.Dense(depth, kernel_initializer=init, activation='tanh'))\n    model.add(layers.Dense(depth, kernel_initializer=init, activation='tanh'))\n    model.add(layers.Dense(1 if bw else 3, activation='tanh'))\n    model.compile(optimizer='rmsprop', loss='mse')\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        variance = np.random.uniform(0.01, 2.0)\n        bw = np.random.choice([True, False])\n        depth = np.random.randint(4, 128)\n        input_shape = (np.random.randint(1, 10),)\n\n        test_case = (variance, bw, depth, input_shape)\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "keras_6", "library": "keras", "code_problem": "You are tasked with implementing a deep learning model based on the ResNet architecture, specifically the ResNet50 variant. The model should be able to process input images and produce feature maps that can be used for various computer vision tasks. The architecture utilizes convolutional layers, batch normalization, activation functions, and residual connections to enhance the learning capability of the network.\n\nFunction Signature:\n```python\ndef ResNet50(inputs):\n```\n\n### Constants Used:\n- The momentum for batch normalization is set to `0.95`.\n- The kernel initializer used for convolutional layers is `glorot_uniform(seed=0)`.\n\n### Input and Output Format:\n- **Input**: The input to the `ResNet50` function is a tensor representing the input images, typically of shape `(batch_size, height, width, channels)`.\n- **Output**: The output of the function is a tensor representing the feature maps after processing through the ResNet50 architecture. The shape of the output tensor will depend on the input size and the architecture's configuration.\n\nInput:\n```python\nimport numpy as np\nimport tensorflow as tf\n\n# Generate a single test case input\ninput_shape = (224, 224, 3)\nrandom_input = np.random.randn(*input_shape).astype(np.float32)\ninput_tensor = tf.convert_to_tensor(random_input)\ninput_tensor = tf.expand_dims(input_tensor, axis=0)  # Shape becomes (1, 224, 224, 3)\n```\n\nOutput:\n```python\n# Assuming the ResNet50 function is defined and imported\noutput_tensor = ResNet50(input_tensor)\nprint(output_tensor.shape)  # Expected output shape: (1, 28, 28, 2048)\n```", "ground_truth_code": "from keras.layers import Conv2D, BatchNormalization, Activation, ZeroPadding2D, Add, MaxPooling2D\nfrom keras.initializers import glorot_uniform\n\n\ndef convolutional_block(x, f_kernel_size, filters, strides, dilation, pad):\n    filters_1, filters_2, filters_3 = filters\n    x_shortcut = x\n\n    x = Conv2D(filters_1, kernel_size=(1, 1), strides=strides, padding='valid',\n               kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = ZeroPadding2D(padding=pad)(x)\n    x = Conv2D(filters_2, kernel_size=f_kernel_size, strides=(1, 1), dilation_rate=dilation,\n               kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = Conv2D(filters_3, kernel_size=(1, 1), strides=(1, 1), kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x_shortcut = Conv2D(filters_3, kernel_size=(1, 1), strides=strides, padding='valid',\n                        kernel_initializer=glorot_uniform(seed=0))(x_shortcut)\n    x_shortcut = BatchNormalization(momentum=0.95, axis=-1)(x_shortcut)\n\n    x = Add()([x, x_shortcut])\n    x = Activation('relu')(x)\n    return x\n\n\ndef identity_block(x, f_kernel_size, filters, dilation, pad):\n    filters_1, filters_2, filters_3 = filters\n    x_shortcut = x\n\n    x = Conv2D(filters_1, kernel_size=(1, 1), strides=(1, 1), padding='valid',\n               kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = ZeroPadding2D(padding=pad)(x)\n    x = Conv2D(filters_2, kernel_size=f_kernel_size, strides=(1, 1), dilation_rate=dilation,\n               kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = Conv2D(filters_3, kernel_size=(1, 1), strides=(1, 1), padding='valid',\n               kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n\n    x = Add()([x, x_shortcut])\n    x = Activation('relu')(x)\n    return x\n\n# main code\ndef ResNet50(inputs):\n    x = ZeroPadding2D(padding=(1, 1))(inputs)\n    x = Conv2D(64, (3, 3), strides=(2, 2), kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = ZeroPadding2D(padding=(1, 1))(x)\n    x = Conv2D(64, (3, 3), strides=(1, 1), kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x = ZeroPadding2D(padding=(1, 1))(x)\n    x = Conv2D(128, (3, 3), strides=(1, 1), kernel_initializer=glorot_uniform(seed=0))(x)\n    x = BatchNormalization(momentum=0.95, axis=-1)(x)\n    x = Activation('relu')(x)\n\n    x_stage_1 = MaxPooling2D((3, 3), strides=(2, 2))(x)\n    x = convolutional_block(x_stage_1, (3, 3), [64, 64, 256], strides=1, pad=(1, 1), dilation=1)\n    x = identity_block(x, (3, 3), [64, 64, 256], pad=(1, 1), dilation=1)\n    x_stage_2 = identity_block(x, (3, 3), [64, 64, 256], pad=(1, 1), dilation=1)\n\n    x = convolutional_block(x_stage_2, (3, 3), [128, 128, 512], strides=2, pad=(1, 1), dilation=1)\n    for _ in range(3):\n        x = identity_block(x, (3, 3), [128, 128, 512], pad=(1, 1), dilation=1)\n    x_stage_3 = x\n\n    x = convolutional_block(x_stage_3, (3, 3), [256, 256, 1024], strides=1, pad=(2, 2), dilation=2)\n    for _ in range(5):\n        x = identity_block(x, (3, 3), [256, 256, 1024], pad=(2, 2), dilation=2)\n    x_stage_4 = x\n\n    x = convolutional_block(x_stage_4, (3, 3), [512, 512, 2048], strides=1, pad=(4, 4), dilation=4)\n    for _ in range(2):\n        x = identity_block(x, (3, 3), [256, 256, 2048], pad=(4, 4), dilation=4)\n    x_stage_5 = x\n\n    return x_stage_5", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        input_shape = (224, 224, 3)\n        random_input = np.random.randn(*input_shape).astype(np.float32)\n\n        input_tensor = tf.convert_to_tensor(random_input)\n        input_tensor = tf.expand_dims(input_tensor, axis=0)\n        test_cases.append(input_tensor)\n    return test_cases"}
{"problem_id": "keras_7", "library": "keras", "code_problem": "You are tasked with creating a deep learning model using the ResNet50 architecture as a base. The model should be designed to classify images into a specified number of classes, with the option to include dropout for regularization. \n\nThe function signature for the main code is as follows:\n```python\ndef create_model(num_classes, dropout, shape):\n```\n\nIn this function, the following constant is used:\n- `weights='imagenet'`: This constant indicates that the model should be initialized with weights pre-trained on the ImageNet dataset.\n\nInput format:\n- `num_classes`: An integer representing the number of classes for classification.\n- `dropout`: A float representing the dropout rate (between 0 and 1).\n- `shape`: A tuple representing the shape of the input images (height, width, channels).\n\nOutput format:\n- The function returns a Keras Model object that can be used for training and inference.\n\n```python\nInput: (num_classes=10, dropout=0.25, shape=(224, 224, 3))\nOutput: <keras.engine.training.Model object at 0x...>\n``` \n\n(Note: The output will be a Keras model object, and the specific memory address will vary each time the model is created.)", "ground_truth_code": "from keras.applications.resnet50 import ResNet50\nfrom keras.models import Model\nfrom keras.layers import GlobalAveragePooling2D\nfrom keras.layers import Dropout\nfrom keras.layers import Dense\nfrom keras.layers import Input\n\n# main code\ndef create_model(num_classes, dropout, shape):\n    base_model = ResNet50(weights='imagenet', include_top=False, input_tensor=Input(shape=shape))\n    x = base_model.output\n    x = GlobalAveragePooling2D()(x)\n    x = Dropout(dropout)(x)\n    predictions = Dense(num_classes, activation='softmax')(x)\n    model_final = Model(inputs=base_model.input, outputs=predictions)\n    return model_final", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    valid_shapes = [(224, 224, 3), (256, 256, 3), (299, 299, 3), (512, 512, 3)]\n    for _ in range(n):\n        num_classes = random.randint(2, 1000)\n        dropout = round(random.uniform(0.0, 0.7), 2)\n        shape = random.choice(valid_shapes)\n\n        test_cases.append((num_classes, dropout, shape))\n\n    return test_cases"}
{"problem_id": "keras_8", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the F1 score in a macro-averaged manner for binary classification problems. The F1 score is a measure of a model's accuracy that considers both the precision and the recall of the test to compute the score. The function should handle the true labels and predicted labels as inputs and return the F1 score.\n\nFunction signature:\n```python\ndef F1_macro(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero in the calculation of the F1 score.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted probabilities (values between 0 and 1).\n\nOutput format:\n- Returns a scalar value representing the macro-averaged F1 score.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0], [1, 1, 0]], dtype=np.float32)  # Shape: (3, 3)\ny_pred = np.array([[0.9, 0.1, 0.8], [0.2, 0.7, 0.1], [0.6, 0.4, 0.3]], dtype=np.float32)  # Shape: (3, 3)\n\n# Output\nF1_macro(y_true, y_pred)\n# tf.Tensor(0.8, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef F1_macro(y_true, y_pred):\n    K = tf.keras.backend\n    y_pred_pos = K.round(K.clip(y_pred, 0, 1))\n    y_pred_neg = 1 - y_pred_pos\n    y_pos = K.round(K.clip(y_true, 0, 1))\n    y_neg = 1 - y_pos\n    tp = K.sum(y_pos * y_pred_pos)\n    tn = K.sum(y_neg * y_pred_neg)\n    fp = K.sum(y_neg * y_pred_pos)\n    fn = K.sum(y_pos * y_pred_neg)\n    numerator = tp * tn - fp * fn\n    denominator = K.sqrt((tp + fp) * (tp + fn) * (tn + fp) * (tn + fn))\n    return numerator / (denominator + K.epsilon())", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 100)\n        num_classes = np.random.randint(1, 20)\n\n        y_true = np.random.randint(0, 2, (batch_size, num_classes)).astype(np.float32)\n        y_pred = np.random.rand(batch_size, num_classes).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_9", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a convolutional neural network (CNN) model using Keras. The model should be structured to classify images, specifically designed for a dataset with 10 classes. The architecture of the model consists of multiple convolutional layers, batch normalization, activation functions, max pooling layers, and fully connected layers, with L2 regularization applied to prevent overfitting.\n\nFunction Signature:\n```python\ndef build_model(weight_decay: float, input_shape: tuple) -> keras.models.Sequential:\n```\n\nConstants:\n- The constant used in the main code is the dropout rate of `0.5`, which is applied after the fully connected layers to reduce overfitting.\n\nInput Format:\n- `weight_decay`: A float representing the weight decay for L2 regularization.\n- `input_shape`: A tuple representing the shape of the input images (e.g., (height, width, channels)).\n\nOutput Format:\n- The function returns a Keras `Sequential` model object that represents the constructed CNN architecture.\n\nInput: `(0.0005, (64, 64, 3))`\n\nOutput: `<keras.engine.sequential.Sequential object at 0x...>` (the actual memory address will vary)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import BatchNormalization\nfrom keras.layers import Activation\nfrom keras.layers import MaxPooling2D\nfrom keras.layers import Flatten\nfrom keras.layers import Dense\nfrom keras.layers import Dropout\nfrom keras.initializers import he_normal\nimport keras\n\n# main code\ndef build_model(weight_decay, input_shape):\n    model = Sequential()\n    model.add(Conv2D(64, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block1_conv1', input_shape=input_shape))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(64, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block1_conv2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block1_pool'))\n    model.add(Conv2D(128, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block2_conv1'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(128, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block2_conv2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block2_pool'))\n    model.add(Conv2D(256, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block3_conv1'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(256, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block3_conv2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(256, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block3_conv3'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(256, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block3_conv4'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block3_pool'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block4_conv1'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block4_conv2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block4_conv3'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block4_conv4'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block4_pool'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block5_conv1'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block5_conv2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block5_conv3'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Conv2D(512, (3, 3), padding='same', kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='block5_conv4'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(MaxPooling2D((2, 2), strides=(2, 2), name='block5_pool'))\n    model.add(Flatten(name='flatten'))\n    model.add(Dense(4096, use_bias=True, kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='fc_cifa10'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Dropout(0.5))\n    model.add(Dense(4096, kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='fc2'))\n    model.add(BatchNormalization())\n    model.add(Activation('relu'))\n    model.add(Dropout(0.5))\n    model.add(Dense(10, kernel_regularizer=keras.regularizers.l2(weight_decay), kernel_initializer=he_normal(), name='predictions_cifa10'))\n    model.add(BatchNormalization())\n    model.add(Activation('softmax'))\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        weight_decay = np.random.uniform(1e-6, 1e-2)\n\n        input_height = np.random.choice([32, 64, 128, 224])\n        input_width = input_height\n        input_channels = np.random.choice([1, 3])\n        input_shape = (input_height, input_width, input_channels)\n\n        test_cases.append((weight_decay, input_shape))\n\n    return test_cases"}
{"problem_id": "keras_10", "library": "keras", "code_problem": "You are tasked with implementing a deep learning model based on the ResNet architecture, specifically ResNet v2. The model should be able to take an input shape, a specified depth, and the number of output classes, and return a compiled Keras model.\n\nFunction Signature:\n```python\ndef resnet_v2(input_shape, depth, num_classes):\n```\n\nConstant used in the main code:\n- The constant `num_filters_in` is initialized to `16`, which represents the number of filters in the first convolutional layer.\n\nInput Format:\n- `input_shape`: A tuple of integers (height, width, channels).\n- `depth`: An integer representing the depth of the network.\n- `num_classes`: An integer representing the number of output classes.\n\nOutput Format:\n- Returns a Keras Model object that can be compiled and trained on a dataset.\n\n```python\nInput: ((32, 32, 3), 20, 10)\nOutput: <Keras Model Object>\n``` \n\nIn this case, the input specifies an image shape of 32x32 pixels with 3 color channels, a ResNet depth of 20, and 10 output classes. The output is a Keras model object created by the `resnet_v2` function.", "ground_truth_code": "from keras.layers import Conv2D, BatchNormalization, Activation, Input\nfrom keras.layers import AveragePooling2D, Flatten, Dense\nfrom keras.models import Model\nimport keras\n\ndef resnet_layer(inputs, num_filters=16, kernel_size=3, strides=1, activation='relu', batch_normalization=True, conv_first=True):\n    conv = Conv2D(num_filters, kernel_size=kernel_size, strides=strides, padding='same', kernel_initializer='he_normal')\n    x = inputs\n    if conv_first:\n        x = conv(x)\n        if batch_normalization:\n            x = BatchNormalization()(x)\n        if activation:\n            x = Activation(activation)(x)\n    else:\n        if batch_normalization:\n            x = BatchNormalization()(x)\n        if activation:\n            x = Activation(activation)(x)\n        x = conv(x)\n    return x\n\n# main code\ndef resnet_v2(input_shape, depth, num_classes):\n    depth = int(depth)\n    num_filters_in = 16\n    num_res_blocks = (depth - 2) // 9\n    inputs = Input(shape=input_shape)\n    x = resnet_layer(inputs=inputs, num_filters=num_filters_in, conv_first=True)\n    for stage in range(3):\n        for res_block in range(num_res_blocks):\n            activation = 'relu'\n            batch_normalization = True\n            strides = 1\n            if stage == 0:\n                num_filters_out = num_filters_in * 4\n                if res_block == 0:\n                    activation = None\n                    batch_normalization = False\n            else:\n                num_filters_out = num_filters_in * 2\n                if res_block == 0:\n                    strides = 2\n            y = resnet_layer(x, num_filters=num_filters_in, kernel_size=1, strides=strides, activation=activation, batch_normalization=batch_normalization, conv_first=False)\n            y = resnet_layer(y, num_filters=num_filters_in, conv_first=False)\n            y = resnet_layer(y, num_filters=num_filters_out, kernel_size=1, conv_first=False)\n            if res_block == 0:\n                x = resnet_layer(x, num_filters=num_filters_out, kernel_size=1, strides=strides, activation=None, batch_normalization=False)\n            x = keras.layers.add([x, y])\n        num_filters_in = num_filters_out\n    x = BatchNormalization()(x)\n    x = Activation('relu')(x)\n    x = AveragePooling2D(pool_size=8)(x)\n    y = Flatten()(x)\n    outputs = Dense(num_classes, activation='softmax', kernel_initializer='he_normal')(y)\n    model = Model(inputs=inputs, outputs=outputs)\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    possible_shapes = [(32, 32, 3), (64, 64, 3), (128, 128, 3)]\n    for _ in range(n):\n        input_shape = possible_shapes[np.random.randint(len(possible_shapes))]\n        depth = int(np.random.choice([20, 29, 47]))\n        num_classes = np.random.choice([10, 20])\n        test_cases.append((input_shape, depth, num_classes))\n    return test_cases\n"}
{"problem_id": "keras_11", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the true negative rate (TNR) for a binary classification problem using Keras backend operations. The function should take two inputs: the true labels and the predicted labels, both of which are expected to be in the form of tensors. The function signature is as follows:\n\n```python\ndef tn(y_true, y_pred):\n```\n\nIn this function, a constant `smooth` is defined with a value of `1`. This constant is used to prevent division by zero and to stabilize the calculation of the true negative rate.\n\nThe input format for the function is two tensors: `y_true` and `y_pred`, both representing the true and predicted labels, respectively. The output format is a single tensor representing the true negative rate.\n\nThe return should follow the following format (replace {} into the code problem):\n{}\n\nInput:\n```python\ny_true = np.array([[[[0.0], [0.0], [1.0]], \n                     [[1.0], [0.0], [0.0]], \n                     [[0.0], [1.0], [0.0]]]])\n                     \ny_pred = np.array([[[[0.1], [0.4], [0.8]], \n                     [[0.9], [0.2], [0.1]], \n                     [[0.3], [0.7], [0.2]]]])\n```\n\nOutput:\n```python\ntf.Tensor(1.0, shape=(), dtype=float64)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef tn(y_true, y_pred):\n    K = tf.keras.backend\n    smooth = 1\n    y_pred_pos = K.round(K.clip(y_pred, 0, 1))\n    y_pred_neg = 1 - y_pred_pos\n    y_pos = K.round(K.clip(y_true, 0, 1))\n    y_neg = 1 - y_pos\n    tn = (K.sum(y_neg * y_pred_neg) + smooth) / (K.sum(y_neg) + smooth)\n    return tn", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(5, 100)\n        width = np.random.randint(5, 100)\n        channels = np.random.randint(1, 5)\n        shape = (batch_size, height, width, channels)\n        y_true = np.random.rand(*shape)\n        y_pred = np.random.rand(*shape)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_12", "library": "keras", "code_problem": "You are tasked with implementing a function that computes the dot product of a given input vector and a kernel (weight vector) using the Keras backend. The function should handle the input and kernel as constants and return the result based on the backend being used (TensorFlow or another backend).\n\nFunction signature:\n```python\ndef dot_product(x, kernel):\n```\n\nConstant used in the main code:\n- `K`: This is the Keras backend module that provides various functions for tensor operations.\n\nInput format:\n- The function takes two inputs:\n  - `x`: A list or array-like structure representing the input vector.\n  - `kernel`: A list or array-like structure representing the weight vector.\n\nOutput format:\n- The function returns the result of the dot product as a tensor, which may be a scalar or a tensor of reduced dimensions depending on the backend used.\n\n```python\n# Input\nx = np.array([[0.5, -1.2, 3.0], [1.5, 2.3, -0.7]], dtype=np.float32)\nkernel = np.array([0.1, -0.4, 0.6], dtype=np.float32)\n\n# Output\noutput = tf.Tensor([ 2.3300002 -1.19     ], shape=(2,), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef dot_product(x, kernel):\n    K = tf.keras.backend\n    x = K.constant(x)\n    kernel = K.constant(kernel)\n\n    if K.backend() == 'tensorflow':\n        return K.squeeze(K.dot(x, K.expand_dims(kernel)), axis=-1)\n    else:\n        return K.dot(x, kernel)\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 20)\n        input_dim = np.random.randint(1, 50)\n\n        x = np.random.randn(batch_size, input_dim).astype(np.float32)\n        kernel = np.random.randn(input_dim).astype(np.float32)\n\n        test_cases.append((x, kernel))\n\n    return test_cases\n"}
{"problem_id": "keras_13", "library": "keras", "code_problem": "You are tasked with implementing a function that computes a weight vector based on a given set of inputs. The function signature is as follows:\n\n```python\ndef get_weight_vector(M, w_tm1, k, beta, g, s, gamma, C, batch_size):\n```\n\n### Constants Used:\n- `C`: A constant tensor that is used in the computation of the weight vector.\n\n### Input and Output Format:\n- **Input**: The function takes the following parameters:\n  - `M`: A matrix of shape (batch_size, n_features).\n  - `w_tm1`: A tensor representing the previous weight vector.\n  - `k`: A vector used for calculating cosine distance.\n  - `beta`: A scalar value for scaling the cosine distance.\n  - `g`: A scalar value for weighting the previous and current weight vectors.\n  - `s`: A tensor used in the weighted sum calculation.\n  - `gamma`: A scalar value for exponentiation.\n  - `C`: A constant tensor used in the computation.\n  - `batch_size`: An integer representing the number of samples in the batch.\n\n- **Output**: The function returns a tensor representing the normalized weight vector of shape (batch_size, n_features).\n\n**Input:**\n```python\nimport numpy as np\n\nM = np.array([[[0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9],\n                [0.1, 0.1, 0.1],\n                [0.2, 0.2, 0.2]]], dtype=np.float32)  # Shape: (1, 5, 3)\n\nw_tm1 = np.array([[0.1, 0.2, 0.3, 0.4, 0.5]], dtype=np.float32)  # Shape: (1, 5)\n\nk = np.array([[0.5, 0.5, 0.5]], dtype=np.float32)  # Shape: (1, 3)\n\nbeta = np.array([[0.1]], dtype=np.float32)  # Shape: (1, 1)\n\ng = np.array([[0.5]], dtype=np.float32)  # Shape: (1, 1)\n\ns = np.array([[0.1, 0.2]], dtype=np.float32)\n\ngamma = np.array([[2.0]], dtype=np.float32)  # Shape: (1, 1)\n\nC = np.array([[[0.1, 0.2],\n                [0.3, 0.4],\n                [0.5, 0.6],\n                [0.7, 0.8],\n                [0.9, 1.0]],\n\n               [[1.0, 0.9],\n                [0.8, 0.7],\n                [0.6, 0.5],\n                [0.4, 0.3],\n                [0.2, 0.1]]], dtype=np.float32)  # Shape: (5, 5, 2)\n\nbatch_size = 1\n```\n\n**Output:**\n```python\noutput = tf.Tensor([[0.6709184  0.32908157]], shape=(1, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef renorm(x):\n    K = tf.keras.backend\n    return x / K.sum(x, axis=1, keepdims=True)\n\ndef cosine_distance(M, k):\n    K = tf.keras.backend\n    nk = K.l2_normalize(k, axis=-1)\n    nM = K.l2_normalize(M, axis=-1)\n    return K.batch_dot(nM, nk)\n\n# main code\ndef get_weight_vector(M, w_tm1, k, beta, g, s, gamma, C, batch_size):\n    K = tf.keras.backend\n    num = beta * cosine_distance(M, k)\n    w_c = K.softmax(num)\n    w_g = g * w_c + (1 - g) * w_tm1\n\n    C = K.constant(C)\n    C_expanded = K.expand_dims(C, axis=0)\n    C_repeated = K.repeat_elements(C_expanded, batch_size, axis=0)\n\n    s_reshaped = K.reshape(s, (batch_size, 1, 1, -1))\n\n    C_s = K.sum(C_repeated * s_reshaped, axis=3)\n\n    w_tilda = K.batch_dot(C_s, w_g)\n    return renorm(w_tilda ** gamma)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        memory_size = np.random.randint(5, 20)\n        key_size = np.random.randint(3, 10)\n        num_heads = np.random.randint(1, 5)\n\n        # Generate random tensors with appropriate shapes\n        M = np.random.rand(batch_size, memory_size, key_size).astype(np.float32)\n        w_tm1 = np.random.rand(batch_size, memory_size).astype(np.float32)\n        k = np.random.rand(batch_size, key_size).astype(np.float32)\n        beta = np.random.rand(batch_size, 1).astype(np.float32)\n        g = np.random.rand(batch_size, 1).astype(np.float32)\n        s = np.random.rand(batch_size, num_heads).astype(np.float32)\n        gamma = np.random.rand(batch_size, 1).astype(np.float32)\n        C = np.random.rand(memory_size, memory_size, num_heads).astype(np.float32)\n\n        test_cases.append((M, w_tm1, k, beta, g, s, gamma, C, batch_size))\n\n    return test_cases"}
{"problem_id": "keras_14", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a generator model for a Generative Adversarial Network (GAN) using Keras. The generator will take random noise and class labels as inputs to produce synthetic data. The generator architecture will consist of several dense layers with Leaky ReLU activations and dropout for regularization.\n\nFunction signature:\n```python\ndef build_generator(latent_dim: int, num_classes: int, data_dim: int) -> Model:\n```\n\nConstant used in the main code:\n- The dropout rate is set to 0.3.\n\nInput format:\n- `latent_dim`: An integer representing the size of the input noise vector.\n- `num_classes`: An integer representing the number of distinct classes for the labels.\n- `data_dim`: An integer representing the dimensionality of the generated data.\n\nOutput format:\n- Returns a Keras Model that takes two inputs (noise and class label) and outputs the generated data.\n\nInput: (latent_dim=32, num_classes=5, data_dim=50)  \nOutput: (Generated data shape: (None, 50))", "ground_truth_code": "from keras.models import Model, Sequential\nfrom keras.layers import Input, multiply, Dense, LeakyReLU, Dropout, Flatten, Embedding\n\n# main code\ndef build_generator(latent_dim, num_classes, data_dim):\n    generator_seq = Sequential(name='Generator')\n    generator_seq.add(Dense(256, input_dim=latent_dim))\n    generator_seq.add(LeakyReLU(alpha=0.2))\n    generator_seq.add(Dropout(0.3))\n    generator_seq.add(Dense(512))\n    generator_seq.add(LeakyReLU(alpha=0.2))\n    generator_seq.add(Dropout(0.3))\n    generator_seq.add(Dense(1024))\n    generator_seq.add(LeakyReLU(alpha=0.2))\n    generator_seq.add(Dropout(0.3))\n    generator_seq.add(Dense(data_dim, activation='tanh'))\n\n    noise = Input(shape=(latent_dim,), name='noise_input')\n    label = Input(shape=(1,), dtype='int32', name='class_label')\n    label_embedding = Flatten()(Embedding(num_classes, latent_dim)(label))\n    model_input = multiply([noise, label_embedding])\n    generated_data = generator_seq(model_input)\n    return Model(inputs=[noise, label], outputs=generated_data)\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    latent_dim_range = (10, 100)\n    num_classes_range = (2, 10)\n    data_dim_range = (10, 500)\n    for _ in range(n):\n        latent_dim = np.random.randint(latent_dim_range[0], latent_dim_range[1])\n        num_classes = np.random.randint(num_classes_range[0], num_classes_range[1])\n        data_dim = np.random.randint(data_dim_range[0], data_dim_range[1])\n        test_cases.append((latent_dim, num_classes, data_dim))\n    return test_cases\n"}
{"problem_id": "keras_15", "library": "keras", "code_problem": "You are tasked with implementing a function that computes a weighted sum of input vectors based on attention weights. The function will take in a set of input vectors, an optional mask, a flag indicating whether to return attention weights, and an optional weight matrix. The function will utilize Keras backend operations to perform the necessary computations.\n\nFunction signature:\n```python\ndef call(x, mask, return_attention, W=None):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero when normalizing the attention weights.\n\nInput format:\n- `x`: A 2D array-like structure representing the input vectors.\n- `mask`: An optional 2D array-like structure used to mask certain input vectors.\n- `return_attention`: A boolean flag indicating whether to return the attention weights.\n- `W`: An optional 2D array-like structure representing the weight matrix.\n\nOutput format:\n- If `return_attention` is `True`, the output will be a list containing:\n  - A 1D array representing the weighted sum of the input vectors.\n  - A 2D array representing the attention weights.\n- If `return_attention` is `False`, the output will be a 1D array representing the weighted sum of the input vectors.\n\n```python\n# Input\nx = np.array([[[0.1, 0.2, 0.3],\n                [0.4, 0.5, 0.6],\n                [0.7, 0.8, 0.9]]], dtype=np.float32)  # Shape: (1, 3, 3)\n\nmask = np.array([[1, 0, 1]], dtype=np.float32)  # Shape: (1, 3)\nreturn_attention = True\nW = np.array([[0.1],\n              [0.2],\n              [0.3]], dtype=np.float32)  # Shape: (3, 1)\n\n# Output\nresult, att_weights = call(x, mask, return_attention, W)\n# result: tf.Tensor([[0.4534242  0.5534242  0.65342414]], shape=(1, 3), dtype=float32)\n# att_weights: tf.Tensor([[0.41095954 0.         0.58904034]], shape=(1, 3), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, mask, return_attention, W=None):\n    K = tf.keras.backend\n    x = K.constant(x)\n    W = K.constant(W)\n\n    logits = K.dot(x, W)\n    x_shape = K.shape(x)\n    logits = K.reshape(logits, (x_shape[0], x_shape[1]))\n    ai = K.exp(logits - K.max(logits, axis=-1, keepdims=True))\n\n    if mask is not None:\n        mask = K.constant(mask)\n        mask = K.cast(mask, K.floatx())\n        ai = ai * mask\n\n    att_weights = ai / (K.sum(ai, axis=1, keepdims=True) + K.epsilon())\n    weighted_input = x * K.expand_dims(att_weights)\n    result = K.sum(weighted_input, axis=1)\n\n    if return_attention:\n        return [result, att_weights]\n\n    return result", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len = np.random.randint(5, 20)\n        feature_dim = np.random.randint(4, 16)\n\n        x = np.random.randn(batch_size, seq_len, feature_dim).astype(np.float32)\n        W = np.random.randn(feature_dim, 1).astype(np.float32)\n        mask = np.random.choice([0, 1], size=(batch_size, seq_len)).astype(np.float32)\n        return_attention = np.random.choice([True, False])\n\n        test_cases.append((x, mask, return_attention, W))\n\n    return test_cases"}
{"problem_id": "keras_16", "library": "keras", "code_problem": "You are tasked with implementing a reinforcement learning training step for an actor network using Keras and TensorFlow. The main function, `train_step`, is responsible for training the actor network based on the provided state inputs, actions taken, and advantages calculated from the environment.\n\nFunction signature:\n```python\ndef train_step(action_size, state_shape, actor_lr, state_input, action, advantages):\n```\n\nIn this function, the following constant is used:\n- `1e-6`: This small constant is added to avoid logarithm of zero during the calculation of the loss.\n\nInput format:\n- `action_size`: An integer representing the number of possible actions.\n- `state_shape`: A tuple representing the shape of the input state.\n- `actor_lr`: A float representing the learning rate for the actor network.\n- `state_input`: A tensor representing the current state input to the actor network.\n- `action`: A tensor representing the actions taken by the agent.\n- `advantages`: A tensor representing the advantages calculated from the environment.\n\nOutput format:\n- The function returns a tensor representing the loss value computed during the training step.\n\nInput:\n```python\naction_size = 4\nstate_shape = (8,)\nactor_lr = 0.001\nstate_input = np.array([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8],\n                        [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9],\n                        [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n                        [0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1],\n                        [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2],\n                        [0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3],\n                        [0.7, 0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4],\n                        [0.8, 0.9, 1.0, 1.1, 1.2, 1.3, 1.4, 1.5]], dtype=np.float32)\naction = np.array([[0.1, 0.2, 0.3, 0.4],\n                   [0.2, 0.3, 0.4, 0.1],\n                   [0.3, 0.4, 0.1, 0.2],\n                   [0.4, 0.1, 0.2, 0.3],\n                   [0.1, 0.4, 0.3, 0.2],\n                   [0.2, 0.1, 0.4, 0.3],\n                   [0.3, 0.2, 0.1, 0.4],\n                   [0.4, 0.3, 0.2, 0.1]], dtype=np.float32)\nadvantages = np.array([0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 1.1, 1.2], dtype=np.float32)\n```\n\nOutput:\n```python\nloss = train_step(action_size, state_shape, actor_lr, state_input, action, advantages)\n# loss = tf.Tensor(3.0341005, shape=(), dtype=float32)\n```", "ground_truth_code": "from keras.models import Model\nfrom keras.layers import Input, Dense\nfrom keras.optimizers import Adam\nimport tensorflow as tf\n\n\ndef build_actor_network(state_shape, action_size):\n    state_input = Input(shape=state_shape)\n    dense1 = Dense(32, activation='relu')(state_input)\n    dense2 = Dense(32, activation='relu')(dense1)\n    action_output = Dense(action_size, activation='softmax')(dense2)\n    model = Model(inputs=state_input, outputs=action_output)\n    return model\n\ndef actor_loss(action, advantages, policy):\n    action_prob = tf.reduce_sum(action * policy, axis=1)\n    cross_entropy = -tf.reduce_mean(tf.math.log(action_prob + 1e-6) * advantages)\n    entropy = tf.reduce_mean(tf.reduce_sum(policy * tf.math.log(policy + 1e-6), axis=1))\n    return cross_entropy + entropy * entropy\n\n# main code\ndef train_step(action_size, state_shape, actor_lr, state_input, action, advantages):\n    actor = build_actor_network(state_shape, action_size)\n    optimizer = Adam(learning_rate=actor_lr)\n\n    with tf.GradientTape() as tape:\n        policy = actor(state_input, training=True)\n        loss = actor_loss(action, advantages, policy)\n\n    gradients = tape.gradient(loss, actor.trainable_variables)\n    optimizer.apply_gradients(zip(gradients, actor.trainable_variables))\n    return loss", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    state_shape = (8,)\n    action_size = 4\n    batch_size = 32\n    actor_lr = 0.001\n    test_cases = []\n    for _ in range(n):\n        state_input = np.random.rand(batch_size, *state_shape).astype(np.float32)\n        action = np.random.rand(batch_size, action_size).astype(np.float32)\n        advantages = np.random.rand(batch_size).astype(np.float32)\n        test_cases.append((action_size, state_shape, actor_lr, state_input, action, advantages))\n    return test_cases\n"}
{"problem_id": "keras_17", "library": "keras", "code_problem": "You are tasked with implementing a machine learning model to classify handwritten digits using the MNIST dataset. The model will be built using Keras, a high-level neural networks API. Your implementation should include data preprocessing, model building, training, and evaluation.\n\nThe main function signature is as follows:\n```python\ndef train(x_train, y_train, x_test, y_test, batch_size=64, epochs=5):\n```\n\nIn this function, the constant used is `batch_size=64` and `epochs=5`, which are the default parameters for the training process.\n\nInput format:\n- `x_train`: A numpy array of shape (num_samples, 28, 28) representing the training images.\n- `y_train`: A numpy array of shape (num_samples,) representing the labels for the training images.\n- `x_test`: A numpy array of shape (num_samples, 28, 28) representing the testing images.\n- `y_test`: A numpy array of shape (num_samples,) representing the labels for the testing images.\n- `batch_size`: An integer representing the number of samples per gradient update (default is 64).\n- `epochs`: An integer representing the number of epochs to train the model (default is 5).\n\nOutput format:\n- The function returns a tuple containing:\n  - `model`: The trained Keras model.\n  - `score`: A list containing the loss and accuracy of the model on the test dataset.\n\nInput:\n```python\nx_train = np.array([[[  0,  10,  20, ...,  30,  40,  50],\n                     [ 60,  70,  80, ...,  90, 100, 110],\n                     ...,\n                     [200, 210, 220, ..., 230, 240, 250]],\n\n                    [[  5,  15,  25, ...,  35,  45,  55],\n                     [ 65,  75,  85, ...,  95, 105, 115],\n                     ...,\n                     [205, 215, 225, ..., 235, 245, 255]]], dtype=np.uint8)\n\ny_train = np.array([0, 1], dtype=np.uint8)\n\nx_test = np.array([[[  0,  10,  20, ...,  30,  40,  50],\n                    [ 60,  70,  80, ...,  90, 100, 110],\n                    ...,\n                    [200, 210, 220, ..., 230, 240, 250]],\n\n                   [[  5,  15,  25, ...,  35,  45,  55],\n                    [ 65,  75,  85, ...,  95, 105, 115],\n                    ...,\n                    [205, 215, 225, ..., 235, 245, 255]]], dtype=np.uint8)\n\ny_test = np.array([0, 1], dtype=np.uint8)\n```\n\nOutput:\n```python\nmodel, score = train(x_train, y_train, x_test, y_test, batch_size=1, epochs=1)\n# score might look like: (loss, accuracy) = (0.693, 0.500)\n```", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import SGD\nimport keras\n\ndef preprocess_mnist_data(x_train, y_train, x_test, y_test):\n    x_train = x_train.reshape(x_train.shape[0], -1) / 255.0\n    x_test = x_test.reshape(x_test.shape[0], -1) / 255.0\n    y_train = keras.utils.to_categorical(y_train, 10)\n    y_test = keras.utils.to_categorical(y_test, 10)\n    return x_train, y_train, x_test, y_test\n\ndef build_model(input_shape):\n\n    model = Sequential([\n        Dense(512, activation='relu', input_shape=input_shape),\n        Dense(256, activation='relu'),\n        Dense(10, activation='softmax')\n    ])\n    model.compile(optimizer=SGD(), loss='categorical_crossentropy', metrics=['accuracy'])\n    return model\n\n# main cde\ndef train(x_train, y_train, x_test, y_test, batch_size=64, epochs=5):\n    x_train, y_train, x_test, y_test = preprocess_mnist_data(x_train, y_train, x_test, y_test)\n    model = build_model((x_train.shape[1],))\n    model.fit(x_train, y_train, batch_size=batch_size, epochs=epochs, validation_data=(x_test, y_test))\n    score = model.evaluate(x_test, y_test)\n    return model, score", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    num_classes = 10\n    img_rows, img_cols = 28, 28\n    num_train_samples = 1000\n    num_test_samples = 100\n\n    for _ in range(n):\n        x_train = np.random.randint(0, 256, (num_train_samples, img_rows, img_cols), dtype=np.uint8)\n        y_train = np.random.randint(0, num_classes, (num_train_samples,), dtype=np.uint8)\n\n        x_test = np.random.randint(0, 256, (num_test_samples, img_rows, img_cols), dtype=np.uint8)\n        y_test = np.random.randint(0, num_classes, (num_test_samples,), dtype=np.uint8)\n        test_cases.append((x_train, y_train, x_test, y_test))\n\n    return test_cases\n"}
{"problem_id": "keras_18", "library": "keras", "code_problem": "You are tasked with building a convolutional neural network (CNN) model using Keras for a reinforcement learning application. The model will take in a state represented as a 2D image and output action values corresponding to possible actions in an environment. The architecture of the model consists of several convolutional layers followed by fully connected layers.\n\nThe function signature of the main code is:\n```python\ndef _build_model(action_size, state_height, state_width):\n```\n\nIn the main code, the constant used is:\n- The number of filters in the convolutional layers, which is set to 64 for the first two layers and 3 for the last convolutional layer.\n\nInput format:\n- The function takes three parameters:\n  - `action_size`: An integer representing the number of possible actions.\n  - `state_height`: An integer representing the height of the input state image.\n  - `state_width`: An integer representing the width of the input state image.\n\nOutput format:\n- The function returns a compiled Keras Sequential model that can be used for training and predicting action values based on input states.\n\nInput: (5, 32, 32)  \nOutput: Model summary with layers: Conv2D(64, (4, 2)), Conv2D(64, (4, 2)), Conv2D(3, (1, 1)), Flatten, Dense(256), Dense(64), Dense(5)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Conv2D\nfrom keras.layers import Flatten\nfrom keras.layers import Dense\n\n# main code\ndef _build_model(action_size, state_height, state_width):\n    model = Sequential()\n    model.add(Conv2D(64, (4, 2), strides=1, activation='relu', padding='valid', data_format='channels_first', input_shape=(1, state_height, state_width)))\n    model.add(Conv2D(64, (4, 2), strides=1, activation='relu', padding='valid'))\n    model.add(Conv2D(3, 1, strides=1, activation='relu', padding='valid'))\n    model.add(Flatten())\n    model.add(Dense(256, activation='relu'))\n    model.add(Dense(64, activation='relu'))\n    model.add(Dense(action_size, activation='linear'))\n    model.compile(loss='mse')\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        action_size = np.random.randint(1, 10)\n\n        state_height = np.random.randint(8, 64)\n        state_width = np.random.randint(8, 64)\n\n        test_cases.append((action_size, state_height, state_width))\n\n    return test_cases"}
{"problem_id": "keras_19", "library": "keras", "code_problem": "You are tasked with building a neural network model using Keras that serves as a discriminator in a generative adversarial network (GAN) setup. The model will process multiple input sequences, each represented by a different key, and will output a single value indicating the likelihood that the input data is real.\n\nFunction signature:\n```python\ndef build_discriminator(max_length, vocab_size, keys):\n```\n\nConstants used in the main code:\n- The constant `64` is used as the number of units in the dense layer for all keys except 'lat_lon'.\n- The constant `100` is used as the number of units in the dense layer for the trajectory points.\n- The constant `0.02` is used as the regularization parameter for the LSTM layer.\n\nInput format:\n- `max_length`: An integer representing the maximum length of the input sequences.\n- `vocab_size`: A dictionary where each key corresponds to a specific input type and its value is the size of the vocabulary for that input.\n- `keys`: A list of strings representing the different input types, which may include 'mask', 'lat_lon', and others.\n\nOutput format:\n- The function returns a Keras Model object that can be used for training or inference in a GAN setup. The model's input is a list of tensors corresponding to the input layers, and the output is a single tensor representing the discriminator's prediction.\n\nInput:\n```python\n(15, {'lat_lon': 5, 'time': 3}, ['lat_lon', 'time'])\n```\n\nOutput:\n```python\n<keras.engine.training.Model object at 0x7f8c1c0e3b50>\n```", "ground_truth_code": "from keras.layers import Dense, LSTM, Input, Concatenate, Lambda\nfrom keras.models import Model\nfrom keras.initializers import he_uniform\nimport tensorflow as tf\nfrom keras.regularizers import l1\n\n# main code\ndef build_discriminator(max_length, vocab_size, keys):\n    inputs = []\n    embeddings = []\n\n    for key in keys:\n        if key == 'mask':\n            continue\n\n        input_layer = Input(shape=(max_length, vocab_size[key]), name=f'input_{key}')\n        unstacked = Lambda(lambda x: tf.unstack(x, axis=1))(input_layer)\n\n        dense_layer = Dense(\n            units=64 if key == 'lat_lon' else vocab_size[key],\n            use_bias=True,\n            activation='relu',\n            kernel_initializer=he_uniform(seed=1),\n            name=f'emb_{key}'\n        )\n\n        transformed = [dense_layer(x) for x in unstacked]\n        stacked = Lambda(lambda x: tf.stack(x, axis=1))(transformed)\n\n        inputs.append(input_layer)\n        embeddings.append(stacked)\n\n    concat_input = Concatenate(axis=2)(embeddings)\n    unstacked = Lambda(lambda x: tf.unstack(x, axis=1))(concat_input)\n\n    dense_layer = Dense(\n        units=100,\n        use_bias=True,\n        activation='relu',\n        kernel_initializer=he_uniform(seed=1),\n        name='emb_trajpoint'\n    )\n\n    dense_outputs = [dense_layer(x) for x in unstacked]\n    emb_traj = Lambda(lambda x: tf.stack(x, axis=1))(dense_outputs)\n\n    lstm_cell = LSTM(units=100, recurrent_regularizer=l1(0.02))(emb_traj)\n    output_layer = Dense(1, activation='sigmoid')(lstm_cell)\n\n    return Model(inputs=inputs, outputs=output_layer)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    max_length = random.randint(5, 20)\n    possible_keys = ['lat_lon', 'time', 'event', 'sensor']\n    keys = random.sample(possible_keys, k=random.randint(2, len(possible_keys)))\n    vocab_size = {key: random.randint(2, 10) for key in keys}\n    for _ in range(n):\n        test_cases.append((max_length, vocab_size, keys))\n    return test_cases\n"}
{"problem_id": "keras_20", "library": "keras", "code_problem": "You are tasked with implementing a function that prepares input data for various types of neural network models used in natural language processing. The function should handle different configurations based on the model type specified in the configuration object. The input data may consist of text sequences, aspect terms, and additional information depending on the model type. The function will pad these sequences to ensure they are of uniform length, which is essential for processing in neural networks.\n\nFunction signature:\n```python\ndef prepare_input(input_data, asp_max_len, max_len, config, right_max_len, left_max_len):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `padding='post'` and `truncating='post'` for the padding sequences in the 'cabasc' model type.\n\nInput format:\n- `input_data`: A tuple or list containing the sequences to be padded, which varies based on the model type.\n- `asp_max_len`: An integer representing the maximum length for aspect sequences.\n- `max_len`: An integer representing the maximum length for general text sequences.\n- `config`: An object containing model configuration, including `model_name` and `is_aspect_term`.\n- `right_max_len`: An integer representing the maximum length for right text sequences.\n- `left_max_len`: An integer representing the maximum length for left text sequences.\n\nOutput format:\n- The function returns a list containing the padded sequences, where each element corresponds to the padded input for the model type specified in the `config`.\n\n**Input:**\n```python\n(\n    (\n        [[1, 2, 3], [4, 5]],  # text_l\n        [[6, 7, 8, 9], [10]]   # text_r\n    ),\n    5,  # asp_max_len\n    10, # max_len\n    Config(model_name='td_lstm'),  # config\n    10, # right_max_len\n    5   # left_max_len\n)\n```\n\n**Output:**\n```python\n[\n   array([[0, 0, 1, 2, 3],\n       [0, 0, 0, 4, 5]], dtype=int32), \n   array([[ 0,  0,  0,  0,  0,  0,  6,  7,  8,  9],\n       [ 0,  0,  0,  0,  0,  0,  0,  0,  0, 10]], dtype=int32)\n]\n```\n", "ground_truth_code": "from keras.preprocessing.sequence import pad_sequences\nimport numpy as np\n\n# main code\ndef prepare_input(input_data, asp_max_len, max_len, config, right_max_len, left_max_len):\n    input_pad = None\n\n    model_type = config.model_name\n    is_aspect_term = getattr(config, \"is_aspect_term\", False)  # Avoid hardcoded attribute assumptions\n\n    if model_type == 'td_lstm':\n        text_l, text_r = input_data\n        input_pad = [pad_sequences(text_l, left_max_len), pad_sequences(text_r, right_max_len)]\n    elif model_type == 'tc_lstm':\n        text_l, text_r, aspect = input_data\n        input_pad = [pad_sequences(text_l, left_max_len), pad_sequences(text_r, right_max_len), np.array(aspect)]\n    elif model_type in ['at_lstm', 'ae_lstm', 'atae_lstm'] or (model_type in ['memnet', 'ram'] and not is_aspect_term):\n        text, aspect = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect)]\n    elif model_type == 'memnet' and is_aspect_term:\n        text, aspect, loc = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect), pad_sequences(loc, max_len)]\n    elif model_type == 'ram' and is_aspect_term:\n        text, aspect, loc, offset = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect), pad_sequences(loc, max_len), pad_sequences(offset, max_len)]\n    elif model_type == 'ian':\n        text, aspect_text = input_data\n        input_pad = [pad_sequences(text, max_len), pad_sequences(aspect_text, asp_max_len)]\n    elif model_type == 'cabasc':\n        text, text_l, text_r, aspect, mask = input_data\n        input_pad = [\n            pad_sequences(text, max_len, padding='post', truncating='post'),\n            pad_sequences(text_l, max_len, padding='post', truncating='post'),\n            pad_sequences(text_r, max_len, padding='post', truncating='post'),\n            np.array(aspect),\n            pad_sequences(mask, max_len, padding='post', truncating='post')\n        ]\n\n    return input_pad", "test_script": "import numpy as np\nimport random\n\ndef test_case_input_generator(n=200):\n\n    class Config:\n        def __init__(self, model_name, is_aspect_term=False):\n            self.model_name = model_name\n            self.is_aspect_term = is_aspect_term\n\n    test_cases = []\n    model_types = [\n        'td_lstm', 'tc_lstm', 'at_lstm', 'ae_lstm', 'atae_lstm',\n        'memnet', 'ram', 'ian', 'cabasc'\n    ]\n\n    for _ in range(n):\n        model_type = random.choice(model_types)\n        is_aspect_term = random.choice([True, False]) if model_type in ['memnet', 'ram'] else False\n        config = Config(model_type, is_aspect_term)\n\n        max_len = random.randint(5, 50)\n        asp_max_len = random.randint(2, 10)\n        left_max_len = random.randint(5, 25)\n        right_max_len = random.randint(5, 25)\n\n        if model_type == 'td_lstm':\n            text_l = [np.random.randint(1, 100, size=random.randint(1, left_max_len)).tolist() for _ in range(10)]\n            text_r = [np.random.randint(1, 100, size=random.randint(1, right_max_len)).tolist() for _ in range(10)]\n            test_input = (text_l, text_r)\n        elif model_type == 'tc_lstm':\n            text_l = [np.random.randint(1, 100, size=random.randint(1, left_max_len)).tolist() for _ in range(10)]\n            text_r = [np.random.randint(1, 100, size=random.randint(1, right_max_len)).tolist() for _ in range(10)]\n            aspect = np.random.randint(1, 100, size=(10,)).tolist()\n            test_input = (text_l, text_r, aspect)\n        elif model_type in ['at_lstm', 'ae_lstm', 'atae_lstm'] or (\n                model_type in ['memnet', 'ram'] and not is_aspect_term):\n            text = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            aspect = np.random.randint(1, 100, size=(10,)).tolist()\n            test_input = (text, aspect)\n        elif model_type == 'memnet' and is_aspect_term:\n            text = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            aspect = np.random.randint(1, 100, size=(10,)).tolist()\n            loc = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            test_input = (text, aspect, loc)\n        elif model_type == 'ram' and is_aspect_term:\n            text = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            aspect = np.random.randint(1, 100, size=(10,)).tolist()\n            loc = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            offset = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            test_input = (text, aspect, loc, offset)\n        elif model_type == 'ian':\n            text = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            aspect_text = [np.random.randint(1, 100, size=random.randint(1, asp_max_len)).tolist() for _ in range(10)]\n            test_input = (text, aspect_text)\n        elif model_type == 'cabasc':\n            text = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            text_l = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            text_r = [np.random.randint(1, 100, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            aspect = np.random.randint(1, 100, size=(10,)).tolist()\n            mask = [np.random.randint(0, 2, size=random.randint(1, max_len)).tolist() for _ in range(10)]\n            test_input = (text, text_l, text_r, aspect, mask)\n\n        test_cases.append((test_input, asp_max_len, max_len, config, right_max_len, left_max_len))\n\n    return test_cases"}
{"problem_id": "keras_21", "library": "keras", "code_problem": "You are tasked with implementing a function that processes energy values and states in a computational model, specifically for use in a neural network context. The function will manipulate input energy values based on certain conditions and return a result based on the specified parameters.\n\nFunction signature:\n```python\ndef step(input_energy_t, states, return_logZ=True):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `2`, which is used to define the range of slicing for the mask.\n\nInput format:\n- `input_energy_t`: A tensor representing the input energy values.\n- `states`: A list containing previous target values, indices, chain energy, and optionally a mask.\n- `return_logZ`: A boolean indicating whether to return the log partition function or the index of the minimum energy.\n\nOutput format:\n- A tuple containing:\n  - The computed result based on the energy calculations.\n  - An updated list of states with the incremented index.\n\n**Input:**\n```python\ninput_energy_t = np.array([[0.5, -1.2], [1.0, 0.3]], dtype=np.float32)  # Shape: (2, 2)\nprev_target_val = np.array([[0.0, 0.0], [0.5, -0.5]], dtype=np.float32)  # Shape: (2, 2)\ni = np.array([[1]], dtype=np.int32)  # Shape: (1, 1)\nchain_energy = np.array([[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]], dtype=np.float32)  # Shape: (2, 2, 2)\nmask = np.array([[1, 0], [0, 1]], dtype=np.float32)  # Shape: (2, 2)\n\nstates = [prev_target_val, i, chain_energy, mask]\nreturn_logZ = True\n```\n\n**Output:**\n```python\nresult, new_states = step(input_energy_t, states, return_logZ=True)\nresult = tf.Tensor(\n[[ 0.6931472   0.6931472 ]\n [-0.525923   -0.62592304]], shape=(2, 2), dtype=float32)\nnew_states = [<tf.Tensor: shape=(2, 2), dtype=float32, numpy=\narray([[ 0.6931472 ,  0.6931472 ],\n       [-0.525923  , -0.62592304]], dtype=float32)>, array([[2]], dtype=int32)]\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef step(input_energy_t, states, return_logZ=True):\n    K = tf.keras.backend\n    prev_target_val, i, chain_energy = states[:3]\n    t = K.get_value(K.cast(i[0, 0], dtype='int32'))\n\n    if len(states) > 3:\n        mask = states[3]\n        if K.backend() == 'theano':\n            m = mask[:, t:t + 2]\n        else:\n            t = int(t)\n            m = tf.slice(mask, [0, t], [-1, 1])\n\n        input_energy_t *= K.expand_dims(m[:, 0])\n        chain_energy *= K.expand_dims(K.expand_dims(m[:, 0] * m[:, 0]))\n\n    energy = chain_energy + K.expand_dims(input_energy_t - prev_target_val, 2) if return_logZ else \\\n        chain_energy + K.expand_dims(input_energy_t + prev_target_val, 2)\n\n    result = tf.math.reduce_logsumexp(-energy, axis=1) if return_logZ else K.cast(tf.argmin(energy, axis=1), K.floatx())\n\n    return result, [result, i + 1]", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        feature_dim = np.random.randint(1, 10)\n        chain_dim = np.random.randint(1, 10)\n\n        input_energy_t = np.random.randn(batch_size, feature_dim).astype(np.float32)\n        prev_target_val = np.random.randn(batch_size, feature_dim).astype(np.float32)\n        i = np.array([[np.random.randint(0, chain_dim)]], dtype=np.int32)\n        chain_energy = np.random.randn(batch_size, feature_dim, chain_dim).astype(np.float32)\n        if np.random.rand() > 0.5:\n            mask = np.random.choice([0, 1], size=(batch_size, chain_dim)).astype(np.float32)\n            states = [prev_target_val, i, chain_energy, mask]\n        else:\n            states = [prev_target_val, i, chain_energy]\n\n        test_cases.append((input_energy_t, states))\n\n    return test_cases"}
{"problem_id": "keras_22", "library": "keras", "code_problem": "```python\ndef call(inputs, W):\n```\n\nIn this code, the function `call` takes two parameters: `inputs`, which is a tuple containing two tensors `H` and `U`, and `W`, which is a weight matrix. The function performs a series of tensor operations to compute a dot product based on the input tensors and the weight matrix.\n\n### Constant Used:\n- The constant used in the main code is the value `1`, which is used in the construction of the `H_repeat` and `U_repeat` tensors.\n\n### Input and Output Format:\n- **Input**: The function takes two inputs:\n  - `inputs`: A tuple containing two tensors `H` and `U`.\n  - `W`: A weight matrix.\n  \n- **Output**: The function returns a tensor that represents the result of the dot product operation after processing the input tensors and the weight matrix.\n\nInput:\n```python\nH = np.array([[[ 0.1, -0.2,  0.3],\n                [ 0.4,  0.5, -0.6],\n                [-0.7,  0.8,  0.9]],\n\n               [[ 0.2,  0.1, -0.1],\n                [-0.3,  0.4,  0.5],\n                [ 0.6, -0.7,  0.8]]])\n\nU = np.array([[[-0.1,  0.2,  0.3],\n                [ 0.4, -0.5,  0.6]],\n\n               [[ 0.1, -0.2,  0.3],\n                [-0.4,  0.5, -0.6]]])\n\nW = np.array([[ 1.2],\n             [ 0.8],\n             [-0.4],\n             [-0.3],\n             [-0.6],\n             [ 0.0],\n             [-0.2],\n             [ 0.5],\n             [ 0.8]])\n```\n\nOutput:\n```python\ntf.Tensor(\n[[[-0.21300206  0.21425417]\n  [ 1.0198392   0.9065441 ]\n  [-0.3337975  -0.05346406]]\n [[ 0.4393707   0.28640854]\n  [-0.04427449 -0.60604334]\n  [ 0.15567416 -0.97516644]]], shape=(2, 3, 2), dtype=float32)\n``` \n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, W):\n    K = tf.keras.backend\n    H, U = inputs\n    num_context_words = K.shape(H)[1]\n    num_query_words = K.shape(U)[1]\n\n    H_repeat = K.concatenate([[1, 1], [num_query_words], [1]], axis=0)\n    U_repeat = K.concatenate([[1], [num_context_words], [1, 1]], axis=0)\n\n    H = K.tile(K.expand_dims(H, axis=2), H_repeat)\n    U = K.tile(K.expand_dims(U, axis=1), U_repeat)\n\n    M = H * U\n    concatenated = K.concatenate([H, U, M], axis=-1)\n    dot_product = K.squeeze(K.dot(concatenated, W), axis=-1)\n\n    return dot_product", "test_script": "import numpy as np\nimport tensorflow as tf\nfrom keras import backend as K\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        context_words = np.random.randint(5, 20)\n        query_words = np.random.randint(5, 20)\n        embedding_dim = np.random.randint(8, 32)\n\n        H = tf.random.normal((batch_size, context_words, embedding_dim))\n        U = tf.random.normal((batch_size, query_words, embedding_dim))\n        W = tf.random.normal((embedding_dim * 3, 1))\n\n        test_cases.append(((H, U), W))\n\n    return test_cases\n\ntest_cases = test_case_input_generator()\nfor i in range(len(test_cases)):\n   print(call(*test_cases[i]))"}
{"problem_id": "keras_23", "library": "keras", "code_problem": "You are tasked with creating a convolutional neural network (CNN) model using Keras. The model architecture is defined by a configuration dictionary that specifies the layers to be included in the model. The function signature for the main code is as follows:\n\n```python\ndef get_model(config, softmax):\n```\n\n### Constants Used:\n- The dropout rate is set to a constant value of `0.5` in the model.\n\n### Input and Output Format:\n- **Input**: The function takes two parameters:\n  - `config`: A dictionary containing the model configuration, including the layer specifications and input shape.\n  - `softmax`: A boolean indicating whether to include a softmax activation in the output layer.\n\n- **Output**: The function returns a Keras `Sequential` model object that represents the constructed CNN based on the provided configuration.\n\nInput:\n```python\n({\n    'input_shape': (32, 32, 3),\n    'layers': [\n        (Conv2D, 32, (3, 3), 'same'),\n        (Conv2D, 32, (3, 3), 'same'),\n        (MaxPooling2D, (2, 2)),\n        (Conv2D, 64, (3, 3), 'same'),\n        (Conv2D, 64, (3, 3), 'same'),\n        (MaxPooling2D, (2, 2)),\n        (Conv2D, 128, (3, 3), 'same'),\n        (Conv2D, 128, (3, 3), 'same'),\n        (MaxPooling2D, (2, 2)),\n        (Dense, 1024, l2(0.01)),\n        (Dense, 512, l2(0.01))\n    ]\n}, True)\n```\n\nOutput:\n```python\n<keras.engine.sequential.Sequential object at 0x7f8c1c0e1c10>\n``` \n\n(Note: The output will be a Keras model object, and the memory address will vary each time the model is created.)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Conv2D, Activation, BatchNormalization, MaxPooling2D\nfrom keras.layers import Dropout, Flatten, Dense\n\n# main code\ndef get_model(config, softmax):\n    model = Sequential()\n    for layer in config['layers']:\n        if layer[0] == Conv2D:\n            model.add(Conv2D(layer[1], layer[2], padding=layer[3] if layer[3] else 'valid', input_shape=config['input_shape']))\n            model.add(Activation('relu'))\n            model.add(BatchNormalization())\n        elif layer[0] == MaxPooling2D:\n            model.add(MaxPooling2D(pool_size=layer[1]))\n        elif layer[0] == Dense:\n            model.add(Flatten())\n            model.add(Dense(layer[1], kernel_regularizer=layer[2] if len(layer) > 2 else None))\n            model.add(Activation('relu'))\n            model.add(BatchNormalization())\n            model.add(Dropout(0.5))\n    model.add(Dense(10))\n    if softmax:\n        model.add(Activation('softmax'))\n    return model", "test_script": "import numpy as np\nfrom keras.layers import Conv2D, MaxPooling2D, Dense\nfrom keras.regularizers import l2\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    datasets = ['mnist', 'cifar', 'svhn']\n    model_configs = {'mnist': {'input_shape': (28, 28, 1),\n                               'layers': [(Conv2D, 64, (3, 3), 'valid'), (Conv2D, 64, (3, 3), None),\n                                          (MaxPooling2D, (2, 2)),\n                                          (Dense, 128)]},\n                     'cifar': {'input_shape': (32, 32, 3),\n                               'layers': [(Conv2D, 32, (3, 3), 'same'),\n                                          (Conv2D, 32, (3, 3), 'same'),\n                                          (MaxPooling2D, (2, 2)),\n                                          (Conv2D, 64, (3, 3), 'same'),\n                                          (Conv2D, 64, (3, 3), 'same'),\n                                          (MaxPooling2D, (2, 2)),\n                                          (Conv2D, 128, (3, 3), 'same'),\n                                          (Conv2D, 128, (3, 3), 'same'),\n                                          (MaxPooling2D, (2, 2)),\n                                          (Dense, 1024, l2(0.01)),\n                                          (Dense, 512, l2(0.01))]},\n                     'svhn': {'input_shape': (32, 32, 3),\n                              'layers': [(Conv2D, 64, (3, 3), 'valid'), (Conv2D, 64, (3, 3), None),\n                                         (MaxPooling2D, (2, 2)),\n                                         (Dense, 512), (Dense, 128)]}}\n    for _ in range(n):\n        dataset = np.random.choice(datasets)\n        config = model_configs.get(dataset)\n        softmax = np.random.choice([True, False])\n        test_cases.append((config, softmax))\n    return test_cases"}
{"problem_id": "keras_24", "library": "keras", "code_problem": "You are tasked with implementing a function that computes an attention score matrix using additive attention mechanisms. The function will take several parameters, including input data and weight matrices, to produce the attention scores based on the provided inputs.\n\nFunction signature:\n```python\ndef call_additive_emission(inputs, use_additive_bias, Wt, bh, Wa, ba, use_attention_bias, Wx):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the number `2`, which is used in the `K.expand_dims` function to specify the axis for expanding dimensions.\n\nInput format:\n- `inputs`: A 2D tensor of shape `(batch_size, input_len)`.\n- `use_additive_bias`: A boolean indicating whether to use an additive bias in the hidden state calculation.\n- `Wt`: A weight matrix for the query transformation.\n- `bh`: A bias vector for the hidden state (used if `use_additive_bias` is True).\n- `Wa`: A weight matrix for the attention score calculation.\n- `ba`: A bias vector for the attention scores (used if `use_attention_bias` is True).\n- `use_attention_bias`: A boolean indicating whether to use an attention bias.\n- `Wx`: A weight matrix for the key transformation.\n\nOutput format:\n- The function returns a 3D tensor of shape `(batch_size, input_len, input_len)` representing the attention score matrix.\n\n**Input:**\n```python\ninputs = K.constant([[[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]]])  # Shape: (1, 2, 3)\nuse_additive_bias = True\nWt = K.constant([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])  # Shape: (3, 3)\nbh = K.constant([0.1, 0.2, 0.3])  # Shape: (3,)\nWa = K.constant([[0.1], [0.2], [0.3]])  # Shape: (3, 1)\nba = K.constant([[0.1, 0.2], [0.3, 0.4]])  # Shape: (2, 2)\nuse_attention_bias = True\nWx = K.constant([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])  # Shape: (3, 3)\n```\n\n**Output:**\n```python\noutput = tf.Tensor(\n[[[0.5499405 0.7341633]\n  [0.8341633 0.9717325]]], shape=(1, 2, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call_additive_emission(inputs, use_additive_bias, Wt, bh, Wa, ba, use_attention_bias, Wx):\n    K = tf.keras.backend\n    input_shape = K.shape(inputs)\n    batch_size, input_len = input_shape[0], input_shape[1]\n\n    q = K.expand_dims(K.dot(inputs, Wt), 2)\n    k = K.expand_dims(K.dot(inputs, Wx), 1)\n\n    h = K.tanh(q + k + bh) if use_additive_bias else K.tanh(q + k)\n\n    e = K.dot(h, Wa)\n    e = K.squeeze(e, axis=-1)\n\n    if use_attention_bias:\n        e = e + ba\n\n    e = K.reshape(e, (batch_size, input_len, input_len))\n    return e", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        input_len = np.random.randint(1, 20)\n        feature_dim = np.random.randint(5, 50)\n\n        inputs = np.random.randn(batch_size, input_len, feature_dim).astype(np.float32)\n        Wt = np.random.randn(feature_dim, feature_dim).astype(np.float32)\n        Wx = np.random.randn(feature_dim, feature_dim).astype(np.float32)\n        Wa = np.random.randn(feature_dim, 1).astype(np.float32)\n\n        use_additive_bias = np.random.choice([True, False])\n        use_attention_bias = np.random.choice([True, False])\n\n        bh = np.random.randn(feature_dim).astype(np.float32) if use_additive_bias else None\n        ba = np.random.randn(input_len, input_len).astype(np.float32) if use_attention_bias else None\n        inputs = K.constant(inputs)\n        Wt = K.constant(Wt)\n        Wx = K.constant(Wx)\n        Wa = K.constant(Wa)\n        bh = K.constant(bh) if bh is not None else None\n        ba = K.constant(ba) if ba is not None else None\n        test_cases.append((inputs, use_additive_bias, Wt, bh, Wa, ba, use_attention_bias, Wx))\n\n    return test_cases"}
{"problem_id": "keras_25", "library": "keras", "code_problem": "You are tasked with creating a function that builds a convolutional autoencoder model using Keras. The autoencoder will consist of an encoder and a decoder, designed to compress and then reconstruct input images. The function should allow customization of the number of filters in each convolutional layer, the size of the convolutional kernels, and the pooling size used in the max pooling layers.\n\nFunction signature:\n```python\ndef get_autoencoder_model(input_shape, filters=[32, 8, 4], kernel_size=(3, 3), pool_size=(2, 2)):\n```\n\nConstants used in the main code:\n- The default filter sizes are set to `[32, 8, 4]`.\n- The default kernel size is set to `(3, 3)`.\n- The default pool size is set to `(2, 2)`.\n\nInput format:\n- The function expects a tuple for `input_shape` that defines the dimensions of the input images, and optional lists for `filters`, `kernel_size`, and `pool_size`.\n\nOutput format:\n- The function returns a Keras `Model` object representing the autoencoder architecture.\n\nInput:\n```python\ninput_shape = (64, 64, 3)\nfilters = [16, 32, 64]\nkernel_size = (3, 3)\npool_size = (2, 2)\n```\n\nOutput:\n```python\n# The output would be the model summary or structure, which is not directly representable as a single output value.\n# However, we can represent the expected output as a string indicating the model was created successfully.\nmodel = get_autoencoder_model(input_shape, filters, kernel_size, pool_size)\noutput = \"Model created with input shape: (64, 64, 3) and filters: [16, 32, 64]\"\n```", "ground_truth_code": "from keras.layers import Input, Conv2D, MaxPooling2D, UpSampling2D\nfrom keras.models import Model\n\n# main code\ndef get_autoencoder_model(input_shape, filters=[32, 8, 4], kernel_size=(3, 3), pool_size=(2, 2)):\n    image = Input(shape=input_shape)\n\n    encoder = Conv2D(filters[0], kernel_size, activation='relu', padding='same')(image)\n    encoder = MaxPooling2D(pool_size, padding='same')(encoder)\n    encoder = Conv2D(filters[1], kernel_size, activation='relu', padding='same')(encoder)\n    encoder = Conv2D(filters[2], kernel_size, activation='relu', padding='same')(encoder)\n    encoder = MaxPooling2D(pool_size, padding='same')(encoder)\n\n    decoder = UpSampling2D(pool_size, name='embedding')(encoder)\n    decoder = Conv2D(filters[2], kernel_size, activation='relu', padding='same')(decoder)\n    decoder = Conv2D(filters[1], kernel_size, activation='relu', padding='same')(decoder)\n    decoder = UpSampling2D(pool_size)(decoder)\n    decoder = Conv2D(filters[0], kernel_size, activation='relu', padding='same')(decoder)\n    decoder = Conv2D(1, kernel_size, activation='sigmoid', padding='same')(decoder)\n\n    return Model(image, decoder)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        height = random.choice([32, 64, 128, 256])\n        width = random.choice([32, 64, 128, 256])\n        channels = random.choice([1, 3])\n        input_shape = (height, width, channels)\n        filters = sorted(random.sample(range(8, 129, 8), 3))\n        kernel_size = random.choice([(3, 3), (5, 5)])\n        pool_size = random.choice([(2, 2), (4, 4)])\n\n        test_cases.append((input_shape, filters, kernel_size, pool_size))\n\n    return test_cases\n"}
{"problem_id": "keras_26", "library": "keras", "code_problem": "You are tasked with implementing a neural network model using Keras that can be used for a reinforcement learning environment. The model will take the state of the environment as input and output an action that the agent can take. The architecture of the neural network should include several layers with specific configurations.\n\nFunction signature:\n```python\ndef build_net(act_dim, env_dim, act_range, noise_level=1.0, layer_sizes=(256, 128)):\n```\n\nConstants used in the main code:\n- The default value for `noise_level` is set to `1.0`.\n- The default value for `layer_sizes` is set to `(256, 128)`.\n\nInput format:\n- The function takes the following inputs:\n  - `act_dim`: An integer representing the action dimension.\n  - `env_dim`: An integer representing the environment dimension.\n  - `act_range`: A float representing the range for the actions.\n  - `noise_level`: An optional float representing the level of Gaussian noise to be added (default is `1.0`).\n  - `layer_sizes`: An optional tuple of integers representing the sizes of the hidden layers (default is `(256, 128)`).\n\nOutput format:\n- The function returns a Keras `Model` object that represents the constructed neural network.\n\n```python\nInput: (act_dim=10, env_dim=5, act_range=5.0, noise_level=0.5, layer_sizes=(128, 64))\nOutput: A Keras model with the specified architecture and parameters.\n```", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef build_net(act_dim, env_dim, act_range, noise_level=1.0, layer_sizes=(256, 128)):\n    KL = tf.keras.layers\n    KM = tf.keras.models\n    KI = tf.keras.initializers\n    inp = KL.Input(shape=(env_dim,))\n    x = KL.Dense(layer_sizes[0], activation='relu')(inp)\n    x = KL.GaussianNoise(noise_level)(x)\n    x = KL.Dense(layer_sizes[1], activation='relu')(x)\n    x = KL.GaussianNoise(noise_level)(x)\n    out = KL.Dense(act_dim, activation='tanh', kernel_initializer=KI.RandomUniform())(x)\n    out = KL.Lambda(lambda i: i * act_range)(out)\n    model = KM.Model(inp, out)\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        env_dim = np.random.randint(1, 100)\n        act_dim = np.random.randint(1, 50)\n        act_range = np.random.uniform(0.1, 10.0)\n        noise_level = np.random.uniform(0.0, 1.0)\n        layer_sizes = (\n            np.random.randint(32, 512),\n            np.random.randint(16, 256)\n        )\n\n        test_cases.append((act_dim, env_dim, act_range, noise_level, layer_sizes))\n\n    return test_cases"}
{"problem_id": "keras_27", "library": "keras", "code_problem": "You are tasked with creating a function that initializes a bidirectional LSTM model for sequence prediction tasks using Keras. The function should allow customization of various parameters such as the number of LSTM units, dropout rate, sequence length, character set, output size, number of layers, loss function, and optimizer.\n\nFunction signature:\n```python\ndef initialize_model_bidirectional(n, dropout, seq_length, chars, output_size, layers, loss='categorical_crossentropy', optimizer='adam'):\n```\n\nConstant used in the main code:\n- The default loss function is set to `'categorical_crossentropy'`.\n- The default optimizer is set to `'adam'`.\n\nInput format:\n- `n`: Integer representing the number of LSTM units in each layer.\n- `dropout`: Float representing the dropout rate.\n- `seq_length`: Integer representing the length of the input sequences.\n- `chars`: List of characters or features used in the model.\n- `output_size`: Integer representing the number of output classes.\n- `layers`: Integer representing the number of LSTM layers to include in the model.\n- `loss`: (Optional) String representing the loss function to use (default is 'categorical_crossentropy').\n- `optimizer`: (Optional) String representing the optimizer to use (default is 'adam').\n\nOutput format:\n- Returns a Keras model object if the initialization is successful, or `None` if the input parameters are invalid.\n\nInput:\n```python\n(128, 0.25, 50, ['a', 'b', 'c', 'd', 'e', 'f', 'g', 'h', 'i', 'j'], 10, 3, 'categorical_crossentropy', 'adam')\n```\n\nOutput:\n```python\n<keras.engine.sequential.Sequential object at 0x7f8c1e4b3c10>\n``` \n\n(Note: The output will be a Keras model object, and the memory address will vary each time the model is created.)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Bidirectional, Dropout, TimeDistributed, LSTM, Dense\n\n# main code\ndef initialize_model_bidirectional(n, dropout, seq_length, chars, output_size, layers, loss='categorical_crossentropy',\n                                   optimizer='adam'):\n    if not chars or layers < 1:\n        return None\n\n    model = Sequential()\n    model.add(Bidirectional(LSTM(n, return_sequences=True), input_shape=(seq_length, len(chars))))\n    model.add(Dropout(dropout))\n\n    for _ in range(layers - 1):\n        model.add(Bidirectional(LSTM(n, return_sequences=True)))\n        model.add(Dropout(dropout))\n\n    model.add(TimeDistributed(Dense(output_size, activation='softmax')))\n    model.compile(loss=loss, optimizer=optimizer, metrics=['accuracy'])\n\n    return model", "test_script": "import string\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_units = random.randint(16, 256)\n        dropout = round(random.uniform(0.0, 0.5), 2)\n        seq_length = random.randint(10, 100)\n        num_chars = random.randint(5, 50)\n        output_size = random.randint(2, 20)\n        layers = random.randint(1, 4)\n        loss = random.choice(['categorical_crossentropy', 'sparse_categorical_crossentropy'])\n        optimizer = random.choice(['adam', 'rmsprop', 'sgd'])\n\n        chars = list(random.sample(string.ascii_letters + string.digits, num_chars))\n\n        test_cases.append((n_units, dropout, seq_length, chars, output_size, layers, loss, optimizer))\n\n    return test_cases"}
{"problem_id": "keras_28", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a neural network model for a discriminator in a generative adversarial network (GAN) using Keras. The model will take multiple input features, process them through dense layers, and ultimately output a single value representing the discriminator's prediction.\n\nFunction Signature:\n```python\ndef build_discriminator(keys, vocab_size, max_length):\n```\n\nConstants used in the main code:\n- The constant `64` is used as the number of units in the dense layer for the 'lat_lon' key, while for other keys, the number of units corresponds to the vocabulary size of that key.\n- The constant `100` is used as the number of units in the dense layer for trajectory points and the LSTM layer.\n- The constant `0.02` is used as the regularization parameter for the LSTM layer.\n\nInput Format:\n- `keys`: A list of strings representing the names of the input features.\n- `vocab_size`: A dictionary where keys are feature names and values are their corresponding vocabulary sizes.\n- `max_length`: An integer representing the maximum length of the input sequences.\n\nOutput Format:\n- The function returns a Keras Model object that can be used for training or inference in a GAN setup.\n\nInput:\n```python\nkeys = ['feature1', 'feature2', 'lat_lon', 'feature3']\nvocab_size = {\n    'feature1': 15,\n    'feature2': 25,\n    'lat_lon': 30,\n    'feature3': 20\n}\nmax_length = 10\n```\n\nOutput:\n```python\n# The output will be a Keras Model object representing the discriminator.\n# The model summary can be printed to see the architecture.\nmodel = build_discriminator(keys, vocab_size, max_length)\nmodel.summary()\n``` \n\n(Note: The actual output of the model will be a Keras Model object, and the summary will provide details about the layers and parameters in the model.)", "ground_truth_code": "from keras.layers import Dense, Concatenate, Lambda, LSTM, Input\nfrom keras.models import Model\nfrom keras.initializers import he_uniform\nfrom keras.regularizers import l1\nimport tensorflow as tf\n\n# main code\ndef build_discriminator(keys, vocab_size, max_length):\n    inputs = []\n    embeddings = []\n\n    for key in keys:\n        if key == 'mask':\n            continue\n\n        input_layer = Input(shape=(max_length, vocab_size[key]), name=f'input_{key}')\n        unstacked = Lambda(lambda x: tf.unstack(x, axis=1))(input_layer)\n\n        dense_layer = Dense(units=(64 if key == 'lat_lon' else vocab_size[key]),\n                            use_bias=True, activation='relu',\n                            kernel_initializer=he_uniform(seed=1),\n                            name=f'emb_{key}')\n        dense_outputs = [dense_layer(x) for x in unstacked]\n        embedding_layer = Lambda(lambda x: tf.stack(x, axis=1))(dense_outputs)\n\n        inputs.append(input_layer)\n        embeddings.append(embedding_layer)\n\n    concatenated = Concatenate(axis=2)(embeddings)\n    unstacked_concat = Lambda(lambda x: tf.unstack(x, axis=1))(concatenated)\n\n    dense_traj_layer = Dense(units=100, use_bias=True, activation='relu',\n                             kernel_initializer=he_uniform(seed=1), name='emb_trajpoint')\n    dense_traj_outputs = [dense_traj_layer(x) for x in unstacked_concat]\n    emb_traj = Lambda(lambda x: tf.stack(x, axis=1))(dense_traj_outputs)\n\n    lstm_output = LSTM(units=100, recurrent_regularizer=l1(0.02))(emb_traj)\n    output_layer = Dense(1, activation='sigmoid')(lstm_output)\n\n    return Model(inputs=inputs, outputs=output_layer)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    keys = ['feature1', 'feature2', 'lat_lon', 'feature3']\n\n    for _ in range(n):\n        random_vocab_size = {key: np.random.randint(10, 100) for key in keys}\n        random_max_length = np.random.randint(5, 20)\n        test_cases.append((keys, random_vocab_size, random_max_length))\n\n    return test_cases\n"}
{"problem_id": "keras_29", "library": "keras", "code_problem": "You are tasked with building a neural network model that processes sequences of states and actions using Keras. The model will utilize shared embeddings and LSTM layers to learn representations of the input sequences. The final output will be a dot product of the processed state and action representations.\n\nFunction signature:\n```python\ndef build_model(vocab_size, embed_dim=16, lstm_dim=32, dense_dim=8):\n```\n\nConstant used in the main code:\n- `embed_dim`: The dimension of the embedding layer, set to a default value of 16.\n- `lstm_dim`: The dimension of the LSTM layer, set to a default value of 32.\n- `dense_dim`: The dimension of the dense layers, set to a default value of 8.\n\nInput format:\n- `vocab_size`: An integer representing the size of the vocabulary for the embedding layer.\n- `embed_dim`: An optional integer representing the dimension of the embedding layer (default is 16).\n- `lstm_dim`: An optional integer representing the dimension of the LSTM layer (default is 32).\n- `dense_dim`: An optional integer representing the dimension of the dense layers (default is 8).\n\nOutput format:\n- The function returns a compiled Keras model that can be used for training and inference on state and action sequences.\n\n```python\nInput: (vocab_size=50, embed_dim=16, lstm_dim=32, dense_dim=8)\nOutput: Model Summary (not shown here, but the model is built successfully)\n```", "ground_truth_code": "from keras.layers import Input, Embedding, LSTM, Dense, Dot\nfrom keras.models import Model\n\n# main code\ndef build_model(vocab_size, embed_dim=16, lstm_dim=32, dense_dim=8):\n    input_state = Input(batch_shape=(None, None), name='input_state')\n    input_action = Input(batch_shape=(None, None), name='input_action')\n\n    embedding_shared = Embedding(\n        input_dim=vocab_size + 1,\n        output_dim=embed_dim,\n        mask_zero=True,\n        trainable=True,\n        name='embedding_shared'\n    )\n\n    embedding_state = embedding_shared(input_state)\n    embedding_action = embedding_shared(input_action)\n\n    lstm_shared = LSTM(lstm_dim, name='lstm_shared')\n    lstm_state = lstm_shared(embedding_state)\n    lstm_action = lstm_shared(embedding_action)\n\n    dense_state = Dense(dense_dim, activation='linear', name='dense_state')(lstm_state)\n    dense_action = Dense(dense_dim, activation='linear', name='dense_action')(lstm_action)\n\n    input_dot_state = Input(shape=(dense_dim,))\n    input_dot_action = Input(shape=(dense_dim,))\n\n    dot_state_action = Dot(axes=-1, normalize=False, name='dot_state_action')(\n        [input_dot_state, input_dot_action]\n    )\n\n    model_dot_state_action = Model(\n        inputs=[input_dot_state, input_dot_action], outputs=dot_state_action, name='dot_state_action'\n    )\n\n    model_state = Model(inputs=input_state, outputs=dense_state, name='state')\n    model_action = Model(inputs=input_action, outputs=dense_action, name='action')\n\n    model = Model(\n        inputs=[model_state.input, model_action.input],\n        outputs=model_dot_state_action([model_state.output, model_action.output])\n    )\n\n    model.compile(optimizer='RMSProp', loss='mse')\n\n    return model\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    max_vocab_size = 500\n    max_embed_dim = 64\n    max_lstm_dim = 128\n    max_dense_dim = 32\n\n    for _ in range(n):\n        vocab_size = np.random.randint(10, max_vocab_size + 1)\n        embed_dim = np.random.randint(8, max_embed_dim + 1)\n        lstm_dim = np.random.randint(16, max_lstm_dim + 1)\n        dense_dim = np.random.randint(4, max_dense_dim + 1)\n\n        test_cases.append((vocab_size, embed_dim, lstm_dim, dense_dim))\n\n    return test_cases"}
{"problem_id": "keras_30", "library": "keras", "code_problem": "You are tasked with implementing a function that processes input data using a combination of linear transformations and gating mechanisms. The function will apply a series of operations to the input tensor, including optional transformations based on provided weight matrices. The function signature is as follows:\n\n```python\ndef call(x, use_gated, w, U, V):\n```\n\n### Constants:\n- The constant used in the main code is `None`, which is used to check if the matrix `V` is provided.\n\n### Input and Output Format:\n- **Input**: The function takes in a tensor `x`, a boolean `use_gated`, and three matrices `w`, `U`, and `V`.\n- **Output**: The function returns a tensor that represents the softmax probabilities after applying the transformations and gating mechanism.\n\n**Input:**\n```python\nx = tf.convert_to_tensor([[0.5, -0.2, 0.1]], dtype=tf.float32)  # Shape: (1, 3)\nuse_gated = True\nw = tf.convert_to_tensor([[0.3], [0.7]], dtype=tf.float32)\nU = tf.convert_to_tensor([[0.1, -0.3], [0.4, 0.2], [-0.5, 0.6]], dtype=tf.float32)  # Shape: (3, 2)\nV = tf.convert_to_tensor([[0.2, -0.1], [0.3, 0.4], [0.5, -0.2]], dtype=tf.float32)  # Shape: (3, 2)\n```\n\n**Output:**\n```python\n\noutput = tf.Tensor([[1.]], shape=(1, 1), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, use_gated, w, U, V):\n    K = tf.keras.backend\n    ori_x = x\n    if V is not None:\n        x = K.tanh(K.dot(x, V))\n    else:\n        x = K.dot(x, w) if w.shape[0] == x.shape[1] else x\n\n    if use_gated and U is not None:\n        gate_x = K.sigmoid(K.dot(ori_x, U))\n        ac_x = x * gate_x\n    else:\n        ac_x = x\n\n    soft_x = K.dot(ac_x, w)\n    alpha = K.softmax(K.transpose(soft_x))\n    return K.transpose(alpha)\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        input_dim = np.random.randint(5, 20)\n        output_dim = np.random.randint(5, 20)\n\n        x = tf.convert_to_tensor(np.random.randn(batch_size, input_dim), dtype=tf.float32)\n        use_gated = np.random.choice([True, False])\n        w = tf.convert_to_tensor(np.random.randn(output_dim, 1), dtype=tf.float32)\n        U = tf.convert_to_tensor(np.random.randn(input_dim, output_dim), dtype=tf.float32) if use_gated else None\n        V = tf.convert_to_tensor(np.random.randn(input_dim, output_dim),\n                                 dtype=tf.float32)\n\n        test_cases.append((x, use_gated, w, U, V))\n\n    return test_cases"}
{"problem_id": "keras_31", "library": "keras", "code_problem": "You are tasked with implementing a function that computes a weighted sum of input vectors based on a given mask and parameters. The function will utilize Keras backend operations to perform matrix multiplications, apply activation functions, and handle masking.\n\nFunction signature:\n```python\ndef call(x, mask, W, b, u=None):\n```\n\nConstants used in the main code:\n- `K.epsilon()`: A small constant added to avoid division by zero.\n\nInput format:\n- `x`: A 2D array (matrix) representing the input vectors.\n- `mask`: A 1D array (vector) used to mask certain elements of the output.\n- `W`: A 2D array (matrix) representing the weights for the linear transformation.\n- `b`: A 1D array (vector) representing the biases to be added.\n- `u`: An optional 2D array (matrix) used for an additional transformation.\n\nOutput format:\n- The function returns a 1D array (vector) representing the weighted sum of the input vectors after applying the transformations and masking.\n\nInput:\n```python\nx = np.array([[[ 0.1, -0.2,  0.3],\n                [ 0.4,  0.5, -0.6],\n                [ 0.7, -0.8,  0.9]]], dtype=np.float32)  # shape (1, 3, 3)\n\nmask = np.array([[1, 1, 0]], dtype=np.float32)  # shape (1, 3)\n\nW = np.array([[ 0.1, -0.1],\n              [ 0.2,  0.2],\n              [-0.3,  0.3]], dtype=np.float32)  # shape (3, 2)\n\nb = np.array([0.1, -0.1], dtype=np.float32)  # shape (2,)\n\nu = np.array([[0.5],\n              [0.5]], dtype=np.float32)  # shape (2, 1)\n```\n\nOutput:\n```python\noutput = tf.Tensor([[ 0.25974894  0.17274746 -0.17924675]], shape=(1, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, mask, W, b, u=None):\n    K = tf.keras.backend\n    x = K.constant(x)\n    mask = K.constant(mask)\n    W = K.constant(W)\n    b = K.constant(b)\n    u = K.constant(u) if u is not None else None\n\n    uit = K.tanh(K.bias_add(K.dot(x, W), b))\n    ait = K.dot(uit, u)\n    ait = K.squeeze(ait, -1)\n    ait = K.exp(ait)\n\n    if mask is not None:\n        ait *= K.cast(mask, K.floatx())\n\n    ait /= K.cast(K.sum(ait, axis=1, keepdims=True) + K.epsilon(), K.floatx())\n    ait = K.expand_dims(ait)\n\n    weighted_input = x * ait\n    output = K.sum(weighted_input, axis=1)\n\n    return output", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        time_steps = np.random.randint(5, 20)\n        input_dim = np.random.randint(4, 16)\n        attention_dim = np.random.randint(4, 16)\n\n        x = np.random.randn(batch_size, time_steps, input_dim).astype(np.float32)\n        mask = np.random.choice([0, 1], size=(batch_size, time_steps)).astype(np.float32)\n        W = np.random.randn(input_dim, attention_dim).astype(np.float32)\n        b = np.random.randn(attention_dim).astype(np.float32)\n        u = np.random.randn(attention_dim, 1).astype(np.float32)\n\n        test_cases.append((x, mask, W, b, u))\n\n    return test_cases"}
{"problem_id": "keras_32", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the smooth recall metric for evaluating the performance of a binary classification model. The function should take two inputs: the true labels and the predicted labels, both in the form of tensors. The smooth recall metric is defined as the ratio of the intersection of the true and predicted labels to the sum of the true labels, with a small constant added to avoid division by zero.\n\nFunction signature:\n```python\ndef recall_smooth(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero in the calculation of the smooth recall.\n\nInput format:\n- `y_true`: A tensor representing the true labels (binary values).\n- `y_pred`: A tensor representing the predicted labels (binary values).\n\nOutput format:\n- A single float value representing the smooth recall metric.\n\nInput:\n```python\ny_true = tf.convert_to_tensor([[1, 0, 1], [0, 1, 0]], dtype=tf.float32)\ny_pred = tf.convert_to_tensor([[0.9, 0.1, 0.8], [0.2, 0.7, 0.1]], dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(0.8, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef recall_smooth(y_true, y_pred):\n    K = tf.keras.backend\n    y_pred_f = K.flatten(y_pred)\n    y_true_f = K.flatten(y_true)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return intersection / (K.sum(y_true_f) + K.epsilon())\n\n", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 5)))\n        y_true = np.random.randint(0, 2, size=shape, dtype=np.int32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n        y_true_tensor = tf.convert_to_tensor(y_true, dtype=tf.float32)\n        y_pred_tensor = tf.convert_to_tensor(y_pred, dtype=tf.float32)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases\n"}
{"problem_id": "keras_33", "library": "keras", "code_problem": "You are tasked with creating a neural network model using Keras for a reinforcement learning application. The model will take in observations of a given state and output action predictions. Your goal is to implement a function that builds this model architecture.\n\nFunction Signature:\n```python\ndef build_baseline1_model(action_dim: int, state_dim: int) -> Model:\n```\n\nConstant Used:\n- The activation functions used in the model are 'relu' for hidden layers and 'tanh' for the output layer. The optimizer used for compiling the model is 'Adam', and the loss function is 'categorical_crossentropy'.\n\nInput Format:\n- The function takes two integer parameters:\n  - `action_dim`: The number of possible actions the model can predict.\n  - `state_dim`: The dimension of the input state observations.\n\nOutput Format:\n- The function returns a Keras `Model` object that represents the constructed neural network architecture.", "ground_truth_code": "from keras.layers import Input\nfrom keras.models import Model\nfrom keras.layers import Dense\nfrom keras.layers import Activation\n\n# main code\ndef build_baseline1_model(action_dim, state_dim):\n    input_obs = Input(shape=(state_dim,))\n    h = Dense(400)(input_obs)\n    h = Activation('relu')(h)\n    h = Dense(300)(h)\n    h = Activation('relu')(h)\n    h = Dense(action_dim)(h)\n    pred = Activation('tanh')(h)\n    model = Model(inputs=input_obs, outputs=pred)\n    model.compile(optimizer='Adam', loss='categorical_crossentropy')\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        state_dim = np.random.randint(2, 100)\n        action_dim = np.random.randint(2, 50)\n        test_cases.append((action_dim, state_dim))\n    return test_cases"}
{"problem_id": "keras_34", "library": "keras", "code_problem": "You are tasked with creating a function that builds a multi-layer perceptron (MLP) model using the Keras library. The model should consist of an input layer, two hidden layers, and an output layer. The function should allow customization of the input shape, the number of hidden units in each hidden layer, and the number of output units.\n\nFunction Signature:\n```python\ndef create_functional_model(input_shape=(784,), hidden_units=64, output_units=10):\n```\n\nConstant Used:\n- The default value for `input_shape` is set to `(784,)`, which represents the shape of the input data (e.g., flattened images of size 28x28 pixels).\n\nInput Format:\n- The function accepts three parameters:\n  - `input_shape`: A tuple representing the shape of the input data.\n  - `hidden_units`: An integer representing the number of units in each hidden layer.\n  - `output_units`: An integer representing the number of units in the output layer.\n\nOutput Format:\n- The function returns a Keras Model object that represents the constructed MLP model.\n\nInput: ((784,), 64, 10)  \nOutput: <keras.engine.functional.Functional object at 0x...>", "ground_truth_code": "import keras\n\n# main code\ndef create_functional_model(input_shape=(784,), hidden_units=64, output_units=10):\n    inputs = keras.Input(shape=input_shape, name='input_layer')\n    x = keras.layers.Dense(hidden_units, activation='relu', name='hidden_layer_1')(inputs)\n    x = keras.layers.Dense(hidden_units, activation='relu', name='hidden_layer_2')(x)\n    outputs = keras.layers.Dense(output_units, name='output_layer')(x)\n    return keras.Model(inputs=inputs, outputs=outputs, name='mlp_model')", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        input_shape = (np.random.randint(10, 1000),)\n        hidden_units = np.random.randint(16, 256)\n        output_units = np.random.randint(2, 100)\n\n\n        test_cases.append((input_shape, hidden_units, output_units))\n\n    return test_cases"}
{"problem_id": "keras_35", "library": "keras", "code_problem": "You are tasked with creating a neural network model using Keras, a high-level neural networks API. The model should be designed to classify input data into a specified number of classes. The architecture of the model consists of several layers, including dense layers and dropout layers to prevent overfitting.\n\nFunction Signature:\n```python\ndef create_model(nb_classes, input_shape):\n```\n\nConstant Used:\n- The dropout rate is set to 0.5, which means that during training, 50% of the neurons in the dropout layers will be randomly set to zero to help prevent overfitting.\n\nInput Format:\n- `nb_classes`: An integer representing the number of classes for classification.\n- `input_shape`: A tuple representing the shape of the input data (excluding the batch size).\n\nOutput Format:\n- The function returns a Keras Model object that can be compiled and trained on data.\n\n```python\nInput: (5, (32,))\nOutput: <keras.engine.training.Model object at 0x...>\n``` \n\nIn this example, the input specifies that the model should have 5 output classes and an input shape of 32 features. The output is a Keras model object created by the `create_model` function.", "ground_truth_code": "from keras.layers import Input\nfrom keras.models import Model\nfrom keras.layers import Dense\nfrom keras.layers import Dropout\nfrom keras.layers import Activation\n\n# main code\ndef create_model(nb_classes, input_shape):\n    input_ = Input(shape=input_shape)\n    x = input_\n    x = Dense(512, activation='relu')(x)\n    x = Dropout(0.5)(x)\n    x = Dense(256, activation='relu')(x)\n    x = Dropout(0.5)(x)\n    x = Dense(nb_classes)(x)\n    x = Activation('sigmoid')(x)\n    model = Model(inputs=input_, outputs=x)\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        feature_dim = np.random.randint(10, 1000)\n        input_shape = (feature_dim,)\n        nb_classes = np.random.randint(2, 20)\n\n        test_cases.append((nb_classes, input_shape))\n\n    return test_cases"}
{"problem_id": "keras_36", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a neural network model for item recommendation using Keras. The model will take item IDs as input and output a probability distribution over all items, indicating the likelihood of each item being relevant to the user.\n\nFunction signature:\n```python\ndef build(NUM_ITEMS: int, k: int) -> Model:\n```\n\nConstants used in the main code:\n- `NUM_ITEMS`: This constant represents the total number of unique items in the dataset.\n- `k`: This constant represents the dimensionality of the item embeddings.\n\nInput format:\n- The function takes two parameters:\n  - `NUM_ITEMS`: An integer representing the total number of unique items.\n  - `k`: An integer representing the dimensionality of the item embeddings.\n\nOutput format:\n- The function returns a Keras `Model` object that can be used for training and making predictions in an item recommendation system.\n\n```json\n{\n  \"input\": {\n    \"NUM_ITEMS\": 1200,\n    \"k\": 64\n  },\n  \"output\": \"Model created with input shape (1,) and output shape (1200,)\"\n}\n```", "ground_truth_code": "from keras.layers import Input\nfrom keras.layers import Embedding\nfrom keras.models import Model\nfrom keras.layers import Flatten\nfrom keras.layers import Dense\n\n# main code\ndef build(NUM_ITEMS, k):\n    iid = Input(shape=(1,), dtype='int32', name='iids')\n    item_embedding = Embedding(input_dim=NUM_ITEMS, output_dim=k, input_length=1, name='item_embedding')\n    selected_items = Flatten()(item_embedding(iid))\n    h1 = Dense(k // 2, activation='relu')(selected_items)\n    sig = Dense(NUM_ITEMS, activation='softmax', name='softmax')(h1)\n    model = Model(inputs=[iid], outputs=sig)\n    return model\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n\n        num_items = np.random.randint(500, 2000)\n        k = np.random.randint(16, 128)\n\n        test_cases.append((num_items, k))\n\n    return test_cases"}
{"problem_id": "keras_37", "library": "keras", "code_problem": "You are tasked with implementing a function that evaluates the performance of a machine learning model using the ROC AUC score and calculates the normalized Gini coefficient for both training and validation datasets. The function will be called `on_epoch_end`, and it will take in the validation features, the trained model, the validation labels, the training features, and the training labels as inputs. The function will return a dictionary containing the ROC AUC scores and normalized Gini coefficients for both the training and validation datasets.\n\nFunction signature:\n```python\ndef on_epoch_end(x_val, model, y_val, x, y):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the value `2`, which is used to calculate the normalized Gini coefficient.\n\nInput format:\n- `x_val`: A 2D array-like structure representing the validation features.\n- `model`: A trained machine learning model that has a `predict` method.\n- `y_val`: A 1D array-like structure representing the true labels for the validation dataset.\n- `x`: A 2D array-like structure representing the training features.\n- `y`: A 1D array-like structure representing the true labels for the training dataset.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `'roc_auc'`: The ROC AUC score for the training dataset.\n  - `'norm_gini'`: The normalized Gini coefficient for the training dataset.\n  - `'roc_auc_val'`: The ROC AUC score for the validation dataset.\n  - `'norm_gini_val'`: The normalized Gini coefficient for the validation dataset.\n\nInput:\n```python\nx_val = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n                  [0.5, 0.4, 0.3, 0.2, 0.1]])\nmodel = Sequential([\n    Dense(10, activation='relu', input_shape=(5,)),\n    Dense(1, activation='sigmoid')\n])\ny_val = np.array([0, 1])\nx = np.array([[0.2, 0.3, 0.4, 0.5, 0.6],\n               [0.6, 0.5, 0.4, 0.3, 0.2]])\ny = np.array([0, 1])\n```\n\nOutput:\n```python\n{\n   'roc_auc': 1.0, \n   'norm_gini': 1.0, \n   'roc_auc_val': 1.0, \n   'norm_gini_val': 1.0\n}\n```", "ground_truth_code": "from sklearn.metrics import roc_auc_score\n\n# main code\ndef on_epoch_end(x_val, model, y_val, x, y):\n    logs = {}\n    y_pred = model.predict(x, verbose=0)\n    y_pred_val = model.predict(x_val, verbose=0)\n\n    roc = roc_auc_score(y, y_pred)\n    roc_val = roc_auc_score(y_val, y_pred_val)\n\n    logs['roc_auc'] = roc\n    logs['norm_gini'] = roc * 2 - 1\n    logs['roc_auc_val'] = roc_val\n    logs['norm_gini_val'] = roc_val * 2 - 1\n\n    return logs\n", "test_script": "import numpy as np\nfrom tensorflow.keras.models import Sequential\nfrom tensorflow.keras.layers import Dense\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(10, 100)\n        feature_dim = np.random.randint(5, 50)\n        x_val = np.random.rand(batch_size, feature_dim).astype(np.float32)\n        x = np.random.rand(batch_size, feature_dim).astype(np.float32)\n        y_val = np.random.randint(0, 2, batch_size)\n        y = np.random.randint(0, 2, batch_size)\n        model = Sequential([\n            Dense(10, activation='relu', input_shape=(feature_dim,)),\n            Dense(1, activation='sigmoid')\n        ])\n\n        test_cases.append((x_val, model, y_val, x, y))\n\n    return test_cases"}
{"problem_id": "keras_38", "library": "keras", "code_problem": "Implement a function that applies a gated transformation to an input tensor using two dense layers and an activation function. The function should compute a transformed output based on the input tensor and the specified dense layers and activation function.\n\nFunction signature:\n```python\ndef call(x, dense_1, activation, dense_2):\n```\n\nConstant used in the main code:\n- The constant `1.0` is used in the computation of the carry gate.\n\nInput format:\n- `x`: A tensor input of shape (batch_size, ..., features).\n- `dense_1`: A Keras dense layer that will be applied to `x` to compute the transform gate.\n- `activation`: A string representing the activation function to be applied to the output of `dense_2`.\n- `dense_2`: A Keras dense layer that will be applied to `x` to compute the transformed data.\n\nOutput format:\n- The function returns a tensor that is the result of the gated transformation, combining the transformed data and the original input based on the computed gates.\n\nInput:\n```python\nx = tf.constant([[0.5, -0.2, 0.1], [0.3, 0.8, -0.5]])\ndense_1 = Dense(3, activation=None, use_bias=True)\ndense_2 = Dense(3, activation=None, use_bias=True)\nactivation = 'relu'\n```\n\nOutput:\n```python\noutput = call(x, dense_1, activation, dense_2)\noutput = tf.Tensor(\n[[ 0.29238075 -0.05767615  0.10621531]\n [ 0.23086074  0.86820924 -0.3439936 ]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, dense_1, activation, dense_2):\n    K = tf.keras.backend\n    KL = tf.keras.layers\n    dim = K.int_shape(x)[-1]\n    transform_gate = dense_1(x)\n    transform_gate = KL.Activation('sigmoid')(transform_gate)\n    carry_gate = KL.Lambda(lambda x: 1.0 - x, output_shape=(dim,))(transform_gate)\n    transformed_data = dense_2(x)\n    transformed_data = KL.Activation(activation)(transformed_data)\n    transformed_gated = KL.Multiply()([transform_gate, transformed_data])\n    identity_gated = KL.Multiply()([carry_gate, x])\n    value = KL.Add()([transformed_gated, identity_gated])\n    return value", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    KL = tf.keras.layers\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        feature_dim = np.random.randint(5, 50)\n        x = tf.random.normal((batch_size, feature_dim))\n        dense_1 = KL.Dense(feature_dim)\n        dense_2 = KL.Dense(feature_dim)\n\n        activation = np.random.choice(['relu', 'tanh', 'sigmoid', 'softmax'])\n\n        test_cases.append((x, dense_1, activation, dense_2))\n\n    return test_cases\n"}
{"problem_id": "keras_39", "library": "keras", "code_problem": "You are tasked with implementing a function that performs a specific type of convolution operation on a 3D input tensor, typically used in time series or sequential data processing. The function applies a convolutional layer with optional bias addition and activation functions, while also handling padding and dimensional adjustments.\n\nFunction signature:\n```python\ndef call(x, strides, bias, activation, use_bias, output_dim, kernel, window_size):\n```\n\nConstants used in the main code:\n- The constant used in the main code is `1`, which is used in the calculation of the padding for the temporal padding operation.\n\nInput format:\n- `x`: A 3D tensor (input data).\n- `strides`: A tuple representing the strides for the convolution operation.\n- `bias`: A tensor representing the bias to be added (if `use_bias` is True).\n- `activation`: A callable activation function to be applied to the output.\n- `use_bias`: A boolean indicating whether to use the bias term.\n- `output_dim`: An integer specifying the number of output dimensions to take from the convolution result.\n- `kernel`: A 4D tensor representing the convolutional kernel.\n- `window_size`: An integer specifying the size of the temporal window for padding.\n\nOutput format:\n- The function returns a tensor that is the result of the activation applied to `z` multiplied by the sigmoid of `g`.\n\n**Input:**\n```python\n{\n    \"x\": np.array([[[0.1, 0.2, 0.3, 0.4],\n                    [0.5, 0.6, 0.7, 0.8],\n                    [0.9, 1.0, 1.1, 1.2],\n                    [1.3, 1.4, 1.5, 1.6]]], dtype=np.float32),  # shape (1, 4, 4)\n    \"strides\": (1, 1),\n    \"bias\": np.array([0.1, 0.2, 0.3, 0.4], dtype=np.float32),  # shape (4,)\n    \"activation\": relu,\n    \"use_bias\": True,\n    \"output_dim\": 2,\n    \"kernel\": np.array([[[[0.1, 0.2, 0.3, 0.4],\n                          [0.5, 0.6, 0.7, 0.8]]]], dtype=np.float32),  # shape (2, 1, 4, 4)\n    \"window_size\": 2\n}\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[[0.05744425 0.11973753]\n  [0.13891566 0.23747818]\n  [0.3350686  0.52085996]\n  [0.5610096  0.84098595]\n  [0.8058062  1.1793692 ]]], shape=(1, 5, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, strides, bias, activation, use_bias, output_dim, kernel, window_size):\n    K = tf.keras.backend\n    if window_size > 1:\n        x = K.temporal_padding(x, (window_size - 1, 0))\n    x = K.expand_dims(x, 2)\n    output = K.conv2d(x, kernel, strides=strides, padding='same', data_format='channels_last')\n    output = K.squeeze(output, 2)\n    if use_bias:\n        output = K.bias_add(output, bias, data_format='channels_last')\n    z = output[:, :, :output_dim]\n    g = output[:, :, output_dim:]\n    return activation(z) * K.sigmoid(g)", "test_script": "import numpy as np\nimport tensorflow as tf\nimport random\n\ndef test_case_input_generator(n=200):\n    KA = tf.keras.activations\n    test_cases = []\n    for _ in range(n):\n        seq_len = random.randint(5, 50)\n        input_dim = random.randint(4, 64)\n        output_dim = random.randint(2, 32)\n        window_size = random.randint(1, 5)\n\n        strides = (1, 1)\n        activation = random.choice([KA.tanh, KA.relu, KA.sigmoid])\n        use_bias = random.choice([True, False])\n        batch_size = random.randint(1, 8)\n        x = np.random.rand(batch_size, seq_len, input_dim).astype(np.float32)\n        kernel_shape = (window_size, 1, input_dim, output_dim * 2)\n        kernel = np.random.rand(*kernel_shape).astype(np.float32)\n        if use_bias:\n            bias = np.random.rand(output_dim * 2).astype(np.float32)\n        else:\n            bias = None\n\n        test_cases.append((x, strides, bias, activation, use_bias, output_dim, kernel, window_size))\n\n    return test_cases\n"}
{"problem_id": "keras_40", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the Dice coefficient, a statistical measure used to gauge the similarity between two sets. This function is particularly useful in the field of image segmentation, where it helps to evaluate the performance of models by comparing the predicted segmentation with the ground truth.\n\nFunction signature:\n```python\ndef dice_coef(y_true, y_pred, smooth=1.0):\n```\n\nConstant used in the main code:\n- `smooth`: A small constant added to the numerator and denominator to prevent division by zero and to ensure numerical stability. The default value is set to `1.0`.\n\nInput format:\n- The function takes two input tensors `y_true` and `y_pred`, which are expected to be of the same shape, representing the ground truth and predicted segmentation masks, respectively. The `smooth` parameter is a float.\n\nOutput format:\n- The function returns a float value representing the Dice coefficient between the two input tensors.\n\nInput:\n```python\ny_true = tf.convert_to_tensor(np.array([[[1], [0]], [[0], [1]]]), dtype=tf.float32)\ny_pred = tf.convert_to_tensor(np.array([[[1], [1]], [[0], [0]]]), dtype=tf.float32)\n```\n\nOutput:\n```python\ntf.Tensor(0.6, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef dice_coef(y_true, y_pred, smooth=1.0):\n    K = tf.keras.backend\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return (2.0 * intersection + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(10, 100)\n        width = np.random.randint(10, 100)\n        shape = (height, width, 1)\n        y_true = np.random.randint(0, 2, shape).astype(np.float32)\n        y_pred = np.random.randint(0, 2, shape).astype(np.float32)\n        y_true_tensor = tf.convert_to_tensor(y_true)\n        y_pred_tensor = tf.convert_to_tensor(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases"}
{"problem_id": "keras_41", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the precision of a binary classification model's predictions. Precision is a metric that indicates the accuracy of the positive predictions made by the model. The function should take two inputs: the true labels and the predicted labels, both represented as tensors.\n\nFunction signature:\n```python\ndef precision(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero when calculating precision.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0s and 1s).\n- `y_pred`: A tensor of predicted binary labels (0s and 1s).\n\nOutput format:\n- The function returns a scalar tensor representing the precision of the predictions.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0]], dtype=np.float32)\ny_pred = np.array([[1, 0, 0], [0, 1, 1]], dtype=np.float32)\n\n# Output\ntf.Tensor(0.6666667, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef precision(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    precision = true_positives / (predicted_positives + K.epsilon())\n    return precision", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 5, size=np.random.randint(1, 4)))\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.randint(0, 2, size=shape).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_42", "library": "keras", "code_problem": "You are tasked with implementing a custom loss function for a regression model using Keras. The loss function should compute the R-squared (coefficient of determination) value, which is a statistical measure that represents the proportion of variance for a dependent variable that's explained by an independent variable or variables in a regression model.\n\nThe function signature for the main code is as follows:\n```python\ndef r2_keras_loss(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K.epsilon()`: This is a small constant added to the denominator to prevent division by zero.\n\nThe input format for the function is two arrays (or lists) of numerical values representing the true and predicted values. The output format is a single numerical value representing the R-squared loss.\n\n```python\nInput: (array([[ 0.49671414, -0.1382643 ,  0.64768854],\n               [ 1.52302986, -0.23415337, -0.23413696]]), \n        array([[ 0.35778736,  0.56078453, -0.6571966 ],\n               [ 0.32408397, -0.38508228, -0.676922  ]]))\nOutput: tf.Tensor(1.6067393, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef r2_keras_loss(y_true, y_pred):\n    K = tf.keras.backend\n    y_true = K.constant(y_true)\n    y_pred = K.constant(y_pred)\n\n    SS_res = K.sum(K.square(y_true - y_pred))\n    SS_tot = K.sum(K.square(y_true - K.mean(y_true)))\n    return SS_res / (SS_tot + K.epsilon())\n\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        features = np.random.randint(1, 20)\n\n        y_true = np.random.randn(batch_size, features).astype(np.float32)\n        y_pred = np.random.randn(batch_size, features).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n\n"}
{"problem_id": "keras_43", "library": "keras", "code_problem": "You are tasked with building a neural network model using Keras that processes image data and velocity information to predict actions and value estimates. The model consists of two main components: an actor model that outputs action probabilities and a critic model that outputs value estimates. \n\nThe function signature for the main code is as follows:\n\n```python\ndef build_model(state_size, action_size, vel_size):\n```\n\n### Constants Used:\n- The constant used in the main code is the kernel initializer for certain layers, specifically `kernel_initializer='he_normal'`, which is used to initialize the weights of the convolutional and dense layers.\n\n### Input and Output Format:\n- **Input**: The function takes three parameters:\n  - `state_size`: A tuple representing the dimensions of the input image data.\n  - `action_size`: An integer representing the number of possible actions.\n  - `vel_size`: An integer representing the size of the velocity input.\n\n- **Output**: The function returns a tuple containing:\n  - `actor`: A Keras Model that outputs action probabilities.\n  - `critic`: A Keras Model that outputs value estimates.\n\n```python\nInput: ((10, 64, 64, 3), 5, 4)\nOutput: (actor_model, critic_model)\n``` \n\nIn this example, the input represents a state size of 10 time steps with images of size 64x64 pixels and 3 color channels, an action size of 5, and a velocity size of 4. The output indicates that the function returns the actor and critic models built from these parameters.", "ground_truth_code": "from keras.layers import Input, BatchNormalization, TimeDistributed, GRU\nfrom keras.layers import Activation, Dense, ELU, Conv2D, MaxPooling2D, Flatten\nfrom keras.models import Model\nimport tensorflow as tf\n\n# main code\ndef build_model(state_size, action_size, vel_size):\n    image = Input(shape=tuple(state_size))\n    image_process = BatchNormalization()(image)\n    image_process = TimeDistributed(Conv2D(32, (8, 8), activation='elu', padding='same', kernel_initializer='he_normal'))(image_process)\n    image_process = TimeDistributed(MaxPooling2D((2, 2)))(image_process)\n    image_process = TimeDistributed(Conv2D(32, (5, 5), activation='elu', kernel_initializer='he_normal'))(image_process)\n    image_process = TimeDistributed(MaxPooling2D((2, 2)))(image_process)\n    image_process = TimeDistributed(Conv2D(16, (3, 3), activation='elu', kernel_initializer='he_normal'))(image_process)\n    image_process = TimeDistributed(MaxPooling2D((2, 2)))(image_process)\n    image_process = TimeDistributed(Conv2D(8, (1, 1), activation='elu', kernel_initializer='he_normal'))(image_process)\n    image_process = TimeDistributed(Flatten())(image_process)\n    image_process = GRU(64, kernel_initializer='he_normal', use_bias=False)(image_process)\n    image_process = BatchNormalization()(image_process)\n    image_process = Activation('tanh')(image_process)\n    vel = Input(shape=(vel_size,))\n    state_process = image_process\n    policy = Dense(128, kernel_initializer='he_normal', use_bias=False)(state_process)\n    policy = ELU()(policy)\n    policy = BatchNormalization()(policy)\n    policy = Dense(action_size, activation='softmax', kernel_initializer=tf.random_uniform_initializer(-0.002, 0.002))(policy)\n    actor = Model(inputs=[image, vel], outputs=policy)\n    value = Dense(128, kernel_initializer='he_normal', use_bias=False)(state_process)\n    value = ELU()(value)\n    value = BatchNormalization()(value)\n    value = Dense(1, kernel_initializer=tf.random_uniform_initializer(-0.003, 0.003))(value)\n    critic = Model(inputs=[image, vel], outputs=value)\n    return (actor, critic)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        time_steps = np.random.randint(5, 15)\n        img_height = np.random.randint(32, 128)\n        img_width = np.random.randint(32, 128)\n        channels = 3\n        state_size = (time_steps, img_height, img_width, channels)\n        vel_size = np.random.randint(2, 10)\n        action_size = np.random.randint(2, 10)\n        test_cases.append((state_size, action_size, vel_size))\n    return test_cases\n"}
{"problem_id": "keras_44", "library": "keras", "code_problem": "In this code, the function `fit_GRU` is designed to create and train a Gated Recurrent Unit (GRU) neural network model using TensorFlow's Keras API. The function takes in a training dataset, batch size, number of epochs, and a list of neuron counts for each GRU layer.\n\n```python\ndef fit_GRU(train: np.ndarray, batch_size: int, nb_epoch: int, neurons: list) -> tf.keras.Model:\n```\n\n### Constant Used:\n- The dropout rate is set to a constant value of `0.3` in the model architecture.\n\n### Input and Output Format:\n- **Input**:\n  - `train`: A NumPy array of shape (n_samples, n_features) containing the training data.\n  - `batch_size`: An integer representing the number of samples per gradient update.\n  - `nb_epoch`: An integer representing the number of epochs to train the model.\n  - `neurons`: A list of integers where each integer represents the number of neurons in the corresponding GRU layer.\n\n- **Output**:\n  - Returns a TensorFlow Keras Model object that represents the trained GRU model.\n\nInput:\n```python\ntrain = np.array([[0.1, 0.2, 0.3, 0.4, 0.5],\n                  [0.2, 0.3, 0.4, 0.5, 0.6],\n                  [0.3, 0.4, 0.5, 0.6, 0.7],\n                  [0.4, 0.5, 0.6, 0.7, 0.8],\n                  [0.5, 0.6, 0.7, 0.8, 0.9]])\nbatch_size = 1\nnb_epoch = 5\nneurons = [32, 64, 32]\n```\n\nOutput:\n```python\n# The output will be the trained model object, but for the sake of this example, we can represent it as:\n<keras.engine.sequential.Sequential object at 0x...>\n```", "ground_truth_code": "import tensorflow as tf\n\ndef fit_GRU(train, batch_size, nb_epoch, neurons):\n    KM = tf.keras.models\n    KL = tf.keras.layers\n\n    X, y = train[:, 0:-1], train[:, -1]\n    X = X.reshape(X.shape[0], X.shape[1], 1)\n\n    batch_size = int(batch_size)\n    time_steps = int(X.shape[1])\n\n    inputs = KL.Input(batch_shape=(batch_size, time_steps, 1))\n    x = KL.GRU(neurons[0], return_sequences=True, stateful=True)(inputs)\n    x = KL.Dropout(0.3)(x)\n    x = KL.GRU(neurons[1], return_sequences=True, stateful=True)(x)\n    x = KL.Dropout(0.3)(x)\n    x = KL.GRU(neurons[2], stateful=True)(x)\n    x = KL.Dropout(0.3)(x)\n    outputs = KL.Dense(1)(x)\n\n    model = KM.Model(inputs=inputs, outputs=outputs)\n    model.compile(loss='mean_squared_error', optimizer='adam')\n\n    gru_layers = [layer for layer in model.layers if isinstance(layer, KL.GRU)]\n\n    for i in range(nb_epoch):\n        print('Epoch:', i + 1)\n        model.fit(X, y, epochs=1, batch_size=batch_size, verbose=1, shuffle=False)\n        for gru in gru_layers:\n            gru.reset_states()\n\n    return model\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        features = np.random.randint(2, 5)\n        samples = np.random.randint(10, 50)\n        train = np.random.rand(samples, features + 1)\n        batch_size = np.random.choice([b for b in range(1, samples + 1) if samples % b == 0])\n        nb_epoch = np.random.randint(1, 10)\n        neurons = [np.random.randint(10, 50) for _ in range(3)]\n        test_cases.append((train, batch_size, nb_epoch, neurons))\n\n    return test_cases\n"}
{"problem_id": "keras_45", "library": "keras", "code_problem": "You are tasked with implementing a function that constructs a convolutional neural network (CNN) model for processing sequences, such as text data. The model will utilize an embedding layer, followed by a convolutional layer, a max pooling layer, and an optional transformation layer. The function should allow for customization of various parameters related to the model architecture.\n\nFunction Signature:\n```python\ndef gen_layers(num_filters, filter_size, pool_length, max_sequence_length, transform, transform_dim, embedding_dim, word_index=None, embedding_matrix=None):\n```\n\nConstants Used:\n- The constant `vocab_size` is calculated as the length of the `word_index` plus one, which accounts for the zero index. If `word_index` is not provided, `vocab_size` defaults to 1.\n\nInput Format:\n- `num_filters`: Integer representing the number of filters in the convolutional layer.\n- `filter_size`: Integer representing the size of the convolutional filter.\n- `pool_length`: Integer representing the size of the pooling window.\n- `max_sequence_length`: Integer representing the maximum length of input sequences.\n- `transform`: Boolean indicating whether to apply a transformation layer.\n- `transform_dim`: Integer representing the output dimension of the transformation layer if applied.\n- `embedding_dim`: Integer representing the dimension of the embedding vectors.\n- `word_index`: Optional dictionary mapping words to their indices.\n- `embedding_matrix`: Optional matrix of pre-trained embeddings.\n\nOutput Format:\n- The function returns a Keras model object that can be used for training and inference on sequence data.\n\n**Input:**\n```python\nnum_filters = 64\nfilter_size = 3\npool_length = 2\nmax_sequence_length = 20\ntransform = True\ntransform_dim = 50\nembedding_dim = 100\nword_index = {'word1': 1, 'word2': 2, 'word3': 3, 'word4': 4, 'word5': 5}\nembedding_matrix = np.random.rand(6, embedding_dim)  # 6 because we have 5 words + 1 for padding\n```\n\n**Output:**\n```python\n# The output will be a Keras Model object\nmodel = gen_layers(num_filters, filter_size, pool_length, max_sequence_length, transform, transform_dim, embedding_dim, word_index, embedding_matrix)\n\n# To check the model summary\nmodel.summary()\n```\n\nThis output will provide a summary of the model architecture created by the `gen_layers` function, which includes the layers and their respective shapes.", "ground_truth_code": "from keras.layers import Embedding, Input, Conv1D, MaxPooling1D, Flatten, Dense\nfrom keras.models import Model\n\n# main code\ndef gen_layers(num_filters, filter_size, pool_length, max_sequence_length, transform, transform_dim, embedding_dim, word_index=None, embedding_matrix=None):\n    vocab_size = len(word_index) + 1 if word_index else 1\n    embedding_matrix = embedding_matrix if embedding_matrix is not None else embedding_dim\n    embedding_layer = Embedding(vocab_size, embedding_dim, weights=[embedding_matrix], input_length=max_sequence_length, trainable=False)\n    sequence_input = Input(shape=(max_sequence_length,), dtype='int32')\n    embedded_sequences = embedding_layer(sequence_input)\n    conv = Conv1D(num_filters, filter_size, padding='same', activation='relu')(embedded_sequences)\n    pooling = MaxPooling1D(pool_length)(conv)\n    flatten_pooling = Flatten()(pooling)\n    transformed = Dense(transform_dim, activation='linear')(flatten_pooling) if transform else flatten_pooling\n    seq_model = Model(sequence_input, transformed)\n    return seq_model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        max_sequence_length = np.random.randint(10, 50)\n        embedding_dim = np.random.randint(50, 300)\n        num_filters = np.random.randint(32, 128)\n        filter_size = np.random.randint(2, 6)\n        pool_length = np.random.randint(2, 4)\n        transform = np.random.choice([True, False])\n        transform_dim = np.random.randint(10, 100) if transform else None\n        vocab_size = np.random.randint(500, 2000)\n        word_index = {f'word{i}': i for i in range(1, vocab_size)}\n        embedding_matrix = np.random.rand(vocab_size, embedding_dim)\n        test_case = (num_filters, filter_size, pool_length, max_sequence_length, transform, transform_dim, embedding_dim, word_index, embedding_matrix)\n        test_cases.append(test_case)\n    return test_cases"}
{"problem_id": "keras_46", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the Dice loss, which is commonly used in image segmentation tasks to measure the overlap between two samples. The Dice loss is particularly useful when dealing with imbalanced datasets, as it emphasizes the importance of correctly predicting the positive class.\n\nFunction signature:\n```python\ndef dice_loss(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `smooth`: A small constant value set to `1.0` to prevent division by zero and to stabilize the calculation of the Dice coefficient.\n\nInput format:\n- The function takes two arguments:\n  - `y_true`: A tensor representing the ground truth labels.\n  - `y_pred`: A tensor representing the predicted labels.\n\nOutput format:\n- The function returns a single floating-point value representing the Dice loss.\n\n```python\n# Input\ny_true = np.array([[[0.0, 1.0], [1.0, 0.0]], \n                    [[1.0, 0.0], [0.0, 1.0]]], dtype=np.float32)  # Shape: (2, 2, 2)\ny_pred = np.array([[[0.0, 0.8], [0.6, 0.0]], \n                    [[0.9, 0.0], [0.0, 0.7]]], dtype=np.float32)  # Shape: (2, 2, 2)\n\n# Output\ndice_loss_value = tf.Tensor(0.125, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef dice_loss(y_true, y_pred):\n    K = tf.keras.backend\n    smooth = 1.0\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = y_true_f * y_pred_f\n    score = (2.0 * K.sum(intersection) + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return 1.0 - score", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(10, 256)\n        width = np.random.randint(10, 256)\n        channels = np.random.randint(1, 4)\n\n        y_true = np.random.rand(height, width, channels).astype(np.float32)\n        y_pred = np.random.rand(height, width, channels).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_47", "library": "keras", "code_problem": "You are tasked with implementing a custom loss function for a deep learning model that combines two different loss metrics: weighted binary cross-entropy loss and dice loss. This combined loss function will help improve the model's performance, especially in tasks like image segmentation where both false positives and false negatives are critical.\n\nThe function signature of the main code is as follows:\n```python\ndef weighted_bce_dice_loss(y_true, y_pred, pool_size=(50, 50), weight_factor=5.0):\n```\n\nIn this function, the constant used is:\n- `weight_factor`: This constant is set to `5.0` and is used to calculate the weights for the binary cross-entropy loss.\n\nInput and output format:\n- Input: The function takes in three parameters: `y_true` (the ground truth labels), `y_pred` (the predicted labels), and two optional parameters `pool_size` (a tuple indicating the size of the pooling window) and `weight_factor` (a float that influences the weight calculation).\n- Output: The function returns a single scalar value representing the combined loss, which is the sum of the weighted binary cross-entropy loss and the dice loss.\n\n```python\n# Input\ny_true = np.array([[[[0, 1, 0], [1, 0, 1]], [[0, 1, 0], [1, 1, 0]]]], dtype=np.float32)  # Shape: (1, 2, 2, 3)\ny_pred = np.array([[[[0.1, 0.9, 0.2], [0.8, 0.3, 0.4]], [[0.2, 0.7, 0.1], [0.6, 0.5, 0.3]]]], dtype=np.float32)  # Shape: (1, 2, 2, 3)\n\n# Output\nloss = tf.Tensor(0.583351, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef weighted_bce_loss(y_true, y_pred, weight, epsilon=1e-07):\n    K = tf.keras.backend\n    y_pred = K.clip(y_pred, epsilon, 1.0 - epsilon)\n    logit_y_pred = K.log(y_pred / (1.0 - y_pred))\n    loss = weight * (logit_y_pred * (1.0 - y_true) + K.log(1.0 + K.exp(-K.abs(logit_y_pred))) + K.maximum(-logit_y_pred, 0.0))\n    return K.sum(loss) / K.sum(weight)\n\ndef dice_loss(y_true, y_pred, smooth=1.0):\n    K = tf.keras.backend\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = y_true_f * y_pred_f\n    score = (2.0 * K.sum(intersection) + smooth) / (K.sum(y_true_f) + K.sum(y_pred_f) + smooth)\n    return 1.0 - score\n\n# main code\ndef weighted_bce_dice_loss(y_true, y_pred, pool_size=(50, 50), weight_factor=5.0):\n    K = tf.keras.backend\n    y_true = K.cast(y_true, 'float32')\n    y_pred = K.cast(y_pred, 'float32')\n    averaged_mask = K.pool2d(y_true, pool_size=pool_size, strides=(1, 1), padding='same', pool_mode='avg')\n    weight = weight_factor * K.exp(-weight_factor * K.abs(averaged_mask - 0.5))\n    weight *= K.sum(K.ones_like(weight)) / K.sum(weight)\n    return weighted_bce_loss(y_true, y_pred, weight) + dice_loss(y_true, y_pred)", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(50, 200)\n        width = np.random.randint(50, 200)\n        channels = np.random.choice([1, 3])\n        y_true = np.random.randint(0, 2, size=(batch_size, height, width, channels)).astype(np.float32)\n        y_pred = np.random.rand(batch_size, height, width, channels).astype(np.float32)\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_48", "library": "keras", "code_problem": "You are tasked with creating a 1D Convolutional Neural Network (CNN) model using Keras. The model should be designed to process input data with a specified shape and perform classification tasks. The function signature for the main code is as follows:\n\n```python\ndef cnn1d_model(input_shape):\n```\n\nIn the main code, the following constant is used:\n- The number of filters in the convolutional layer is set to 16.\n- The kernel size for the convolutional layer is set to 5.\n\nInput format:\n- The function `cnn1d_model` takes a single argument `input_shape`, which is a tuple representing the shape of the input data.\n\nOutput format:\n- The function returns a Keras Sequential model that is configured with the specified layers and activations.\n\nInput: (50, 10)  \nOutput: Model Summary:  \n```\nModel: \"sequential\"\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n conv1d (Conv1D)             (46, 16)                 816       \n                                                                 \n activation (Activation)     (46, 16)                 0         \n                                                                 \n flatten (Flatten)           (736,)                   0         \n                                                                 \n dense (Dense)               (64,)                    47168     \n                                                                 \n dense_1 (Dense)             (1,)                     65        \n                                                                 \n activation_1 (Activation)   (1,)                     0         \n                                                                 \n=================================================================\nTotal params: 48,049\nTrainable params: 48,049\nNon-trainable params: 0\n_________________________________________________________________\n```", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Convolution1D\nfrom keras.layers import Activation\nfrom keras.layers import Flatten\nfrom keras.layers import Dense\n\n# main code\ndef cnn1d_model(input_shape):\n    model = Sequential()\n    model.add(Convolution1D(16, 5, input_shape=input_shape))\n    model.add(Activation('relu'))\n    model.add(Flatten())\n    model.add(Dense(64))\n    model.add(Dense(1))\n    model.add(Activation('softmax'))\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        steps = np.random.randint(10, 101)\n        input_dim = np.random.randint(1, 21)\n\n        input_shape = (steps, input_dim)\n        test_cases.append(input_shape)\n\n    return test_cases"}
{"problem_id": "keras_49", "library": "keras", "code_problem": "You are tasked with implementing a function that compiles a neural network model for sequence labeling tasks using Keras. The model will utilize pre-trained word embeddings and a bidirectional LSTM architecture. The function should take in a tokenizer, an embeddings index, embedding dimensions, hidden dimensions, and a tag mapping as inputs, and return a compiled Keras model.\n\nFunction signature:\n```python\ndef compile_model(tokenizer, embeddings_index, embedding_dim, hidden_dim, tag_map):\n```\n\nConstant used in the main code:\n- `vocab_size`: This constant represents the size of the vocabulary, which is determined by the number of unique words in the tokenizer's word index plus one (to account for the zero padding).\n\nInput format:\n- `tokenizer`: An object that contains a word index and a maximum sequence length.\n- `embeddings_index`: A dictionary mapping words to their corresponding embedding vectors.\n- `embedding_dim`: An integer representing the dimensionality of the embedding vectors.\n- `hidden_dim`: An integer representing the number of units in the LSTM layer.\n- `tag_map`: A dictionary mapping tags to their corresponding indices.\n\nOutput format:\n- The function returns a compiled Keras model ready for training on sequence labeling tasks.\n\n**Input:**\n```python\ntokenizer = type('TokenizerMock', (object,), {\n    'tokenizer': type('TokenizerInnerMock', (object,), {\n        'word_index': {'word1': 1, 'word2': 2, 'word3': 3, 'word4': 4, 'word5': 5}\n    })(),\n    'max_sequence_length': 10\n})()\n\nembeddings_index = {\n    'word1': np.array([0.1, 0.2, 0.3]),\n    'word2': np.array([0.4, 0.5, 0.6]),\n    'word3': np.array([0.7, 0.8, 0.9]),\n    'word4': np.array([0.0, 0.1, 0.2]),\n    'word5': np.array([0.3, 0.4, 0.5])\n}\n\nembedding_dim = 3\nhidden_dim = 32\ntag_map = {'tag1': 0, 'tag2': 1, 'tag3': 2}\n```\n\n**Output:**\n```python\nmodel = compile_model(tokenizer, embeddings_index, embedding_dim, hidden_dim, tag_map)\nmodel.summary()  # This will print the model architecture\n```\n\n### Explanation:\n- The input consists of a mock tokenizer with a small vocabulary of 5 words, a simple embeddings index with random vectors, specified embedding and hidden dimensions, and a tag map with 3 tags.\n- The output is the model created by the `compile_model` function, and calling `model.summary()` will provide a summary of the model architecture, which can be used to verify that the model has been constructed correctly.", "ground_truth_code": "import numpy as np\nfrom keras.models import Sequential\nfrom keras.layers import Embedding, Bidirectional, TimeDistributed, Activation, LSTM, Dense\n\n# main code\ndef compile_model(tokenizer, embeddings_index, embedding_dim, hidden_dim, tag_map):\n    vocab_size = len(tokenizer.tokenizer.word_index) + 1\n    embedding_matrix = np.zeros((vocab_size, embedding_dim))\n\n    for word, i in tokenizer.tokenizer.word_index.items():\n        embedding_vector = embeddings_index.get(word)\n        if embedding_vector is not None:\n            embedding_matrix[i] = embedding_vector\n\n    model = Sequential()\n    model.add(Embedding(vocab_size, embedding_dim, weights=[embedding_matrix],\n                        input_length=tokenizer.max_sequence_length, trainable=False, mask_zero=True))\n    model.add(Bidirectional(LSTM(hidden_dim, return_sequences=True)))\n    model.add(TimeDistributed(Dense(len(tag_map) + 1)))\n    model.add(Activation('softmax'))\n    model.compile(loss='categorical_crossentropy', optimizer='adam', metrics=['acc'])\n\n    return model", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        vocab_size = random.randint(50, 500)\n        embedding_dim = random.choice([50, 100, 200, 300])\n        hidden_dim = random.randint(16, 128)\n        tokenizer = type('TokenizerMock', (object,), {\n            'tokenizer': type('TokenizerInnerMock', (object,), {\n                'word_index': {f'word{i}': i + 1 for i in range(vocab_size - 1)}\n            })(),\n            'max_sequence_length': random.randint(10, 50)\n        })()\n        embeddings_index = {\n            f'word{i}': np.random.rand(embedding_dim) for i in range(vocab_size - 1)\n        }\n        tag_map = {f'tag{i}': i for i in range(random.randint(3, 10))}\n\n        test_cases.append((tokenizer, embeddings_index, embedding_dim, hidden_dim, tag_map))\n\n    return test_cases"}
{"problem_id": "keras_50", "library": "keras", "code_problem": "You are tasked with creating a function that builds a neural network model to serve as a critic in a Generative Adversarial Network (GAN). The model will take a time series input and output a single validity score indicating how real or fake the input data is. \n\nThe function signature is as follows:\n```python\ndef build_critic(ts_shape):\n```\n\nIn this function, a constant is used:\n- The constant `100` is used to define the number of neurons in the first two dense layers of the model.\n\nThe input format for the function is a tuple representing the shape of the time series data, and the output format is a Keras Model object that can be used for further training or evaluation.\n\nInput: (5, 10)\nOutput: Model Summary:\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n dense (Dense)               (None, 100)              1100      \n                                                                 \n dense_1 (Dense)             (None, 100)              10100     \n                                                                 \n flatten (Flatten)           (None, 100)              0         \n                                                                 \n dense_2 (Dense)             (None, 1)                101       \n                                                                 \n=================================================================\nTotal params: 11201 (43.88 KB)\nTrainable params: 11201 (43.88 KB)\nNon-trainable params: 0 (0.00 Byte)\n_________________________________________________________________", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Input\nfrom keras.models import Model\nfrom keras.layers import Dense\nfrom keras.layers import Flatten\n\n# main code\ndef build_critic(ts_shape):\n    model = Sequential([Dense(100, input_shape=ts_shape), Dense(100), Flatten(), Dense(1)])\n    model.summary()\n    ts = Input(shape=ts_shape)\n    validity = model(ts)\n    return Model(ts, validity)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape_len = np.random.randint(1, 4)\n        ts_shape = tuple(np.random.randint(1, 20, size=shape_len))\n\n        test_cases.append(ts_shape)\n\n    return test_cases"}
{"problem_id": "keras_51", "library": "keras", "code_problem": "You are tasked with implementing a function that constructs a fire module for a neural network using Keras. The fire module is a building block commonly used in deep learning architectures, particularly in SqueezeNet. The function should take an input tensor and apply a series of convolutional operations to produce an output tensor.\n\nFunction Signature:\n```python\ndef fire_module(fire_input, fire_id, squeeze, expand):\n```\n\nConstants used in the main code:\n- The dropout rate is set to 0.4.\n- The L2 regularization factor is set to 0.0001.\n\nInput Format:\n- `fire_input`: A tensor of shape (batch_size, height, width, channels) representing the input to the fire module.\n- `fire_id`: An integer representing the identifier for the fire module.\n- `squeeze`: An integer representing the number of filters for the squeeze layer.\n- `expand`: An integer representing the number of filters for the expand layers.\n\nOutput Format:\n- The function returns a tensor that is the result of the concatenation of the outputs from Tower 01 and Tower 02, with shape (batch_size, height, width, 2 * expand).\n\nInput:\n```python\nfire_input = tf.random.normal((1, 32, 32, 16))  # Random input tensor\nfire_id = 5  # Fire module ID\nsqueeze = 16  # Squeeze filter size\nexpand = 32  # Expand filter size\n```\n\nOutput:\n```python\noutput_shape = (1, 32, 32, 64)  # Shape after concatenation of two towers\n```", "ground_truth_code": "import tensorflow as tf\nfrom keras import regularizers\n\n# main code\ndef fire_module(fire_input, fire_id, squeeze, expand):\n    KL = tf.keras.layers\n    s_id = f'fire{fire_id}_'\n    x = KL.Conv2D(\n        squeeze, (1, 1), padding='same', kernel_initializer='glorot_uniform',\n        bias_initializer='zeros', kernel_regularizer=regularizers.l2(0.0001),\n        data_format='channels_last', activation='relu', name=f'{s_id}sq1x1'\n    )(fire_input)\n\n    tower01 = KL.Conv2D(\n        expand, (1, 1), padding='same', kernel_initializer='glorot_uniform',\n        bias_initializer='zeros', kernel_regularizer=regularizers.l2(0.0001),\n        data_format='channels_last', activation='relu', name=f'{s_id}exp1x1'\n    )(x)\n    tower01 = KL.Conv2D(\n        expand, (3, 3), padding='same', kernel_initializer='glorot_uniform',\n        bias_initializer='zeros', kernel_regularizer=regularizers.l2(0.0001),\n        data_format='channels_last', activation='relu', name=f'{s_id}exp3x3'\n    )(tower01)\n    tower01 = KL.Dropout(0.4)(tower01)\n\n    tower02 = KL.Conv2DTranspose(\n        expand, (1, 1), padding='same', kernel_initializer='glorot_uniform',\n        bias_initializer='zeros', kernel_regularizer=regularizers.l2(0.0001),\n        data_format='channels_last', activation='relu', name=f'{s_id}d_exp1x1'\n    )(x)\n    tower02 = KL.Conv2DTranspose(\n        expand, (3, 3), padding='same', kernel_initializer='glorot_uniform',\n        bias_initializer='zeros', kernel_regularizer=regularizers.l2(0.0001),\n        data_format='channels_last', activation='relu', name=f'{s_id}d_exp3x3'\n    )(tower02)\n    tower02 = KL.Dropout(0.4)(tower02)\n\n    return KL.concatenate([tower01, tower02], axis=3, name=f'{s_id}concat')", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        height = np.random.choice([16, 32, 64, 128])\n        width = np.random.choice([16, 32, 64, 128])\n        channels = np.random.choice([16, 32, 64])\n\n        fire_input = tf.random.normal((1, height, width, channels))\n        squeeze = np.random.choice([8, 16, 32])\n        expand = np.random.choice([16, 32, 64])\n\n        test_cases.append((fire_input, np.random.randint(1, 100), squeeze, expand))\n\n    return test_cases"}
{"problem_id": "keras_52", "library": "keras", "code_problem": "You are tasked with implementing a Convolutional Neural Network (CNN) based Autoencoder using Keras. The goal of this Autoencoder is to learn a compressed representation of input images and then reconstruct the images from this representation. The Autoencoder consists of an encoder that compresses the input and a decoder that reconstructs the input from the compressed representation.\n\nThe function signature for the main code is as follows:\n\n```python\ndef get_CNN_AE(feat_dim=256, input_shape=(99, 40, 1), depth=32, learning_rate=0.001):\n```\n\nIn this function, the following constant is used:\n- `depth`: This constant determines the number of filters in the convolutional layers and is set to a default value of 32.\n\nInput format:\n- The function accepts the following parameters:\n  - `feat_dim`: An integer representing the dimension of the encoded feature space (default is 256).\n  - `input_shape`: A tuple representing the shape of the input images (default is (99, 40, 1)).\n  - `depth`: An integer representing the number of filters in the convolutional layers (default is 32).\n  - `learning_rate`: A float representing the learning rate for the optimizer (default is 0.001).\n\nOutput format:\n- The function returns two Keras Model objects:\n  - The first is the encoder model that outputs the compressed representation of the input images.\n  - The second is the autoencoder model that outputs the reconstructed images from the compressed representation.\n\nInput: `(256, (99, 40, 1), 32, 0.0001)`\n\nOutput: `(<keras.engine.functional.Functional object at 0x...>, <keras.engine.functional.Functional object at 0x...>)` \n\n(Note: The output will be the encoder and autoencoder models, represented as Keras Functional objects, and the memory addresses will vary with each execution.)", "ground_truth_code": "from keras.layers import Input, Conv2D, MaxPooling2D, Flatten, Dense, Reshape, UpSampling2D\nfrom keras.models import Model\nfrom keras.optimizers import Adam\n\n# main code\ndef get_CNN_AE(feat_dim=256, input_shape=(99, 40, 1), depth=32, learning_rate=0.001):\n    input_img = Input(shape=input_shape)\n\n    x = Conv2D(depth, (3, 3), activation='relu', padding='same')(input_img)\n    x = MaxPooling2D((2, 2), padding='same')(x)\n    x = Conv2D(2 * depth, (3, 3), activation='relu', padding='same')(x)\n    x = MaxPooling2D((2, 1), padding='same')(x)\n    x = Conv2D(4 * depth, (3, 3), activation='relu', padding='same')(x)\n    x = MaxPooling2D((3, 2), padding='same')(x)\n\n    x = Flatten()(x)\n    encoded = Dense(feat_dim, activation='relu')(x)\n\n    x = Dense(9 * 7 * 4 * depth, activation='relu')(encoded)\n    x = Reshape((9, 7, 4 * depth))(x)\n\n    x = Conv2D(4 * depth, (3, 3), activation='relu', padding='same')(x)\n    x = UpSampling2D((3, 2))(x)\n    x = Conv2D(2 * depth, (5, 3), activation='relu', padding='same')(x)\n    x = UpSampling2D((2, 2))(x)\n    x = Conv2D(depth, (3, 6), activation='relu')(x)\n    x = UpSampling2D((2, 2))(x)\n\n    decoded = Conv2D(1, (6, 7), activation='sigmoid', padding='valid')(x)\n\n    encoder = Model(input_img, encoded)\n    autoencoder = Model(input_img, decoded)\n\n    autoencoder.compile(optimizer=Adam(learning_rate=learning_rate), loss='mse')\n\n    return encoder, autoencoder", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        feat_dim = np.random.randint(128, 512)\n        input_shape = (99, 40, 1)\n        depth = np.random.choice([16, 32, 64, 128])\n        learning_rate = 10 ** np.random.uniform(-4, -2)\n\n        test_cases.append((feat_dim, input_shape, depth, learning_rate))\n\n    return test_cases"}
{"problem_id": "keras_53", "library": "keras", "code_problem": "You are tasked with implementing a function that constructs a residual block for a convolutional neural network using Keras. This function will apply batch normalization, activation, and convolution operations to an input tensor, and then add the result to the original input tensor (shortcut connection) to form a residual connection.\n\nFunction signature:\n```python\ndef block(channels: int, input_tensor: Tensor, bn_axis: int, data_format: str, weight_decay: float) -> Tensor:\n```\n\nConstant used in the main code:\n- The kernel size for the convolutional layers is set to 3.\n\nInput format:\n- `channels`: an integer representing the number of output channels.\n- `input_tensor`: a Keras tensor representing the input to the block.\n- `bn_axis`: an integer representing the axis for batch normalization.\n- `data_format`: a string indicating the data format ('channels_last' or 'channels_first').\n- `weight_decay`: a float representing the weight decay for L2 regularization.\n\nOutput format:\n- The function returns a Keras tensor that represents the output of the residual block, which is the result of adding the output of the second convolutional layer to the original input tensor (shortcut). If the input tensor is None, it returns None.\n\nInput:\n```python\nchannels = 32\ninput_tensor = tf.random.normal((1, 32, 32, 32))  # channels_last format\nbn_axis = 3\ndata_format = \"channels_last\"\nweight_decay = 0.0001\n```\n\nOutput:\n```python\noutput_tensor = block(channels, input_tensor, bn_axis, data_format, weight_decay)\n```", "ground_truth_code": "from keras.layers import BatchNormalization, Activation, Conv2D, Add\nfrom keras.regularizers import l2\n\n# main code\ndef block(channels, input_tensor, bn_axis, data_format, weight_decay):\n    shortcut = input_tensor\n    x = BatchNormalization(axis=bn_axis)(input_tensor)\n    x = Activation('relu')(x)\n    x = Conv2D(channels, kernel_size=3, padding='same', data_format=data_format, kernel_regularizer=l2(weight_decay))(x)\n    x = BatchNormalization(axis=bn_axis)(x)\n    x = Activation('relu')(x)\n    x = Conv2D(channels, kernel_size=3, padding='same', data_format=data_format, kernel_regularizer=l2(weight_decay))(x)\n    return Add()([x, shortcut]) if input_tensor is not None else None", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_format = np.random.choice([\"channels_last\", \"channels_first\"])\n        batch_size = np.random.randint(1, 5)\n        height = np.random.randint(8, 64)\n        width = np.random.randint(8, 64)\n        channels = np.random.randint(8, 64)\n\n        if data_format == \"channels_last\":\n            input_shape = (batch_size, height, width, channels)\n            bn_axis = 3\n        else:\n            input_shape = (batch_size, channels, height, width)\n            bn_axis = 1\n        input_tensor = tf.random.normal(input_shape)\n        weight_decay = np.random.uniform(1e-5, 1e-2)\n        test_cases.append((channels, input_tensor, bn_axis, data_format, weight_decay))\n\n    return test_cases\n"}
{"problem_id": "keras_54", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the sensitivity (also known as recall) of a binary classification model. Sensitivity is a metric that measures the proportion of actual positive cases that were correctly identified by the model. The function should be able to handle inputs in the form of tensors, which represent the true labels and the predicted labels of a dataset.\n\nFunction signature:\n```python\ndef sensitivity(y_true, y_pred):\n```\n\nIn the main code, the following constant is used:\n- `K.epsilon()`: This is a small constant added to the denominator to prevent division by zero.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0s and 1s).\n- `y_pred`: A tensor of predicted binary labels (0s and 1s).\n\nOutput format:\n- A scalar value representing the sensitivity of the model, which is a float between 0 and 1.\n\n```python\n# Input\ny_true = np.array([[1., 0., 1.], [0., 1., 0.], [1., 1., 0.]])\ny_pred = np.array([[0.9, 0.1, 0.8], [0.2, 0.7, 0.1], [0.6, 0.4, 0.3]])\n\n# Output\ntf.Tensor(0.7999999840000003, shape=(), dtype=float64)\n```", "ground_truth_code": "import tensorflow as tf\n# main code\ndef sensitivity(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    return true_positives / (possible_positives + K.epsilon())", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        num_classes = np.random.randint(2, 10)\n\n        y_true = np.random.randint(0, 2, size=(batch_size, num_classes)).astype(float)\n        y_pred = np.random.rand(batch_size, num_classes)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n"}
{"problem_id": "keras_55", "library": "keras", "code_problem": "You are tasked with implementing a function that computes a weight vector based on a given set of inputs. The function signature is as follows:\n\n```python\ndef get_weight_vector(M, w_tm1, k, beta, g, s, gamma, batch_size, C):\n```\n\n### Constants Used:\n- `C`: A constant tensor that is used in the computation of the output weight vector.\n\n### Input Format:\n- `M`: A tensor of shape (batch_size, n, d) representing a batch of matrices.\n- `w_tm1`: A tensor of shape (batch_size, n) representing the previous weight vector.\n- `k`: A tensor of shape (d,) representing a vector for comparison.\n- `beta`: A scalar value used to scale the cosine distance.\n- `g`: A scalar value used to weight the current and previous weight vectors.\n- `s`: A tensor of shape (batch_size, m) representing some contextual information.\n- `gamma`: A scalar value used to exponentiate the intermediate weight vector.\n- `batch_size`: An integer representing the number of samples in the batch.\n- `C`: A tensor of shape (n, m, d) representing a constant context tensor.\n\n### Output Format:\n- The function returns a tensor of shape (batch_size, n) representing the computed weight vector after normalization.\n\n**Input:**\n```python\nM = K.variable(np.array([[[0.1, 0.2, 0.3], \n                           [0.4, 0.5, 0.6]], \n                          [[0.7, 0.8, 0.9], \n                           [0.1, 0.2, 0.3]]]))  # Shape: (2, 2, 3)\n\nw_tm1 = K.variable(np.array([[0.2, 0.3], \n                              [0.5, 0.5]]))  # Shape: (2, 2)\n\nk = K.variable(np.array([[0.1, 0.2, 0.3], \n                          [0.4, 0.5, 0.6]]))  # Shape: (2, 3)\n\nbeta = K.variable(np.array([[0.5], \n                             [0.5]]))  # Shape: (2, 1)\n\ng = K.variable(np.array([[0.7], \n                          [0.3]]))  # Shape: (2, 1)\n\ns = K.variable(np.array([[0.1, 0.2, 0.3], \n                          [0.4, 0.5, 0.6]]))  # Shape: (2, 3)\n\ngamma = K.variable(np.array([[2.0], \n                              [2.0]]))  # Shape: (2, 1)\n\nC = K.variable(np.array([\n                      [[0.1, 0.2],\n                       [0.3, 0.4],\n                       [0.5, 0.6]],\n                      [[0.7, 0.8],\n                       [0.9, 1.0],\n                       [1.1, 1.2]]\n                  ]))  # Shape: (2, 3, 2)\n\nbatch_size = 2\n```\n\n**Output:**\n```python\ntf.Tensor(\n[[0.02419016 0.20146975 0.7743401 ]\n [0.08136904 0.26529765 0.65333337]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\ndef renorm(x):\n    K = tf.keras.backend\n    return x / K.sum(x, axis=1, keepdims=True)\n\ndef cosine_distance(M, k):\n    K = tf.keras.backend\n    nk = K.l2_normalize(k, axis=-1)\n    nM = K.l2_normalize(M, axis=-1)\n    return K.batch_dot(nM, nk)\n\n# main code\ndef get_weight_vector(M, w_tm1, k, beta, g, s, gamma, batch_size, C):\n    K = tf.keras.backend\n    num = beta * cosine_distance(M, k)\n    w_c = K.softmax(num)\n    w_g = g * w_c + (1 - g) * w_tm1\n    C_s = K.sum(K.repeat_elements(C[None, :, :, :], batch_size, axis=0) * s[:, None, :, None], axis=1)\n    w_tilda = K.batch_dot(C_s, w_g)\n    w_out = renorm(w_tilda ** gamma)\n    return w_out", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        N = np.random.randint(5, 20)\n        M_dim = np.random.randint(5, 20)\n        C_dim = np.random.randint(5, 20)\n\n        M = K.variable(np.random.rand(batch_size, N, M_dim))\n        w_tm1 = K.variable(np.random.rand(batch_size, N))\n        k = K.variable(np.random.rand(batch_size, M_dim))\n        beta = K.variable(np.random.rand(batch_size, 1))\n        g = K.variable(np.random.rand(batch_size, 1))\n        s = K.variable(np.random.rand(batch_size, C_dim))\n        gamma = K.variable(np.random.rand(batch_size, 1))\n        C = K.variable(np.random.rand(N, C_dim, N))\n\n        test_cases.append((M, w_tm1, k, beta, g, s, gamma, batch_size, C))\n\n    return test_cases"}
{"problem_id": "keras_56", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the true positive rate (TPR) for a binary classification problem using Keras backend operations. The function should take two inputs: the true labels and the predicted labels, both of which are expected to be in the form of tensors. The function should handle the case where the predicted values may not be strictly between 0 and 1 by clipping them to this range. Additionally, to avoid division by zero, a small constant should be added to both the numerator and the denominator.\n\nFunction signature:\n```python\ndef true_positive(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `smooth = 1`\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted probabilities (values between 0 and 1).\n\nOutput format:\n- The function returns a scalar tensor representing the true positive rate.\n\nInput:\n```python\ny_true = K.constant([[1, 0, 1], [0, 1, 0]])\ny_pred = K.constant([[0.9, 0.1, 0.8], [0.2, 0.7, 0.3]])\n```\n\nOutput:\n```python\ntf.Tensor(1.0, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef true_positive(y_true, y_pred):\n    K = tf.keras.backend\n    smooth = 1\n    y_pred_pos = K.round(K.clip(y_pred, 0, 1))\n    y_pos = K.round(K.clip(y_true, 0, 1))\n    tp = (K.sum(y_pos * y_pred_pos) + smooth) / (K.sum(y_pos) + smooth)\n    return tp", "test_script": "import numpy as np\nimport tensorflow as tf\nimport random\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n    for _ in range(n):\n        shape = random.choices([(32,), (64,), (128,), (32, 32), (16, 16, 16)], weights=[0.2, 0.2, 0.2, 0.2, 0.2])[0]\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n        y_true_tensor = K.constant(y_true)\n        y_pred_tensor = K.constant(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases"}
{"problem_id": "keras_57", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the precision of a binary classification model using Keras backend operations. The function will take two inputs: the true labels and the predicted labels, both represented as tensors. The precision is defined as the ratio of true positive predictions to the total number of positive predictions made by the model.\n\nFunction signature:\n```python\ndef precision_m(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero when calculating precision.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted binary labels (0 or 1).\n\nOutput format:\n- A scalar tensor representing the precision of the predictions.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0]], dtype=np.float32)  # Shape: (2, 3)\ny_pred = np.array([[0.8, 0.1, 0.6], [0.2, 0.9, 0.0]], dtype=np.float32)  # Shape: (2, 3)\n\n# Output\nprecision_value = precision_m(y_true, y_pred)  \n# tf.Tensor(1.0, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef precision_m(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    predicted_positives = K.sum(K.round(K.clip(y_pred, 0, 1)))\n    precision = true_positives / (predicted_positives + K.epsilon())\n    return precision", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 128)\n        num_classes = np.random.choice([1, 2, 10, 100])\n        y_true = np.random.choice([0, 1], size=(batch_size, num_classes)).astype(np.float32)\n        y_pred = np.random.rand(batch_size, num_classes).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n"}
{"problem_id": "keras_58", "library": "keras", "code_problem": "You are tasked with creating a neural network model using Keras that incorporates an embedding layer for processing textual data. The model should be designed to take a specified number of features and a maximum sequence length as input parameters. \n\nThe function signature for the main code is:\n```python\ndef dense_with_embeddings_model(max_features, max_len):\n```\n\nIn this function, the following constant is used:\n- The embedding dimension is set to 8.\n\nInput format:\n- `max_features`: An integer representing the number of unique tokens in the input data.\n- `max_len`: An integer representing the maximum length of the input sequences.\n\nOutput format:\n- The function returns a Keras Sequential model that can be compiled and trained on a dataset.\n\nInput: (256, 20)  \nOutput: A Keras Sequential model with an Embedding layer of 256 features, input length of 20, followed by a Flatten layer, a Dense layer with 64 units, and a final Dense layer with 1 unit activated by sigmoid.", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Embedding\nfrom keras.layers import Flatten\nfrom keras.layers import Dense\nfrom keras.layers import Activation\n\n# main code\ndef dense_with_embeddings_model(max_features, max_len):\n    model = Sequential()\n    model.add(Embedding(max_features, 8, input_length=max_len))\n    model.add(Flatten())\n    model.add(Dense(64))\n    model.add(Dense(1))\n    model.add(Activation('sigmoid'))\n    return model\n\n", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        max_features = random.randint(50, 5000)\n        max_len = random.randint(5, 100)\n\n        test_cases.append((max_features, max_len))\n    return test_cases"}
{"problem_id": "keras_59", "library": "keras", "code_problem": "You are tasked with implementing a function that processes complex-valued inputs using real-valued kernels and biases. The function will concatenate the real and imaginary parts of the input, apply a transformation using the provided kernels, and optionally add a bias and an activation function.\n\nFunction signature:\n```python\ndef call(inputs, bias, imag_kernel, activation, use_bias, real_kernel):\n```\n\nConstants used in the main code:\n- The constant used in the main code is the axis parameter for concatenation, which is set to `1` for concatenating the real and imaginary inputs and `-1` for concatenating the kernels along the last dimension.\n\nInput format:\n- `inputs`: A list or tuple containing two tensors (real and imaginary parts).\n- `bias`: A tensor representing the bias to be added (if `use_bias` is `True`).\n- `imag_kernel`: A tensor representing the imaginary part of the kernel.\n- `activation`: A callable activation function (or `None`).\n- `use_bias`: A boolean indicating whether to use the bias.\n- `real_kernel`: A tensor representing the real part of the kernel.\n\nOutput format:\n- The function returns a tensor that represents the processed output after applying the transformations defined in the function logic.\n\n**Input:**\n```python\ninputs = [\n    tf.convert_to_tensor([[0.5, -0.2], [1.0, 0.3]]),  # Real input\n    tf.convert_to_tensor([[0.1, 0.4], [-0.5, 0.2]])  # Imaginary input\n]\nbias = tf.convert_to_tensor([0.1, -0.1, 0.2, -0.2])  # Bias\nimag_kernel = tf.convert_to_tensor([[0.3, -0.1], [0.2, 0.5]])  # Imaginary kernel\nactivation = activations.relu  # Activation function\nuse_bias = True  # Use bias\nreal_kernel = tf.convert_to_tensor([[0.4, 0.2], [-0.3, 0.6]])  # Real kernel\n```\n\n**Output:**\n```python\noutput = call(inputs, bias, imag_kernel, activation, use_bias, real_kernel)\n# output\ntf.Tensor(\n[[0.47       0.07       0.01000001 0.21      ]\n [0.3        0.42999998 0.         0.        ]], shape=(2, 4), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, bias, imag_kernel, activation, use_bias, real_kernel):\n    K = tf.keras.backend\n    real_input = inputs[0]\n    imag_input = inputs[1]\n    inputs = K.concatenate([real_input, imag_input], axis=1)\n    cat_kernels_4_real = K.concatenate([real_kernel, -imag_kernel], axis=-1)\n    cat_kernels_4_imag = K.concatenate([imag_kernel, real_kernel], axis=-1)\n    cat_kernels_4_complex = K.concatenate([cat_kernels_4_real, cat_kernels_4_imag], axis=0)\n    output = K.dot(inputs, cat_kernels_4_complex)\n    if use_bias:\n        output = K.bias_add(output, bias)\n    if activation is not None:\n        output = activation(output)\n    return output", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    KA = tf.keras.activations\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        input_dim = np.random.randint(2, 20)\n        output_dim = np.random.randint(2, 20)\n\n        real_input = np.random.randn(batch_size, input_dim).astype(np.float32)\n        imag_input = np.random.randn(batch_size, input_dim).astype(np.float32)\n\n        real_kernel = np.random.randn(input_dim, output_dim).astype(np.float32)\n        imag_kernel = np.random.randn(input_dim, output_dim).astype(np.float32)\n\n        use_bias = np.random.choice([True, False])\n        bias = np.random.randn(2 * output_dim).astype(np.float32) if use_bias else None\n\n        activation_fn = np.random.choice([None, KA.relu, KA.sigmoid, KA.tanh])\n\n        test_case = (\n            [tf.convert_to_tensor(real_input), tf.convert_to_tensor(imag_input)],\n            tf.convert_to_tensor(bias) if use_bias else None,\n            tf.convert_to_tensor(imag_kernel),\n            activation_fn,\n            use_bias,\n            tf.convert_to_tensor(real_kernel)\n        )\n\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "keras_60", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a neural network model for a discriminator in a Generative Adversarial Network (GAN) using Keras. The function should take the shape of the input images as an argument and return a Keras model that outputs three different predictions based on the input features.\n\nFunction Signature:\n```python\ndef build_discriminator(img_shape):\n```\n\nConstant Used:\n- The momentum constant used in BatchNormalization layers is set to `0.8`.\n\nInput Format:\n- The function takes a single argument `img_shape`, which is a tuple representing the shape of the input images (e.g., (height, width, channels)).\n\nOutput Format:\n- The function returns a Keras Model object that outputs three predictions: validity, bot, and normal, each as a single value between 0 and 1.\n", "ground_truth_code": "from keras.models import Sequential, Model\nfrom keras.layers import Dense, BatchNormalization, LeakyReLU, Input\n\n# main code\ndef build_discriminator(img_shape):\n    model = Sequential()\n    model.add(Dense(128, input_shape=img_shape))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(BatchNormalization(momentum=0.8))\n\n    model.add(Dense(64))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(BatchNormalization(momentum=0.8))\n\n    model.add(Dense(32))\n    model.add(LeakyReLU(alpha=0.2))\n    model.add(BatchNormalization(momentum=0.8))\n\n    img = Input(shape=img_shape)\n    features = model(img)\n\n    validity = Dense(1, activation='sigmoid')(features)\n    bot = Dense(1, activation='sigmoid')(features)\n    normal = Dense(1, activation='sigmoid')(features)\n\n    return Model(img, [validity, bot, normal])\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        img_shape = (np.random.randint(1, 100),)\n        test_cases.append(img_shape)\n\n    return test_cases"}
{"problem_id": "keras_61", "library": "keras", "code_problem": "You are tasked with implementing a function that extracts features from an image using a pre-trained VGG16 model from Keras. The function will preprocess the input image and return the output of the last layer of the model, which represents the extracted features.\n\nFunction signature:\n```python\ndef extract_feature(image: np.ndarray) -> np.ndarray:\n```\n\nConstant used in the main code:\n- The VGG16 model is used as the feature extractor.\n\nInput format:\n- The input to the function is a single image represented as a NumPy array.\n\nOutput format:\n- The output of the function is a NumPy array containing the extracted features from the image.\n\nInput:\n```python\narray([[[  34,  120,  200],\n        [  56,  130,  210],\n        [  78,  140,  220],\n        ...,\n        [  90,  150,  230],\n        [  12,  160,  240],\n        [  34,  170,  250]],\n\n       [[  45,  110,  190],\n        [  67,  120,  200],\n        [  89,  130,  210],\n        ...,\n        [  11,  140,  220],\n        [  23,  150,  230],\n        [  35,  160,  240]],\n\n       ...,\n\n       [[  12,  100,  180],\n        [  34,  110,  190],\n        [  56,  120,  200],\n        ...,\n        [  78,  130,  210],\n        [  90,  140,  220],\n        [  12,  150,  230]]], dtype=uint8)\n```\n\nOutput:\n```python\narray([[  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ],\n       [  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ],\n       [  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ],\n       ...,\n       [  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ],\n       [  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ],\n       [  0.        ,   0.        ,   0.        , ...,   0.        ,\n          0.        ,   0.        ]], dtype=float32)\n```", "ground_truth_code": "from keras.applications.vgg16 import VGG16\nfrom keras.models import Model\nfrom keras.applications.vgg16 import preprocess_input\nimport numpy as np\n\ndef extract_feature(image):\n    model = VGG16()\n    model.layers.pop()\n    model = Model(inputs=model.inputs, outputs=model.layers[-1].output)\n\n    if isinstance(image, np.ndarray):\n        processed_image = image\n    else:\n        return None\n\n    processed_image = processed_image.reshape((1, *processed_image.shape))\n    processed_image = preprocess_input(processed_image)\n\n    feature = model.predict(processed_image, verbose=0)\n    return feature", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        image = np.random.randint(0, 256, size=(224, 224, 3), dtype=np.uint8)\n\n        test_cases.append(image)\n    return test_cases"}
{"problem_id": "keras_62", "library": "keras", "code_problem": "You are tasked with implementing a function that performs a scaled dot-product attention mechanism, commonly used in neural networks, particularly in transformer architectures. The function will compute attention scores based on input queries, keys, and values, and return the resulting output after applying the attention mechanism.\n\nFunction signature:\n```python\ndef call(inputs, use_bias, scaling, query_kernel, key_kernel, activation, key_bias, query_bias):\n```\n\nConstants used in the main code:\n- The constant `K` from the `keras.backend` module is used for various tensor operations.\n\nInput format:\n- `inputs`: A tuple of three tensors (queries, keys, values).\n- `use_bias`: A boolean value.\n- `scaling`: A float value.\n- `query_kernel`: A tensor representing the query transformation matrix.\n- `key_kernel`: A tensor representing the key transformation matrix.\n- `activation`: A callable activation function or None.\n- `key_bias`: A tensor representing the key bias vector.\n- `query_bias`: A tensor representing the query bias vector.\n\nOutput format:\n- The function returns a tensor representing the output after applying the attention mechanism.\n\n**Input:**\n```python\ninputs = (\n    np.array([[[0.1, 0.2], [0.3, 0.4]]], dtype=np.float32),  # queries\n    np.array([[[0.5, 0.6], [0.7, 0.8]]], dtype=np.float32),  # keys\n    np.array([[[0.9, 1.0], [1.1, 1.2]]], dtype=np.float32)   # values\n)\nuse_bias = True\nscaling = 1.0\nquery_kernel = np.array([[0.1, 0.2], [0.3, 0.4]], dtype=np.float32)\nkey_kernel = np.array([[0.5, 0.6], [0.7, 0.8]], dtype=np.float32)\nactivation = tf.nn.relu\nquery_bias = np.array([0.1, 0.2], dtype=np.float32)\nkey_bias = np.array([0.3, 0.4], dtype=np.float32)\n```\n\n**Output:**\n```python\noutput = np.array([[[1.0, 1.2]]], dtype=np.float32)\n# output\ntf.Tensor(\n[[[1.0062319 1.1062319]\n  [1.0088568 1.1088567]]], shape=(1, 2, 2), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, use_bias, scaling, query_kernel, key_kernel, activation, key_bias, query_bias):\n    K = tf.keras.backend\n    (queries, keys, values) = inputs\n    q = K.dot(K.constant(queries), K.constant(query_kernel))\n    k = K.dot(K.constant(keys), K.constant(key_kernel))\n\n    if use_bias:\n        q = K.bias_add(q, query_bias)\n        k = K.bias_add(k, key_bias)\n    if activation is not None:\n        q = activation(q)\n    weights = K.softmax(scaling * K.batch_dot(q, k, axes=[2, 2]))\n    output = K.batch_dot(weights, values)\n    return output", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len_q = np.random.randint(1, 20)\n        seq_len_k = np.random.randint(1, 20)\n        seq_len_v = seq_len_k\n        feature_dim = np.random.randint(4, 32)\n\n        queries = np.random.randn(batch_size, seq_len_q, feature_dim).astype(np.float32)\n        keys = np.random.randn(batch_size, seq_len_k, feature_dim).astype(np.float32)\n        values = np.random.randn(batch_size, seq_len_v, feature_dim).astype(np.float32)\n\n        query_kernel = np.random.randn(feature_dim, feature_dim).astype(np.float32)\n        key_kernel = np.random.randn(feature_dim, feature_dim).astype(np.float32)\n\n        use_bias = np.random.choice([True, False])\n        scaling = np.random.uniform(0.1, 2.0)\n\n        query_bias = np.random.randn(feature_dim).astype(np.float32) if use_bias else None\n        key_bias = np.random.randn(feature_dim).astype(np.float32) if use_bias else None\n\n        activation = tf.nn.relu if np.random.choice([True, False]) else None\n\n        inputs = (queries, keys, values)\n        test_case = (inputs, use_bias, scaling, query_kernel, key_kernel, activation, key_bias, query_bias)\n\n        test_cases.append(test_case)\n\n    return test_cases"}
{"problem_id": "keras_63", "library": "keras", "code_problem": "You are tasked with creating a neural network model using Keras for a reinforcement learning application. The model will take in a state representation and output a set of options, which can be used to make decisions in an environment. Your goal is to implement a function that builds this model with a specified architecture and compiles it with a mean squared error loss function and an Adam optimizer.\n\nFunction signature:\n```python\ndef build_model(state_size: int, learning_rate: float, option_size: int) -> Sequential:\n```\n\nConstant used in the main code:\n- The architecture of the neural network consists of three hidden layers with 300, 600, and 300 neurons respectively, all using the ReLU activation function.\n\nInput format:\n- `state_size`: An integer representing the size of the input state.\n- `learning_rate`: A float representing the learning rate for the optimizer.\n- `option_size`: An integer representing the number of output options.\n\nOutput format:\n- The function returns a Keras Sequential model that is ready for training.\n\n```python\nInput: (state_size=25, learning_rate=0.005, option_size=10)\nOutput: <keras.engine.sequential.Sequential object at 0x...>\n``` \n\n(Note: The output will be a Keras model object, and the memory address will vary each time the model is created.)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import Adam\n\n# main code\ndef build_model(state_size, learning_rate, option_size):\n    model = Sequential()\n    model.add(Dense(300, input_dim=state_size, activation='relu'))\n    model.add(Dense(600, activation='relu'))\n    model.add(Dense(300, activation='relu'))\n    model.add(Dense(option_size))\n    model.compile(loss='mse', optimizer=Adam(learning_rate=learning_rate))\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        state_size = np.random.randint(10, 100)\n        learning_rate = np.random.uniform(0.0001, 0.01)\n        option_size = np.random.randint(2, 50)\n\n        test_cases.append((state_size, learning_rate, option_size))\n\n    return test_cases"}
{"problem_id": "keras_64", "library": "keras", "code_problem": "You are tasked with implementing a function that loads and preprocesses datasets for natural language processing tasks using the Keras library. The function should be able to handle two different datasets: the IMDB movie reviews dataset and the Reuters newswire dataset. The function will also pad the sequences to a specified maximum length and prepare the data for use with PyTorch.\n\nFunction signature:\n```python\ndef load_data_set(dataset_type: bool, max_len: int, vocab_size: int) -> Tuple[data_utils.TensorDataset, np.ndarray, np.ndarray]:\n```\n\nConstant used in the main code:\n- `INDEX_FROM = 3`: This constant is used to specify the starting index for the word indices in the datasets.\n\nInput format:\n- `dataset_type`: A boolean value (True or False).\n- `max_len`: An integer representing the maximum length for padding sequences.\n- `vocab_size`: An integer representing the maximum number of words to consider.\n\nOutput format:\n- A tuple containing:\n  - A `TensorDataset` object for the training data.\n  - A NumPy array of padded test sequences.\n  - A NumPy array of test labels.\n\n```python\nInput: (0, 150, 10000)\nOutput: (train_data, x_test_pad, y_test)  # where train_data is a TensorDataset of padded training sequences and labels, x_test_pad is a padded test set, and y_test is the corresponding labels.\n```", "ground_truth_code": "from keras.datasets import imdb, reuters\nfrom keras.preprocessing.sequence import pad_sequences\nimport torch.utils.data as data_utils\nimport torch\n\n# main code\ndef load_data_set(dataset_type, max_len, vocab_size):\n    INDEX_FROM = 3\n    NUM_WORDS = vocab_size\n\n    if not dataset_type:\n        (x_train, y_train), (x_test, y_test) = imdb.load_data(num_words=NUM_WORDS, index_from=INDEX_FROM)\n    else:\n        (x_train, y_train), (x_test, y_test) = reuters.load_data(num_words=NUM_WORDS, index_from=INDEX_FROM)\n\n\n    x_train_pad = pad_sequences(x_train, maxlen=max_len)\n    x_test_pad = pad_sequences(x_test, maxlen=max_len)\n\n    train_data = data_utils.TensorDataset(\n        torch.from_numpy(x_train_pad).long(),\n        torch.from_numpy(y_train).long() if dataset_type else torch.from_numpy(y_train).double()\n    )\n\n    return train_data, x_test_pad, y_test", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dataset_type = random.choice([0, 1])\n        max_len = random.randint(50, 500)\n        vocab_size = random.randint(5000, 50000)\n\n\n        test_case = (dataset_type, max_len, vocab_size)\n        test_cases.append(test_case)\n\n    return test_cases\n"}
{"problem_id": "keras_65", "library": "keras", "code_problem": "You are tasked with creating a neural network model using Keras for a classification task. The model should be defined in a function that takes the input shape as an argument. The architecture of the model consists of several layers, including dense layers and dropout layers to prevent overfitting.\n\nFunction signature:\n```python\ndef define_model(shape):\n```\n\nConstant used in the main code:\n- The dropout rate is set to 0.5, which means that during training, 50% of the neurons in the dropout layers will be randomly set to zero to help prevent overfitting.\n\nInput format:\n- The function `define_model` takes a single integer input representing the number of features in the input data.\n\nOutput format:\n- The function returns a Keras Sequential model object that can be compiled and trained on a dataset.\n\nInput: (256)  \nOutput: <keras.engine.sequential.Sequential object at 0x...>", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import Dropout\n\n# main code\ndef define_model(shape):\n    model = Sequential()\n    model.add(Dense(1024, activation='relu', input_shape=(shape,)))\n    model.add(Dropout(0.5))\n    model.add(Dense(512, activation='relu'))\n    model.add(Dropout(0.5))\n    model.add(Dense(64, activation='relu'))\n    model.add(Dense(2, activation='softmax'))\n    return model", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = random.randint(10, 500)\n        test_cases.append((shape))\n    return test_cases\n"}
{"problem_id": "keras_66", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the Schroff triplet loss, which is commonly used in deep learning for tasks involving similarity learning, such as face recognition. The function should take in predictions from a neural network and compute the loss based on the differences between the predicted embeddings of anchor, positive, and negative samples.\n\nFunction signature:\n```python\ndef schroff_triplet_loss(y_pred, margin_value=0.2):\n```\n\nConstant used in the main code:\n- `margin_value`: This is a float constant that represents the margin by which the positive sample's distance should be less than the negative sample's distance. The default value is set to 0.2.\n\nInput format:\n- `y_pred`: A tensor of shape (batch_size, 2, 1) where each entry contains the predicted embeddings for the anchor, positive, and negative samples.\n\nOutput format:\n- A tensor representing the mean Schroff triplet loss across the batch.\n\n```python\nInput: (np.array([[[-0.5], [0.3]],[[0.7], [0.1]]], dtype=np.float32), 0.3)\nOutput: tf.Tensor(0.62, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef schroff_triplet_loss(y_pred, margin_value=0.2):\n    K = tf.keras.backend\n    margin = K.constant(margin_value)\n    zero = K.constant(0)\n    return K.mean(K.maximum(zero, K.square(y_pred[:, 0, 0]) - K.square(y_pred[:, 1, 0]) + margin))", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        y_pred = np.random.randn(np.random.randint(1, 10), 2, 1).astype(np.float32)\n        margin_value = np.random.uniform(0.1, 0.5)\n\n        test_cases.append((y_pred, margin_value))\n    return test_cases"}
{"problem_id": "keras_67", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the Determination Coefficient, commonly known as R-squared, which is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model.\n\nThe function signature is as follows:\n```python\ndef det_coeff(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K`: This is the Keras backend module, which provides various mathematical operations that can be used in the computation.\n\nInput format:\n- The function takes two inputs:\n  - `y_true`: A tensor representing the true values.\n  - `y_pred`: A tensor representing the predicted values.\n\nOutput format:\n- The function returns a tensor representing the R-squared value, which indicates the goodness of fit of the predictions.\n\n```python\n# Input\ny_true = K.variable(np.array([[1.0, 2.0], [3.0, 4.0]], dtype=np.float32))\ny_pred = K.variable(np.array([[1.5, 2.5], [2.5, 3.5]], dtype=np.float32))\n\n# Output\ndet_coeff(y_true, y_pred)  # tf.Tensor(0.8, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef det_coeff(y_true, y_pred):\n    K = tf.keras.backend\n    u = K.sum(K.square(y_true - y_pred))\n    v = K.sum(K.square(y_true - K.mean(y_true)))\n    return K.ones_like(v) - u / v", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 4)))\n        y_true = np.random.randn(*shape).astype(np.float32)\n        y_pred = np.random.randn(*shape).astype(np.float32)\n        y_true_tensor = K.variable(y_true)\n        y_pred_tensor = K.variable(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases\n"}
{"problem_id": "keras_68", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the Dice coefficient, a statistical measure used to gauge the similarity between two sets. This function is particularly useful in the field of image segmentation, where it helps to evaluate the performance of models by comparing the predicted segmentation with the ground truth.\n\nFunction signature:\n```python\ndef dice_coef(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K.epsilon()`: This is a small constant added to avoid division by zero during the calculation.\n\nInput format:\n- The function accepts two inputs:\n  - `y_true`: A tensor representing the ground truth segmentation mask.\n  - `y_pred`: A tensor representing the predicted segmentation mask.\n\nOutput format:\n- The function returns a single floating-point value representing the Dice coefficient between the two input masks.\n\n```python\n# Input\ny_true = np.array([[[1, 0], [0, 1]], [[0, 1], [1, 0]]]).astype(np.float32)\ny_pred = np.array([[[0.8, 0.2], [0.1, 0.9]], [[0.4, 0.6], [0.7, 0.3]]]).astype(np.float32)\n\n# Output\ndice_coefficient = dice_coef(y_true, y_pred)  # tf.Tensor(0.75, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef dice_coef(y_true, y_pred):\n    K = tf.keras.backend\n    y_true_f = K.flatten(y_true)\n    y_pred_f = K.flatten(y_pred)\n    intersection = K.sum(y_true_f * y_pred_f)\n    return (2.0 * intersection + K.epsilon()) / (K.sum(y_true_f) + K.sum(y_pred_f) + K.epsilon())\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(2, 10, size=np.random.randint(2, 4)))\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_69", "library": "keras", "code_problem": "You are required to implement a function that calculates the coefficient of determination, commonly known as R\u00b2, which is a statistical measure that represents the proportion of the variance for a dependent variable that's explained by an independent variable or variables in a regression model.\n\nFunction signature:\n```python\ndef coeff_determination(y_true, y_pred):\n```\n\nIn this function, the following constant is used:\n- `K.epsilon()`: This is a small constant added to the denominator to prevent division by zero.\n\nInput format:\n- The function accepts two parameters:\n  - `y_true`: A list or array of true values (ground truth).\n  - `y_pred`: A list or array of predicted values from a regression model.\n\nOutput format:\n- The function returns a single float value representing the coefficient of determination (R\u00b2).\n\n```python\n# Input\ny_true = np.array([[3.0, 2.5], [4.0, 5.0], [2.0, 1.5]], dtype=np.float32)\ny_pred = np.array([[2.5, 2.0], [4.5, 4.0], [1.5, 1.0]], dtype=np.float32)\n\n# Output\ncoeff_determination(y_true, y_pred)  # Output: tf.Tensor(0.7352941, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef coeff_determination(y_true, y_pred):\n    K = tf.keras.backend\n    y_true = K.constant(y_true)\n    y_pred = K.constant(y_pred)\n\n    ss_res = K.sum(K.square(y_true - y_pred))\n    ss_tot = K.sum(K.square(y_true - K.mean(y_true)))\n    return 1 - ss_res / (ss_tot + K.epsilon())", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        batch_size = np.random.randint(1, 100)\n        features = np.random.randint(1, 50)\n\n        y_true = np.random.rand(batch_size, features).astype(np.float32)\n        y_pred = np.random.rand(batch_size, features).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_70", "library": "keras", "code_problem": "You are tasked with implementing a function that processes a set of input tensors based on specified parameters and returns a modified tensor. The function will utilize Keras backend operations to perform mathematical computations on the input data.\n\nFunction signature:\n```python\ndef call(inputs, r, mode, sigma):\n```\n\nConstants used in the main code:\n- The constant `1.0` is used to initialize the output when the sign of `r_` is zero.\n- The constant `0.0` is used to create a tensor that represents a zeroed output when the sign of `r_` is zero.\n- The constant `2` is used in the denominator of the exponent in the Gaussian function.\n\nInput format:\n- `inputs`: A tensor of shape (N, ..., M) where N is the batch size and M is the last dimension size.\n- `r`: A list of real numbers that influence the computation.\n- `mode`: A string that determines how to combine the outputs ('average', 'concat', or other).\n- `sigma`: A positive real number used in the Gaussian function.\n\nOutput format:\n- The function returns a tensor that is the result of the computations based on the input parameters. If no valid output is generated, it returns `None`.\n\n```python\n# Input\ninputs = np.array([[0.5, -1.2, 0.3, 0.8, 1.5, -0.5],\n                   [1.0, 0.0, -0.3, 0.2, -1.0, 0.4]], dtype=np.float32)\nr = [2.0, -1.0]\nmode = 'average'\nsigma = 0.5\n\n# Output\noutput = tf.Tensor(\n[[2.6194914e-05]\n [4.2564949e-04]], shape=(2, 1), dtype=float32)\n```", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\n# main code\ndef call(inputs, r, mode, sigma):\n    K = tf.keras.backend\n    KL = tf.keras.layers\n    output_part = []\n    manifold_size = K.int_shape(inputs)[-1] // len(r)\n    inputs = K.constant(inputs)\n\n    for idx, r_ in enumerate(r):\n        start = idx * manifold_size\n        stop = start + manifold_size\n        part = inputs[..., start:stop]\n        sign = np.sign(r_)\n\n        if sign == 0.0:\n            output_pre = K.sum(inputs, -1, keepdims=True) * 0.0 + 1.0\n        else:\n            free_components = part[..., :-1] ** 2\n            bound_component = sign * part[..., -1:] ** 2\n            free_components = K.constant(free_components)\n            bound_component = K.constant(bound_component)\n\n            all_components = K.concatenate((free_components, bound_component), -1)\n            ext_product = K.sum(all_components, -1, keepdims=True)\n            output_pre = K.exp(-(ext_product - sign * r_ ** 2) ** 2 / (2 * sigma ** 2))\n\n        output_part.append(output_pre)\n\n    if len(output_part) >= 2:\n        if mode == 'average':\n            output = KL.Average()(output_part)\n        elif mode == 'concat':\n            output = KL.Concatenate()(output_part)\n        else:\n            output = output_part[0]\n    else:\n        output = output_part[0]\n\n    return output if output_part else None", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_partitions = np.random.randint(1, 5)\n        batch_size = np.random.randint(1, 10)\n        feature_size = np.random.randint(4, 20) * num_partitions\n        inputs = np.random.randn(batch_size, feature_size).astype(np.float32)\n        r = np.random.uniform(-5, 5, size=num_partitions).tolist()\n        mode = np.random.choice(['average', 'concat', 'single'])\n        sigma = np.random.uniform(0.1, 2.0)\n\n        test_cases.append((inputs, r, mode, sigma))\n\n    return test_cases"}
{"problem_id": "keras_71", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a neural network model using Keras. The model will take two types of inputs: observations and actions, and it will output a single value. The architecture of the model consists of several dense layers, and it merges the outputs of the observation and action pathways before producing the final output.\n\nFunction signature:\n```python\ndef build_baseline_model(action_dim, state_dim, hidden_units_1, hidden_units_2):\n```\n\nConstants used in the main code:\n- The output layer of the model uses a kernel initializer set to 'random_uniform'.\n\nInput format:\n- `action_dim`: An integer representing the number of action dimensions.\n- `state_dim`: An integer representing the number of state dimensions.\n- `hidden_units_1`: An integer representing the number of units in the first hidden layer.\n- `hidden_units_2`: An integer representing the number of units in the second hidden layer.\n\nOutput format:\n- The function returns a Keras Model object that can be used for training and inference.\n\n```python\nInput: (action_dim=4, state_dim=6, hidden_units_1=32, hidden_units_2=64)\nOutput: Model Summary: \n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n input_1 (InputLayer)        [(None, 6)]              0         \n input_2 (InputLayer)        [(None, 4)]              0         \n dense (Dense)               (None, 32)               224       \n dense_1 (Dense)             (None, 64)               2112      \n dense_2 (Dense)             (None, 64)               320       \n add (Add)                   (None, 64)               0         \n dense_3 (Dense)             (None, 64)               4160      \n dense_4 (Dense)             (None, 1)                65        \n=================================================================\nTotal params: 6,881\nTrainable params: 6,881\nNon-trainable params: 0\n_________________________________________________________________\n```", "ground_truth_code": "from keras.layers import Input, Dense, Add\nfrom keras.models import Model\n\n# main code\ndef build_baseline_model(action_dim, state_dim, hidden_units_1, hidden_units_2):\n    input_obs = Input(shape=(state_dim,))\n    input_actions = Input(shape=(action_dim,))\n    temp_obs = Dense(hidden_units_1, activation='relu')(input_obs)\n    obs_layer = Dense(hidden_units_2)(temp_obs)\n    actions_layer = Dense(hidden_units_2)(input_actions)\n    merged = Add()([obs_layer, actions_layer])\n    merged = Dense(hidden_units_2, activation='relu')(merged)\n    output_layer = Dense(1, kernel_initializer='random_uniform')(merged)\n    model = Model(inputs=[input_obs, input_actions], outputs=output_layer)\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        action_dim = np.random.randint(1, 11)\n        state_dim = np.random.randint(1, 11)\n        hidden_units_1 = np.random.randint(5, 101)\n        hidden_units_2 = np.random.randint(5, 101)\n        test_cases.append((action_dim, state_dim, hidden_units_1, hidden_units_2))\n    return test_cases"}
{"problem_id": "keras_72", "library": "keras", "code_problem": "You are tasked with implementing a function that computes a weighted sum of input vectors based on an attention mechanism. The function will take in a set of input vectors, a mask, and an optional context vector. The attention mechanism will allow the model to focus on specific parts of the input based on the context provided.\n\nFunction signature:\n```python\ndef call(x, mask, context=None):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `K`, which refers to the Keras backend module.\n\nInput format:\n- `x`: A tensor representing the input vectors.\n- `mask`: A tensor representing the mask to be applied to the attention weights (can be None).\n- `context`: An optional tensor representing the context vector.\n\nOutput format:\n- The function returns a tensor representing the weighted sum of the input vectors based on the computed attention weights.\n\nInput:\n```python\nx = np.array([[[ 0.1, -0.2,  0.3],\n                [ 0.4,  0.5, -0.6],\n                [ 0.7, -0.8,  0.9]]], dtype=np.float32)  # shape (1, 3, 3)\n\nmask = np.array([[1, 0, 1]], dtype=np.float32)  # shape (1, 3)\n\ncontext = np.array([[0.1],\n                    [0.2],\n                    [0.3]], dtype=np.float32)  # shape (3, 1)\n```\n\nOutput:\n```python\nweighted_sum = np.array([[0.5, -0.5, 0.5]])  # shape (1, 3)\n``` \n", "ground_truth_code": "import tensorflow as tf\n\n\n# main code\ndef call(x, mask, context=None):\n    K = tf.keras.backend\n    x = K.constant(x)\n    context = K.constant(context)\n\n    attention_in = K.exp(K.squeeze(K.dot(x, context), axis=-1))\n    attention = attention_in / K.expand_dims(K.sum(attention_in, axis=-1), -1)\n\n    if mask is not None:\n        mask = K.constant(mask)\n        attention = attention * K.cast(mask, 'float32')\n\n    weighted_sum = K.batch_dot(K.permute_dimensions(x, [0, 2, 1]), attention)\n    return weighted_sum\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len = np.random.randint(5, 50)\n        feature_dim = np.random.randint(10, 100)\n        x = np.random.randn(batch_size, seq_len, feature_dim).astype(np.float32)\n        context = np.random.randn(feature_dim, 1).astype(np.float32)\n        mask = None if np.random.rand() < 0.5 else np.random.randint(0, 2, (batch_size, seq_len)).astype(np.float32)\n\n        test_cases.append((x, mask, context))\n\n    return test_cases\n"}
{"problem_id": "keras_73", "library": "keras", "code_problem": "Code problem description:\n\n```python\ndef calculate_md_loss(y_true, y_pred, hps):\n```\n\nIn this code, the function `calculate_md_loss` computes a loss value based on a mixture density network (MDN) approach. The function takes three parameters: `y_true`, `y_pred`, and `hps`. The `hps` parameter is a dictionary that contains hyperparameters, including a constant `num_mixture`, which specifies the number of mixture components to be used in the model.\n\n### Input and Output Format:\n- **Input**:\n  - `y_true`: A tensor containing the true values, structured as a 3D tensor with shape `(batch_size, sequence_length, features)`.\n  - `y_pred`: A tensor containing the predicted values from the model, structured similarly to `y_true`.\n  - `hps`: A dictionary containing hyperparameters, including `num_mixture`.\n\n- **Output**:\n  - A scalar tensor representing the mean loss value computed from the GMM and penalty losses.\n\n\nInput:\n```python\ny_true = np.array([[[ 0.5, -0.2, 0.1, 0.3, 0.6],\n                    [ 0.1,  0.4, 0.2, 0.3, 0.5],\n                    [ 0.3, -0.1, 0.4, 0.2, 0.4]]], dtype=np.float32)\n\ny_pred = np.array([[[-0.1, 0.2, 0.5, 0.1, -0.3, 0.4, 0.2, 0.3, -0.1, 0.1, 0.2, 0.3, 0.4, -0.2, 0.1, 0.5, 0.2, 0.1],\n                    [ 0.3, -0.4, 0.1, 0.2, 0.5, 0.1, 0.3, -0.1, 0.2, 0.4, 0.1, 0.3, 0.2, 0.1, -0.3, 0.5, 0.2, 0.1],\n                    [ 0.2, 0.1, -0.2, 0.3, 0.4, 0.1, 0.2, 0.3, -0.1, 0.1, 0.2, 0.4, 0.5, 0.1, 0.3, -0.2, 0.2, 0.1]]], dtype=np.float32)\n\nhps = {'num_mixture': 2}\n```\n\nOutput:\n```python\nloss_value = calculate_md_loss(y_true, y_pred, hps)\n# tf.Tensor(1.7328664, shape=(), dtype=float32)\n```", "ground_truth_code": "import numpy as np\nimport tensorflow as tf\n\ndef get_mixture_coef(out_tensor, hps):\n    z_pen_logits = out_tensor[:, :, :3]\n    M = hps.get('num_mixture', 1)\n    dist_params = [out_tensor[:, :, 3 + M * (n - 1):3 + M * n] for n in range(1, 7)]\n\n    z_pi, z_mu1, z_mu2, z_sigma1, z_sigma2, z_corr = dist_params\n    z_pi = tf.nn.softmax(z_pi, axis=-1)\n    z_pen = tf.nn.softmax(z_pen_logits, axis=-1)\n    z_sigma1 = tf.exp(z_sigma1)\n    z_sigma2 = tf.exp(z_sigma2)\n    z_corr = tf.tanh(z_corr)\n\n    return [z_pi, z_mu1, z_mu2, z_sigma1, z_sigma2, z_corr, z_pen, z_pen_logits]\n\ndef keras_2d_normal(x1, x2, mu1, mu2, s1, s2, rho):\n    M = tf.shape(mu1)[2]\n    norm1 = tf.tile(tf.expand_dims(x1, axis=-1), [1, 1, M]) - mu1\n    norm2 = tf.tile(tf.expand_dims(x2, axis=-1), [1, 1, M]) - mu2\n    s1s2 = s1 * s2\n    z = tf.square(norm1 / s1) + tf.square(norm2 / s2) - 2.0 * (rho * norm1 * norm2) / s1s2\n    neg_rho = 1.0 - tf.square(rho)\n    result = tf.exp(-z / (2 * neg_rho))\n    denom = 2 * np.pi * s1s2 * tf.sqrt(neg_rho)\n\n    return result / denom\n\n# main code\ndef calculate_md_loss(y_true, y_pred, hps):\n    out = get_mixture_coef(y_pred, hps)\n    o_pi, o_mu1, o_mu2, o_sigma1, o_sigma2, o_corr, o_pen, _ = out\n\n    x1_data, x2_data = y_true[:, :, 0], y_true[:, :, 1]\n    pen_data = y_true[:, :, 2:5]\n\n    pdf_values = keras_2d_normal(x1_data, x2_data, o_mu1, o_mu2, o_sigma1, o_sigma2, o_corr)\n    gmm_values = tf.reduce_sum(pdf_values * o_pi, axis=2, keepdims=True)\n\n    epsilon = tf.keras.backend.epsilon()\n    gmm_loss = -tf.math.log(gmm_values + epsilon)\n\n    fs = tf.expand_dims(1.0 - pen_data[:, :, 2], axis=-1)\n    gmm_loss *= fs\n\n    pen_loss = tf.expand_dims(tf.keras.losses.categorical_crossentropy(pen_data, o_pen), axis=-1)\n\n    pen_loss *= fs\n\n    return tf.reduce_mean(gmm_loss + pen_loss)", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len = np.random.randint(5, 20)\n        num_mixture = np.random.randint(1, 5)\n\n        hps = {'num_mixture': num_mixture}\n\n        y_true = np.random.randn(batch_size, seq_len, 5).astype(np.float32)\n        y_true[:, :, 2:5] = tf.nn.softmax(y_true[:, :, 2:5], axis=-1).numpy()\n\n        output_dim = 3 + num_mixture * 6\n        y_pred = np.random.randn(batch_size, seq_len, output_dim).astype(np.float32)\n\n        test_cases.append((y_true, y_pred, hps))\n\n    return test_cases"}
{"problem_id": "keras_74", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the recall metric for a binary classification problem using Keras backend operations. The function will take two inputs: the true labels and the predicted labels, both represented as tensors. The recall metric is a measure of the ability of a classifier to find all the positive samples.\n\nFunction signature:\n```python\ndef recall(y_true, y_pred):\n```\n\nIn the main code, the following constant is used:\n- `K.epsilon()`: This is a small constant added to the denominator to prevent division by zero.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted binary labels (0 or 1).\n\nOutput format:\n- The function returns a scalar tensor representing the recall value, which is a float between 0 and 1.\n\n```python\n# Input\ny_true = np.array([[1., 0., 1.], [0., 1., 0.]], dtype=np.float32)\ny_pred = np.array([[0.9, 0.1, 0.8], [0.2, 0.7, 0.1]], dtype=np.float32)\n\n# Output\nrecall_value = recall(y_true, y_pred)  # tf.Tensor(1.0, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef recall(y_true, y_pred):\n    K = tf.keras.backend\n    true_positives = K.sum(K.round(K.clip(y_true * y_pred, 0, 1)))\n    possible_positives = K.sum(K.round(K.clip(y_true, 0, 1)))\n    recall = true_positives / (possible_positives + K.epsilon())\n    return recall", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    shape_options = [(32, 10), (64, 5), (128, 20), (256, 1)]\n\n    for _ in range(n):\n        shape = shape_options[np.random.choice(len(shape_options))]\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_75", "library": "keras", "code_problem": "You are tasked with implementing a deep learning model using Keras that incorporates various attention mechanisms and convolutional layers. The model should be designed to process input data of a specified shape and classify it into a given number of classes. \n\nThe main function signature for your implementation is as follows:\n\n```python\ndef build_model(reg, inp_shape, num_classes):\n```\n\n### Constants:\n- `reg`: This parameter represents the regularization technique to be applied to the convolutional layers in the model. It is passed to the convolutional layers to prevent overfitting.\n\n### Input and Output Format:\n- **Input**: The function takes three parameters:\n  - `reg`: The regularization method to be applied to the convolutional layers.\n  - `inp_shape`: A tuple representing the shape of the input data.\n  - `num_classes`: An integer representing the number of output classes for classification.\n\n- **Output**: The function returns a Keras model object that can be compiled and trained on the specified input data.\n\nInput:\n```python\nreg = regularizers.l2(0.01)\ninp_shape = (64, 64, 3)\nnum_classes = 10\n```\n\nOutput:\n```python\nModel Summary:\n_________________________________________________________________\n Layer (type)                Output Shape              Param #\n=================================================================\n input_1 (InputLayer)        [(None, 64, 64, 3)]      0\n_________________________________________________________________\n conv2d (Conv2D)             (None, 32, 32, 120)      3240\n_________________________________________________________________\n batch_normalization (BatchN  (None, 32, 32, 120)      480\n ormalization)                                                  \n_________________________________________________________________\n max_pooling2d (MaxPooling2D  (None, 16, 16, 120)     0\n )                                                              \n_________________________________________________________________\n conv2d_1 (Conv2D)           (None, 16, 16, 256)      307200\n_________________________________________________________________\n max_pooling2d_1 (MaxPooling  (None, 8, 8, 256)       0\n 2D)                                                           \n_________________________________________________________________\n conv2d_2 (Conv2D)           (None, 8, 8, 384)        884736\n_________________________________________________________________\n batch_normalization_1 (Batc  (None, 8, 8, 384)       1536\n hNormalization)                                              \n_________________________________________________________________\n time_attention (Conv2D)     (None, 8, 8, 64)         17216\n_________________________________________________________________\n frequency_attention (Conv2D) (None, 8, 8, 64)         17216\n_________________________________________________________________\n concatenate (Concatenate)    (None, 8, 8, 128)        0\n_________________________________________________________________\n batch_normalization_2 (Batc  (None, 8, 8, 128)       512\n hNormalization)                                              \n_________________________________________________________________\n conv2d_3 (Conv2D)           (None, 4, 4, 120)        138240\n_________________________________________________________________\n batch_normalization_3 (Batc  (None, 4, 4, 120)       480\n hNormalization)                                              \n_________________________________________________________________\n flatten (Flatten)           (None, 1920)             0\n_________________________________________________________________\n dense (Dense)               (None, 80)               153680\n_________________________________________________________________\n batch_normalization_4 (Batc  (None, 80)              320\n hNormalization)                                              \n_________________________________________________________________\n dense_1 (Dense)             (None, 10)               810\n=================================================================\nTotal params: 1,487,000\nTrainable params: 1,485,000\nNon-trainable params: 2,000\n_________________________________________________________________\n```", "ground_truth_code": "from tensorflow import keras\nfrom keras import layers\n\ndef time_attention(inp, reg):\n    x = layers.Conv2D(filters=64, kernel_size=(1, 9), activation='relu', kernel_regularizer=reg, padding='same')(inp)\n    x = layers.Conv2D(filters=64, kernel_size=(1, 3), activation='relu', kernel_regularizer=reg, padding='same')(x)\n    x = layers.Conv2D(filters=64, kernel_size=(1, 3), activation='relu', kernel_regularizer=reg, padding='same')(x)\n    x = layers.BatchNormalization()(x)\n    return x\n\ndef frequency_attention(inp, reg):\n    x = layers.Conv2D(filters=64, kernel_size=(9, 1), activation='relu', kernel_regularizer=reg, padding='same')(inp)\n    x = layers.Conv2D(filters=64, kernel_size=(3, 1), activation='relu', kernel_regularizer=reg, padding='same')(x)\n    x = layers.Conv2D(filters=64, kernel_size=(3, 1), activation='relu', kernel_regularizer=reg, padding='same')(x)\n    x = layers.BatchNormalization()(x)\n    return x\n\n\ndef FLB(inp, reg):\n    x = layers.Conv2D(filters=120, kernel_size=(9, 9), strides=(2, 2), activation='relu', kernel_regularizer=reg,\n                      padding='same')(inp)\n    x = layers.BatchNormalization()(x)\n\n    shape = keras.backend.int_shape(x)\n    if shape[1] >= 4 and shape[2] >= 4:\n        x = layers.MaxPooling2D(pool_size=(2, 2), strides=(2, 2), padding='same')(x)\n\n    x = layers.Conv2D(filters=256, kernel_size=(5, 5), strides=(1, 1), activation='relu', kernel_regularizer=reg,\n                      padding='same')(x)\n\n    shape = keras.backend.int_shape(x)\n    if shape[1] >= 4 and shape[2] >= 4:\n        x = layers.MaxPooling2D(pool_size=(2, 2), padding='same')(x)\n\n    x = layers.Conv2D(filters=384, kernel_size=(3, 3), activation='relu', kernel_regularizer=reg, padding='same')(x)\n    x = layers.BatchNormalization()(x)\n    return x\n\n\ndef MAM(inp, reg):\n    ta = time_attention(inp, reg)\n    fa = frequency_attention(inp, reg)\n    mam = layers.concatenate([ta, fa])\n    mam = layers.BatchNormalization()(mam)\n    return mam\n\n# main code\ndef build_model(reg, inp_shape, num_classes):\n    inp = keras.Input(shape=inp_shape)\n    x = FLB(inp, reg)\n    mam = MAM(x, reg)\n    x = layers.concatenate([x, mam])\n    x = FLB(x, reg)\n    x = layers.Flatten()(x)\n    x = layers.Dense(80, activation='relu', kernel_regularizer=reg)(x)\n    x = layers.BatchNormalization()(x)\n    out = layers.Dense(units=num_classes, activation='softmax')(x)\n    model = keras.Model(inp, out)\n    return model", "test_script": "import numpy as np\nfrom keras import regularizers\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        height = np.random.choice([32, 64, 128, 256])\n        width = np.random.choice([32, 64, 128, 256])\n        channels = np.random.choice([1, 3])\n\n        inp_shape = (height, width, channels)\n        num_classes = np.random.randint(2, 20)\n        reg = regularizers.l2(0.01)\n\n        test_cases.append((reg, inp_shape, num_classes))\n\n    return test_cases"}
{"problem_id": "keras_76", "library": "keras", "code_problem": "You are tasked with implementing a function that performs a specific type of convolution operation on a given input tensor. The function will apply a convolutional layer with optional bias addition and an activation function. The function signature is as follows:\n\n```python\ndef call(x, output_dim, use_bias, window_size, bias, strides, kernel, activation):\n```\n\n### Constants:\n- The constant used in the main code is `1`, which is used in the calculation of the padding for the temporal convolution.\n\n### Input and Output Format:\n- **Input Format**: The function takes in a tensor `x` and several parameters as described above.\n- **Output Format**: The function returns a tensor that is the result of the convolution operation, potentially modified by the bias and activation function.\n\nInput:\n```python\nx = np.array([[[ 0.5, -1.2, 0.3, 0.8]], [[ 0.1, 0.4, -0.5, 1.0]], [[-0.3, 0.2, 0.6, -0.1]], [[ 0.7, -0.8, 0.9, 0.0]], [[ 0.2, 0.3, -0.4, 0.5]]], dtype=np.float32)\noutput_dim = 2\nuse_bias = True\nwindow_size = 1\nstrides = 1\nkernel = np.array([[[[ 2.1895998 , -1.4132164 , -0.41680187, -0.382865  ],\n         [-1.9383316 , -1.142143  , -1.7882994 ,  0.06822109]]]],\n      dtype=float32)\nbias = np.array([ 0.5125117 ,  0.45785695, -0.12295889, -0.89581746], dtype=float32)\nactivation = sigmoid\n```\n\nOutput:\n```python\ntf.Tensor([[[0.33942965 0.20289631]]], shape=(1, 1, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(x, output_dim, use_bias, window_size, bias, strides, kernel, activation):\n    K = tf.keras.backend\n    if window_size > 1:\n        x = K.temporal_padding(x, (window_size - 1, 0))\n\n    x = K.expand_dims(x, axis=2)\n    output = K.conv2d(x, kernel, strides=strides, padding='valid', data_format='channels_last')\n    output = K.squeeze(output, axis=2)\n\n    if use_bias and bias is not None:\n        output = K.bias_add(output, bias, data_format='channels_last')\n\n    z, g = output[:, :, :output_dim], output[:, :, output_dim:]\n\n    return activation(z) * K.sigmoid(g) if activation else z", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    KA = tf.keras.activations\n    test_cases = []\n\n    for _ in range(n):\n        time_steps = np.random.randint(5, 20)\n        input_dim = np.random.randint(4, 16)\n        output_dim = np.random.randint(2, max(3, input_dim // 2))\n        use_bias = np.random.choice([True, False])\n        window_size = np.random.randint(1, 5)\n        strides = np.random.randint(1, 3)\n        x = np.random.randn(1, time_steps, input_dim).astype(np.float32)\n        kernel = np.random.randn(window_size, 1, input_dim, output_dim * 2).astype(np.float32)\n        bias = np.random.randn(output_dim * 2).astype(np.float32) if use_bias else None\n        activation = np.random.choice([KA.relu, KA.sigmoid, KA.tanh, KA.linear, None])\n        test_cases.append((x, output_dim, use_bias, window_size, bias, strides, kernel, activation))\n\n    return test_cases"}
{"problem_id": "keras_77", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the coefficient of determination, commonly known as R\u00b2, which is a statistical measure that represents the proportion of variance for a dependent variable that's explained by an independent variable or variables in a regression model. The function should be able to handle tensor inputs, as it will be used in a machine learning context with Keras.\n\nFunction signature:\n```python\ndef coeff_determination_metric(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `K.epsilon()`: This constant is used to prevent division by zero in the calculation of the R\u00b2 metric.\n\nInput format:\n- The function accepts two inputs: `y_true` and `y_pred`, both of which are tensors representing the true and predicted values, respectively.\n\nOutput format:\n- The function returns a single tensor value representing the coefficient of determination (R\u00b2).\n\n```python\n# Input\ny_true = tf.convert_to_tensor([[1.0, 2.0], [3.0, 4.0]], dtype=tf.float32)\ny_pred = tf.convert_to_tensor([[1.5, 2.5], [2.5, 3.5]], dtype=tf.float32)\n\n# Output\noutput = coeff_determination_metric(y_true, y_pred)  # tf.Tensor(0.8, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef coeff_determination_metric(y_true, y_pred):\n    K = tf.keras.backend\n    SS_res = K.sum(K.square(y_true - y_pred))\n    SS_tot = K.sum(K.square(y_true - K.mean(y_true)))\n    return 1 - SS_res / (SS_tot + K.epsilon())", "test_script": "import numpy as np\nimport tensorflow as tf\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 4)))\n        y_true = tf.convert_to_tensor(np.random.rand(*shape), dtype=tf.float32)\n        y_pred = tf.convert_to_tensor(np.random.rand(*shape), dtype=tf.float32)\n\n        test_cases.append((y_true, y_pred))\n    return test_cases"}
{"problem_id": "keras_78", "library": "keras", "code_problem": "You are tasked with implementing a function that processes a multi-dimensional input tensor using a series of operations, including mean reduction, matrix multiplication, bias addition, activation functions, and dimensional expansion. The function should be able to handle different data formats for the input tensor.\n\nFunction signature:\n```python\ndef call(inputs, data_format, bias1, bias2, kernel2, kernel1, use_bias):\n```\n\nConstants used in the main code:\n- There are no explicit constants defined in the code; however, the dimensions used in the mean reduction and the expansion of dimensions are implicitly constant based on the expected shape of the input tensor.\n\nInput format:\n- `inputs`: A multi-dimensional tensor (e.g., a 4D tensor for images).\n- `data_format`: A string ('channels_first' or 'channels_last').\n- `bias1`: A tensor for the first bias addition.\n- `bias2`: A tensor for the second bias addition.\n- `kernel1`: A weight matrix for the first linear transformation.\n- `kernel2`: A weight matrix for the second linear transformation.\n- `use_bias`: A boolean indicating whether to use bias in the calculations.\n\nOutput format:\n- The function returns a tensor that is the result of the element-wise multiplication of the original `inputs` tensor and the processed tensor `ex`.\n\n**Input:**\n```python\ninputs = tf.convert_to_tensor([[[[ 0.1, -0.2, 0.3],\n                                  [ 0.4, -0.5, 0.6]],\n                                 [[ 0.7, -0.8, 0.9],\n                                  [ 1.0, -1.1, 1.2]]]], dtype=tf.float32)  # Shape: (1, 2, 2, 3)\n\ndata_format = 'channels_last'\nbias1 = tf.convert_to_tensor([0.1, 0.2], dtype=tf.float32)  # Shape: (2,) \u2190 matches ex after first dot\nbias2 = tf.convert_to_tensor([0.1, 0.2, 0.3], dtype=tf.float32)  # Shape: (3,) \u2190 matches final ex\n\nkernel1 = tf.convert_to_tensor([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]], dtype=tf.float32)  # Shape: (3, 2)\nkernel2 = tf.convert_to_tensor([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6]], dtype=tf.float32)  # Shape: (2, 3)\nuse_bias = True\n```\n\n**Output:**\n```python\noutput = tf.Tensor([[[[ 0.05826108 -0.1252892   0.2004896 ]\n                     [ 0.23304431 -0.313223    0.4009792 ]]\n                    [[ 0.40782756 -0.5011568   0.60146874]\n                     [ 0.5826108  -0.6890906   0.8019584 ]]]], shape=(1, 2, 2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, data_format, bias1, bias2, kernel2, kernel1, use_bias):\n    K = tf.keras.backend\n    if data_format == 'channels_first':\n        sq = K.mean(inputs, [2, 3])\n    else:\n        sq = K.mean(inputs, [1, 2])\n    ex = K.dot(sq, kernel1)\n    if use_bias:\n        ex = K.bias_add(ex, bias1)\n    ex = K.relu(ex)\n    ex = K.dot(ex, kernel2)\n    if use_bias:\n        ex = K.bias_add(ex, bias2)\n    ex = K.sigmoid(ex)\n    if data_format == 'channels_first':\n        ex = K.expand_dims(ex, -1)\n        ex = K.expand_dims(ex, -1)\n    else:\n        ex = K.expand_dims(ex, 1)\n        ex = K.expand_dims(ex, 1)\n    return inputs * ex", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_format = np.random.choice(['channels_first', 'channels_last'])\n        batch_size = np.random.randint(1, 10)\n        channels = np.random.randint(1, 20)\n        height = np.random.randint(5, 50)\n        width = np.random.randint(5, 50)\n\n        if data_format == 'channels_first':\n            input_shape = (batch_size, channels, height, width)\n        else:\n            input_shape = (batch_size, height, width, channels)\n\n        inputs = tf.convert_to_tensor(np.random.randn(*input_shape), dtype=tf.float32)\n        kernel1_shape = (channels, np.random.randint(1, 10))\n        kernel2_shape = (kernel1_shape[1], channels)\n        kernel1 = tf.convert_to_tensor(np.random.randn(*kernel1_shape), dtype=tf.float32)\n        kernel2 = tf.convert_to_tensor(np.random.randn(*kernel2_shape), dtype=tf.float32)\n        use_bias = np.random.choice([True, False])\n        bias1 = tf.convert_to_tensor(np.random.randn(kernel1_shape[1]), dtype=tf.float32) if use_bias else None\n        bias2 = tf.convert_to_tensor(np.random.randn(channels), dtype=tf.float32) if use_bias else None\n\n        test_cases.append((inputs, data_format, bias1, bias2, kernel2, kernel1, use_bias))\n\n    return test_cases\n"}
{"problem_id": "keras_79", "library": "keras", "code_problem": "You are tasked with creating a convolutional neural network (CNN) model for binary classification tasks using Keras. The model should be designed to process input images with a specific shape and should include several convolutional layers, pooling layers, dropout layers, and fully connected layers. The model should be compiled with a binary cross-entropy loss function and an Adam optimizer.\n\nFunction Signature:\n```python\ndef get_model(input_shape=(75, 75, 8), drop_prob=0.5, learning_rate=0.001):\n```\n\nConstants used in the main code:\n- `input_shape`: A tuple representing the shape of the input images, defaulting to (75, 75, 8).\n- `drop_prob`: A float representing the dropout probability, defaulting to 0.5.\n- `learning_rate`: A float representing the learning rate for the optimizer, defaulting to 0.001.\n\nInput Format:\n- The function accepts three parameters:\n  - `input_shape`: A tuple representing the shape of the input images.\n  - `drop_prob`: A float representing the dropout probability.\n  - `learning_rate`: A float representing the learning rate for the optimizer.\n\nOutput Format:\n- The function returns a compiled Keras Sequential model ready for training on binary classification tasks.\n\n```python\nInput: ((75, 75, 8), 0.5, 0.001)\nOutput: <keras.engine.sequential.Sequential object at 0x...>\n``` \n\n(Note: The output will be a Keras model object, and the memory address will vary each time the model is created.)", "ground_truth_code": "from keras.models import Sequential\nfrom keras.optimizers import Adam\nfrom keras.layers import Conv2D, MaxPooling2D, Dropout, Flatten, Dense\n\n# main code\ndef get_model(input_shape=(75, 75, 8), drop_prob=0.5, learning_rate=0.001):\n    model = Sequential([\n        Conv2D(64, kernel_size=(3, 3), activation='relu', input_shape=input_shape),\n        MaxPooling2D(pool_size=(3, 3), strides=(2, 2)),\n        Dropout(drop_prob),\n\n        Conv2D(128, kernel_size=(3, 3), activation='relu'),\n        MaxPooling2D(pool_size=(2, 2), strides=(2, 2)),\n        Dropout(drop_prob),\n\n        Conv2D(128, kernel_size=(3, 3), activation='relu'),\n        MaxPooling2D(pool_size=(2, 2), strides=(2, 2)),\n        Dropout(drop_prob),\n\n        Conv2D(64, kernel_size=(3, 3), activation='relu'),\n        MaxPooling2D(pool_size=(2, 2), strides=(2, 2)),\n        Dropout(drop_prob),\n\n        Flatten(),\n        Dense(512, activation='relu'),\n        Dropout(drop_prob),\n        Dense(256, activation='relu'),\n        Dropout(drop_prob),\n        Dense(1, activation='sigmoid')\n    ])\n\n    optimizer = Adam(learning_rate=learning_rate)\n    model.compile(loss='binary_crossentropy', optimizer=optimizer, metrics=['accuracy'])\n\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.randint(60, 100)\n        width = np.random.randint(60, 100)\n        input_shape = (height, width, 8)\n        drop_prob = np.random.uniform(0.0, 0.7)\n        learning_rate = np.random.uniform(1e-5, 1e-2)\n\n        test_cases.append((input_shape, drop_prob, learning_rate))\n\n    return test_cases"}
{"problem_id": "keras_80", "library": "keras", "code_problem": "You are tasked with implementing a function that prepares input data for various types of models used in natural language processing. The function should handle different configurations based on the model type specified in the configuration object. The function will pad sequences of text and aspect terms to ensure they are of uniform length, which is essential for feeding into machine learning models.\n\nFunction signature:\n```python\ndef prepare_input(input_data, left_max_len, asp_max_len, max_len, config, right_max_len):\n```\n\nConstants used in the main code:\n- `padding='post'`: This constant is used in the `pad_sequences` function to specify that padding should be added after the sequences.\n\nInput format:\n- `input_data`: A tuple or list containing the sequences to be padded, which varies based on the model type.\n- `left_max_len`: An integer specifying the maximum length for left text sequences.\n- `asp_max_len`: An integer specifying the maximum length for aspect sequences.\n- `max_len`: An integer specifying the maximum length for general text sequences.\n- `config`: An object containing configuration settings, including the model name and possibly other attributes.\n- `right_max_len`: An integer specifying the maximum length for right text sequences.\n\nOutput format:\n- The function returns a list of padded sequences, where each element corresponds to the padded input for the model, or an empty list if no valid model type was matched.\n\n**Input:**\n```python\ninput_data = (\n    [[12, 34, 56, 78, 90]],  # text_l\n    [[23, 45, 67, 89, 12]],  # text_r\n)\nleft_max_len = 25\nasp_max_len = 10\nmax_len = 50\nconfig = Config(model_name='td_lstm', is_aspect_term=False)\nright_max_len = 25\n```\n\n**Output:**\n```python\n[\n   array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n         0,  0,  0,  0, 12, 34, 56, 78, 90]], dtype=int32), \n   array([[ 0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,  0,\n         0,  0,  0,  0, 23, 45, 67, 89, 12]], dtype=int32)\n]\n```\n", "ground_truth_code": "from keras.preprocessing.sequence import pad_sequences\nimport numpy as np\n\n# main code\ndef prepare_input(input_data, left_max_len, asp_max_len, max_len, config, right_max_len):\n    model_type = config.model_name\n    is_aspect_term = getattr(config, 'is_aspect_term', False)\n\n    input_pad = None\n\n    if model_type == 'td_lstm':\n        text_l, text_r = input_data\n        input_pad = [pad_sequences(text_l, left_max_len), pad_sequences(text_r, right_max_len)]\n    elif model_type == 'tc_lstm':\n        text_l, text_r, aspect = input_data\n        input_pad = [pad_sequences(text_l, left_max_len), pad_sequences(text_r, right_max_len), np.array(aspect)]\n    elif model_type in ['at_lstm', 'ae_lstm', 'atae_lstm'] or (model_type in ['memnet', 'ram'] and not is_aspect_term):\n        text, aspect = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect)]\n    elif model_type == 'memnet' and is_aspect_term:\n        text, aspect, loc = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect), pad_sequences(loc, max_len)]\n    elif model_type == 'ram' and is_aspect_term:\n        text, aspect, loc, offset = input_data\n        input_pad = [pad_sequences(text, max_len), np.array(aspect), pad_sequences(loc, max_len),\n                     pad_sequences(offset, max_len)]\n    elif model_type == 'ian':\n        text, aspect_text = input_data\n        input_pad = [pad_sequences(text, max_len), pad_sequences(aspect_text, asp_max_len)]\n    elif model_type == 'cabasc':\n        text, text_l, text_r, aspect, mask = input_data\n        input_pad = [\n            pad_sequences(text, max_len, padding='post', truncating='post'),\n            pad_sequences(text_l, max_len, padding='post', truncating='post'),\n            pad_sequences(text_r, max_len, padding='post', truncating='post'),\n            np.array(aspect),\n            pad_sequences(mask, max_len, padding='post', truncating='post')\n        ]\n\n    return input_pad if input_pad is not None else []", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    class Config:\n        def __init__(self, model_name, is_aspect_term=False):\n            self.model_name = model_name\n            self.is_aspect_term = is_aspect_term\n\n    test_cases = []\n    model_types = ['td_lstm', 'tc_lstm', 'at_lstm', 'ae_lstm', 'atae_lstm', 'memnet', 'ram', 'ian', 'cabasc']\n    max_len = 50\n    left_max_len = 25\n    right_max_len = 25\n    asp_max_len = 10\n\n    for _ in range(n):\n        model_type = random.choice(model_types)\n        is_aspect_term = random.choice([True, False])\n        config = Config(model_type, is_aspect_term)\n\n        text = [np.random.randint(1, 100, size=(random.randint(5, max_len),)).tolist()]\n        text_l = [np.random.randint(1, 100, size=(random.randint(5, left_max_len),)).tolist()]\n        text_r = [np.random.randint(1, 100, size=(random.randint(5, right_max_len),)).tolist()]\n        aspect = [np.random.randint(1, 100, size=(random.randint(1, asp_max_len),)).tolist()]\n        aspect_text = [np.random.randint(1, 100, size=(random.randint(1, asp_max_len),)).tolist()]\n        loc = [np.random.randint(1, 100, size=(random.randint(1, max_len),)).tolist()]\n        offset = [np.random.randint(1, 100, size=(random.randint(1, max_len),)).tolist()]\n        mask = [np.random.randint(0, 2, size=(random.randint(1, max_len),)).tolist()]\n\n        if model_type == 'td_lstm':\n            input_data = (text_l, text_r)\n        elif model_type == 'tc_lstm':\n            input_data = (text_l, text_r, aspect)\n        elif model_type in ['at_lstm', 'ae_lstm', 'atae_lstm'] or (\n                model_type in ['memnet', 'ram'] and not is_aspect_term):\n            input_data = (text, aspect)\n        elif model_type == 'memnet' and is_aspect_term:\n            input_data = (text, aspect, loc)\n        elif model_type == 'ram' and is_aspect_term:\n            input_data = (text, aspect, loc, offset)\n        elif model_type == 'ian':\n            input_data = (text, aspect_text)\n        elif model_type == 'cabasc':\n            input_data = (text, text_l, text_r, aspect, mask)\n        else:\n            continue\n\n        test_cases.append((input_data, left_max_len, asp_max_len, max_len, config, right_max_len))\n\n    return test_cases"}
{"problem_id": "keras_81", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the Jaccard coefficient, a statistical measure used to gauge the similarity between two sets. This function will be particularly useful in evaluating the performance of binary classification models in machine learning, especially in the context of image segmentation tasks.\n\nFunction signature:\n```python\ndef jaccard_coef_int(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `smooth`: A small constant value set to `1e-12` to prevent division by zero during the calculation of the Jaccard coefficient.\n\nInput format:\n- The function expects two tensors `y_true` and `y_pred`, both of which should have the same shape and contain binary values (0s and 1s).\n\nOutput format:\n- The function returns a single scalar value representing the mean Jaccard coefficient, which quantifies the similarity between the true and predicted labels.\n\n```python\n# Input\ny_true = np.array([[[[0., 1.],\n                     [1., 0.]],\n                    \n                    [[1., 0.],\n                     [0., 1.]]]])\n\ny_pred = np.array([[[[0.8, 0.2],\n                     [0.1, 0.9]],\n                    \n                    [[0.6, 0.4],\n                     [0.3, 0.7]]]])\n\n# Output\njaccard_coef_int(y_true, y_pred)  # Expected output: tf.Tensor(0.500000000000125, shape=(), dtype=float64)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef jaccard_coef_int(y_true, y_pred):\n    K = tf.keras.backend\n    smooth = 1e-12\n    y_pred_pos = K.round(K.clip(y_pred, 0, 1))\n    intersection = K.sum(y_true * y_pred_pos, axis=[0, -1, -2])\n    sum_ = K.sum(y_true + y_pred_pos, axis=[0, -1, -2])\n    jac = (intersection + smooth) / (sum_ - intersection + smooth)\n    return K.mean(jac)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(16, 128)\n        width = np.random.randint(16, 128)\n        channels = np.random.randint(1, 5)\n\n        shape = (batch_size, height, width, channels)\n\n        y_true = np.random.randint(0, 2, shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases"}
{"problem_id": "keras_82", "library": "keras", "code_problem": "You are tasked with implementing a function that processes a multi-dimensional input tensor using a series of linear transformations and non-linear activations. The function will compute a weighted average of the input tensor, apply a series of transformations, and return a modified version of the input tensor based on the computed values.\n\nFunction signature:\n```python\ndef call(inputs, kernel1, bias2, kernel2, use_bias, bias1, data_format):\n```\n\nConstants used in the main code:\n- The constant `axes` is determined based on the `data_format` parameter, which can either be 'channels_first' or 'channels_last'. It is set to `[2, 3]` for 'channels_first' and `[1, 2]` for 'channels_last'.\n\nInput format:\n- `inputs`: A multi-dimensional tensor (e.g., a 4D tensor for images).\n- `kernel1`: A weight matrix for the first linear transformation.\n- `bias2`: A bias vector for the second linear transformation.\n- `kernel2`: A weight matrix for the second linear transformation.\n- `use_bias`: A boolean indicating whether to use bias terms in the transformations.\n- `bias1`: A bias vector for the first linear transformation.\n- `data_format`: A string indicating the format of the input tensor, either 'channels_first' or 'channels_last'.\n\nOutput format:\n- The function returns a tensor that is the result of the element-wise multiplication of the original `inputs` and the final processed tensor, or just the processed tensor if `inputs` is `None`.\n\n**Input:**\n```python\ninputs = tf.constant([[[[0.1, 0.2], [0.3, 0.4]], [[0.5, 0.6], [0.7, 0.8]]]])  # Shape: (1, 2, 2, 2)\nkernel1 = tf.constant([[0.1, 0.2], [0.3, 0.4]])  # Shape: (2, 2)\nbias1 = tf.constant([0.1, 0.2])  # Shape: (2,)\nkernel2 = tf.constant([[0.5, 0.6], [0.7, 0.8]])  # Shape: (2, 2)\nbias2 = tf.constant([0.1, 0.2])  # Shape: (2,)\nuse_bias = True\ndata_format = 'channels_last'\n```\n\n**Output:**\n```python\noutput = tf.Tensor(\n[[[[0.06412975 0.13618387]\n   [0.19238925 0.27236775]]\n  [[0.32064873 0.40855163]\n   [0.4489082  0.5447355 ]]]], shape=(1, 2, 2, 2), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, kernel1, bias2, kernel2, use_bias, bias1, data_format):\n    K = tf.keras.backend\n    axes = [2, 3] if data_format == 'channels_first' else [1, 2]\n    sq = K.mean(inputs, axes)\n\n    ex = K.dot(sq, kernel1)\n    if use_bias:\n        ex = K.bias_add(ex, bias1)\n\n    ex = K.relu(ex)\n    ex = K.dot(ex, kernel2)\n\n    if use_bias:\n        ex = K.bias_add(ex, bias2)\n\n    ex = K.sigmoid(ex)\n\n    expand_dims_axes = (-1, -1) if data_format == 'channels_first' else (1, 1)\n    ex = K.expand_dims(ex, expand_dims_axes[0])\n    ex = K.expand_dims(ex, expand_dims_axes[1])\n\n    return inputs * ex if inputs is not None else ex", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data_format = np.random.choice(['channels_first', 'channels_last'])\n        batch_size = np.random.randint(1, 10)\n        channels = np.random.randint(1, 10)\n        height = np.random.randint(5, 50)\n        width = np.random.randint(5, 50)\n\n        if data_format == 'channels_first':\n            input_shape = (batch_size, channels, height, width)\n        else:\n            input_shape = (batch_size, height, width, channels)\n        inputs = tf.random.normal(input_shape)\n        kernel1_shape = (channels, np.random.randint(1, 10))\n        kernel1 = tf.random.normal(kernel1_shape)\n        use_bias = np.random.choice([True, False])\n        bias1 = tf.random.normal((kernel1_shape[1],)) if use_bias else None\n        kernel2_shape = (kernel1_shape[1], channels)\n        kernel2 = tf.random.normal(kernel2_shape)\n        bias2 = tf.random.normal((channels,)) if use_bias else None\n        test_cases.append((inputs, kernel1, bias2, kernel2, use_bias, bias1, data_format))\n    return test_cases\n"}
{"problem_id": "keras_83", "library": "keras", "code_problem": "You are tasked with implementing a function that computes the softmax of a given input tensor. The softmax function is commonly used in machine learning, particularly in classification tasks, to convert raw scores (logits) into probabilities.\n\nFunction signature:\n```python\ndef softmax(x, axis=1):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `K`, which refers to the Keras backend module.\n\nInput format:\n- The input `x` can be a list or a numpy array representing the scores (logits) for which the softmax needs to be computed. The `axis` parameter is an integer indicating the axis along which to compute the softmax.\n\nOutput format:\n- The output will be a Keras constant tensor containing the softmax probabilities corresponding to the input tensor `x`. If the input tensor has fewer than 2 dimensions, the output will be an empty Keras constant.\n\n```python\n# Input\nx = np.array([[1.0, 2.0, 3.0], [1.0, 2.0, 3.0]], dtype=np.float32)\naxis = 1\n\n# Output\noutput = tf.Tensor([[0.09003057 0.24472848 0.6652409 ] [0.09003057 0.24472848 0.6652409 ]], shape=(2, 3), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n# main code\ndef softmax(x, axis=1):\n    K = tf.keras.backend\n    x = K.constant(x)\n    ndim = K.ndim(x)\n\n    if ndim == 2:\n        return K.softmax(x)\n    elif ndim > 2:\n        e = K.exp(x - K.max(x, axis=axis, keepdims=True))\n        s = K.sum(e, axis=axis, keepdims=True)\n        return e / s\n    return K.constant([])\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        ndim = np.random.choice([2, 3, 4, 5])\n        shape = tuple(np.random.randint(1, 10) for _ in range(ndim))\n        x = np.random.randn(*shape).astype(np.float32)\n        axis = np.random.randint(0, ndim)\n        test_cases.append((x, axis))\n\n    return test_cases\n"}
{"problem_id": "keras_84", "library": "keras", "code_problem": "You are tasked with implementing a custom loss function for a binary classification problem using TensorFlow and Keras. The loss function is known as the Focal Loss, which is designed to address class imbalance by focusing more on hard-to-classify examples.\n\nFunction signature:\n```python\ndef focal_loss(y_true, y_pred, gamma=2.0, alpha=0.25):\n```\n\nConstants used in the main code:\n- `gamma`: A focusing parameter that adjusts the rate at which easy examples are down-weighted. The default value is set to `2.0`.\n- `alpha`: A balancing factor that helps to balance the importance of positive/negative examples. The default value is set to `0.25`.\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted probabilities for the positive class (values between 0 and 1).\n- `gamma`: (optional) A float value for the focusing parameter (default is 2.0).\n- `alpha`: (optional) A float value for the balancing factor (default is 0.25).\n\nOutput format:\n- A scalar tensor representing the computed focal loss value.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0], [1, 1, 0]])\ny_pred = np.array([[0.9, 0.1, 0.8], [0.2, 0.7, 0.3], [0.6, 0.4, 0.5]])\n\n# Output\nfocal_loss(y_true, y_pred)  # tf.Tensor(0.2749443793379359, shape=(), dtype=float64)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef focal_loss(y_true, y_pred, gamma=2.0, alpha=0.25):\n    K = tf.keras.backend\n    pt_1 = tf.where(tf.equal(y_true, 1), y_pred, tf.ones_like(y_pred))\n    pt_0 = tf.where(tf.equal(y_true, 0), y_pred, tf.zeros_like(y_pred))\n    return -K.sum(alpha * K.pow(1.0 - pt_1, gamma) * K.log(pt_1)) - K.sum((1 - alpha) * K.pow(pt_0, gamma) * K.log(1.0 - pt_0))", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 20)\n        num_classes = np.random.randint(1, 10)\n\n        y_true = np.random.randint(0, 2, (batch_size, num_classes))\n        y_pred = np.random.rand(batch_size, num_classes)\n\n        test_cases.append((y_true, y_pred))\n\n    return test_cases\n"}
{"problem_id": "keras_85", "library": "keras", "code_problem": "You are tasked with implementing a custom loss function for a multi-class classification problem using Keras. The function should compute a weighted categorical cross-entropy loss, which takes into account the importance of different classes based on a provided weight matrix. This is particularly useful in scenarios where certain classes are more significant than others, allowing for a more nuanced training process.\n\nThe function signature of the main code is as follows:\n```python\ndef w_categorical_crossentropy(y_true, y_pred, weights):\n```\n\nIn this function, the following constant is used:\n- `nb_cl`: This constant represents the number of classes, which is derived from the shape of the `weights` matrix.\n\nThe input and output format of the code is as follows:\n- **Input**: \n  - `y_true`: A tensor of shape (batch_size, num_classes) representing the true labels in a one-hot encoded format.\n  - `y_pred`: A tensor of shape (batch_size, num_classes) representing the predicted probabilities for each class.\n  - `weights`: A 2D tensor (matrix) of shape (num_classes, num_classes) representing the weights for each class pair.\n\n- **Output**: \n  - A tensor representing the computed weighted categorical cross-entropy loss.\n\n**Input:**\n```python\ny_true = np.array([[[0., 1., 0.], \n                    [0., 0., 1.], \n                    [1., 0., 0.]], \n\n                   [[1., 0., 0.], \n                    [0., 1., 0.], \n                    [0., 0., 1.]]])  # Shape: (2, 3, 3)\n\ny_pred = np.array([[[0.1, 0.7, 0.2], \n                     [0.2, 0.1, 0.7], \n                     [0.8, 0.1, 0.1]], \n\n                    [[0.6, 0.2, 0.2], \n                     [0.1, 0.6, 0.3], \n                     [0.2, 0.3, 0.5]]])  # Shape: (2, 3, 3)\n\nweights = np.array([[1.0, 0.5, 0.2], \n                    [0.5, 1.0, 0.3], \n                    [0.2, 0.3, 1.0]], dtype=np.float32)  # Shape: (3, 3)\n```\n\n**Output:**\n```python\noutput = tf.Tensor(\n[[0.35667497 0.35667497 0.22314355]\n [0.5108256  0.5108256  0.6931472 ]], shape=(2, 3), dtype=float32)\n```\n", "ground_truth_code": "from itertools import product\nimport tensorflow as tf\n\n# main code\ndef w_categorical_crossentropy(y_true, y_pred, weights):\n    K = tf.keras.backend\n    y_true = K.cast(y_true, dtype=tf.float32)\n    y_pred = K.cast(y_pred, dtype=tf.float32)\n\n    nb_cl = len(weights)\n    final_mask = K.zeros_like(y_pred[:, :, 0], dtype=tf.float32)\n\n    y_pred_max = K.max(y_pred, axis=2)\n    y_pred_max = K.reshape(y_pred_max, (K.shape(y_pred)[0], K.shape(y_pred)[1], 1))\n    y_pred_max_mat = K.equal(y_pred, y_pred_max)\n\n    for (c_p, c_t) in product(range(nb_cl), range(nb_cl)):\n        final_mask += weights[c_t, c_p] * K.cast(y_pred_max_mat, tf.float32)[:, :, c_p] * y_true[:, :, c_t]\n\n    return K.categorical_crossentropy(y_true, y_pred) * final_mask", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    KU = tf.keras.utils\n    test_cases = []\n\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len = np.random.randint(5, 20)\n        num_classes = np.random.randint(2, 10)\n        y_true_labels = np.random.randint(0, num_classes, (batch_size, seq_len))\n        y_true = KU.to_categorical(y_true_labels, num_classes=num_classes)\n        y_pred_logits = np.random.randn(batch_size, seq_len, num_classes)\n        y_pred = tf.nn.softmax(y_pred_logits).numpy()\n        weights = np.random.rand(num_classes, num_classes).astype(np.float32)\n\n        test_cases.append((y_true, y_pred, weights))\n\n    return test_cases"}
{"problem_id": "keras_86", "library": "keras", "code_problem": "You are tasked with implementing a function that builds a generator model for a Generative Adversarial Network (GAN) using Keras. The generator will take random noise and class labels as inputs to produce images of a specified shape. The generator architecture will consist of several dense layers with batch normalization applied after each layer to stabilize training.\n\nFunction signature:\n```python\ndef build_generator(num_classes, embedding_layer, batch_norm, img_shape, latent_dim):\n```\n\nConstants used in the main code:\n- The constant `0.8` is used as the momentum parameter for the batch normalization layers.\n\nInput format:\n- `num_classes`: An integer representing the number of classes for the labels.\n- `embedding_layer`: A Keras embedding layer function that will be used to embed the class labels.\n- `batch_norm`: A Keras batch normalization layer function.\n- `img_shape`: An integer representing the shape of the output image.\n- `latent_dim`: An integer representing the dimension of the latent space.\n\nOutput format:\n- The function returns a Keras Model that takes two inputs (noise and label) and outputs the generated image.\n\nInput:\n```python\nnum_classes = 5\nlatent_dim = 20\nimg_shape = 50\nembedding_layer = lambda num_classes, latent_dim: Embedding(num_classes, latent_dim)\nbatch_norm = lambda momentum: BatchNormalization(momentum=momentum)\n```\n\nOutput:\n```python\n# The output will be a Keras Model object\nmodel = build_generator(num_classes, embedding_layer, batch_norm, img_shape, latent_dim)\nmodel.summary()  # This will show the architecture of the model\n``` \n\n(Note: The actual output of `model.summary()` will vary based on the random initialization of weights and the specific architecture defined in the `build_generator` function.)", "ground_truth_code": "from keras.layers import Input, Dense, Flatten\nfrom keras.models import Model, Sequential\nimport tensorflow as tf\n\n# main code\ndef build_generator(num_classes, embedding_layer, batch_norm, img_shape, latent_dim):\n    model = Sequential()\n    model.add(Dense(32, activation='relu', input_dim=latent_dim))\n    model.add(batch_norm(momentum=0.8))\n    model.add(Dense(64, activation='relu'))\n    model.add(batch_norm(momentum=0.8))\n    model.add(Dense(128, activation='relu'))\n    model.add(batch_norm(momentum=0.8))\n    model.add(Dense(img_shape, activation='relu'))\n\n    noise = Input(shape=(latent_dim,))\n    label = Input(shape=(1,), dtype='int32')\n    label_embedding = Flatten()(embedding_layer(num_classes, latent_dim)(label))\n    model_input = tf.keras.layers.multiply([noise, label_embedding])\n    img = model(model_input)\n\n    return Model([noise, label], img)", "test_script": "import numpy as np\nfrom keras.layers import BatchNormalization, Embedding\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_classes = np.random.randint(2, 20)\n        latent_dim = np.random.randint(10, 100)\n        img_shape = np.random.randint(10, 200)\n        embedding_layer = lambda num_classes, latent_dim: Embedding(num_classes, latent_dim)\n        batch_norm = lambda momentum: BatchNormalization(momentum=momentum)\n\n        test_cases.append((num_classes, embedding_layer, batch_norm, img_shape, latent_dim))\n\n    return test_cases\n"}
{"problem_id": "keras_87", "library": "keras", "code_problem": "You are tasked with implementing a function that processes input sequences by incorporating positional embeddings, which are essential in various neural network architectures, particularly in natural language processing tasks. The function should handle optional masking to ensure that certain positions in the input sequences are ignored during the computation.\n\nFunction signature:\n```python\ndef call(inputs, mask, embeddings, merge_mode=None):\n```\n\n### Constants:\n- `K`: This is a backend module from Keras that provides various tensor operations.\n- `tf`: This is the TensorFlow library, which is used for numerical computations and building machine learning models.\n\n### Input Format:\n- `inputs`: A tensor of shape `[batch_size, seq_len, embedding_dim]` representing the input sequences.\n- `mask`: A tensor of shape `[batch_size, seq_len]` that indicates which positions in the input should be masked (ignored).\n- `embeddings`: A tensor of shape `[max_seq_len, embedding_dim]` containing the positional embeddings for sequences.\n- `merge_mode`: An optional string that determines how to combine the `inputs` and `pos_embeddings`. It can be `None` or `'add'`.\n\n### Output Format:\n- The function returns a tensor that is either the sum of `inputs` and `pos_embeddings` (if `merge_mode` is `'add'`) or a concatenated tensor of `inputs` and `pos_embeddings` along the last dimension. The output shape will depend on the `merge_mode` used.\n\nInput:\n```python\ninputs = tf.constant([[[ 0.1, -0.2,  0.3],\n                        [ 0.4,  0.5, -0.6]],\n                       [[ 0.7,  0.8,  0.9],\n                        [-0.1, -0.2, -0.3]]], dtype=tf.float32)\n\nmask = tf.constant([[1, 1],\n                    [1, 0]], dtype=tf.int32)\n\nembeddings = tf.constant([[0.1, 0.2, 0.3],\n                          [0.4, 0.5, 0.6],\n                          [0.7, 0.8, 0.9],\n                          [1.0, 1.1, 1.2],\n                          [1.3, 1.4, 1.5],\n                          [1.6, 1.7, 1.8],\n                          [1.9, 2.0, 2.1],\n                          [2.2, 2.3, 2.4],\n                          [2.5, 2.6, 2.7],\n                          [2.8, 2.9, 3.0]], dtype=tf.float32)\n\nmerge_mode = 'add'\n```\n\nOutput:\n```python\noutput = tf.Tensor(\n[[[0.2 0.  0.6]\n  [0.8 1.  0. ]]\n [[0.8 1.  1.2]\n  [0.  0.  0. ]]], shape=(2, 2, 3), dtype=float32)\n```\n", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef call(inputs, mask, embeddings, merge_mode=None):\n    K = tf.keras.backend\n    input_shape = K.shape(inputs)\n    batch_size, seq_len = input_shape[0], input_shape[1]\n\n    pos_embeddings = embeddings[:seq_len]\n    pos_embeddings = K.expand_dims(pos_embeddings, 0)\n    pos_embeddings = K.tile(pos_embeddings, [batch_size, 1, 1])\n\n    if mask is not None:\n        mask_0 = K.repeat(mask, K.shape(inputs)[-1])\n        mask_0 = tf.transpose(mask_0, [0, 2, 1])\n        mask_0 = K.cast(mask_0, K.floatx())\n        inputs = inputs * mask_0\n\n        mask_1 = K.repeat(mask, K.shape(pos_embeddings)[-1])\n        mask_1 = tf.transpose(mask_1, [0, 2, 1])\n        mask_1 = K.cast(mask_1, K.floatx())\n        pos_embeddings = pos_embeddings * mask_1\n\n    if merge_mode == 'add':\n        return inputs + pos_embeddings\n    return K.concatenate([inputs, pos_embeddings])", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        seq_len = np.random.randint(5, 50)\n        feature_dim = np.random.randint(16, 128)\n        max_seq_len = 50\n\n        inputs = tf.random.normal((batch_size, seq_len, feature_dim))\n        mask = tf.random.uniform((batch_size, seq_len), minval=0, maxval=2, dtype=tf.int32)\n        embeddings = tf.random.normal((max_seq_len, feature_dim))\n        merge_mode = np.random.choice([None, 'add'])\n\n        test_cases.append((inputs, mask, embeddings, merge_mode))\n\n    return test_cases"}
{"problem_id": "keras_88", "library": "keras", "code_problem": "You are tasked with implementing a function to calculate the specificity of a binary classification model. Specificity is a measure of the proportion of actual negatives that are correctly identified as such. The function should take two inputs: the ground truth labels and the predicted labels from the model.\n\nFunction signature:\n```python\ndef specificity(truth, prediction):\n```\n\nIn the main code, the following constant is used:\n- `K.epsilon()`: This is a small constant added to the denominator to prevent division by zero.\n\nInput format:\n- The function takes two inputs:\n  - `truth`: A tensor of shape (n,) containing binary values (0 or 1) representing the ground truth labels.\n  - `prediction`: A tensor of shape (n,) containing binary values (0 or 1) representing the predicted labels from the model.\n\nOutput format:\n- The function returns a single scalar value representing the specificity, which is a float.\n\nInput:\n```python\ntruth = tf.convert_to_tensor(np.array([[[[0], [1]], [[0], [0]]]]), dtype=tf.float32)\nprediction = tf.convert_to_tensor(np.array([[[[0], [1]], [[1], [0]]]]), dtype=tf.float32)\n```\n\nOutput:\n```python\nspecificity(truth, prediction)  # Output: tf.Tensor(0.6666667, shape=(), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef specificity(truth, prediction):\n    K = tf.keras.backend\n    TN = K.sum(K.round(K.clip((1 - truth) * (1 - prediction), 0, 1)))\n    N = K.sum(K.round(K.clip(1 - truth, 0, 1)))\n    return TN / (N + K.epsilon())", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 10)\n        height = np.random.randint(5, 50)\n        width = np.random.randint(5, 50)\n        channels = np.random.randint(1, 5)\n\n        shape = (batch_size, height, width, channels)\n        truth = tf.convert_to_tensor(np.random.randint(0, 2, size=shape), dtype=tf.float32)\n        prediction = tf.convert_to_tensor(np.random.randint(0, 2, size=shape), dtype=tf.float32)\n\n        test_cases.append((truth, prediction))\n\n    return test_cases"}
{"problem_id": "keras_89", "library": "keras", "code_problem": "You are tasked with implementing a function that formats image data and corresponding labels for a machine learning model. The function will preprocess the input images and labels, ensuring that the labels are converted into a suitable format for training. The function signature is as follows:\n\n```python\ndef format_data(x, y, img_rows, img_cols, split_ratio, num_classes=36, max_label_length=5):\n```\n\n### Constants:\n- `num_classes`: This constant is set to 36, representing the total number of classes, which includes 26 letters (A-Z) and 10 digits (0-9).\n- `max_label_length`: This constant is set to 5, indicating the maximum length of the label sequences.\n\n### Input Format:\n- `x`: A list or array of images, where each image is represented as a 2D array.\n- `y`: A list of strings, where each string represents a label corresponding to an image in `x`.\n- `img_rows`: An integer representing the number of rows (height) of the images.\n- `img_cols`: An integer representing the number of columns (width) of the images.\n- `split_ratio`: A float representing the ratio of the dataset to be used for training (e.g., 0.8 for 80% training data).\n- `num_classes`: An optional integer (default is 36) representing the total number of classes.\n- `max_label_length`: An optional integer (default is 5) representing the maximum length of the label sequences.\n\n### Output Format:\n- The function returns a tuple containing:\n  - The reshaped image data as a NumPy array.\n  - The processed labels as a NumPy array.\n  - The training split of the image data.\n  - The testing split of the image data.\n  - The training split of the labels.\n  - The testing split of the labels.\n\n**Input:**\n```python\nx = np.array([[[  0,  10,  20], [ 30,  40,  50]], [[ 60,  70,  80], [ 90, 100, 110]]], dtype=np.uint8)\ny = [\"A1\", \"B2\"]\nimg_rows = 2\nimg_cols = 3\nsplit_ratio = 0.5\nnum_classes = 36\nmax_label_length = 5\n```\n\n**Output:**\n```python\n(\n   array([[[[0.        ],\n         [0.03921569],\n         [0.07843138]],\n        [[0.11764706],\n         [0.15686275],\n         [0.19607843]]],\n       [[[0.23529412],\n         [0.27450982],\n         [0.3137255 ]],\n        [[0.3529412 ],\n         [0.39215687],\n         [0.43137255]]]], dtype=float32), \n   array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.],\n       [0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]], dtype=float32), \n   array([[[[0.        ],\n         [0.03921569],\n         [0.07843138]],\n        [[0.11764706],\n         [0.15686275],\n         [0.19607843]]]], dtype=float32), \n   array([[[[0.23529412],\n         [0.27450982],\n         [0.3137255 ]],\n        [[0.3529412 ],\n         [0.39215687],\n         [0.43137255]]]], dtype=float32), \n   array([[[[0.23529412],\n         [0.27450982],\n         [0.3137255 ]],\n        [[0.3529412 ],\n         [0.39215687],\n         [0.43137255]]]], dtype=float32), \n   array([[1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]], dtype=float32), \n   array([[0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]], dtype=float32), \n   array([[0., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        1., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 0.,\n        0., 0., 0., 0.]], dtype=float32)\n )\n```\n", "ground_truth_code": "import numpy as np\nimport keras\n\n# main code\ndef format_data(x, y, img_rows, img_cols, split_ratio, num_classes=36, max_label_length=5):\n    labeldict = {chr(i + 65): i for i in range(26)}\n    labeldict.update({str(i): i + 26 for i in range(10)})\n\n    x = np.array(x, dtype=np.float32) / 255.0\n\n    y_processed = []\n    for label in y:\n        one_hot_vectors = [keras.utils.to_categorical(labeldict[char], num_classes) for char in label]\n        while len(one_hot_vectors) < max_label_length:\n            one_hot_vectors.append(np.zeros(num_classes))\n        y_processed.append(np.concatenate(one_hot_vectors[:max_label_length]))\n\n    y = np.array(y_processed, dtype=np.float32)\n\n    x_data = x.reshape(-1, img_rows, img_cols, 1)\n    split_idx = int(len(x_data) * split_ratio)\n\n    return (\n        x_data,\n        y,\n        x_data[:split_idx],\n        x_data[split_idx:],\n        x_data[split_idx:],\n        y[:split_idx],\n        y[split_idx:],\n        y[split_idx:],\n    )", "test_script": "import numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    num_classes = 36\n\n    for _ in range(n):\n        img_rows = random.randint(20, 64)\n        img_cols = img_rows\n        max_label_length = random.randint(3, 10)\n        split_ratio = round(random.uniform(0.5, 0.9), 2)\n\n        labeldict = {chr(i + 65): i for i in range(26)}\n        labeldict.update({str(i): i + 26 for i in range(10)})\n        valid_chars = list(labeldict.keys())\n\n        num_samples = random.randint(10, 100)\n\n        x = np.random.randint(0, 256, (num_samples, img_rows, img_cols), dtype=np.uint8)\n        y = [\"\".join(random.choices(valid_chars, k=random.randint(1, max_label_length))) for _ in range(num_samples)]\n\n        test_cases.append((x, y, img_rows, img_cols, split_ratio, num_classes, max_label_length))\n\n    return test_cases"}
{"problem_id": "keras_90", "library": "keras", "code_problem": "You are tasked with creating a function that builds a generator model for a neural network using Keras. The generator will be designed to produce time series data based on a latent space input. The function signature for the main code is as follows:\n\n```python\ndef build_generator(ts_feature, latent_shape):\n```\n\nIn this function, the following constant is used:\n- The number of units in the Dense layers is set to 100.\n\nInput format:\n- `ts_feature`: An integer representing the number of features in the generated time series data.\n- `latent_shape`: A tuple representing the shape of the latent space input.\n\nOutput format:\n- The function returns a Keras Model object that can be used to generate time series data from latent space inputs.\n\n```python\nInput: (ts_feature=15, latent_shape=(32,))\nOutput: Model Summary:\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n dense (Dense)               (None, 100)              3300      \n                                                                 \n leaky_re_lu (LeakyReLU)    (None, 100)              0         \n                                                                 \n layer_normalization (LayerN  (None, 100)              200       \n ormalization)                                                  \n                                                                 \n dense_1 (Dense)             (None, 100)              10100     \n                                                                 \n leaky_re_lu_1 (LeakyReLU)  (None, 100)              0         \n                                                                 \n layer_normalization_1 (Laye  (None, 100)              200       \n rNormalization)                                                \n                                                                 \n dense_2 (Dense)             (None, 15)               1515      \n                                                                 \n=================================================================\nTotal params: 13,315\nTrainable params: 13,215\nNon-trainable params: 100\n_________________________________________________________________\n```", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Input\nfrom keras.models import Model\nfrom keras.layers import Dense\nfrom keras.layers import LeakyReLU\nfrom keras.layers import LayerNormalization\n\n# main code\ndef build_generator(ts_feature, latent_shape):\n    model = Sequential([Dense(100, input_shape=latent_shape, activation='sigmoid'), LeakyReLU(alpha=0.2), LayerNormalization(), Dense(100, activation='sigmoid'), LeakyReLU(alpha=0.2), LayerNormalization(), Dense(ts_feature)])\n    model.summary()\n    noise = Input(shape=latent_shape)\n    ts = model(noise)\n    return Model(noise, ts)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        ts_feature = np.random.randint(1, 20)\n        latent_shape = (np.random.randint(10, 100),)\n\n        test_cases.append((ts_feature, latent_shape))\n    return test_cases"}
{"problem_id": "keras_91", "library": "keras", "code_problem": "You are tasked with implementing a function that computes the posterior distribution parameters given the mean and log variance of two distributions. The function will utilize the Keras backend for mathematical operations.\n\nFunction signature:\n```python\ndef compute_posterior(z_mean, z_log_var, lam_mean, lam_log_var):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the mathematical constant `e`, which is represented in the code by the Keras backend function `K.exp()`.\n\n\nInput format:\n- The function accepts four inputs: `z_mean`, `z_log_var`, `lam_mean`, and `lam_log_var`, all of which are expected to be numerical values or tensors.\n\nOutput format:\n- The function returns a list containing two elements: the posterior mean and the posterior log variance, both of which are numerical values or tensors.\n\n```python\n# Input\nz_mean = K.variable(np.array([[0.5, -1.2], [0.3, 0.8]]).astype(np.float32))\nz_log_var = K.variable(np.array([[0.1, 0.2], [0.3, 0.4]]).astype(np.float32))\nlam_mean = K.variable(np.array([[0.4, -0.5], [0.6, 0.1]]).astype(np.float32))\nlam_log_var = K.variable(np.array([[0.2, 0.1], [0.5, 0.3]]).astype(np.float32))\n\n# Output\npost_mean, post_log_var = compute_posterior(z_mean, z_log_var, lam_mean, lam_log_var)\n# post_mean\ntf.Tensor(\n[[ 0.4524979  -0.8325145 ]\n [ 0.43504983  0.43251458]], shape=(2, 2), dtype=float32)\n# post_log_var\ntf.Tensor(\n[[-0.5443967 -0.5443967]\n [-0.2981388 -0.3443967]], shape=(2, 2), dtype=float32)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef compute_posterior(z_mean, z_log_var, lam_mean, lam_log_var):\n    K = tf.keras.backend\n    post_mean = z_mean / (1 + K.exp(z_log_var - lam_log_var)) + lam_mean / (1 + K.exp(lam_log_var - z_log_var))\n    post_log_var = z_log_var + lam_log_var - K.log(K.exp(z_log_var) + K.exp(lam_log_var))\n    return [post_mean, post_log_var]", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n    for _ in range(n):\n        shape = tuple(np.random.randint(1, 10, size=np.random.randint(1, 4)))\n        z_mean = K.variable(np.random.randn(*shape).astype(np.float32))\n        z_log_var = K.variable(np.random.randn(*shape).astype(np.float32))\n        lam_mean = K.variable(np.random.randn(*shape).astype(np.float32))\n        lam_log_var = K.variable(np.random.randn(*shape).astype(np.float32))\n\n        test_cases.append((z_mean, z_log_var, lam_mean, lam_log_var))\n\n    return test_cases"}
{"problem_id": "keras_92", "library": "keras", "code_problem": "You are tasked with building a neural network model using Keras for a specific application. The model will take in a state representation and output a set of options. Your goal is to implement a function that constructs this model with a specified learning rate, state size, and option size.\n\nFunction signature:\n```python\ndef _build_model(learning_rate: float, state_size: int, option_size: int) -> Sequential:\n```\n\nConstant used in the main code:\n- The number of neurons in the first hidden layer is set to 300.\n- The number of neurons in the second hidden layer is set to 600.\n- The number of neurons in the third hidden layer is set to 300.\n\nInput format:\n- `learning_rate`: A float representing the learning rate for the optimizer.\n- `state_size`: An integer representing the size of the input state.\n- `option_size`: An integer representing the number of output options.\n\nOutput format:\n- The function returns a Keras Sequential model that has been built according to the specified parameters.\n\n```python\nInput: (0.005, 128, 10)\nOutput: <keras.engine.sequential.Sequential object at 0x7f8c1c0e3c10>\n``` \n\nIn this example, the input consists of a learning rate of 0.005, a state size of 128, and an option size of 10. The output is a reference to the created Keras Sequential model object.", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.optimizers import Adam\n\n# main code\ndef _build_model(learning_rate, state_size, option_size):\n    model = Sequential()\n    model.add(Dense(300, input_dim=state_size, activation='relu'))\n    model.add(Dense(600, activation='relu'))\n    model.add(Dense(300, activation='relu'))\n    model.add(Dense(option_size))\n    model.compile(loss='mse', optimizer=Adam(learning_rate=learning_rate))\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        learning_rate = np.random.uniform(0.0001, 0.1)\n        state_size = np.random.randint(10, 500)\n        option_size = np.random.randint(2, 50)\n\n        test_cases.append((learning_rate, state_size, option_size))\n\n    return test_cases\n\n\ntest_cases = test_case_input_generator()\nfor i in range(len(test_cases)):\n   print(_build_model(*test_cases[i]))"}
{"problem_id": "keras_93", "library": "keras", "code_problem": "You are tasked with creating a function that builds a neural network classifier using Keras. The function should allow for the specification of the optimizer to be used during the compilation of the model. The neural network will consist of several layers, including dense layers with activation functions and dropout layers for regularization.\n\nFunction signature:\n```python\ndef build_classifier(optimizer):\n```\n\nConstant used in the main code:\n- The input dimension for the first dense layer is set to 16.\n- The number of units in the first two dense layers is set to 8.\n- The dropout rate for the dropout layers is set to 0.1.\n- The final dense layer has 1 unit and uses the sigmoid activation function.\n\n\nInput format:\n- The function takes a single input parameter, `optimizer`, which is a string representing the optimization algorithm to be used (e.g., 'adam', 'sgd').\n\nOutput format:\n- The function returns a compiled Keras Sequential model that can be used for training on binary classification tasks.\n\n```json\n{\n  \"input\": \"Adam()\",\n  \"output\": \"Classifier built with Adam optimizer, loss: binary_crossentropy, metrics: ['accuracy']\"\n}\n```", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Dense\nfrom keras.layers import Dropout\n\n# main code\ndef build_classifier(optimizer):\n    classifier = Sequential()\n    classifier.add(Dense(activation='relu', input_dim=16, units=8, kernel_initializer='uniform'))\n    classifier.add(Dropout(rate=0.1))\n    classifier.add(Dense(activation='relu', units=8, kernel_initializer='uniform'))\n    classifier.add(Dropout(rate=0.1))\n    classifier.add(Dense(activation='sigmoid', units=1, kernel_initializer='uniform'))\n    classifier.compile(optimizer=optimizer, loss='binary_crossentropy', metrics=['accuracy'])\n    return classifier", "test_script": "import random\nfrom keras.optimizers import Adam, SGD, RMSprop, Adagrad, Adadelta, Adamax, Nadam\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    optimizers = [Adam(), SGD(), RMSprop(), Adagrad(), Adadelta(), Adamax(), Nadam()]\n\n    for _ in range(n):\n        optimizer = random.choice(optimizers)\n        test_cases.append(optimizer)\n\n    return test_cases"}
{"problem_id": "keras_94", "library": "keras", "code_problem": "You are tasked with implementing a function that calculates the precision and recall metrics for a binary classification problem using Keras backend operations. The function should take two inputs: the true labels and the predicted labels, both represented as tensors. The function will return the precision and recall values, which are essential for evaluating the performance of classification models.\n\nFunction signature:\n```python\ndef confusion(y_true, y_pred):\n```\n\nConstant used in the main code:\n- `smooth`: A constant value set to `1`, used to avoid division by zero when calculating precision and recall.\n\n\nInput format:\n- `y_true`: A tensor representing the true binary labels (0 or 1).\n- `y_pred`: A tensor representing the predicted probabilities for the positive class (values between 0 and 1).\n\nOutput format:\n- A tuple containing two values: the precision and recall, both as floating-point numbers.\n\nInput:\n```python\ny_true = K.constant([[1, 0, 1], [0, 1, 0]])\ny_pred = K.constant([[0.9, 0.2, 0.8], [0.1, 0.6, 0.3]])\n```\n\nOutput:\n```python\n(<tf.Tensor: shape=(), dtype=float32, numpy=0.84615386>, <tf.Tensor: shape=(), dtype=float32, numpy=0.82500005>)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef confusion(y_true, y_pred):\n    K = tf.keras.backend\n    smooth = 1\n    y_pred_pos = K.clip(y_pred, 0, 1)\n    y_pred_neg = 1 - y_pred_pos\n    y_pos = K.clip(y_true, 0, 1)\n    y_neg = 1 - y_pos\n    tp = K.sum(y_pos * y_pred_pos)\n    fp = K.sum(y_neg * y_pred_pos)\n    fn = K.sum(y_pos * y_pred_neg)\n    prec = (tp + smooth) / (tp + fp + smooth)\n    recall = (tp + smooth) / (tp + fn + smooth)\n    return (prec, recall)", "test_script": "import numpy as np\nimport tensorflow as tf\n\n\ndef test_case_input_generator(n=200):\n    K = tf.keras.backend\n    test_cases = []\n\n    for _ in range(n):\n        shape = np.random.randint(1, 10, size=np.random.randint(1, 4)).tolist()\n\n        y_true = np.random.randint(0, 2, size=shape).astype(np.float32)\n        y_pred = np.random.rand(*shape).astype(np.float32)\n\n        y_true_tensor = K.constant(y_true)\n        y_pred_tensor = K.constant(y_pred)\n\n        test_cases.append((y_true_tensor, y_pred_tensor))\n\n    return test_cases"}
{"problem_id": "keras_95", "library": "keras", "code_problem": "You are tasked with creating a convolutional neural network (CNN) model using Keras. The model should be designed to classify images based on the specified input dimensions and number of classes. The architecture of the model includes convolutional layers, activation functions, pooling layers, and dense layers.\n\nFunction Signature:\n```python\ndef build_model(width, height, depth, classes, conv_filters=(10, 40), kernel_size=(5, 5), pool_size=(2, 2), dense_units=500):\n```\n\nConstant Used:\n- The constant used in the main code is `K.image_data_format()`, which determines the format of the input data (either 'channels_first' or 'channels_last').\n\n\nInput Format:\n- `width`: Integer representing the width of the input images.\n- `height`: Integer representing the height of the input images.\n- `depth`: Integer representing the number of channels in the input images (e.g., 3 for RGB images).\n- `classes`: Integer representing the number of output classes for classification.\n- `conv_filters`: Tuple of two integers representing the number of filters for the first and second convolutional layers (default is (10, 40)).\n- `kernel_size`: Tuple of two integers representing the size of the convolutional kernels (default is (5, 5)).\n- `pool_size`: Tuple of two integers representing the size of the pooling windows (default is (2, 2)).\n- `dense_units`: Integer representing the number of units in the dense layer (default is 500).\n\nOutput Format:\n- The function returns a Keras Sequential model object that can be used for training and inference in image classification tasks.\n\n```python\nInput: (64, 64, 3, 10, (16, 64), (5, 5), (2, 2), 512)\nOutput: <keras.engine.sequential.Sequential object at 0x...>\n``` \n\n(Note: The output will be a Keras model object, and the memory address will vary each time the model is created.)", "ground_truth_code": "from keras.models import Sequential\nfrom keras import backend as K\nfrom keras.layers import Conv2D, Activation, MaxPool2D, Flatten, Dense\n\n# main code\ndef build_model(width, height, depth, classes, conv_filters=(10, 40), kernel_size=(5, 5), pool_size=(2, 2),\n                dense_units=500):\n    input_shape = (depth, height, width) if K.image_data_format() == 'channels_first' else (height, width, depth)\n\n    model = Sequential([\n        Conv2D(conv_filters[0], kernel_size, padding='same', input_shape=input_shape),\n        Activation('relu'),\n        MaxPool2D(pool_size=pool_size, strides=pool_size),\n\n        Conv2D(conv_filters[1], kernel_size, padding='same'),\n        Activation('relu'),\n        MaxPool2D(pool_size=pool_size, strides=pool_size),\n\n        Flatten(),\n        Dense(dense_units),\n        Activation('relu'),\n        Dense(classes),\n        Activation('softmax')\n    ])\n\n    return model", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        width = random.choice([28, 32, 64, 128, 256])\n        height = random.choice([28, 32, 64, 128, 256])\n        depth = random.choice([1, 3])\n        classes = random.randint(2, 100)\n        conv_filters = (random.randint(8, 64), random.randint(32, 128))\n        kernel_size = (random.choice([3, 5]), random.choice([3, 5]))\n        pool_size = (2, 2)\n        dense_units = random.randint(128, 1024)\n        test_case = (width, height, depth, classes, conv_filters, kernel_size, pool_size, dense_units)\n        test_cases.append(test_case)\n    return test_cases"}
{"problem_id": "keras_96", "library": "keras", "code_problem": "Code problem description:\nYou are tasked with building a recurrent neural network (RNN) model using TensorFlow's Keras API. The model will be designed to process time series data, where the input shape is defined by the number of time steps (look_back) and the batch size. The model will consist of an LSTM layer followed by a dense output layer.\n\nFunction signature:\n```python\ndef build_model(look_back: int, batch_size: int):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the number of units in the LSTM layer, which is set to 64.\n\n\nInput format:\n- The function takes two integer inputs: `look_back` and `batch_size`.\n\nOutput format:\n- The function returns a compiled Keras model object.\n\n```python\nInput: (look_back=10, batch_size=5)\nOutput: A Keras LSTM model with 64 units, compiled with mean squared error loss and Adam optimizer.\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef build_model(look_back, batch_size):\n    KM = tf.keras.models\n    KL = tf.keras.layers\n\n    model = KM.Sequential()\n    model.add(KL.Input(batch_shape=(batch_size, look_back, 1)))\n    model.add(KL.LSTM(64, activation='relu', stateful=True, return_sequences=False))\n    model.add(KL.Dense(1, activation='linear'))\n    model.compile(loss='mean_squared_error', optimizer='adam')\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        look_back = np.random.randint(1, 50)\n        batch_size = np.random.randint(1, 20)\n\n        test_cases.append((look_back, batch_size))\n\n    return test_cases\n"}
{"problem_id": "keras_97", "library": "keras", "code_problem": "You are tasked with implementing a learning rate scheduler that adjusts the learning rate based on the number of iterations during training. The function signature for the main code is as follows:\n\n```python\ndef clr(base_lr, step_size, scale_fn, clr_iterations, max_lr, scale_mode):\n```\n\nIn this function, the following constant is used:\n- `step_size`: This constant defines the number of iterations after which the learning rate will complete a cycle.\n\nInput format:\n- `base_lr`: A float representing the base learning rate.\n- `step_size`: An integer representing the number of iterations per cycle.\n- `scale_fn`: A function that takes an integer input and returns a float, used to scale the learning rate.\n- `clr_iterations`: An integer representing the current iteration number.\n- `max_lr`: A float representing the maximum learning rate.\n- `scale_mode`: A string that can either be 'cycle' or another value to determine the scaling behavior.\n\nOutput format:\n- The function returns a float representing the adjusted learning rate based on the input parameters.\n\n```python\nInput: (0.01, 10, <function scale_fn at 0x7f8c1c0e1e50>, 25, 0.05, 'cycle')\nOutput: 0.025\n```", "ground_truth_code": "import numpy as np\n\n# main code\ndef clr(base_lr, step_size, scale_fn, clr_iterations, max_lr, scale_mode):\n    cycle = np.floor(1 + clr_iterations / (2 * step_size))\n    x = np.abs(clr_iterations / step_size - 2 * cycle + 1)\n    if scale_mode == 'cycle':\n        return base_lr + (max_lr - base_lr) * np.maximum(0, 1 - x) * scale_fn(cycle)\n    else:\n        return base_lr + (max_lr - base_lr) * np.maximum(0, 1 - x) * scale_fn(clr_iterations)", "test_script": "import random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        base_lr = random.uniform(0.0001, 0.1)\n        step_size = random.randint(1, 100)\n        max_lr = base_lr + random.uniform(0.01, 0.5)\n        clr_iterations = random.randint(0, 1000)\n        scale_mode = random.choice(['cycle', 'iterations'])\n        def scale_fn(x):\n            return 1 / (2.0 ** (x - 1)) if x > 1 else 1\n\n        test_cases.append((base_lr, step_size, scale_fn, clr_iterations, max_lr, scale_mode))\n\n    return test_cases\n"}
{"problem_id": "keras_98", "library": "keras", "code_problem": "You are tasked with implementing a deep learning model based on the ResNet architecture using TensorFlow and Keras. The model should be able to classify images into a specified number of classes. The main function to implement is `resnet_v1`, which constructs the ResNet model based on the provided input shape, depth, and number of classes.\n\nFunction Signature:\n```python\ndef resnet_v1(input_shape, depth, num_classes=10):\n```\n\n### Constants Used:\n- `num_filters`: This constant is initialized to 16 and is used to determine the number of filters in the convolutional layers of the ResNet model.\n\n### Input Format:\n- `input_shape`: A tuple representing the shape of the input images (height, width, channels).\n- `depth`: An integer representing the depth of the ResNet model (number of layers).\n- `num_classes`: An integer representing the number of output classes (default is 10).\n\n### Output Format:\n- The function returns a Keras Model object that can be used for training and inference.\n\n```python\n# Input\ninput_shape = (32, 32, 3)\ndepth = 20\nnum_classes = 10\n\n# Output\nmodel = resnet_v1(input_shape, depth, num_classes)\nmodel.summary()  # This will print the model architecture\n``` \n\nIn this example, the input shape is a 32x32 image with 3 color channels, the depth of the ResNet model is 20, and it is configured to classify into 10 classes. The output will be the summary of the model architecture, which provides details about the layers and parameters in the model.", "ground_truth_code": "from tensorflow.keras.layers import Conv2D, BatchNormalization, Activation, Input, AveragePooling2D, Flatten, Dense\nfrom tensorflow.keras.regularizers import l2\nfrom tensorflow.keras.models import Model\nfrom tensorflow.keras import layers\n\n\ndef resnet_layer(inputs, num_filters=16, kernel_size=3, strides=1, activation='relu', batch_normalization=True,\n                 conv_first=True):\n    conv = Conv2D(num_filters, kernel_size=kernel_size, strides=strides, padding='same',\n                  kernel_initializer='he_normal', kernel_regularizer=l2(0.0001))\n    x = inputs\n    if conv_first:\n        x = conv(x)\n        if batch_normalization:\n            x = BatchNormalization()(x)\n        if activation is not None:\n            x = Activation(activation)(x)\n    else:\n        if batch_normalization:\n            x = BatchNormalization()(x)\n        if activation is not None:\n            x = Activation(activation)(x)\n        x = conv(x)\n    return x\n\n# main code\ndef resnet_v1(input_shape, depth, num_classes=10):\n\n    num_filters = 16\n    num_res_blocks = (depth - 2) // 6\n    inputs = Input(shape=input_shape)\n    x = resnet_layer(inputs=inputs)\n\n    for stack in range(3):\n        for res_block in range(num_res_blocks):\n            strides = 1\n            if stack > 0 and res_block == 0:\n                strides = 2\n            y = resnet_layer(inputs=x, num_filters=num_filters, strides=strides)\n            y = resnet_layer(inputs=y, num_filters=num_filters, activation=None)\n            if stack > 0 and res_block == 0:\n                x = resnet_layer(inputs=x, num_filters=num_filters, kernel_size=1, strides=strides, activation=None,\n                                 batch_normalization=False)\n            x = layers.add([x, y])\n            x = Activation('relu')(x)\n        num_filters *= 2\n\n    x = AveragePooling2D(pool_size=8)(x)\n    y = Flatten()(x)\n    outputs = Dense(num_classes, activation='softmax', kernel_initializer='he_normal')(y)\n\n    model = Model(inputs=inputs, outputs=outputs)\n    return model", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        height = np.random.choice([32, 64, 128])\n        width = height\n        channels = np.random.choice([1, 3])\n\n        n_blocks = np.random.randint(3, 10)\n        depth = 6 * n_blocks + 2\n\n        input_shape = (height, width, channels)\n        num_classes = np.random.choice([10, 100])\n\n        test_cases.append((input_shape, depth, num_classes))\n\n    return test_cases"}
{"problem_id": "keras_99", "library": "keras", "code_problem": "You are tasked with implementing a function that constructs a Region Proposal Network (RPN) graph for object detection using Keras and TensorFlow. The function will take a feature map and generate class logits, probabilities, and bounding box predictions based on anchor boxes.\n\nFunction signature:\n```python\ndef rpn_graph(feature_map, anchors_per_location, anchor_stride):\n```\n\nConstants used in the main code:\n- The number of filters for the shared convolutional layer is set to 512.\n- The kernel size for the convolutional layers is set to (3, 3) for the shared layer and (1, 1) for the classification and bounding box prediction layers.\n- The activation function for the shared layer is ReLU, while the classification layer uses a linear activation function.\n\nInput format:\n- `feature_map`: A tensor representing the feature map from a backbone network.\n- `anchors_per_location`: An integer representing the number of anchors per spatial location.\n- `anchor_stride`: An integer representing the stride used in the convolutional layers.\n\nOutput format:\n- Returns a tuple containing:\n  - `rpn_class_logits`: A tensor of shape `[batch_size, num_anchors, 2]` representing the raw class logits for each anchor.\n  - `rpn_probs`: A tensor of shape `[batch_size, num_anchors, 2]` representing the probabilities for each class for each anchor.\n  - `rpn_bbox`: A tensor of shape `[batch_size, num_anchors, 4]` representing the bounding box predictions for each anchor.\n\nInput:\n```python\nfeature_map = np.random.randn(2, 64, 64, 256).astype(np.float32)  # Batch size 2, height 64, width 64, channels 256\nanchors_per_location = 3  # Number of anchors per location\nanchor_stride = 1  # Stride for the anchors\n```\n\nOutput:\n```python\nrpn_class_logits, rpn_probs, rpn_bbox = rpn_graph(feature_map, anchors_per_location, anchor_stride)\n# rpn_class_logits shape: (2, 64*64*3, 2)\n# rpn_probs shape: (2, 64*64*3, 2)\n# rpn_bbox shape: (2, 64*64*3, 4)\n```", "ground_truth_code": "import keras.layers as KL\nimport tensorflow as tf\n\n# main code\ndef rpn_graph(feature_map, anchors_per_location, anchor_stride):\n    shared = KL.Conv2D(\n        filters=512,\n        kernel_size=(3, 3),\n        padding='same',\n        activation='relu',\n        strides=(anchor_stride, anchor_stride),\n        name='rpn_conv_shared'\n    )(feature_map)\n\n    x = KL.Conv2D(\n        filters=2 * anchors_per_location,\n        kernel_size=(1, 1),\n        padding='valid',\n        activation='linear',\n        name='rpn_class_raw'\n    )(shared)\n\n    rpn_class_logits = KL.Lambda(lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 2]))(x)\n    rpn_probs = KL.Activation('softmax', name='rpn_class_xxx')(rpn_class_logits)\n\n    x = KL.Conv2D(\n        filters=anchors_per_location * 4,\n        kernel_size=(1, 1),\n        padding='valid',\n        activation='linear',\n        name='rpn_bbox_pred'\n    )(shared)\n\n    rpn_bbox = KL.Lambda(lambda t: tf.reshape(t, [tf.shape(t)[0], -1, 4]))(x)\n\n    return rpn_class_logits, rpn_probs, rpn_bbox", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        batch_size = np.random.randint(1, 5)\n        height = np.random.randint(16, 128)\n        width = np.random.randint(16, 128)\n        channels = 256\n\n        feature_map = np.random.randn(batch_size, height, width, channels).astype(np.float32)\n        anchors_per_location = np.random.choice([3, 6, 9])\n        anchor_stride = np.random.choice([1, 2])\n\n        test_cases.append((feature_map, anchors_per_location, anchor_stride))\n\n    return test_cases"}
{"problem_id": "keras_100", "library": "keras", "code_problem": "You are tasked with creating a deep learning model for time series prediction using Keras. The model should be designed to process sequential data and output predictions based on a specified time window size. \n\nThe function signature for the main code is as follows:\n```python\ndef create_model(time_window_size, metric):\n```\n\nIn this function, a constant is used:\n- The number of filters in the convolutional layer is set to 256.\n- The kernel size for the convolutional layer is set to 5.\n- The pool size for the max pooling layer is set to 4.\n- The number of units in the dense layer is equal to the `time_window_size`.\n- The LSTM layer has 64 units.\n\nInput format:\n- The function takes two parameters:\n  - `time_window_size`: An integer representing the size of the time window for the input sequences.\n  - `metric`: A string representing the evaluation metric to be used during model training.\n\nOutput format:\n- The function returns a compiled Keras model that can be used for training on time series data. The model architecture is also printed to the console.\n\n```python\nInput: (time_window_size=25, metric='mean_absolute_error')\nOutput: Model Summary:\n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n conv1d (Conv1D)             (None, 25, 256)          1286      \n                                                                 \n max_pooling1d (MaxPooling1D  (None, 6, 256)          0         \n )                                                               \n                                                                 \n lstm (LSTM)                 (None, 64)               82560     \n                                                                 \n dense (Dense)               (None, 25)               1625      \n                                                                 \n=================================================================\nTotal params: 85,471\nTrainable params: 85,471\nNon-trainable params: 0\n_________________________________________________________________\n```", "ground_truth_code": "from keras.models import Sequential\nfrom keras.layers import Conv1D\nfrom keras.layers import MaxPooling1D\nfrom keras.layers import LSTM\nfrom keras.layers import Dense\n\n# main code\ndef create_model(time_window_size, metric):\n    model = Sequential()\n    model.add(Conv1D(filters=256, kernel_size=5, padding='same', activation='relu', input_shape=(time_window_size, 1)))\n    model.add(MaxPooling1D(pool_size=4))\n    model.add(LSTM(64))\n    model.add(Dense(units=time_window_size, activation='linear'))\n    model.compile(optimizer='adam', loss='mean_squared_error', metrics=[metric])\n    print(model.summary())\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        time_window_size = np.random.randint(10, 101)\n\n        metric = np.random.choice(['accuracy', 'mean_absolute_error'])\n        test_cases.append((time_window_size, metric))\n\n    return test_cases"}
{"problem_id": "keras_101", "library": "keras", "code_problem": "You are tasked with implementing a custom loss function for a binary classification problem using Keras. The function should compute a weighted binary cross-entropy loss, which allows for different importance to be assigned to positive and negative samples during training.\n\nFunction signature:\n```python\ndef weighted_bce_loss(y_true, y_pred, weight):\n```\n\nConstant used in the main code:\n- `epsilon = 1e-07`\n\nInput format:\n- `y_true`: A tensor of true binary labels (0 or 1).\n- `y_pred`: A tensor of predicted probabilities for the positive class (between 0 and 1).\n- `weight`: A tensor of weights corresponding to each sample.\n\nOutput format:\n- A scalar tensor representing the computed weighted binary cross-entropy loss.\n\n```python\n# Input\ny_true = np.array([[1, 0, 1], [0, 1, 0]])\ny_pred = np.array([[0.9, 0.1, 0.8], [0.2, 0.7, 0.3]])\nweight = np.array([[1, 1, 1], [1, 1, 1]])\n\n# Output\nloss = weighted_bce_loss(y_true, y_pred, weight)  # tf.Tensor(0.22839300363692283, shape=(), dtype=float64)\n```", "ground_truth_code": "import tensorflow as tf\n\n# main code\ndef weighted_bce_loss(y_true, y_pred, weight):\n    K = tf.keras.backend\n    epsilon = 1e-07\n    y_pred = K.clip(y_pred, epsilon, 1.0 - epsilon)\n    logit_y_pred = K.log(y_pred / (1.0 - y_pred))\n    loss = weight * (logit_y_pred * (1.0 - y_true) + K.log(1.0 + K.exp(-K.abs(logit_y_pred))) + K.maximum(-logit_y_pred, 0.0))\n    return K.sum(loss) / K.sum(weight)", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        batch_size = np.random.randint(1, 10)\n        num_features = np.random.randint(5, 20)\n        y_true = np.random.randint(0, 2, size=(batch_size, num_features))\n        y_pred = np.random.rand(batch_size, num_features)\n        weight = np.random.rand(batch_size, num_features)\n\n        test_cases.append((y_true, y_pred, weight))\n\n    return test_cases"}
{"problem_id": "keras_102", "library": "keras", "code_problem": "You are tasked with implementing a neural network model using Keras that takes in two types of inputs: the state of an environment and an action. The model will be designed to predict a single output value based on these inputs. The function signature for the main code is as follows:\n\n```python\ndef _build_net(lr, act_dim, env_dim):\n```\n\n### Constants:\n- The constant used in the main code is the number of neurons in the Dense layers, specifically 256 for the first layer and 128 for the second layer.\n\n### Input and Output Format:\n- **Input**: The function takes three parameters:\n  - `lr`: A float representing the learning rate for the optimizer.\n  - `act_dim`: An integer representing the dimensionality of the action input.\n  - `env_dim`: An integer representing the dimensionality of the state input.\n\n- **Output**: The function returns a Keras Model object that can be used for training and inference.\n\n```python\nInput: (0.0053, 7, 15)\nOutput: Model Summary: \n_________________________________________________________________\n Layer (type)                Output Shape              Param #   \n=================================================================\n input_1 (InputLayer)        [(None, 15)]             0         \n                                                                 \n dense (Dense)               (None, 256)              4096      \n                                                                 \n concatenate (Concatenate)    (None, 263)              0         \n                                                                 \n dense_1 (Dense)             (None, 128)              33792     \n                                                                 \n dense_2 (Dense)             (None, 1)                129       \n                                                                 \n=================================================================\nTotal params: 37017 (144.00 KB)\nTrainable params: 37017 (144.00 KB)\nNon-trainable params: 0 (0.00 Byte)\n_________________________________________________________________\n```", "ground_truth_code": "from keras.layers import Input, concatenate, Dense\nfrom keras.models import Model\nfrom keras.optimizers import Adam\nfrom keras.initializers import RandomUniform\n\n\n# main code\ndef _build_net(lr, act_dim, env_dim):\n    state = Input(shape=(env_dim,))\n    action = Input(shape=(act_dim,))\n    x = Dense(256, activation='relu')(state)\n    x = concatenate([x, action])\n    x = Dense(128, activation='relu')(x)\n    out = Dense(1, activation='linear', kernel_initializer=RandomUniform())(x)\n    model = Model([state, action], out)\n    model.compile(Adam(lr), 'mse')\n    model.summary()\n\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        lr = np.random.uniform(0.0001, 0.01)\n        act_dim = np.random.randint(1, 11)\n        env_dim = np.random.randint(5, 21)\n\n        test_cases.append((lr, act_dim, env_dim))\n\n    return test_cases"}
{"problem_id": "keras_103", "library": "keras", "code_problem": "You are tasked with creating a function that builds a simple neural network model using Keras. The model will take in a specified state dimension and action dimension, and it will consist of several layers with specific configurations. The function should validate the input dimensions and return the constructed model along with its trainable weights.\n\nFunction signature:\n```python\ndef build_simple_model(state_dim: int, action_dim: int) -> tuple\n```\n\nConstant used in the main code:\n- The constant value `64` is used to define the number of neurons in the hidden layers of the neural network.\n\nInput format:\n- Two integers: `state_dim` (the dimension of the input state) and `action_dim` (the dimension of the output action).\n\nOutput format:\n- A tuple containing the constructed Keras model and a list of its trainable weights, or `None` if the input dimensions are invalid.\n\n```python\nInput: (32, 4)\nOutput: (<keras.engine.training.Model object at 0x...>, [<tf.Variable 'dense/kernel:0' shape=(32, 64) dtype=float32, numpy=...>, <tf.Variable 'dense_1/kernel:0' shape=(64, 64) dtype=float32, numpy=...>, <tf.Variable 'dense_2/kernel:0' shape=(64, 4) dtype=float32, numpy=...>, <tf.Variable 'dense_2/bias:0' shape=(4,) dtype=float32, numpy=...>])\n```", "ground_truth_code": "from keras.layers import Input, Dense, Activation\nfrom keras.models import Model\nfrom keras import initializers\n\n# main code\ndef build_simple_model(state_dim, action_dim):\n    if not isinstance(state_dim, int) or not isinstance(action_dim, int) or state_dim <= 0 or (action_dim <= 0):\n        return None\n    input_obs = Input(shape=(state_dim,))\n    h = Dense(64, activation='relu', kernel_initializer=initializers.HeUniform())(input_obs)\n    h = Dense(64, activation='relu', kernel_initializer=initializers.HeUniform())(h)\n    h = Dense(action_dim, kernel_initializer=initializers.RandomUniform(minval=-0.1, maxval=0.1), bias_initializer=initializers.Zeros())(h)\n    pred = Activation('tanh')(h)\n    model = Model(inputs=input_obs, outputs=pred)\n    model.compile(optimizer='adam', loss='mean_squared_error')\n    return (model, model.trainable_weights)", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        state_dim = random.randint(1, 256)\n        action_dim = random.randint(1, 128)\n        if random.random() < 0.1:\n            state_dim = random.choice([-1, 0, None, 'invalid'])\n        if random.random() < 0.1:\n            action_dim = random.choice([-1, 0, None, 'invalid'])\n        test_cases.append((state_dim, action_dim))\n    return test_cases"}
{"problem_id": "lightgbm_0", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that initializes a LightGBM model using two subsets of data. The function will take in a dataset and its corresponding labels, along with two indices that specify the subsets of the data to be used for training. The goal is to train a model on the first subset and then use that model to train on the second subset.\n\nFunction signature:\n```python\ndef test_init_with_subset(data, y, subset_index_1, subset_index_2):\n```\n\nConstant used in the main code:\n- `params`: A dictionary containing the parameters for the LightGBM model, specifically `{'objective': 'binary', 'verbose': -1}`.\n\nInput format:\n- `data`: A 2D array-like structure representing the features of the dataset.\n- `y`: A 1D array-like structure representing the labels corresponding to the data.\n- `subset_index_1`: A list or array of indices specifying the first subset of data.\n- `subset_index_2`: A list or array of indices specifying the second subset of data.\n\nOutput format:\n- The function returns a trained LightGBM model object.\n\nInput:\n```python\ndata = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.3, 0.1], [0.5, 0.4, 0.6]])\ny = np.array([0, 1, 0, 1, 0])\nsubset_index_1 = np.array([0, 1, 2])\nsubset_index_2 = np.array([3, 4])\n```\n\nOutput:\n```python\nmodel  # This will be a LightGBM model object trained on the specified subsets.\n``` \n\n(Note: The actual output will be a trained LightGBM model object, which cannot be represented as a simple value. The model can be evaluated or used for predictions after training.)", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef test_init_with_subset(data, y, subset_index_1, subset_index_2):\n    lgb_train = lgb.Dataset(data, y, free_raw_data=False)\n\n    subset_data_1 = lgb_train.subset(subset_index_1)\n    subset_data_2 = lgb_train.subset(subset_index_2)\n\n    params = {'objective': 'binary', 'verbose': -1}\n    init_gbm = lgb.train(params=params, train_set=subset_data_1, num_boost_round=10, keep_training_booster=True)\n\n    model = lgb.train(params=params, train_set=subset_data_2, num_boost_round=10, init_model=init_gbm)\n\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n\n        data = np.random.rand(num_samples, num_features)\n        y = np.random.randint(0, 2, size=(num_samples,))\n\n        subset_index_1 = np.random.choice(num_samples, size=num_samples // 2, replace=False)\n        subset_index_2 = np.random.choice(num_samples, size=num_samples // 2, replace=False)\n\n        test_cases.append((data, y, subset_index_1, subset_index_2))\n\n    return test_cases"}
{"problem_id": "lightgbm_1", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to perform regression analysis on a given dataset. The function will train a model using specified parameters and make predictions based on new input data. The function signature is as follows:\n\n```python\ndef test_forced_bins(x, y):\n```\n\n### Constants Used:\n- `max_bin`: This constant is set to `5` initially and later updated to `11` in the code.\n\n### Input Format:\n- `x`: A 2D numpy array of shape (n_samples, n_features).\n- `y`: A 1D numpy array of shape (n_samples,).\n\n### Output Format:\n- A tuple containing:\n  - `predicted1`: A numpy array of predictions for the first set of new inputs.\n  - `predicted2`: A numpy array of predictions for the second set of new inputs.\n  - `predicted3`: A numpy array of predictions for the new inputs after re-training.\n  - `counts`: A numpy array of counts of unique predicted values from the final prediction.\n\nInput:\n```python\nx = np.array([[0.1, 0.2], [0.4, 0.5], [0.3, 0.1], [0.6, 0.7], [0.9, 0.8]])\ny = np.array([0.2, 0.5, 0.3, 0.7, 0.9])\n```\n\nOutput:\n```python\npredicted1 = np.array([0.5, 0.5, 0.5])\npredicted2 = np.array([0.5, 0.5, 0.5])\npredicted3 = np.array([0.5, 0.5, 0.5])\ncounts = np.array([2, 2])\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n# main code\ndef test_forced_bins(x, y):\n    params = {\n        'objective': 'regression_l1',\n        'max_bin': 5,\n        'num_leaves': 2,\n        'min_data_in_leaf': 1,\n        'verbose': -1\n    }\n\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n\n    new_x = np.zeros((3, x.shape[1]))\n    new_x[:, 0] = [0.31, 0.37, 0.41]\n    new_x[:, 1] = [0, 0, 0]\n    predicted1 = est.predict(new_x)\n\n    new_x[:, 0] = [0, 0, 0]\n    new_x[:, 1] = [-0.9, -0.6, -0.3]\n    predicted2 = est.predict(new_x)\n\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n    predicted3 = est.predict(new_x)\n\n    params['max_bin'] = 11\n    lgb_x = lgb.Dataset(x[:, :1], label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=50)\n    predicted4 = est.predict(x[1:, :1])\n    _, counts = np.unique(predicted4, return_counts=True)\n\n    return predicted1, predicted2, predicted3, counts", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(5, 50)\n        num_features = np.random.randint(2, 10)\n\n        x = np.random.uniform(-1, 1, (num_samples, num_features))\n        y = np.random.uniform(-1, 1, num_samples)\n\n        test_cases.append((x, y))\n    return test_cases"}
{"problem_id": "lightgbm_2", "library": "lightgbm", "code_problem": "```python\ndef evaluate_lightgbm_subsets(data, total_samples, subset_size_1, subset_size_2):\n```\n\nIn this code, the function `evaluate_lightgbm_subsets` is designed to evaluate a LightGBM model using two subsets of data derived from a larger dataset. The function takes in four parameters: `data`, which is the input dataset; `total_samples`, the total number of samples in the dataset; `subset_size_1`, the size of the first subset; and `subset_size_2`, the size of the second subset.\n\n### Constant Used:\n- The constant used in the main code is `10`, which represents the number of boosting rounds for training the LightGBM model.\n\n### Input and Output Format:\n- **Input Format**:\n  - `data`: A 2D array-like structure containing the features of the dataset.\n  - `total_samples`: An integer representing the total number of samples in the dataset.\n  - `subset_size_1`: An integer representing the size of the first subset to be used for training.\n  - `subset_size_2`: An integer representing the size of the second subset to be used for training.\n\n- **Output Format**:\n  - The function returns a tuple containing two LightGBM model objects: `(model_stage_1, final_model)`.\n\nInput:\n```python\ndata = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0], \n                 [0.2, 0.3], [0.4, 0.5], [0.6, 0.7], [0.8, 0.9], [1.0, 1.1]])\ntotal_samples = 10\nsubset_size_1 = 4\nsubset_size_2 = 4\n```\n\nOutput:\n```python\n(model_stage_1, final_model)  # where model_stage_1 and final_model are LightGBM model objects\n```", "ground_truth_code": "import lightgbm as lgb\nimport numpy as np\n\n# main code\ndef evaluate_lightgbm_subsets(data, total_samples, subset_size_1, subset_size_2):\n    labels = np.array([1] * (total_samples // 2) + [0] * (total_samples - total_samples // 2))\n    indices_1 = np.random.choice(total_samples, subset_size_1, replace=False)\n    indices_2 = np.random.choice(total_samples, subset_size_2, replace=False)\n    subset_1 = lgb.Dataset(data[indices_1], label=labels[indices_1], free_raw_data=False)\n    subset_2 = lgb.Dataset(data[indices_2], label=labels[indices_2], free_raw_data=False)\n    config = {'objective': 'binary', 'verbose': -1}\n    model_stage_1 = lgb.train(params=config, train_set=subset_1, num_boost_round=10, keep_training_booster=True)\n    final_model = lgb.train(params=config, train_set=subset_2, num_boost_round=10, init_model=model_stage_1)\n\n    return model_stage_1, final_model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        total_samples = np.random.randint(20, 100)\n        features = np.random.randint(1, 10)\n        subset_size_1 = np.random.randint(5, min(total_samples, max(5, total_samples // 2)))\n        subset_size_2 = np.random.randint(5, min(total_samples, max(5, total_samples // 2)))\n        data = np.random.rand(total_samples, features)\n\n        test_cases.append((data, total_samples, subset_size_1, subset_size_2))\n    return test_cases"}
{"problem_id": "lightgbm_3", "library": "lightgbm", "code_problem": "You are tasked with implementing a machine learning training routine using the LightGBM library. The main function, `run_training`, is designed to train a LightGBM model on a simple quadratic dataset. The function accepts a boolean parameter that determines whether to include a validation dataset during training.\n\nFunction signature:\n```python\ndef run_training(use_valid: bool) -> tuple:\n```\n\nConstant used in the main code:\n- The constant `num_boost_round` is set to `2` in the `train_fn` function, which specifies the number of boosting iterations for the LightGBM model.\n\nInput format:\n- The function `run_training` takes a single boolean argument `use_valid`.\n\nOutput format:\n- The function returns a tuple consisting of:\n  - A trained LightGBM model.\n  - A dictionary containing evaluation results from the training process.\n\nInput:\n```python\ntrain_ds = <lightgbm.basic.Dataset object at 0x...>\neval_result = {}\nvalid_names = ['train', 'valid']\nvalid_sets = [<lightgbm.basic.Dataset object at 0x...>, <lightgbm.basic.Dataset object at 0x...>]\n```\n\nOutput:\n```python\nbst = <lightgbm.basic.Booster object at 0x...>\neval_result = {'train': {'l2': [0.0, 0.0]}, 'valid': {'l2': [0.0, 0.0]}}\n``` \n\n(Note: The actual memory addresses and evaluation results may vary based on the execution environment and the specific data used.)", "ground_truth_code": "import lightgbm as lgb\nimport numpy as np\n\n\ndef train_fn(train_ds, eval_result, valid_names, valid_sets):\n    return lgb.train({'num_leaves': 5}, train_ds, num_boost_round=2,\n                     valid_sets=valid_sets, valid_names=valid_names,\n                     callbacks=[lgb.early_stopping(1), lgb.record_evaluation(eval_result)])\n\n# main code\ndef run_training(use_valid):\n    x = np.linspace(-1, 1, 100)\n    X = x.reshape(-1, 1)\n    y = x ** 2\n    X_train, X_valid = X[:80], X[80:]\n    y_train, y_valid = y[:80], y[80:]\n\n    train_ds = lgb.Dataset(X_train, y_train)\n    valid_ds = lgb.Dataset(X_valid, y_valid)\n    valid_sets = [train_ds]\n    valid_names = ['train']\n\n    if use_valid:\n        valid_sets.append(valid_ds)\n        valid_names.append('valid')\n\n    eval_result = {}\n    bst = train_fn(train_ds, eval_result, valid_names, valid_sets)\n\n    return bst, eval_result", "test_script": "import numpy as np\nimport lightgbm as lgb\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n\n        use_valid = np.random.choice([True, False])\n        x = np.linspace(-1, 1, 100)\n        X = x.reshape(-1, 1)\n        y = x ** 2\n        X_train, X_valid = X[:80], X[80:]\n        y_train, y_valid = y[:80], y[80:]\n        train_ds = lgb.Dataset(X_train, y_train)\n        valid_ds = lgb.Dataset(X_valid, y_valid)\n        valid_sets = [train_ds]\n        valid_names = ['train']\n        if use_valid:\n            valid_sets.append(valid_ds)\n            valid_names.append('valid')\n        eval_result = {}\n        test_cases.append((train_ds, eval_result, valid_names, valid_sets))\n    return test_cases"}
{"problem_id": "lightgbm_4", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that processes categorical features in a dataset and makes predictions using the LightGBM library. The function will take in training and testing datasets, convert specified columns to categorical types, and train multiple LightGBM models with varying configurations of categorical features. The predictions from these models will be returned in a dictionary.\n\nFunction signature:\n```python\ndef process_pandas_categorical(X: pd.DataFrame, y: pd.Series, X_test: pd.DataFrame) -> dict:\n```\n\nConstant used in the main code:\n- `cat_cols_actual`: A list of categorical column names, specifically `['A', 'B', 'C', 'D', 'E']`.\n\nInput format:\n- `X`: A pandas DataFrame containing the training features.\n- `y`: A pandas Series containing the target variable.\n- `X_test`: A pandas DataFrame containing the test features.\n\nOutput format:\n- A dictionary where keys are the model identifiers ('pred0', 'pred2', 'pred3', 'pred7', 'pred8') and values are the corresponding prediction results for the test dataset.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Training data\nX = pd.DataFrame({\n    'A': ['cat1', 'cat2', 'cat1', 'cat3', 'cat2'],\n    'B': ['cat2', 'cat1', 'cat3', 'cat1', 'cat2'],\n    'C': ['cat3', 'cat1', 'cat2', 'cat2', 'cat1'],\n    'D': ['cat1', 'cat3', 'cat2', 'cat1', 'cat3'],\n    'E': ['cat2', 'cat1', 'cat3', 'cat2', 'cat1'],\n    'num_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'num_1': [1.1, 1.2, 1.3, 1.4, 1.5]\n})\n\ny = pd.Series([0, 1, 0, 1, 0])\n\n# Test data\nX_test = pd.DataFrame({\n    'A': ['cat1', 'cat2', 'cat3'],\n    'B': ['cat3', 'cat1', 'cat2'],\n    'C': ['cat1', 'cat2', 'cat3'],\n    'D': ['cat2', 'cat1', 'cat3'],\n    'E': ['cat1', 'cat2', 'cat3'],\n    'num_0': [0.6, 0.7, 0.8],\n    'num_1': [1.6, 1.7, 1.8]\n})\n```\n\n**Output:**\n```python\n{\n   'pred0': array([0.4, 0.4, 0.4]), \n   'pred2': array([0.4, 0.4, 0.4]), \n   'pred3': array([0.4, 0.4, 0.4]), \n   'pred7': array([0.4, 0.4, 0.4]), \n   'pred8': array([0.4, 0.4, 0.4])\n}\n```", "ground_truth_code": "import lightgbm as lgb\nimport pandas as pd\n\n# main code\ndef process_pandas_categorical(X, y, X_test):\n    cat_cols_actual = ['A', 'B', 'C', 'D', 'E']  # Ensure 'E' is included\n    X[cat_cols_actual] = X[cat_cols_actual].astype('category')\n    X_test[cat_cols_actual] = X_test[cat_cols_actual].astype('category')\n\n    params = {'objective': 'binary', 'metric': 'binary_logloss', 'verbose': -1}\n\n    predictions = {}\n\n    lgb_train = lgb.Dataset(X, y)\n    gbm0 = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred0'] = gbm0.predict(X_test)\n\n    lgb_train = lgb.Dataset(X, pd.DataFrame(y), categorical_feature=['A'])\n    gbm2 = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred2'] = gbm2.predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=['A', 'B', 'C', 'D'])\n    gbm3 = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred3'] = gbm3.predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=['A', 'B', 'C', 'D', 'E'])\n    gbm6 = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred7'] = gbm6.predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=[])\n    gbm7 = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred8'] = gbm7.predict(X_test)\n\n    return predictions", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows_train = random.randint(50, 500)\n        num_rows_test = random.randint(20, 200)\n        num_features = 10\n        cat_cols = ['A', 'B', 'C', 'D', 'E']\n        num_cols = [f'num_{i}' for i in range(num_features - len(cat_cols))]\n        X_categorical = {col: np.random.choice(['cat1', 'cat2', 'cat3'], num_rows_train) for col in cat_cols}\n        X_test_categorical = {col: np.random.choice(['cat1', 'cat2', 'cat3'], num_rows_test) for col in cat_cols}\n        X_numerical = {col: np.random.randn(num_rows_train) for col in num_cols}\n        X_test_numerical = {col: np.random.randn(num_rows_test) for col in num_cols}\n        y = np.random.randint(0, 2, num_rows_train)\n        X = pd.DataFrame({**X_categorical, **X_numerical})\n        X_test = pd.DataFrame({**X_test_categorical, **X_test_numerical})\n        test_cases.append((X, y, X_test))\n\n    return test_cases"}
{"problem_id": "lightgbm_5", "library": "lightgbm", "code_problem": "The task is to implement a function that trains a LightGBM model on a given dataset and evaluates its performance using different configurations of categorical features. The function will take in a training dataset, a target variable, and a test dataset, and will return predictions from multiple models trained with varying categorical feature specifications.\n\nFunction signature:\n```python\ndef test_pandas_categorical(X, y, X_test):\n```\n\nConstant used in the main code:\n- `num_boost_round`: This constant is set to `10`, which specifies the number of boosting iterations for the LightGBM model training.\n\nInput format:\n- `X`: A pandas DataFrame containing the training features.\n- `y`: A pandas Series or a 1D array containing the target variable.\n- `X_test`: A pandas DataFrame containing the test features.\n\nOutput format:\n- A tuple containing four lists of predictions from the four different models trained with varying categorical feature specifications. Each list corresponds to the predictions made on `X_test`.\n\n**Input:**\n```python\nX = pd.DataFrame({\n    'A': ['a', 'b', 'c', 'a', 'b', 'c', 'd', 'a', 'b', 'c'],\n    'B': [1, 2, 3, 1, 2, 3, 1, 2, 3, 1],\n    'C': [0.1, 0.2, -0.1, 0.1, 0.2, -0.1, 0.2, 0.1, -0.1, 0.2],\n    'D': [True, False, True, False, True, False, True, False, True, False]\n})\ny = [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\nX_test = pd.DataFrame({\n    'A': ['a', 'b', 'e', 'a', 'b', 'c'],\n    'B': [1, 3, 1, 2, 3, 1],\n    'C': [0.1, -0.1, 0.2, 0.1, 0.2, 0.2],\n    'D': [True, False, True, False, True, False]\n})\n```\n\n**Output:**\n```python\npred0 = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\npred1 = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\npred2 = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\npred3 = [0.5, 0.5, 0.5, 0.5, 0.5, 0.5]\n```\n", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef test_pandas_categorical(X, y, X_test):\n    for col in ['A', 'B', 'C', 'D']:\n        X[col] = X[col].astype('category')\n        X_test[col] = X_test[col].astype('category')\n\n    params = {'objective': 'binary', 'metric': 'binary_logloss', 'verbose': -1}\n\n    lgb_train = lgb.Dataset(X, y)\n    gbm0 = lgb.train(params, lgb_train, num_boost_round=10)\n    pred0 = list(gbm0.predict(X_test))\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=[0])\n    gbm1 = lgb.train(params, lgb_train, num_boost_round=10)\n    pred1 = list(gbm1.predict(X_test))\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=['A'])\n    gbm2 = lgb.train(params, lgb_train, num_boost_round=10)\n    pred2 = list(gbm2.predict(X_test))\n\n    lgb_train = lgb.Dataset(X, y, categorical_feature=['A', 'B', 'C', 'D'])\n    gbm3 = lgb.train(params, lgb_train, num_boost_round=10)\n    pred3 = list(gbm3.predict(X_test))\n\n    return pred0, pred1, pred2, pred3", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X = pd.DataFrame({\n            'A': np.random.choice(['a', 'b', 'c', 'd'], size=300),\n            'B': np.random.choice([1, 2, 3], size=300),\n            'C': np.random.choice([0.1, 0.2, -0.1, -0.1, 0.2], size=300),\n            'D': np.random.choice([True, False], size=300)\n        })\n        y = np.random.choice([0, 1], size=300)\n        X_test = pd.DataFrame({\n            'A': np.random.choice(['a', 'b', 'e'], size=60),\n            'B': np.random.choice([1, 3], size=60),\n            'C': np.random.choice([0.1, -0.1, 0.2, 0.2], size=60),\n            'D': np.random.choice([True, False], size=60)\n        })\n        test_cases.append((X, y, X_test))\n    return test_cases\n"}
{"problem_id": "lightgbm_6", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM regression model on a given dataset and evaluates its performance using mean absolute error. The function should split the dataset into training and testing sets, train the model, and return the evaluation results.\n\nFunction signature:\n```python\ndef test_continue_train(X, y):\n```\n\nConstant used in the main code:\n- `test_size`: This constant is set to `0.1`, which indicates that 10% of the dataset will be used for testing, while the remaining 90% will be used for training.\n\nInput format:\n- The function takes two inputs:\n  - `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the features of the dataset.\n  - `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the target variable.\n\nOutput format:\n- The function returns a tuple:\n  - The first element is a float representing the mean absolute error of the model on the test set.\n  - The second element is a dictionary containing the evaluation results recorded during training.\n\nInput:\n```python\nX = np.array([[-0.123, 0.456, 0.789],\n              [0.234, -0.567, 0.890],\n              [0.345, 0.678, -0.901],\n              [0.456, -0.789, 0.012],\n              [0.567, 0.890, -0.123]])\ny = np.array([1.234, 2.345, 3.456, 4.567, 5.678])\n```\n\nOutput:\n```python\n(2.777500000476837, {'valid_0': OrderedDict([('l1', [2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563]), ('custom_mae', [2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563, 2.7774999737739563])])})\n```", "ground_truth_code": "from sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nfrom sklearn.metrics import mean_absolute_error\n\n# main code\ndef test_continue_train(X, y):\n    X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.1)\n    params = {'objective': 'regression', 'metric': 'l1', 'verbose': -1}\n    lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=False)\n    lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train, free_raw_data=False)\n    init_gbm = lgb.train(params, lgb_train, num_boost_round=20)\n    evals_result = {}\n    gbm = lgb.train(\n        params,\n        lgb_train,\n        num_boost_round=30,\n        valid_sets=lgb_eval,\n        feval=lambda p, d: ('custom_mae', mean_absolute_error(p, d.get_label()), False),\n        callbacks=[lgb.record_evaluation(evals_result)],\n        init_model=init_gbm\n    )\n    ret = mean_absolute_error(y_test, gbm.predict(X_test))\n    return ret, evals_result", "test_script": "import numpy as np\nfrom sklearn.datasets import make_regression\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n\n        X, y = make_regression(n_samples=num_samples, n_features=num_features, noise=0.1)\n        test_cases.append((X, y))\n\n    return test_cases"}
{"problem_id": "lightgbm_7", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to perform regression analysis on a given dataset. The function will train a model using specified parameters and make predictions based on different input scenarios. The function signature is as follows:\n\n```python\ndef test_forced_bins(x: np.ndarray, y: np.ndarray) -> tuple:\n```\n\n### Constants Used:\n- `max_bin`: This constant is initially set to `5` and later changed to `11` during the execution of the function.\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A 2D NumPy array of shape (n_samples, n_features).\n  - `y`: A 1D NumPy array of shape (n_samples,).\n\n- **Output**: \n  - A tuple containing four elements, each being a NumPy array of predicted values corresponding to the different scenarios described above.\n\nInput:\n```python\nx = np.array([[0.1, 0.2],\n              [0.4, 0.5],\n              [0.6, 0.7],\n              [0.8, 0.9],\n              [0.3, 0.1],\n              [0.2, 0.4],\n              [0.5, 0.6],\n              [0.9, 0.8],\n              [0.7, 0.3],\n              [0.0, 0.0]])\ny = np.array([0.1, 0.4, 0.6, 0.8, 0.3, 0.2, 0.5, 0.9, 0.7, 0.0])\n```\n\nOutput:\n```python\n(predicted_1, predicted_2, predicted_3, predicted_4) = (\n   array([0.21829667, 0.4938627 , 0.4938627 ]), \n   array([0.21829667, 0.21829667, 0.21829667]), \n   array([0.21829667, 0.21829667, 0.21829667]), \n   array([0.50332249, 0.50332249, 0.7709722 , 0.19977609, 0.19977609,\n       0.50332249, 0.7709722 , 0.7709722 , 0.02165989])\n)\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n# main code\ndef test_forced_bins(x, y):\n    params = {\n        'objective': 'regression_l1',\n        'max_bin': 5,\n        'num_leaves': 2,\n        'min_data_in_leaf': 1,\n        'verbose': -1\n    }\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n    new_x = np.zeros((3, x.shape[1]))\n    new_x[:, 0] = [0.31, 0.37, 0.41]\n    new_x[:, 1] = [0, 0, 0]\n    predicted_1 = est.predict(new_x)\n    new_x[:, 0] = [0, 0, 0]\n    new_x[:, 1] = [-0.9, -0.6, -0.3]\n    predicted_2 = est.predict(new_x)\n    params['forcedbins_filename'] = ''\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n    predicted_3 = est.predict(new_x)\n    params['max_bin'] = 11\n    lgb_x = lgb.Dataset(x[:, :1], label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=50)\n    predicted_4 = est.predict(x[1:, :1])\n    return predicted_1, predicted_2, predicted_3, predicted_4", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        x = np.random.rand(100, 2)\n        y = np.random.rand(100)\n        test_cases.append((x, y))\n    return test_cases"}
{"problem_id": "lightgbm_8", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that evaluates the performance of a multi-class classification model using the LightGBM library. The function will compute the top-k error rates for a given dataset, which indicates the proportion of instances where the true class is not among the top k predicted classes.\n\nFunction signature:\n```python\ndef test_multi_class_error(X, y):\n```\n\nIn this function, the following constant is used:\n- `num_boost_round`: This constant is set to `10`, which specifies the number of boosting iterations for the LightGBM model training.\n\nInput format:\n- `X`: A 2D numpy array of shape (n_samples, n_features) representing the feature data.\n- `y`: A 1D numpy array of shape (n_samples,) representing the true class labels.\n\nOutput format:\n- A tuple containing three float values representing the top-1, top-2, and top-3 error rates, respectively.\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, \n               0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0],\n              [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, \n               0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1],\n              [0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, \n               0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2],\n              [0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, \n               0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3],\n              [0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4, \n               0.5, 0.6, 0.7, 0.8, 0.9, 1.0, 0.1, 0.2, 0.3, 0.4]])\ny = np.array([0, 1, 2, 3, 4])\n```\n\nOutput:\n```python\n(err_1, err_2, err_3) = (1.0, 1.0, 1.0)\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\ndef top_k_error(y_true, y_pred, k):\n    if k == y_pred.shape[1]:\n        return 0\n    max_rest = np.max(-np.partition(-y_pred, k)[:, k:], axis=1)\n    return 1 - np.mean(y_pred[np.arange(len(y_true)), y_true] > max_rest)\n\n# main code\ndef test_multi_class_error(X, y):\n    params = {'objective': 'multiclass', 'num_classes': len(np.unique(y)), 'metric': 'multi_error', 'num_leaves': 4,\n              'verbose': -1}\n    lgb_data = lgb.Dataset(X, label=y)\n\n    est = lgb.train(dict(params, multi_error_top_k=1), lgb_data, num_boost_round=10, valid_sets=[lgb_data])\n    predict_1 = est.predict(X)\n    err_1 = top_k_error(y, predict_1, 1)\n\n    est = lgb.train(dict(params, multi_error_top_k=2), lgb_data, num_boost_round=10, valid_sets=[lgb_data])\n    predict_2 = est.predict(X)\n    err_2 = top_k_error(y, predict_2, 2)\n\n    est = lgb.train(dict(params, multi_error_top_k=3), lgb_data, num_boost_round=10, valid_sets=[lgb_data])\n    predict_3 = est.predict(X)\n    err_3 = top_k_error(y, predict_3, 3)\n\n    return err_1, err_2, err_3", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X = np.random.rand(100, 20)\n        y = np.random.randint(0, 10, 100)\n        test_cases.append((X, y))\n    return test_cases\n"}
{"problem_id": "lightgbm_9", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using the DART (Dropouts meet Multiple Additive Regression Trees) boosting technique for regression tasks. The function will split the provided dataset into training and testing sets, train the model, and evaluate its performance using the Mean Absolute Error (MAE) metric.\n\nFunction Signature:\n```python\ndef test_continue_train_dart(X, y):\n```\n\nConstant used in the main code:\n- `test_size`: This constant is set to `0.1`, which indicates that 10% of the dataset will be used for testing, while the remaining 90% will be used for training.\n\nInput format:\n- The function takes two inputs:\n  - `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature set.\n  - `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the target values.\n\nOutput format:\n- The function returns a single floating-point number representing the Mean Absolute Error (MAE) of the model's predictions on the test dataset.\n\n```python\n# Input\nX = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.3, 0.1], [0.5, 0.4, 0.6]])\ny = np.array([0.3, 0.6, 0.9, 0.4, 0.5])\n\n# Output\nmean_absolute_error_value = test_continue_train_dart(X, y) # 0.0750000014901161\n```", "ground_truth_code": "from sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nfrom sklearn.metrics import mean_absolute_error\n\n\ndef test_continue_train_dart(X, y):\n    (X_train, X_test, y_train, y_test) = train_test_split(X, y, test_size=0.1, random_state=42)\n    params = {'boosting_type': 'dart', 'objective': 'regression', 'metric': 'l1', 'verbose': -1}\n\n    lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=False)\n    lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train, free_raw_data=False)\n\n    init_gbm = lgb.train(params, lgb_train, num_boost_round=50)\n    evals_result = {}\n\n    gbm = lgb.train(\n        params, lgb_train, num_boost_round=50, valid_sets=lgb_eval,\n        callbacks=[lgb.record_evaluation(evals_result)], init_model=init_gbm\n    )\n\n    ret = mean_absolute_error(y_test, gbm.predict(X_test))\n    return ret", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(100, 500)\n        num_features = np.random.randint(5, 50)\n\n        # Generate random X matrix and y vector\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.rand(num_samples)\n\n        test_cases.append((X, y))\n\n    return test_cases"}
{"problem_id": "lightgbm_10", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to train a model on a given dataset and retrieve the split value histogram for specific features. The function will take in two parameters: a feature matrix `X` and a target vector `y`. The function will train a LightGBM model using the provided data, and then it will compute and return the split value histogram for the first feature in the dataset.\n\nFunction signature:\n```python\ndef test_get_split_value_histogram(X, y):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `num_boost_round`, which is set to `20`. This constant defines the number of boosting iterations for the LightGBM model training.\n\nInput format:\n- The input consists of two parameters:\n  - `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature matrix.\n  - `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the target vector.\n\nOutput format:\n- The output is the split value histogram for the first feature, returned as a data structure that represents the histogram values, which may vary based on the implementation of the LightGBM library.\n\nInput:\n```python\nX = np.array([[0.1, 2.3, 0, 4.5],\n              [1.2, 3.4, 1, 5.6],\n              [2.3, 4.5, 2, 6.7],\n              [3.4, 5.6, 3, 7.8],\n              [4.5, 6.7, 4, 8.9]])\ny = np.array([0, 1, 0, 1, 0])\n```\n\nOutput:\n```python\n(array([0]), array([0., 1.]))\n```", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef test_get_split_value_histogram(X, y):\n    model = lgb.train({'verbose': -1}, lgb.Dataset(X, y, categorical_feature=[2]), num_boost_round=20)\n    feature_indices = [0, model.feature_name()[0], X.shape[-1] - 1, model.feature_name()[X.shape[-1] - 1]]\n\n    for feature in feature_indices:\n        model.get_split_value_histogram(feature, xgboost_style=True)\n\n    return model.get_split_value_histogram(0, bins='auto')", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(4, 20)\n\n        X = np.random.rand(num_samples, num_features) * 10\n        X[:, 2] = np.random.choice([0, 1, 2, 3, 4], size=num_samples)\n\n        y = np.random.randint(0, 2, size=num_samples)\n\n        test_cases.append((X, y))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_11", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that computes the split value histogram for a given feature in a dataset using the LightGBM library. The function will take in a feature index and return the histogram of split values for that feature based on the provided dataset.\n\nFunction signature:\n```python\ndef compute_split_value_histogram(X, y, feature_index, bins='auto', xgboost_style=True):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `num_boost_round`, which is set to `20`.\n\nInput format:\n- `X`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the feature matrix.\n- `y`: A 1D array-like structure (e.g., a list or a NumPy array) representing the target variable.\n- `feature_index`: An integer representing the index of the feature for which the split value histogram is to be computed.\n- `bins`: A string or integer specifying the binning strategy for the histogram (default is 'auto').\n- `xgboost_style`: A boolean indicating whether to use the XGBoost style for the histogram (default is True).\n\nOutput format:\n- The function returns a histogram of split values for the specified feature index, which is typically a list or array containing the counts of split values in each bin.\n\nInput:\n```python\nX = np.array([[1.5, 2.3, 3.1],\n              [4.2, 5.1, 6.3],\n              [7.4, 8.2, 9.0],\n              [2.1, 3.4, 1.2],\n              [5.5, 6.6, 7.7]])\ny = np.array([1.0, 2.0, 3.0, 4.0, 5.0])\nfeature_index = 1\nbins = 'auto'\nxgboost_style = True\n```\n\nOutput:\n```python\nEmpty DataFrame\nColumns: [SplitValue, Count]\nIndex: []\n```", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef compute_split_value_histogram(X, y, feature_index, bins='auto', xgboost_style=True):\n    lgb_train = lgb.Dataset(X, y, categorical_feature=[2])\n    gbm = lgb.train({'verbose': -1}, lgb_train, num_boost_round=20)\n\n    return gbm.get_split_value_histogram(feature_index, bins=bins, xgboost_style=xgboost_style)", "test_script": "import numpy as np\n\ndef generate_synthetic_data(samples, features):\n    X = np.random.rand(samples, features) * 10\n    y = np.random.rand(samples) * 10\n    return X, y\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        samples = np.random.randint(50, 100)\n        features = np.random.randint(2, 10)\n        X, y = generate_synthetic_data(samples=samples, features=features)\n        feature_index = np.random.randint(0, X.shape[1])\n        bins = 'auto'\n        xgboost_style = np.random.choice([True, False])\n\n        test_cases.append((X, y, feature_index, bins, xgboost_style))\n    return test_cases"}
{"problem_id": "lightgbm_12", "library": "lightgbm", "code_problem": "```python\ndef test_validate_features(X, y):\n```\n\nIn this function, the goal is to train a LightGBM model using a given dataset and then perform predictions and refitting on a modified version of the dataset. The function takes two parameters: `X`, which is expected to be a feature matrix, and `y`, which is the target variable.\n\n### Constant Used:\n- The constant used in the main code is `num_leaves`, which is set to `15`, and `num_boost_round`, which is set to `10`.\n\n### Input and Output Format:\n- **Input**: The function takes two inputs:\n  - `X`: A 2D array-like structure representing the feature matrix.\n  - `y`: A 1D array-like structure representing the target variable.\n\n- **Output**: The function returns a trained LightGBM model object.\n\nInput:\n```python\nX = np.array([[0.5, -1.2, 3.1, 0.0],\n              [1.5, 0.3, -0.5, 2.2],\n              [-0.3, 0.8, 1.5, -1.1],\n              [2.1, -0.7, 0.0, 1.3]])\ny = np.array([0.1, 0.4, -0.2, 0.5])\n```\n\nOutput:\n```python\n<lightgbm.basic.Booster object at 0x7f8c1c0e3c40>\n``` \n", "ground_truth_code": "from lightgbm.compat import pd_DataFrame\nimport lightgbm as lgb\n\n\ndef test_validate_features(X, y):\n    features = ['x1', 'x2', 'x3', 'x4']\n    df = pd_DataFrame(X, columns=features)\n    ds = lgb.Dataset(df, y)\n    bst = lgb.train({'num_leaves': 15, 'verbose': -1}, ds, num_boost_round=10)\n\n    df2 = df.rename(columns={'x3': 'z'})\n    bst.predict(df2, validate_features=False)\n    bst.refit(df2, y, validate_features=False)\n\n    return bst", "test_script": "import numpy as np\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 200)\n        X = np.random.randn(num_samples, 4)\n        y = np.random.randn(num_samples)\n        test_cases.append((X, y))\n    return test_cases"}
{"problem_id": "lightgbm_13", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model for predicting quantities based on provided training and testing datasets. The function should preprocess the data, set up the model parameters, and handle the training process with appropriate callbacks for logging and early stopping.\n\nFunction signature:\n```python\ndef train(train_data, test_data, iter_num):\n```\n\n### Constants Used:\n- The random seed is set to `23` for reproducibility.\n\n### Input Format:\n- `train_data`: A pandas DataFrame containing the training data with columns including 'date' and 'quantity'.\n- `test_data`: A pandas DataFrame containing the testing data with columns including 'date' and 'quantity'.\n- `iter_num`: An integer representing the number of iterations for training (can be `None`).\n\n### Output Format:\n- The function returns a trained LightGBM model object.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample training data\ntrain_data = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'feature_2': [0.2, 0.3, 0.4, 0.5, 0.6],\n    'feature_3': [0.6, 0.5, 0.4, 0.3, 0.2],\n    'feature_4': [0.3, 0.2, 0.1, 0.0, 0.1],\n    'feature_5': [0.4, 0.3, 0.2, 0.1, 0.0],\n    'feature_6': [0.5, 0.6, 0.7, 0.8, 0.9],\n    'feature_7': [0.9, 0.8, 0.7, 0.6, 0.5],\n    'feature_8': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_9': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'date': pd.date_range(start='2020-01-01', periods=5),\n    'quantity': [10, 20, 30, 40, 50]\n})\n\n# Sample testing data\ntest_data = pd.DataFrame({\n    'feature_0': [0.2, 0.3, 0.4],\n    'feature_1': [0.4, 0.3, 0.2],\n    'feature_2': [0.3, 0.4, 0.5],\n    'feature_3': [0.5, 0.4, 0.3],\n    'feature_4': [0.2, 0.1, 0.0],\n    'feature_5': [0.3, 0.2, 0.1],\n    'feature_6': [0.6, 0.7, 0.8],\n    'feature_7': [0.8, 0.7, 0.6],\n    'feature_8': [0.2, 0.3, 0.4],\n    'feature_9': [0.4, 0.3, 0.2],\n    'date': pd.date_range(start='2022-01-01', periods=3),\n    'quantity': [15, 25, 35]\n})\n\niter_num = 1000\n```\n\nOutput:\n```python\n# The output will be the trained LightGBM model object\nmodel = train(train_data, test_data, iter_num)\n<lightgbm.basic.Booster object at 0x76fa438cb280>\n```\n", "ground_truth_code": "import lightgbm as lgb\nimport random\nfrom lightgbm import log_evaluation\nfrom lightgbm import early_stopping\nimport numpy as np\n\n# main code\ndef train(train_data, test_data, iter_num):\n    X_train = train_data.drop(['date', 'quantity'], axis=1)\n    X_test = test_data.drop(['date', 'quantity'], axis=1)\n    y_train = train_data['quantity']\n    y_test = test_data['quantity']\n\n    train_data = lgb.Dataset(X_train, label=y_train, free_raw_data=True)\n    test_data = lgb.Dataset(X_test, label=y_test, free_raw_data=True)\n\n    lgb_params = {\n        'boosting_type': 'gbdt',\n        'objective': 'tweedie',\n        'tweedie_variance_power': 1.1,\n        'metric': 'rmse',\n        'subsample': 0.5,\n        'subsample_freq': 1,\n        'learning_rate': 0.015,\n        'num_leaves': 2 ** 11 - 1,\n        'min_data_in_leaf': 2 ** 12 - 1,\n        'feature_fraction': 0.5,\n        'max_bin': 100,\n        'n_estimators': 3000,\n        'boost_from_average': False,\n        'verbose': -1\n    }\n\n    if iter_num is not None:\n        lgb_params['num_iterations'] = iter_num\n\n    np.random.seed(23)\n    random.seed(23)\n\n    callbacks = [\n        log_evaluation(period=10),\n        early_stopping(stopping_rounds=30)\n    ]\n\n    model = lgb.train(lgb_params, train_data, valid_sets=[train_data, test_data], callbacks=callbacks)\n\n    return model", "test_script": "import pandas as pd\nimport numpy as np\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    num_features = 10\n    num_train_samples = 1000\n    num_test_samples = 200\n\n    for _ in range(n):\n        date_range_train = pd.date_range(start='2020-01-01', periods=num_train_samples, freq='D')\n        date_range_test = pd.date_range(start='2022-01-01', periods=num_test_samples, freq='D')\n        X_train = np.random.rand(num_train_samples, num_features)\n        X_test = np.random.rand(num_test_samples, num_features)\n        y_train = np.random.randint(1, 100, size=num_train_samples)\n        y_test = np.random.randint(1, 100, size=num_test_samples)\n        train_data = pd.DataFrame(X_train, columns=[f'feature_{i}' for i in range(num_features)])\n        train_data['date'] = date_range_train\n        train_data['quantity'] = y_train\n        test_data = pd.DataFrame(X_test, columns=[f'feature_{i}' for i in range(num_features)])\n        test_data['date'] = date_range_test\n        test_data['quantity'] = y_test\n        iter_num = random.choice([None, 100, 500, 1000, 2000])\n        test_cases.append((train_data, test_data, iter_num))\n    return test_cases"}
{"problem_id": "lightgbm_14", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that evaluates the performance of a LightGBM model using different configurations and metrics. The function will take in a feature matrix and a target vector, train multiple models, and return the evaluation results for each model.\n\nFunction signature:\n```python\ndef test_auc_mu(X: np.ndarray, y: np.ndarray) -> tuple:\n```\n\n### Constants Used:\n- The constant `num_boost_round` is set to `10` for most training instances, except for one where it is set to `100`.\n\n### Input Format:\n- `X`: A 2D NumPy array of shape (n_samples, n_features).\n- `y`: A 1D NumPy array of shape (n_samples,).\n\n### Output Format:\n- A tuple containing six dictionaries with evaluation results from different model training configurations. Each dictionary corresponds to the results of a specific training scenario.\n\nInput:\n```python\nX = np.array([[ 0.5, -1.2,  0.3],\n              [ 1.5,  0.0, -0.5],\n              [-0.3,  0.8,  1.2],\n              [ 0.1, -0.4,  0.7],\n              [ 0.9,  1.1, -0.2],\n              [-1.0,  0.5,  0.4],\n              [ 0.2, -0.3,  1.0],\n              [ 1.2,  0.9, -1.1],\n              [-0.5,  0.6,  0.3],\n              [ 0.4, -0.2,  1.5]], dtype=np.float32)\n\ny = np.array([0, 1, 0, 1, 0, 1, 0, 1, 0, 1], dtype=np.int32)\n```\n\nOutput:\n```python\n(\n   {'training': OrderedDict([('auc_mu', [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])])}, \n   {'training': OrderedDict([('auc', [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])])}, \n   {'training': OrderedDict([('auc_mu', [0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5, 0.5])])},\n   {'training': OrderedDict([('auc_mu', [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])])}, \n   {'training': OrderedDict([('auc_mu', [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])])}, \n   {'training': OrderedDict([('auc_mu', [nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan, nan])])}\n)\n\n```\n", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n\ndef test_auc_mu(X, y):\n    y_new = np.zeros(len(y))\n    y_new[y != 0] = 1\n    lgb_X = lgb.Dataset(X, label=y_new)\n\n    params = {'objective': 'multiclass', 'metric': 'auc_mu', 'verbose': -1, 'num_classes': 2, 'seed': 0}\n    results_auc_mu = {}\n    lgb.train(params, lgb_X, num_boost_round=10, valid_sets=[lgb_X], callbacks=[lgb.record_evaluation(results_auc_mu)])\n\n    params = {'objective': 'binary', 'metric': 'auc', 'verbose': -1, 'seed': 0}\n    results_auc = {}\n    lgb.train(params, lgb_X, num_boost_round=10, valid_sets=[lgb_X], callbacks=[lgb.record_evaluation(results_auc)])\n\n    lgb_X = lgb.Dataset(X[:10], label=y_new[:10])\n    params = {'objective': 'multiclass', 'metric': 'auc_mu', 'verbose': -1, 'num_classes': 2, 'min_data_in_leaf': 20,\n              'seed': 0}\n    results_auc_mu_small = {}\n    lgb.train(params, lgb_X, num_boost_round=10, valid_sets=[lgb_X],\n              callbacks=[lgb.record_evaluation(results_auc_mu_small)])\n\n    lgb_X = lgb.Dataset(X, label=y)\n    lgb_X_weighted = lgb.Dataset(X, label=y, weight=np.abs(np.random.standard_normal(size=y.shape)))\n\n    results_unweighted = {}\n    results_weighted = {}\n    params = dict(params, num_classes=10, num_leaves=5)\n\n    lgb.train(params, lgb_X, num_boost_round=10, valid_sets=[lgb_X],\n              callbacks=[lgb.record_evaluation(results_unweighted)])\n    lgb.train(params, lgb_X_weighted, num_boost_round=10, valid_sets=[lgb_X_weighted],\n              callbacks=[lgb.record_evaluation(results_weighted)])\n\n    lgb_X_weighted = lgb.Dataset(X, label=y, weight=np.ones(y.shape) * 0.5)\n    lgb.train(params, lgb_X_weighted, num_boost_round=10, valid_sets=[lgb_X_weighted],\n              callbacks=[lgb.record_evaluation(results_weighted)])\n\n    X = X[:10, :]\n    y = y[:10]\n    lgb_X = lgb.Dataset(X, label=y)\n    params = {'objective': 'multiclass', 'metric': 'auc_mu', 'num_classes': 10, 'min_data_in_leaf': 1, 'verbose': -1}\n    results = {}\n    lgb.train(params, lgb_X, num_boost_round=100, valid_sets=[lgb_X], callbacks=[lgb.record_evaluation(results)])\n\n    return results_auc_mu, results_auc, results_auc_mu_small, results_unweighted, results_weighted, results", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 50)\n        X = np.random.randn(num_samples, num_features).astype(np.float32)\n        y = np.random.randint(0, 10, size=num_samples).astype(np.int32)\n\n        test_cases.append((X, y))\n    return test_cases"}
{"problem_id": "lightgbm_15", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to predict probabilities for a binary classification problem based on training, validation, and test datasets. The function will train a model multiple times, each time using a different subset of the validation data, and will return the average predicted probabilities for the test set.\n\nFunction signature:\n```python\ndef model_predict(train_set, val_set, test_set, val_ratio, n_round, random_state):\n```\n\n### Constants:\n- The learning rate for the LightGBM model is set to `0.01`.\n- The boosting type is set to `gbdt`.\n- The objective function is set to `binary`.\n- The evaluation metric is set to `auc`.\n- The number of leaves in the model is set to `31`.\n\n### Input Format:\n- `train_set`: A DataFrame containing the training data with columns including `user_id`, `label`, and feature columns.\n- `val_set`: A DataFrame containing the validation data with columns including `user_id`, `label`, and feature columns.\n- `test_set`: A DataFrame containing the test data with columns including `user_id` and feature columns.\n- `val_ratio`: A float representing the fraction of the validation set to sample for each training iteration.\n- `n_round`: An integer representing the number of training iterations to perform.\n- `random_state`: An integer used for random seed initialization to ensure reproducibility.\n\n### Output Format:\n- The function returns a DataFrame containing:\n  - `user_id`: The unique identifier for each user.\n  - `prob`: The average predicted probability of the positive class for each user in the test set.\n\n**Input:**\n```python\ntrain_set = pd.DataFrame({\n    'user_id': [0, 1, 2, 3, 4],\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'label': [0, 1, 0, 1, 0]\n})\n\nval_set = pd.DataFrame({\n    'user_id': [5, 6, 7, 8, 9],\n    'feature_0': [0.6, 0.7, 0.8, 0.9, 1.0],\n    'feature_1': [1.0, 0.9, 0.8, 0.7, 0.6],\n    'label': [1, 0, 1, 0, 1]\n})\n\ntest_set = pd.DataFrame({\n    'user_id': [10, 11, 12],\n    'feature_0': [0.2, 0.3, 0.4],\n    'feature_1': [0.4, 0.5, 0.6],\n    'label': [0, 1, 0]\n})\n\nval_ratio = 0.3\nn_round = 5\nrandom_state = 42\n```\n\n**Output:**\n```python\n   user_id   prob  prob_0  prob_1  prob_2  prob_3  prob_4\n0       10  0.525   0.625   0.375     0.5     0.5   0.625\n1       11  0.525   0.625   0.375     0.5     0.5   0.625\n2       12  0.525   0.625   0.375     0.5     0.5   0.625\n```", "ground_truth_code": "import pandas as pd\nimport lightgbm as lgb\n\n# main code\ndef model_predict(train_set, val_set, test_set, val_ratio, n_round, random_state):\n    res = test_set[['user_id']].copy()\n    test_x = test_set.drop(['user_id', 'label'], axis=1)\n    res['prob'] = 0\n\n    params = {'learning_rate': 0.01, 'boosting_type': 'gbdt', 'objective': 'binary', 'metric': 'auc', 'num_leaves': 31,\n              'random_state': random_state}\n\n    for i in range(n_round):\n        val = val_set.sample(frac=val_ratio)\n        val_train = val_set.loc[~val_set['user_id'].isin(val['user_id'])]\n        train = pd.concat([train_set, val_train], axis=0)\n        train_y, train_x = train['label'], train.drop(['user_id', 'label'], axis=1)\n        val_y, val_x = val['label'], val.drop(['user_id', 'label'], axis=1)\n\n        valid_data = lgb.Dataset(val_x, label=val_y)\n        clf = lgb.train(params, lgb.Dataset(train_x, label=train_y), 1000,\n                        valid_sets=[valid_data],\n                        callbacks=[lgb.early_stopping(50), lgb.log_evaluation(100)])\n\n        temp_predict = clf.predict(test_x, num_iteration=clf.best_iteration)\n\n        res[f'prob_{i}'] = temp_predict\n\n    res['prob'] = res[[f'prob_{i}' for i in range(n_round)]].mean(axis=1)\n    return res", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_users = random.randint(50, 100)\n        num_features = random.randint(5, 10)\n\n        train_user_ids = np.arange(num_users)\n        train_labels = np.random.randint(0, 2, size=num_users)\n        train_features = np.random.rand(num_users, num_features)\n        train_set = pd.DataFrame(train_features, columns=[f'feature_{i}' for i in range(num_features)])\n        train_set.insert(0, 'user_id', train_user_ids)\n        train_set['label'] = train_labels\n\n        val_user_ids = np.arange(num_users, num_users * 2)\n        val_labels = np.random.randint(0, 2, size=num_users)\n        val_features = np.random.rand(num_users, num_features)\n        val_set = pd.DataFrame(val_features, columns=[f'feature_{i}' for i in range(num_features)])\n        val_set.insert(0, 'user_id', val_user_ids)\n        val_set['label'] = val_labels\n\n        test_user_ids = np.arange(num_users * 2, num_users * 3)\n        test_features = np.random.rand(num_users, num_features)\n        test_set = pd.DataFrame(test_features, columns=[f'feature_{i}' for i in range(num_features)])\n        test_set.insert(0, 'user_id', test_user_ids)\n        test_set['label'] = np.random.randint(0, 2, size=num_users)\n\n        val_ratio = random.uniform(0.1, 0.5)\n        n_round = random.randint(1, 10)\n        random_state = random.randint(0, 1000)\n\n        test_cases.append((train_set, val_set, test_set, val_ratio, n_round, random_state))\n\n    return test_cases"}
{"problem_id": "lightgbm_16", "library": "lightgbm", "code_problem": "The task is to implement a function that utilizes the LightGBM library to perform regression analysis on a given dataset. The function will train a model using specified parameters and make predictions based on different input scenarios. The function signature is as follows:\n\n```python\ndef test_forced_bins(x: np.ndarray, y: np.ndarray) -> tuple:\n```\n\n### Constants Used:\n- `max_bin`: This constant is set to `5` initially and later changed to `11` in the function.\n\n### Input and Output Format:\n- **Input**: \n  - `x`: A 2D NumPy array of shape (n_samples, n_features).\n  - `y`: A 1D NumPy array of shape (n_samples,).\n\n- **Output**: \n  - A tuple containing four elements, each being a NumPy array of predicted values corresponding to the different input scenarios.\n\nInput:\n```python\nx = np.array([[0.1, -0.1],\n              [0.2, -0.2],\n              [0.3, -0.3],\n              [0.4, -0.4],\n              [0.5, -0.5],\n              [0.6, -0.6],\n              [0.7, -0.7],\n              [0.8, -0.8],\n              [0.9, -0.9],\n              [1.0, -1.0]])\ny = np.array([0, 0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9])\n```\n\nOutput:\n```python\n(\n   array([0.1984467, 0.1984467, 0.1984467]), \n   array([0.38429077, 0.26386484, 0.1984467 ]), \n   array([0.38429077, 0.26386484, 0.1984467 ]), \n   array([0.12902781, 0.12902781, 0.39667751, 0.39667751, 0.39667751,\n       0.7002239 , 0.7002239 , 0.7002239 , 0.87834009])\n)\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n# main code\ndef test_forced_bins(x, y):\n    params = {\n        'objective': 'regression_l1',\n        'max_bin': 5,\n        'num_leaves': 2,\n        'min_data_in_leaf': 1,\n        'verbose': -1\n    }\n\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n\n    new_x = np.zeros((3, x.shape[1]))\n    new_x[:, 0] = [0.31, 0.37, 0.41]\n    predicted_1 = est.predict(new_x)\n\n    new_x[:, 0] = [0, 0, 0]\n    new_x[:, 1] = [-0.9, -0.6, -0.3]\n    predicted_2 = est.predict(new_x)\n\n    params['forcedbins_filename'] = ''\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n    predicted_3 = est.predict(new_x)\n\n    params['max_bin'] = 11\n    lgb_x = lgb.Dataset(x[:, :1], label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=50)\n    predicted_4 = est.predict(x[1:, :1])\n\n    return predicted_1, predicted_2, predicted_3, predicted_4\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        x = np.empty((100, 2))\n        x[:, 0] = np.random.uniform(0, 1, 100)\n        x[:, 1] = -x[:, 0]\n        y = np.linspace(0, 1, 100)\n\n        test_cases.append((x, y))\n\n    return test_cases"}
{"problem_id": "lightgbm_17", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes LightGBM to predict probabilities for a binary classification problem based on training, validation, and test datasets. The function should handle stratified sampling of users from the validation set to ensure that the model is trained and validated on a representative subset of the data. \n\nThe function signature is as follows:\n```python\ndef lgb_predict(train_set, val_set, test_set, val_ratio, n_round):\n```\n\n### Constants Used:\n- The learning rate for the LightGBM model is set to `0.01`.\n- The number of leaves in the model is set to `31`.\n- The subsample ratio is set to `0.8`.\n- The column sample by tree ratio is set to `0.9`.\n- The random state for reproducibility is set to `42` and is incremented by the iteration index `i`.\n\n### Input Format:\n- `train_set`: A DataFrame containing the training data with features and labels.\n- `val_set`: A DataFrame containing the validation data with features and labels.\n- `test_set`: A DataFrame containing the test data with features.\n- `val_ratio`: A float representing the ratio of validation data to be used in each fold.\n- `n_round`: An integer representing the number of rounds for model training.\n\n### Output Format:\n- The function returns a DataFrame containing two columns: `user_id` and `prob`, where `prob` represents the predicted probabilities for each user in the test set.\n\nInput:\n```python\ntrain_set = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.0],\n    'feature_1': [0.2, 0.3, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.0, 0.1],\n    'user_id': [1000, 1001, 1002, 1003, 1004, 1005, 1006, 1007, 1008, 1009],\n    'label': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n\nval_set = pd.DataFrame({\n    'feature_0': [0.15, 0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95, 0.05],\n    'feature_1': [0.25, 0.35, 0.45, 0.55, 0.65, 0.75, 0.85, 0.95, 0.05, 0.15],\n    'user_id':   [2000, 2001, 2002, 2003, 2004, 2005, 2006, 2007, 2008, 2009],\n    'label':     [0,    1,    0,    1,    0,    1,    0,    1,    0,    1]\n})\n\n\ntest_set = pd.DataFrame({\n    'feature_0': [0.12, 0.22, 0.32, 0.42],\n    'feature_1': [0.22, 0.32, 0.42, 0.52],\n    'user_id': [3000, 3001, 3002, 3003]\n})\n\nval_ratio = 0.2\nn_round = 5\n```\n\nOutput:\n```python\n   user_id  prob\n0     3000   0.5\n1     3001   0.5\n2     3002   0.5\n3     3003   0.5\n``` \n\n(Note: The actual probabilities in the output will depend on the random state and the model training process, so they are illustrative here.)", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.model_selection import StratifiedKFold\n\n\ndef get_stratified_sample(df, sample_target, reference_target, sample_ratio):\n    sampled_items = []\n    for value in df[reference_target].unique():\n        sampled = (\n            df[df[reference_target] == value][sample_target]\n            .drop_duplicates()\n            .sample(frac=sample_ratio, random_state=42)\n            .tolist()\n        )\n        sampled_items.extend(sampled)\n    return list(set(sampled_items))\n\n# main code\ndef lgb_predict(train_set, val_set, test_set, val_ratio, n_round):\n\n    res = test_set[['user_id']].copy()\n    test_x = test_set.drop(columns=['user_id'])\n    res['prob'] = 0.0\n\n    params = {\n        'learning_rate': 0.01,\n        'boosting_type': 'gbdt',\n        'objective': 'binary',\n        'metric': 'auc',\n        'num_leaves': 31,\n        'subsample': 0.8,\n        'colsample_bytree': 0.9,\n        'n_jobs': -1\n    }\n    feature_cols = [col for col in train_set.columns if col not in {'user_id', 'label'}]\n    val_users = val_set[['user_id', 'label']].drop_duplicates()\n    total_weight = 0\n\n    for i in range(n_round):\n        skf = StratifiedKFold(n_splits=int(1 / val_ratio), shuffle=True, random_state=42 + i)\n        sampled_users = next(iter(skf.split(val_users[['user_id']], val_users['label'])))[0]\n        val_subset = val_set[val_set['user_id'].isin(val_users.iloc[sampled_users]['user_id'])]\n        train_subset = val_set[~val_set['user_id'].isin(val_subset['user_id'])]\n        d_train = lgb.Dataset(train_subset[feature_cols], label=train_subset['label'])\n        d_val = lgb.Dataset(val_subset[feature_cols], label=val_subset['label'])\n        model = lgb.train(\n            params, d_train, num_boost_round=1000,\n            valid_sets=[d_train, d_val],\n            callbacks=[lgb.early_stopping(50, verbose=False)],\n        )\n        val_score = model.best_score['valid_1']['auc']\n        weight = val_score\n        total_weight += weight\n        res['prob'] += model.predict(test_x, num_iteration=model.best_iteration) * weight\n    if total_weight > 0:\n        res['prob'] /= total_weight\n    return res", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    num_features = np.random.randint(5, 20)\n    num_train_samples = 1000\n    num_val_samples = 500\n    num_test_samples = 200\n\n    for _ in range(n):\n        val_ratio = np.random.uniform(0.1, 0.5)\n        n_round = np.random.randint(3, 10)\n\n        train_users = np.random.choice(range(1000, 2000), size=num_train_samples, replace=True)\n        val_users = np.random.choice(range(2000, 2500), size=num_val_samples, replace=True)\n        test_users = np.random.choice(range(2500, 3000), size=num_test_samples, replace=True)\n\n        train_set = pd.DataFrame(\n            np.random.rand(num_train_samples, num_features),\n            columns=[f'feature_{i}' for i in range(num_features)]\n        )\n        train_set['user_id'] = train_users\n        train_set['label'] = np.random.randint(0, 2, num_train_samples)\n\n        val_set = pd.DataFrame(\n            np.random.rand(num_val_samples, num_features),\n            columns=[f'feature_{i}' for i in range(num_features)]\n        )\n        val_set['user_id'] = val_users\n        val_set['label'] = np.random.randint(0, 2, num_val_samples)\n\n        test_set = pd.DataFrame(\n            np.random.rand(num_test_samples, num_features),\n            columns=[f'feature_{i}' for i in range(num_features)]\n        )\n        test_set['user_id'] = test_users\n\n        test_cases.append((train_set, val_set, test_set, val_ratio, n_round))\n\n    return test_cases"}
{"problem_id": "lightgbm_18", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using a given dataset. The function should split the dataset into training and validation sets, create LightGBM datasets, and train the model while optionally using the validation set for evaluation. The function signature is as follows:\n\n```python\ndef train_model(X, y, use_valid):\n```\n\n### Constants:\n- The constant used in the main code is `num_leaves`, which is set to `5` in the model parameters.\n\n### Input and Output Format:\n- **Input Format**:\n  - `X`: A list or array-like structure of shape (n_samples, n_features).\n  - `y`: A list or array-like structure of shape (n_samples,).\n  - `use_valid`: A boolean value.\n\n- **Output Format**:\n  - Returns a tuple containing:\n    - `bst`: The trained LightGBM model.\n    - `eval_result`: A dictionary containing evaluation results.\n\n**Input**\nX = array([[0.48466795, 0.66446406, 0.26477144, ..., 0.05539785, 0.42927431,\n        0.57816742],\n       [0.12774714, 0.56386521, 0.03568539, ..., 0.20963653, 0.93474443,\n        0.77904853],\n       [0.03981233, 0.0597625 , 0.6536711 , ..., 0.5222743 , 0.7987181 ,\n        0.58445533],\n       ...,\n       [0.5626142 , 0.41914248, 0.34477952, ..., 0.97808364, 0.31743469,\n        0.04014764],\n       [0.26891514, 0.92231914, 0.44673957, ..., 0.58959337, 0.78891151,\n        0.13774008],\n       [0.78736422, 0.29676678, 0.10973802, ..., 0.2178169 , 0.94592755,\n        0.09020525]])\nY = array([0.28135675, 0.55786435, 0.53503232, 0.81210854, 0.57446729,\n       ...,\n       0.42598434, 0.28009108, 0.87635139, 0.95246961, 0.81508699])\nuse_valid = True\n**Output** \n(\n<lightgbm.basic.Booster object at 0x7a38d850b580>, \n{'train': OrderedDict([('l2', [0.06802206312142745, 0.06662073181790146])]), 'valid': OrderedDict([('l2', [0.07210616034279942, 0.07404060678247437])])}\n)\n", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef train_model(X, y, use_valid):\n    (X_train, X_valid) = (X[:80], X[80:])\n    (y_train, y_valid) = (y[:80], y[80:])\n    train_ds = lgb.Dataset(X_train, y_train)\n    valid_ds = lgb.Dataset(X_valid, y_valid)\n    valid_sets = [train_ds]\n    valid_names = ['train']\n\n    if use_valid:\n        valid_sets.append(valid_ds)\n        valid_names.append('valid')\n\n    eval_result = {}\n    bst = lgb.train(\n        {'num_leaves': 5},\n        train_ds,\n        num_boost_round=2,\n        valid_sets=valid_sets,\n        valid_names=valid_names,\n        callbacks=[lgb.early_stopping(1), lgb.record_evaluation(eval_result)]\n    )\n\n    return bst, eval_result", "test_script": "import numpy as np\n\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(5, 50)\n        X = np.random.rand(100, num_features)\n        y = np.random.rand(100)\n        use_valid = np.random.choice([True, False])\n\n        test_cases.append((X, y, use_valid))\n\n    return test_cases"}
{"problem_id": "lightgbm_19", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that evaluates a LightGBM classifier based on provided feature data and hyperparameter results. The function will format the data, train the model, and generate predictions for a test set. \n\nFunction signature:\n```python\ndef evaluate(fm: pd.DataFrame, hyp_results: pd.DataFrame) -> pd.DataFrame:\n```\n\nIn the main code, the constant used is `n_estimators`, which is removed from the hyperparameters before training the model.\n\nInput format:\n- `fm`: A pandas DataFrame containing feature data with columns including 'TARGET' and 'SK_ID_CURR'.\n- `hyp_results`: A pandas DataFrame containing hyperparameter results, where one of the columns is 'params' that holds hyperparameter configurations.\n\nOutput format:\n- Returns a pandas DataFrame with two columns: 'SK_ID_CURR' and 'TARGET', where 'SK_ID_CURR' contains the IDs of the test samples and 'TARGET' contains the predicted probabilities for the positive class.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample feature data\ndata = {\n    'feature_0': [0.1, 0.2, 0.3, np.nan, 0.5],\n    'feature_1': [0.2, 0.1, 0.4, 0.3, np.nan],\n    'feature_2': [0.3, 0.4, np.nan, 0.2, 0.1],\n    'TARGET': [0, 1, 0, 1, np.nan],\n    'SK_ID_CURR': [100001, 100002, 100003, 100004, 100005]\n}\nfm = pd.DataFrame(data)\n\n# Sample hyperparameter results\nhyp_results = pd.DataFrame({\n    'params': [\n        str({\n            'learning_rate': 0.1,\n            'num_leaves': 30,\n            'max_depth': 5,\n            'min_child_samples': 20,\n            'subsample': 0.8,\n            'colsample_bytree': 0.8,\n            'reg_alpha': 0.1,\n            'reg_lambda': 0.1,\n        })\n    ]\n})\n```\n\nOutput:\n```python\n   SK_ID_CURR  TARGET\n0      100005     0.5\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nimport pandas as pd\n\n\ndef format_data(features):\n    train = features.dropna(subset=['TARGET'])\n    test = features[features['TARGET'].isna()]\n    train_labels = train['TARGET'].astype(np.int32).values\n    test_ids = test['SK_ID_CURR'].values\n    train = train.drop(columns=['TARGET', 'SK_ID_CURR'])\n    test = test.drop(columns=['TARGET', 'SK_ID_CURR'])\n    return train, train_labels, test, test_ids\n\n# main code\ndef evaluate(fm, hyp_results):\n    train, train_labels, test, test_ids = format_data(fm)\n    best_params = eval(hyp_results.iloc[0]['params'])\n    best_params.pop('n_estimators', None)\n\n    model = lgb.LGBMClassifier(**best_params)\n    model.fit(train, train_labels)\n\n    preds = model.predict_proba(test)[:, 1]\n    submission = pd.DataFrame({'SK_ID_CURR': test_ids, 'TARGET': preds})\n\n    return submission", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(500, 2000)\n        num_features = random.randint(10, 50)\n\n        feature_cols = [f'feature_{i}' for i in range(num_features)]\n        target_col = 'TARGET'\n        sk_id_col = 'SK_ID_CURR'\n        fm_data = np.random.rand(num_samples, num_features)\n        target_data = np.random.choice([0, 1], size=num_samples, p=[0.7, 0.3])\n        sk_id_data = np.arange(100000, 100000 + num_samples)\n        fm = pd.DataFrame(fm_data, columns=feature_cols)\n        fm[target_col] = target_data\n        fm[sk_id_col] = sk_id_data\n        mask = np.random.rand(*fm.shape) < 0.05\n        fm = fm.mask(mask)\n        hyp_results = pd.DataFrame({\n            'params': [\n                str({\n                    'learning_rate': round(random.uniform(0.01, 0.3), 3),\n                    'num_leaves': random.randint(20, 150),\n                    'max_depth': random.choice([-1, 3, 5, 7, 10]),\n                    'min_child_samples': random.randint(10, 50),\n                    'subsample': round(random.uniform(0.6, 1.0), 2),\n                    'colsample_bytree': round(random.uniform(0.6, 1.0), 2),\n                    'reg_alpha': round(random.uniform(0, 1.0), 2),\n                    'reg_lambda': round(random.uniform(0, 1.0), 2),\n                })\n            ]\n        })\n        test_cases.append((fm, hyp_results))\n\n    return test_cases"}
{"problem_id": "lightgbm_20", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to train multiple models on a given dataset and make predictions on a test dataset. The function will handle categorical features and return the predictions from each model.\n\nFunction signature:\n```python\ndef test_pandas_categorical(X: pd.DataFrame, y: pd.Series, X_test: pd.DataFrame) -> dict:\n```\n\nConstant used in the main code:\n- `cat_cols_actual`: This constant is a list of column names that are considered categorical features in the dataset. It is defined as `['A', 'B', 'C', 'D']`.\n\nInput format:\n- `X`: A pandas DataFrame containing the training features.\n- `y`: A pandas Series containing the target variable.\n- `X_test`: A pandas DataFrame containing the test features.\n\nOutput format:\n- A dictionary where the keys are model identifiers (e.g., 'pred0', 'pred1', etc.) and the values are the predictions made by the corresponding models on the test dataset `X_test`.\n\n**Input:**\n```python\nX = pd.DataFrame({\n    'A': pd.Categorical(['a', 'b', 'c', 'a', 'b'], categories=['a', 'b', 'c', 'd']),\n    'B': [1, 2, 3, 1, 2],\n    'C': [0.1, 0.2, -0.1, 0.1, 0.2],\n    'D': [True, False, True, False, True],\n    'E': pd.Categorical(['z', 'y', 'x', 'z', 'y'], categories=['w', 'x', 'y', 'z'], ordered=True)\n})\ny = pd.Series([0, 1, 0, 1, 0])\nX_test = pd.DataFrame({\n    'A': pd.Categorical(['a', 'b', 'e'], categories=['a', 'b', 'c', 'd']),\n    'B': [1, 3, 2],\n    'C': [0.1, -0.1, 0.2],\n    'D': [True, False, True],\n    'E': pd.Categorical(['z', 'y', 'w'], categories=['w', 'y', 'z'], ordered=True)\n})\n```\n\n**Output:**\n```python\n{\n   'pred0': array([0.4, 0.4, 0.4]), \n   'pred1': array([0.4, 0.4, 0.4]), \n   'pred2': array([0.4, 0.4, 0.4]), \n   'pred3': array([0.4, 0.4, 0.4]), \n   'pred7': array([0.4, 0.4, 0.4]), \n   'pred8': array([0.4, 0.4, 0.4])\n}\n```\n", "ground_truth_code": "import lightgbm as lgb\nimport pandas as pd\n\n# main code\ndef test_pandas_categorical(X, y, X_test):\n    cat_cols_actual = ['A', 'B', 'C', 'D']\n    cat_cols_to_store = cat_cols_actual + ['E']\n    X[cat_cols_actual] = X[cat_cols_actual].astype('category')\n    X_test[cat_cols_actual] = X_test[cat_cols_actual].astype('category')\n\n    params = {'objective': 'binary', 'metric': 'binary_logloss', 'verbose': -1}\n\n    models = {}\n    predictions = {}\n\n    lgb_train = lgb.Dataset(X, y)\n    models['gbm0'] = lgb.train(params, lgb_train, num_boost_round=10)\n    predictions['pred0'] = models['gbm0'].predict(X_test)\n\n    lgb_train = lgb.Dataset(X, pd.DataFrame(y))\n    models['gbm1'] = lgb.train(params, lgb_train, num_boost_round=10, categorical_feature=[0])\n    predictions['pred1'] = models['gbm1'].predict(X_test)\n\n    lgb_train = lgb.Dataset(X, pd.Series(y))\n    models['gbm2'] = lgb.train(params, lgb_train, num_boost_round=10, categorical_feature=['A'])\n    predictions['pred2'] = models['gbm2'].predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y)\n    models['gbm3'] = lgb.train(params, lgb_train, num_boost_round=10, categorical_feature=['A', 'B', 'C', 'D'])\n    predictions['pred3'] = models['gbm3'].predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y)\n    models['gbm6'] = lgb.train(params, lgb_train, num_boost_round=10, categorical_feature=['A', 'B', 'C', 'D', 'E'])\n    predictions['pred7'] = models['gbm6'].predict(X_test)\n\n    lgb_train = lgb.Dataset(X, y)\n    models['gbm7'] = lgb.train(params, lgb_train, num_boost_round=10, categorical_feature=[])\n    predictions['pred8'] = models['gbm7'].predict(X_test)\n\n    return predictions", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        train_size = np.random.choice([100, 200, 300])\n        test_size = train_size//5\n        X = pd.DataFrame({\n            'A': np.random.choice(['a', 'b', 'c', 'd'], train_size),\n            'B': np.random.choice([1, 2, 3], train_size),\n            'C': np.random.choice([0.1, 0.2, -0.1, -0.1, 0.2], train_size),\n            'D': np.random.choice([True, False], train_size),\n            'E': pd.Categorical(np.random.choice(['z', 'y', 'x', 'w', 'v'], train_size), ordered=True)\n        })\n        y = np.random.choice([0, 1], train_size)\n        X_test = pd.DataFrame({\n            'A': np.random.choice(['a', 'b', 'e'], test_size),\n            'B': np.random.choice([1, 3], test_size),\n            'C': np.random.choice([0.1, -0.1, 0.2, 0.2], test_size),\n            'D': np.random.choice([True, False], test_size),\n            'E': pd.Categorical(np.random.choice(['z', 'y'], test_size), ordered=True)\n        })\n        test_cases.append((X, y, X_test))\n    return test_cases"}
{"problem_id": "lightgbm_21", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that evaluates the performance of a LightGBM model using the LambdaRank objective. The function will compare the Normalized Discounted Cumulative Gain (NDCG) scores of three different training configurations: one with bagging by query enabled, one with bagging by query disabled, and a baseline without any bagging. \n\nThe function signature is as follows:\n```python\ndef test_bagging_by_query_in_lambdarank(X_train, y_train, q_train, X_test, y_test, q_test):\n```\n\n### Constants Used:\n- The constant used in the main code is `num_boost_round`, which is set to `50`. This constant determines the number of boosting iterations for training the LightGBM model.\n\n\n### Input Format:\n- `X_train`: A 2D array-like structure containing the training features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `q_train`: A 1D array-like structure indicating the query groups for the training data.\n- `X_test`: A 2D array-like structure containing the test features.\n- `y_test`: A 1D array-like structure containing the test labels.\n- `q_test`: A 1D array-like structure indicating the query groups for the test data.\n\n### Output Format:\n- The function returns a tuple of three float values representing the NDCG scores: \n  - The first value is the NDCG score without bagging.\n  - The second value is the NDCG score with bagging by query enabled.\n  - The third value is the NDCG score with bagging by query disabled.\n\n**Input:**\n```python\nX_train = np.tile([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.1, 0.4, 0.7], [0.2, 0.5, 0.8]], (10,1))\ny_train = np.tile([0, 1, 2, 1, 0], 10)\nq_train = [5] * 10\nX_test = np.array([[0.3, 0.2, 0.1], [0.6, 0.5, 0.4], [0.9, 0.8, 0.7]])\ny_test = np.array([1, 2, 0])\nq_test = [3]\n```\n\n**Output:**\n```python\n(0.6590018048024133, 0.7967075809905066, 0.7967075809905066)\n```\n", "ground_truth_code": "import lightgbm as lgb\n\n# main code\ndef test_bagging_by_query_in_lambdarank(X_train, y_train, q_train, X_test, y_test, q_test):\n    params = {'objective': 'lambdarank', 'verbose': -1, 'metric': 'ndcg', 'ndcg_eval_at': [5]}\n\n    lgb_train = lgb.Dataset(X_train, y_train, group=q_train, params=params)\n    lgb_test = lgb.Dataset(X_test, y_test, group=q_test, params=params)\n\n    gbm = lgb.train(params, lgb_train, num_boost_round=50, valid_sets=[lgb_test])\n    ndcg_score = gbm.best_score['valid_0']['ndcg@5']\n\n    params.update({'bagging_by_query': True, 'bagging_fraction': 0.1, 'bagging_freq': 1})\n    gbm_bagging_by_query = lgb.train(params, lgb_train, num_boost_round=50, valid_sets=[lgb_test])\n    ndcg_score_bagging_by_query = gbm_bagging_by_query.best_score['valid_0']['ndcg@5']\n\n    params.update({'bagging_by_query': False, 'bagging_fraction': 0.1, 'bagging_freq': 1})\n    gbm_no_bagging_by_query = lgb.train(params, lgb_train, num_boost_round=50, valid_sets=[lgb_test])\n    ndcg_score_no_bagging_by_query = gbm_no_bagging_by_query.best_score['valid_0']['ndcg@5']\n\n    return ndcg_score, ndcg_score_bagging_by_query, ndcg_score_no_bagging_by_query\n", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 100)\n        num_features = np.random.randint(5, 20)\n        X_train = np.random.rand(num_samples, num_features)\n        y_train = np.digitize(np.random.rand(num_samples), bins=[0.2, 0.4, 0.6, 0.8])  # Bins map to {0,1,2,3,4}\n        q_train = []\n        remaining_samples = num_samples\n        while remaining_samples > 0:\n            group_size = min(remaining_samples, np.random.randint(5, 20))  # Ensure at least 5 per group\n            q_train.append(group_size)\n            remaining_samples -= group_size\n        X_test = np.random.rand(num_samples // 2, num_features)\n        y_test = np.digitize(np.random.rand(num_samples // 2), bins=[0.2, 0.4, 0.6, 0.8])\n        q_test = []\n        remaining_samples = num_samples // 2\n        while remaining_samples > 0:\n            group_size = min(remaining_samples, np.random.randint(5, 20))\n            q_test.append(group_size)\n            remaining_samples -= group_size\n        test_cases.append((X_train, y_train, q_train, X_test, y_test, q_test))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_22", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that benchmarks a LightGBM tree model using provided training and testing datasets. The function will handle both scenarios where the test labels are available and where they are not. The function will utilize the LightGBM library to create datasets, train the model, and make predictions based on the input features.\n\nFunction Signature:\n```python\ndef benchmark_tree_model(extracted_features_train, y_train, weights_train, extracted_features_test, y_test, weights_test, tabular_hyper, additional_hyper):\n```\n\nConstants Used:\n- `max_bin`: This constant is used to define the maximum number of bins for the histogram-based algorithm in LightGBM. It defaults to 255 if not specified in the `tabular_hyper` dictionary.\n- `early_stopping_round`: This constant is used to specify the number of rounds for early stopping during training. It defaults to 0 if not provided in the `tabular_hyper` dictionary.\n- `num_iterations`: This constant defines the number of boosting iterations (trees) to be built. It defaults to 100 if not specified in the `tabular_hyper` dictionary.\n- `gbm_start_iteration`: This constant is used to determine the starting iteration for making predictions. It defaults to 0 if not provided in the `additional_hyper` dictionary.\n\nInput Format:\n- `extracted_features_train`: A 2D array-like structure containing the training feature set.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `weights_train`: A 1D array-like structure containing the weights for the training samples.\n- `extracted_features_test`: A 2D array-like structure containing the testing feature set.\n- `y_test`: A 1D array-like structure containing the testing labels (can be `None`).\n- `weights_test`: A 1D array-like structure containing the weights for the testing samples.\n- `tabular_hyper`: A dictionary containing hyperparameters for the LightGBM model.\n- `additional_hyper`: A dictionary containing additional hyperparameters for the model.\n\nOutput Format:\n- If `y_test` is not `None`, the function returns a tuple containing:\n  - The trained LightGBM model.\n  - A 1D array of predictions for the test features.\n- If `y_test` is `None`, the function returns only the trained LightGBM model.\n\n**Input:**\n```python\n(\n    np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.1, 0.3, 0.5]]),  # extracted_features_train\n    np.array([0, 1, 0, 1]),  # y_train\n    np.array([1.0, 1.0, 1.0, 1.0]),  # weights_train\n    np.array([[0.2, 0.3, 0.4], [0.5, 0.6, 0.7]]),  # extracted_features_test\n    np.array([1, 0]),  # y_test\n    np.array([1.0, 1.0]),  # weights_test\n    {  # tabular_hyper\n        'num_iterations': 100,\n        'learning_rate': 0.1,\n        'max_depth': 5,\n        'num_leaves': 31,\n        'max_bin': 100,\n        'early_stopping_round': 10\n    },\n    {  # additional_hyper\n        'gbm_start_iteration': 0\n    }\n)\n```\n\n**Output:**\n```python\n(<lightgbm.basic.Booster object at 0x739ee4f03280>, array([0.5, 0.5]))\n```", "ground_truth_code": "import lightgbm\n\n# main code\ndef benchmark_tree_model(extracted_features_train, y_train, weights_train, extracted_features_test, y_test, weights_test, tabular_hyper, additional_hyper):\n    if y_test is not None:\n        train_data = lightgbm.Dataset(\n            extracted_features_train, label=y_train, weight=weights_train,\n            params={'max_bin': tabular_hyper.get('max_bin', 255)}\n        )\n        test_data = lightgbm.Dataset(\n            extracted_features_test, label=y_test, weight=weights_test,\n            params={'max_bin': tabular_hyper.get('max_bin', 255)}\n        )\n        early_stopping_rounds = tabular_hyper.get('early_stopping_round', 0)\n        model = lightgbm.train(\n            tabular_hyper, train_set=train_data,\n            num_boost_round=tabular_hyper.get('num_iterations', 100),\n            valid_sets=[test_data],\n            callbacks=[lightgbm.log_evaluation(period=1000), lightgbm.early_stopping(early_stopping_rounds)]\n        )\n        valid_iteration = min(additional_hyper.get('gbm_start_iteration', 0), model.num_trees() // 2)\n        pred = model.predict(extracted_features_test, start_iteration=valid_iteration)\n        return model, pred\n\n    train_data = lightgbm.Dataset(extracted_features_train, label=y_train, weight=weights_train)\n    model = lightgbm.train(tabular_hyper, train_set=train_data,\n                           num_boost_round=tabular_hyper.get('num_iterations', 100))\n\n    return model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples_train = np.random.randint(50, 500)\n        num_samples_test = np.random.randint(20, 200)\n        num_features = np.random.randint(5, 50)\n        extracted_features_train = np.random.rand(num_samples_train, num_features)\n        extracted_features_test = np.random.rand(num_samples_test, num_features)\n        y_train = np.random.randint(0, 2, size=(num_samples_train,))\n        y_test = np.random.randint(0, 2, size=(num_samples_test,))\n        weights_train = np.random.rand(num_samples_train)\n        weights_test = np.random.rand(num_samples_test)\n        tabular_hyper = {\n            'num_iterations': np.random.randint(50, 300),\n            'learning_rate': np.random.uniform(0.01, 0.3),\n            'max_depth': np.random.randint(3, 15),\n            'num_leaves': np.random.randint(10, 100),\n            'max_bin': np.random.randint(50, 255),\n            'early_stopping_round': np.random.randint(5, 50)\n        }\n        additional_hyper = {\n            'gbm_start_iteration': np.random.randint(0, 50)\n        }\n        test_cases.append((\n            extracted_features_train, y_train, weights_train,\n            extracted_features_test, y_test, weights_test,\n            tabular_hyper, additional_hyper\n        ))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_23", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that initializes a LightGBM model using two subsets of data. The function will take in a dataset and its corresponding labels, along with two indices that specify the subsets of the data to be used for training. The goal is to train a model on the first subset and then use that model to train on the second subset.\n\nFunction Signature:\n```python\ndef test_init_with_subset(data, y, subset_index_1, subset_index_2):\n```\n\nConstant used in the main code:\n- `params`: A dictionary containing the parameters for the LightGBM model, specifically `{'objective': 'binary', 'verbose': -1}`.\n\nInput format:\n- `data`: A 2D array-like structure representing the features of the dataset.\n- `y`: A 1D array-like structure representing the labels corresponding to the data.\n- `subset_index_1`: A list or array of indices specifying the first subset of data.\n- `subset_index_2`: A list or array of indices specifying the second subset of data.\n\nOutput format:\n- The function returns a tuple containing:\n  - `final_model`: The trained LightGBM model after training on the second subset.\n  - `subset_data_1`: The first subset of the dataset used for initial training.\n  - `subset_data_2`: The second subset of the dataset used for further training.\n\nInput:\n```python\ndata = np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6], [0.7, 0.8], [0.9, 1.0],\n                 [0.2, 0.3], [0.4, 0.5], [0.6, 0.7], [0.8, 0.9], [1.0, 1.1],\n                 [0.1, 0.3], [0.3, 0.5], [0.5, 0.7], [0.7, 0.9], [0.9, 1.1],\n                 [0.2, 0.4], [0.4, 0.6], [0.6, 0.8], [0.8, 1.0], [1.0, 1.2],\n                 [0.1, 0.4], [0.3, 0.6], [0.5, 0.8], [0.7, 1.0], [0.9, 1.3],\n                 [0.2, 0.5], [0.4, 0.7], [0.6, 0.9], [0.8, 1.1], [1.0, 1.4],\n                 [0.1, 0.5], [0.3, 0.7], [0.5, 0.9], [0.7, 1.1], [0.9, 1.5],\n                 [0.2, 0.6], [0.4, 0.8], [0.6, 1.0], [0.8, 1.2], [1.0, 1.6],\n                 [0.1, 0.6], [0.3, 0.8], [0.5, 1.0], [0.7, 1.2], [0.9, 1.7],\n                 [0.2, 0.7], [0.4, 0.9], [0.6, 1.1], [0.8, 1.3], [1.0, 1.8]])\ny = [1] * 25 + [0] * 25\nsubset_index_1 = np.array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29])\nsubset_index_2 = np.array([30, 31, 32, 33, 34, 35, 36, 37, 38, 39])\n```\n\nOutput:\n```python\n(\n   <lightgbm.basic.Booster object at 0x787722976ad0>, \n   <lightgbm.basic.Dataset object at 0x7877526f0040>, \n   <lightgbm.basic.Dataset object at 0x7877526f3f70>\n)\n\n```", "ground_truth_code": "import lightgbm as lgb\n\n\n# main code\ndef test_init_with_subset(data, y, subset_index_1, subset_index_2):\n    lgb_train = lgb.Dataset(data, y, free_raw_data=False)\n\n    subset_data_1 = lgb_train.subset(subset_index_1)\n    subset_data_2 = lgb_train.subset(subset_index_2)\n\n    params = {'objective': 'binary', 'verbose': -1}\n    init_gbm = lgb.train(params=params, train_set=subset_data_1, num_boost_round=10, keep_training_booster=True)\n\n    final_model = lgb.train(params=params, train_set=subset_data_2, num_boost_round=10, init_model=init_gbm)\n\n    return final_model, subset_data_1, subset_data_2", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        data = np.random.uniform(size=(50, 2))\n        y = [1] * 25 + [0] * 25\n        subset_index_1 = np.random.choice(a=np.arange(50), size=30, replace=False)\n        subset_index_2 = np.random.choice(a=np.arange(50), size=20, replace=False)\n\n        test_cases.append((data, y, subset_index_1, subset_index_2))\n    return test_cases"}
{"problem_id": "lightgbm_24", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using a given dataset and evaluates its performance using various metrics. The function will utilize stratified k-fold cross-validation to ensure that the distribution of the target variable is preserved across the training and validation sets. The function will return the best threshold for classification and the evaluation metrics including F1 score, accuracy, recall, and precision.\n\nFunction signature:\n```python\ndef train(candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params):\n```\n\n### Constants:\n- The constant used in the main code is `early_stopping_rounds`, which is set to `20`.\n\n### Input Format:\n- `candidate_df`: A DataFrame containing features and target labels for training.\n- `candidate_df_soundscapes`: A DataFrame containing features and target labels for validation.\n- `num_kfolds`: An integer representing the number of folds for cross-validation.\n- `lgb_params`: A dictionary containing parameters for the LightGBM model.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `'best_threshold'`: A float representing the best threshold for classification.\n  - `'binary_F1'`: A float representing the F1 score of the model.\n  - `'accuracy'`: A float representing the accuracy of the model.\n  - `'recall'`: A float representing the recall of the model.\n  - `'precision'`: A float representing the precision of the model.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample candidate_df\ncandidate_df = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [1.0, 1.1, 1.2, 1.3, 1.4],\n    'feature_2': [0.5, 0.6, 0.7, 0.8, 0.9],\n    'target': [0, 1, 0, 1, 0],\n    'audio_id': ['a', 'a', 'b', 'b', 'c']\n})\n\n# Sample candidate_df_soundscapes\ncandidate_df_soundscapes = pd.DataFrame({\n    'feature_0': [0.15, 0.25, 0.35],\n    'feature_1': [1.05, 1.15, 1.25],\n    'feature_2': [0.55, 0.65, 0.75],\n    'target': [0, 1, 0],\n    'audio_id': ['f', 'g', 'h']\n})\n\nnum_kfolds = 3\nlgb_params = {\n    'objective': 'binary',\n    'metric': 'binary_logloss',\n    'learning_rate': 0.1,\n    'num_leaves': 30,\n}\n```\n\n**Output:**\n```python\n{\n   'best_threshold': 0.38888893, \n   'binary_F1': 0.0, \n   'accuracy': 0.6666666666666666, \n   'recall': 0.0, \n   'precision': 0.0\n}\n```\n", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nfrom sklearn.metrics import f1_score, accuracy_score, recall_score, precision_score\nfrom sklearn.model_selection import StratifiedGroupKFold\n\n\n# main code\ndef train(candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params):\n    lgb_params = lgb_params or {}\n    lgb_params['early_stopping_rounds'] = 20\n\n    feature_names = list(candidate_df.columns.difference(['audio_id', 'target', 'fold']))\n    candidate_df['fold'] = -1\n    kf = StratifiedGroupKFold(n_splits=num_kfolds)\n\n    for kfold_index, (_, valid_index) in enumerate(kf.split(candidate_df[feature_names], candidate_df['target'], candidate_df['audio_id'])):\n        candidate_df.loc[valid_index, 'fold'] = kfold_index\n\n    X, y = candidate_df[feature_names], candidate_df['target']\n    oofa = np.zeros(len(candidate_df_soundscapes), dtype=np.float32)\n\n    for kfold_index in range(num_kfolds):\n        train_idx = candidate_df[candidate_df['fold'] != kfold_index].index\n        X_train, y_train = X.loc[train_idx], y.loc[train_idx]\n        X_valid, y_valid = candidate_df_soundscapes[feature_names], candidate_df_soundscapes['target']\n\n        dtrain = lgb.Dataset(X_train, label=y_train)\n        dvalid = lgb.Dataset(X_valid, label=y_valid)\n        model = lgb.train(lgb_params, dtrain, valid_sets=[dvalid], num_boost_round=200)\n        oofa += model.predict(X_valid.astype(np.float32)) / num_kfolds\n\n    th = np.mean(oofa)\n    oof = (oofa > th).astype(int)\n\n    result = {\n        'best_threshold': th,\n        'binary_F1': f1_score(candidate_df_soundscapes['target'], oof),\n        'accuracy': accuracy_score(candidate_df_soundscapes['target'], oof),\n        'recall': recall_score(candidate_df_soundscapes['target'], oof),\n        'precision': precision_score(candidate_df_soundscapes['target'], oof)\n    }\n\n    return result", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(100, 500)\n        num_features = np.random.randint(5, 20)\n        num_kfolds = np.random.randint(2, 6)\n\n        X, y = make_classification(\n            n_samples=num_samples,\n            n_features=num_features,\n            n_informative=int(num_features * 0.7),\n            n_redundant=int(num_features * 0.2),\n            n_classes=2,\n            random_state=np.random.randint(0, 10000)\n        )\n\n        candidate_df = pd.DataFrame(X, columns=[f'feature_{i}' for i in range(num_features)])\n        candidate_df['target'] = y\n        candidate_df['audio_id'] = np.random.choice(['a', 'b', 'c', 'd', 'e'], size=num_samples)\n\n        num_soundscape_samples = np.random.randint(50, 200)\n        X_soundscapes, y_soundscapes = make_classification(\n            n_samples=num_soundscape_samples,\n            n_features=num_features,\n            n_informative=int(num_features * 0.7),\n            n_redundant=int(num_features * 0.2),\n            n_classes=2,\n            random_state=np.random.randint(0, 10000)\n        )\n\n        candidate_df_soundscapes = pd.DataFrame(X_soundscapes, columns=[f'feature_{i}' for i in range(num_features)])\n        candidate_df_soundscapes['target'] = y_soundscapes\n        candidate_df_soundscapes['audio_id'] = np.random.choice(['f', 'g', 'h', 'i', 'j'], size=num_soundscape_samples)\n\n        lgb_params = {\n            'objective': 'binary',\n            'metric': 'binary_logloss',\n            'learning_rate': np.random.uniform(0.01, 0.2),\n            'num_leaves': np.random.randint(20, 100),\n        }\n\n        test_cases.append((candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params))\n\n    return test_cases"}
{"problem_id": "lightgbm_25", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to train a model on a given dataset and make predictions on a test dataset. The function should also handle categorical columns appropriately.\n\nFunction signature:\n```python\ndef prediction(X, y, X_test, params, cat_cols_actual=None, cat_cols_to_store=None):\n```\n\n### Constants:\n- The constant used in the main code is `num_boost_round`, which is set to `10`.\n\n### Input Format:\n- `X`: A pandas DataFrame containing the training features.\n- `y`: A pandas Series or array-like structure containing the target variable.\n- `X_test`: A pandas DataFrame containing the test features.\n- `params`: A dictionary containing the parameters for the LightGBM model.\n- `cat_cols_actual`: (Optional) A list of actual categorical column names in `X`.\n- `cat_cols_to_store`: (Optional) A list of categorical column names to be stored.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `'pred'`: A list or array of predictions made by the model on `X_test`.\n  - `'categorical_values'`: A list of lists containing the unique values for each categorical column specified in `cat_cols_to_store`.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\nX = pd.DataFrame({\n    'num_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'num_1': [1.1, 1.2, 1.3, 1.4, 1.5],\n    'cat_0': ['A', 'B', 'A', 'C', 'B'],\n    'cat_1': ['D', 'D', 'C', 'C', 'D']\n})\n\ny = np.array([0.5, 0.6, 0.7, 0.8, 0.9])\nX_test = pd.DataFrame({\n    'num_0': [0.15, 0.25],\n    'num_1': [1.15, 1.25],\n    'cat_0': ['A', 'B'],\n    'cat_1': ['D', 'C']\n})\n\nparams = {\n    'objective': 'regression',\n    'metric': 'rmse',\n    'verbosity': -1,\n}\n\ncat_cols_actual = ['cat_0', 'cat_1']\ncat_cols_to_store = ['cat_0', 'cat_1']\n```\n\n**Output:**\n```python\n{\n   'pred': array([0.7, 0.7]), \n   'categorical_values': [['A', 'B', 'C'], ['C', 'D']]\n}\n```", "ground_truth_code": "import lightgbm as lgb\n\ndef detect_categorical_columns(df):\n    return df.select_dtypes(include=['object', 'category']).columns.tolist()\n\n# main code\ndef prediction(X, y, X_test, params, cat_cols_actual, cat_cols_to_store):\n    if cat_cols_actual is None:\n        cat_cols_actual = detect_categorical_columns(X)\n    if cat_cols_to_store is None:\n        cat_cols_to_store = cat_cols_actual.copy()\n\n    X[cat_cols_actual] = X[cat_cols_actual].astype('category')\n    X_test[cat_cols_actual] = X_test[cat_cols_actual].astype('category')\n\n    cat_values = [X[col].cat.categories.tolist() for col in cat_cols_to_store]\n\n    results = {}\n    lgb_train = lgb.Dataset(X, y, categorical_feature=cat_cols_to_store)\n    gbm = lgb.train(params, lgb_train, num_boost_round=10)\n\n    results['pred'] = gbm.predict(X_test)\n    results['categorical_values'] = cat_values\n\n    return results", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_rows = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n        num_cat_features = np.random.randint(1, min(5, num_features))\n\n        numerical_data = np.random.randn(num_rows, num_features - num_cat_features).astype(np.float32)\n        cat_data = np.random.choice(['A', 'B', 'C', 'D'], size=(num_rows, num_cat_features))\n\n        col_names = [f'num_{i}' for i in range(num_features - num_cat_features)] + \\\n                    [f'cat_{i}' for i in range(num_cat_features)]\n        X = pd.DataFrame(np.hstack((numerical_data, cat_data)), columns=col_names)\n\n        for num_col in [f'num_{i}' for i in range(num_features - num_cat_features)]:\n            X[num_col] = X[num_col].astype(float)\n\n        for cat_col in [f'cat_{i}' for i in range(num_cat_features)]:\n            X[cat_col] = X[cat_col].astype('object')\n        y = np.random.rand(num_rows)\n        X_test = X.sample(frac=0.3).reset_index(drop=True)\n        params = {\n            'objective': 'regression',\n            'metric': 'rmse',\n            'verbosity': -1,\n        }\n\n        cat_cols_actual = [f'cat_{i}' for i in range(num_cat_features)]\n        cat_cols_to_store = cat_cols_actual.copy()\n\n        test_cases.append((X, y, X_test, params, cat_cols_actual, cat_cols_to_store))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_26", "library": "lightgbm", "code_problem": "You are tasked with developing a function that processes a dataset to train a LightGBM model for binary classification. The function will handle missing values, merge additional data, split the dataset into training and testing sets, train the model, and evaluate its performance using the ROC AUC score. Additionally, it will predict labels for a subset of users based on the model's predictions.\n\nFunction signature:\n```python\ndef process_data(df: pd.DataFrame, voc_data: pd.DataFrame, params: dict) -> Tuple[pd.DataFrame, float]:\n```\n\nConstant used in the main code:\n- The constant `50` is used to determine the threshold for classifying predictions for test users.\n\nInput format:\n- `df`: A pandas DataFrame containing the main dataset with features and labels.\n- `voc_data`: A pandas DataFrame containing additional vocational data to be merged.\n- `params`: A dictionary containing parameters for the LightGBM model.\n\nOutput format:\n- Returns a tuple containing:\n  - A pandas DataFrame with columns `['phone_no_m', 'label']` for the test users.\n  - A float representing the ROC AUC score of the model on the test set.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample DataFrame for df\ndata = {\n    'feature_0': np.linspace(0.1, 1.0, 10),\n    'feature_1': np.linspace(1.0, 0.1, 10),\n    'feature_2': np.linspace(0.5, 1.4, 10),\n    'phone_no_m': [f'phone_{i}' for i in range(10)],\n    'label': [-1, 0, 1, -1, 1, 0, 0, 1, -1, 0],\n    'select': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n}\ndf = pd.DataFrame(data)\n\n\n# Sample DataFrame for voc_data\nvoc_data = pd.DataFrame({\n    'phone_no_m': ['phone_0', 'phone_1', 'phone_2'],\n    'start_datetime': pd.to_datetime(['2021-01-01', '2021-01-02', '2021-01-03']),\n    'city_name': ['CityA', 'CityB', 'CityC'],\n    'county_name': ['CountyX', 'CountyY', 'CountyX'],\n    'imei_m': [1234567, 2345678, 3456789],\n    'opposite_no_m': [9876543, 8765432, 7654321],\n    'calltype_id': [1, 2, 3]\n})\n\n# Sample parameters\nparams = {\n    'objective': 'binary',\n    'metric': 'auc',\n    'learning_rate': 0.01,\n    'num_leaves': 30,\n    'feature_fraction': 0.8,\n    'bagging_fraction': 0.8,\n    'bagging_freq': 5,\n    'early_stopping_rounds': 100\n}\n\n```\n\n**Output:**\n```python\n# Expected output format\noutput_df = \n  phone_no_m  label\n0    phone_0      0\n1    phone_3      0\n2    phone_8      0\nauc_score = 0.5  # Example AUC score (this value will vary based on the model training)\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nfrom sklearn.metrics import f1_score, roc_auc_score\nfrom sklearn.model_selection import train_test_split\n\n\ndef score_vail(vaild_preds, real):\n    scores = [(32 + i * 0.08, f1_score(vaild_preds > round(np.percentile(vaild_preds, 32 + i * 0.08), 4), real, average='macro'))\n              for i in range(600)]\n    return max(scores, key=lambda x: x[1])\n\n# main code\ndef process_data(df, voc_data, params):\n    df.fillna(-1, inplace=True)\n\n    voc_cols_to_drop = ['start_datetime', 'city_name', 'county_name', 'imei_m', 'opposite_no_m', 'calltype_id']\n    df_voc = voc_data.drop_duplicates('phone_no_m').drop(voc_cols_to_drop, axis=1).reset_index(drop=True)\n    df = df.merge(df_voc, on='phone_no_m', how='left')\n\n    features = [col for col in df.columns if col not in ['phone_no_m', 'label', 'select']]\n    df_train, df_test, y_train, y_test = train_test_split(\n        df[features], df['select'], test_size=0.2, stratify=df['select']\n    )\n\n    train_data = lgb.Dataset(df_train, label=y_train)\n    valid_data = lgb.Dataset(df_test, label=y_test)\n\n    clf = lgb.train(\n        params, train_data, num_boost_round=5000, valid_sets=[train_data, valid_data],\n        valid_names=['train', 'validate'])\n\n    auc_score = roc_auc_score(y_test, clf.predict(df_test, num_iteration=clf.best_iteration))\n\n    test_user = df[df['label'] == -1]\n    test_user['prob'] = clf.predict(test_user[features], num_iteration=clf.best_iteration)\n    threshold = np.percentile(test_user['prob'], 50)\n    test_user['label'] = (test_user['prob'] > round(threshold, 4)).astype(int)\n\n    return test_user[['phone_no_m', 'label']].reset_index(drop=True), auc_score\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(100, 200)\n        num_features = random.randint(5, 10)\n\n        feature_data = np.random.random((num_samples, num_features))\n        feature_columns = [f'feature_{i}' for i in range(num_features)]\n\n        df = pd.DataFrame(feature_data, columns=feature_columns)\n        df['phone_no_m'] = np.random.choice([f'phone_{i}' for i in range(num_samples)], num_samples)\n        df['label'] = np.random.choice([-1, 0, 1], num_samples)\n        df['select'] = np.random.choice([0, 1], num_samples)\n\n        voc_data = pd.DataFrame({\n            'phone_no_m': np.random.choice(df['phone_no_m'].unique(), num_samples // 2),\n            'start_datetime': pd.to_datetime(np.random.randint(1609459200, 1640995200, num_samples // 2), unit='s'),\n            'city_name': np.random.choice(['CityA', 'CityB', 'CityC'], num_samples // 2),\n            'county_name': np.random.choice(['CountyX', 'CountyY'], num_samples // 2),\n            'imei_m': np.random.randint(1000000, 9999999, num_samples // 2),\n            'opposite_no_m': np.random.randint(1000000, 9999999, num_samples // 2),\n            'calltype_id': np.random.choice([1, 2, 3], num_samples // 2),\n        })\n\n        params = {\n            'objective': 'binary',\n            'metric': 'auc',\n            'learning_rate': 0.01,\n            'num_leaves': random.randint(20, 50),\n            'feature_fraction': 0.8,\n            'bagging_fraction': 0.8,\n            'bagging_freq': 5,\n            'early_stopping_rounds': 100\n        }\n\n        test_cases.append((df, voc_data, params))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_27", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that continues training a LightGBM model on a given dataset. The function will take in training and testing datasets, train a model, and return evaluation metrics.\n\nFunction signature:\n```python\ndef continue_train(X_train, X_test, y_train, y_test):\n```\n\nIn this function, a constant `params` is defined, which contains the parameters for the LightGBM model. Specifically, it sets the objective to 'regression', the evaluation metric to 'l1' (mean absolute error), and suppresses verbose output.\n\nInput format:\n- `X_train`: A 2D array-like structure containing the training features.\n- `X_test`: A 2D array-like structure containing the testing features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `y_test`: A 1D array-like structure containing the testing labels.\n\nOutput format:\n- A dictionary with the following keys:\n  - `'mae'`: The mean absolute error of the predictions on the test set.\n  - `'l1_evals'`: A list of L1 evaluation results from the validation set.\n  - `'custom_mae'`: A list of custom mean absolute error results from the validation set.\n\nInput:\n```python\nX_train = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.3, 0.4], [0.5, 0.6, 0.7]])\nX_test = np.array([[0.15, 0.25, 0.35], [0.45, 0.55, 0.65]])\ny_train = np.array([0.1, 0.4, 0.7, 0.2, 0.5])\ny_test = np.array([0.15, 0.45])\n```\n\nOutput:\n```python\n{\n    'mae': 0.15000000000000002, \n    'l1_evals': [0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328], \n    'custom_mae': [0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328, 0.14999999105930328]\n}\n```\n", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.metrics import mean_absolute_error\n\n# main code\ndef continue_train(X_train, X_test, y_train, y_test):\n    params = {'objective': 'regression', 'metric': 'l1', 'verbose': -1}\n    lgb_train = lgb.Dataset(X_train, y_train, free_raw_data=False)\n    lgb_eval = lgb.Dataset(X_test, y_test, reference=lgb_train, free_raw_data=False)\n\n    init_gbm = lgb.train(params, lgb_train, num_boost_round=20)\n\n    evals_result = {}\n    gbm = lgb.train(\n        params,\n        lgb_train,\n        num_boost_round=30,\n        valid_sets=[lgb_eval],\n        feval=lambda p, d: ('custom_mae', mean_absolute_error(p, d.get_label()), False),\n        callbacks=[lgb.record_evaluation(evals_result)],\n        init_model=init_gbm\n    )\n\n    ret = mean_absolute_error(y_test, gbm.predict(X_test))\n    return {\n        'mae': ret,\n        'l1_evals': evals_result['valid_0']['l1'],\n        'custom_mae': evals_result['valid_0']['custom_mae']\n    }", "test_script": "import numpy as np\nfrom sklearn.model_selection import train_test_split\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 500)\n        num_features = np.random.randint(5, 20)\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.rand(num_samples)\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2)\n        test_cases.append((X_train, X_test, y_train, y_test))\n\n    return test_cases"}
{"problem_id": "lightgbm_28", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that simulates position bias in a dataset and trains a LightGBM model based on the modified labels. The function will take in a dataset of entries, a query data list indicating the number of documents per query, a baseline feature to extract values from, and the parameters for the LightGBM training.\n\nFunction signature:\n```python\ndef simulate_position_bias_and_train(dataset, query_data, baseline_feature, params):\n```\n\n### Constants:\n- The constant used in the main code is `num_boost_round`, which is set to `50`.\n\n### Input Format:\n- `dataset`: A list of lists, where each inner list contains a label followed by feature strings in the format \"index:value\".\n- `query_data`: A list of integers, where each integer represents the number of documents in a query.\n- `baseline_feature`: An integer representing the index of the feature to be used for bias simulation.\n- `params`: A dictionary containing parameters for the LightGBM training.\n\n### Output Format:\n- The function returns a list of integers representing the positions of documents after processing.\n\n**Input:**\n```python\ndataset = [\n    ['1', '0:0.1', '1:0.5', '2:0.3', '3:0.7', '4:0.2', '5:0.9', '6:0.4', '7:0.6', '8:0.8', '9:0.0'],\n    ['0', '0:0.2', '1:0.4', '2:0.1', '3:0.5', '4:0.3', '5:0.8', '6:0.6', '7:0.9', '8:0.0', '9:0.7'],\n    ['1', '0:0.3', '1:0.2', '2:0.4', '3:0.1', '4:0.5', '5:0.0', '6:0.8', '7:0.6', '8:0.9', '9:0.7']\n]\nquery_data = [2, 3, 1]\nbaseline_feature = 2\nparams = {\n    'objective': 'binary',\n    'metric': 'binary_logloss',\n    'verbose': -1,\n}\n```\n\n**Output:**\n```python\npositions_all = [0, 1, 1, 2, 0, 0]\n```", "ground_truth_code": "import lightgbm as lgb\nimport numpy as np\n\ndef extract_feature_value(features, baseline_feature):\n    for feature in features:\n        parts = feature.split(':')\n        if len(parts) == 2 and parts[0].isdigit() and int(parts[0]) == baseline_feature:\n            return float(parts[1])\n    return 0.0\n\n# main code\ndef simulate_position_bias_and_train(dataset, query_data, baseline_feature, params):\n    positions_all = []\n\n    labels = np.array([int(entry[0]) for entry in dataset])\n    features = np.array([\n        [float(feature.split(':')[1]) for feature in entry[1:]]\n        for entry in dataset\n    ])\n\n    for docs_num in query_data:\n        positions = [0] * docs_num\n        index_values = [\n            (index, extract_feature_value(dataset[index], baseline_feature))\n            for index in range(docs_num)\n        ]\n\n        index_values.sort(key=lambda x: -x[1])\n\n        stop = False\n        for pos, (index, _) in enumerate(index_values):\n            new_label = 1 if pos % 2 == 0 else 0\n            stop = stop or (pos % 3 == 0)\n            labels[index] = new_label\n            positions[index] = pos\n\n        positions_all.extend(positions)\n\n    lgb_train = lgb.Dataset(features, label=labels)\n    lgb_valid = [lgb_train.create_valid(features, label=labels)]\n    lgb.train(params, lgb_train, valid_sets=lgb_valid, num_boost_round=50)\n\n    return positions_all", "test_script": "import random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        dataset_size = random.randint(5, 50)\n        dataset = [\n            [str(random.randint(0, 1))] +\n            [f\"{random.randint(0, 10)}:{random.uniform(0, 1):.2f}\" for _ in range(10)]\n            for _ in range(dataset_size)\n        ]\n\n        query_data = [random.randint(1, dataset_size // 2) for _ in range(5)]\n        baseline_feature = random.randint(0, 10)\n\n        params = {\n            'objective': 'binary',\n            'metric': 'binary_logloss',\n            'verbose': -1,\n        }\n\n        test_cases.append((dataset, query_data, baseline_feature, params))\n\n    return test_cases"}
{"problem_id": "lightgbm_29", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model for different types of machine learning tasks, including regression, binary classification, and multiclass classification. The function will take training and testing datasets along with model parameters, train the model, and evaluate its performance based on the specified objective.\n\nFunction Signature:\n```python\ndef train_lightgbm(X_train, X_test, y_train, y_test, params):\n```\n\nConstant Used:\n- The constant `num_boost_round` is set to 1000, which indicates the maximum number of boosting iterations for the LightGBM model.\n\nInput Format:\n- `X_train`: A 2D array-like structure containing the training features.\n- `X_test`: A 2D array-like structure containing the testing features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `y_test`: A 1D array-like structure containing the testing labels.\n- `params`: A dictionary containing model parameters, including the 'objective' key that specifies the type of task (e.g., 'regression', 'binary', 'multiclass').\n\nOutput Format:\n- If the objective is 'regression', the function returns a tuple containing the Mean Squared Error and R-squared score.\n- If the objective is 'binary' or 'multiclass', the function returns the accuracy score as a single float value.\n\n**Input:**\n```python\nX_train = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.3, 0.4]])\nX_test = np.array([[0.15, 0.25, 0.35], [0.45, 0.55, 0.65]])\ny_train = np.array([0.1, 0.4, 0.7, 0.2])\ny_test = np.array([0.15, 0.45])\nparams = {\n    'objective': 'regression',\n    'metric': 'rmse',\n    'learning_rate': 0.1,\n    'num_leaves': 31,\n    'max_depth': -1,\n    'min_data_in_leaf': 20,\n    'feature_fraction': 0.9\n}\n```\n\n**Output:**\n```python\n(0.0249999999627471, -0.11111110945542646)\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nfrom sklearn.metrics import mean_squared_error, r2_score, accuracy_score\nfrom lightgbm import early_stopping, log_evaluation\n\n\n# main code\ndef train_lightgbm(X_train, X_test, y_train, y_test, params):\n    train_data = lgb.Dataset(X_train, label=y_train)\n    valid_data = lgb.Dataset(X_test, label=y_test, reference=train_data)\n\n    model = lgb.train(\n        params,\n        train_data,\n        num_boost_round=1000,\n        valid_sets=[train_data, valid_data],\n        callbacks=[early_stopping(50), log_evaluation(100)],\n    )\n\n\n    y_pred = model.predict(X_test)\n\n    if params['objective'] == 'regression':\n        mse = mean_squared_error(y_test, y_pred)\n        r2 = r2_score(y_test, y_pred)\n        return mse, r2\n\n    elif params['objective'] == 'binary':\n        y_pred_labels = (y_pred > 0.5).astype(int)\n        acc = accuracy_score(y_test, y_pred_labels)\n        return acc\n\n    elif params['objective'] == 'multiclass':\n        y_pred_labels = np.argmax(y_pred, axis=1)\n        acc = accuracy_score(y_test, y_pred_labels)\n        return acc\n", "test_script": "import numpy as np\nfrom sklearn.model_selection import train_test_split\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = np.random.randint(100, 1000)\n        n_features = np.random.randint(5, 20)\n        X = np.random.rand(n_samples, n_features)\n        objective = np.random.choice(['regression', 'binary', 'multiclass'])\n\n        if objective == 'regression':\n            y = np.random.rand(n_samples)\n            metric = np.random.choice(['rmse', 'mae'])\n        elif objective == 'binary':\n            y = np.random.randint(0, 2, n_samples)\n            metric = 'binary_error'\n        elif objective == 'multiclass':\n            num_classes = np.random.randint(3, 10)\n            y = np.random.randint(0, num_classes, n_samples)\n            metric = 'multi_error'\n\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n\n        params = {\n            'objective': objective,\n            'metric': metric,\n            'learning_rate': np.random.uniform(0.001, 0.3),\n            'num_leaves': np.random.randint(10, 100),\n            'max_depth': np.random.choice([-1, 5, 10, 20]),\n            'min_data_in_leaf': np.random.randint(5, 50),\n            'feature_fraction': np.random.uniform(0.5, 1.0)\n        }\n\n        if objective == 'multiclass':\n            params['num_class'] = num_classes\n\n        test_cases.append((X_train, X_test, y_train, y_test, params))\n\n    return test_cases"}
{"problem_id": "lightgbm_30", "library": "lightgbm", "code_problem": "You are tasked with implementing a ranking algorithm that incorporates position bias in a machine learning context using LightGBM. The goal is to simulate the effect of position on click-through rates and train a model that can predict the likelihood of a user clicking on a document based on its position in a list.\n\nFunction Signature:\n```python\ndef ranking_with_position_information(params, train_data, test_data, baseline_feature_values, labels, baseline_feature):\n```\n\n### Constants:\n- `pstop`: A constant value set to `0.2`, representing the probability of stopping the simulation of clicks.\n\n### Input Format:\n- `params`: A dictionary of parameters for the LightGBM model.\n- `train_data`: A 2D array or DataFrame representing the training dataset.\n- `test_data`: A 2D array or DataFrame representing the testing dataset.\n- `baseline_feature_values`: A list of dictionaries containing feature values for each document.\n- `labels`: A list of integers (0 or 1) representing the click labels for each document.\n- `baseline_feature`: A string indicating the feature key to be used for ranking.\n\n### Output Format:\n- A dictionary containing:\n  - `\"unbiased_score\"`: A float representing the NDCG score of the unbiased model.\n  - `\"unbiased_set_position_score\"`: A float representing the NDCG score of the model with position information.\n  - `\"positions\"`: A list of integers representing the positions of the documents after simulation.\n\n**Input:**\n```python\nparams = {\n    'objective': 'lambdarank',\n    'metric': 'ndcg',\n    'learning_rate': 0.1,\n    'num_leaves': 31,\n    'min_data_in_leaf': 5,\n    'max_depth': 7\n}\ntrain_data = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ntest_data = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\nbaseline_feature_values = [\n    {\"feature_0\": 0.5, \"feature_1\": 0.2},\n    {\"feature_0\": 0.3, \"feature_1\": 0.8},\n    {\"feature_0\": 0.9, \"feature_1\": 0.1}\n]\nlabels = [0, 1, 2]\nbaseline_feature = \"feature_0\"\n```\n\n**Output:**\n```python\n{\n    'unbiased_score': 0.9197207891481876, \n    'unbiased_set_position_score': 0.9197207891481876, \n    'positions': [1, 2, 0]\n}\n```", "ground_truth_code": "import lightgbm as lgb\nimport numpy as np\n\ndef get_pclick(label):\n    pclick_values = {0: 0.4, 1: 0.6, 2: 0.7, 3: 0.8}\n    return pclick_values.get(label, 0.9)\n\ndef simulate_position_bias(docs_num, baseline_feature_values, labels, baseline_feature):\n    pstop = 0.2\n    index_values = []\n    positions = [0] * docs_num\n\n    for index, features in enumerate(baseline_feature_values):\n        val = features.get(baseline_feature, 0.0)\n        index_values.append([index, val])\n\n    index_values.sort(key=lambda x: -x[1])\n    stop = False\n\n    for pos in range(docs_num):\n        index = index_values[pos][0]\n        new_label = 0\n        if not stop:\n            label = labels[index]\n            pclick = get_pclick(label)\n            if np.random.random() < pclick:\n                new_label = 1\n            stop = np.random.random() < pstop\n        labels[index] = new_label\n        positions[index] = pos\n\n    return labels, positions\n\n# main code\ndef ranking_with_position_information(params, train_data, test_data, baseline_feature_values, labels, baseline_feature):\n    docs_num = len(labels)\n    updated_labels, positions = simulate_position_bias(docs_num, baseline_feature_values, labels, baseline_feature)\n\n    group = [docs_num]\n\n    lgb_train = lgb.Dataset(train_data, label=updated_labels, group=group, params=params, position=positions)\n    lgb_valid = lgb.Dataset(test_data, label=updated_labels, group=group, params=params)\n\n    gbm_unbiased = lgb.train(params, lgb_train, valid_sets=[lgb_train, lgb_valid], num_boost_round=50)\n\n    lgb_train.set_position(positions)\n    gbm_unbiased_set_position = lgb.train(params, lgb_train, valid_sets=[lgb_train, lgb_valid], num_boost_round=50)\n\n    return {\n        \"unbiased_score\": gbm_unbiased.best_score['valid_1'].get('ndcg@3', 0),\n        \"unbiased_set_position_score\": gbm_unbiased_set_position.best_score['valid_1'].get('ndcg@3', 0),\n        \"positions\": positions\n    }\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        docs_num = np.random.randint(5, 100)\n        feature_dim = np.random.randint(3, 20)\n\n        labels = np.random.choice([0, 1, 2, 3], size=docs_num).tolist()\n\n        baseline_feature_values = [\n            {f\"feature_{i}\": np.random.random() for i in range(feature_dim)}\n            for _ in range(docs_num)\n        ]\n\n        baseline_feature = f\"feature_{np.random.randint(0, feature_dim)}\"\n\n        train_data = np.random.random((docs_num, feature_dim))\n        test_data = np.random.random((docs_num, feature_dim))\n\n        params = {\n            'objective': 'lambdarank',\n            'metric': 'ndcg',\n            'learning_rate': 0.1,\n            'num_leaves': 31,\n            'min_data_in_leaf': 5,\n            'max_depth': 7\n        }\n\n        test_cases.append((params, train_data, test_data, baseline_feature_values, labels, baseline_feature))\n\n    return test_cases"}
{"problem_id": "lightgbm_31", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that prepares categorical data for training a LightGBM model and evaluates its performance. The function will handle missing values, convert specified columns to categorical types, and train a LightGBM model using the provided parameters. Additionally, it will return predictions for a test dataset and the feature importance of the trained model.\n\nFunction signature:\n```python\ndef test_pandas_categorical(X, y, X_test, cat_cols_actual, cat_cols_to_store, params, missing_value_fill):\n```\n\nConstant used in the main code:\n- `random_state`: This constant is set to `42` to ensure reproducibility when splitting the dataset into training and validation sets.\n\nInput format:\n- `X`: A pandas DataFrame containing the training features.\n- `y`: A pandas Series or array-like structure containing the target variable.\n- `X_test`: A pandas DataFrame containing the test features.\n- `cat_cols_actual`: A list of column names in `X` that are categorical and need to be processed.\n- `cat_cols_to_store`: A list of column names for which the unique categories should be stored and returned.\n- `params`: A dictionary containing the parameters for the LightGBM model.\n- `missing_value_fill`: The value to fill in for missing entries in the categorical columns.\n\nOutput format:\n- The function returns a tuple where the first element is a dictionary containing:\n  - `'pred'`: An array of predictions for the test dataset.\n  - `'feature_importance'`: An array of feature importance scores based on the gain.\n- The second element of the tuple is the `cat_values` dictionary containing the unique categories for the specified columns.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample Data\nX = pd.DataFrame({\n    'num_col_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'num_col_1': [0.5, 0.6, 0.7, 0.8, 0.9],\n    'cat_col_0': ['A', 'B', 'C', None, 'A'],\n    'cat_col_1': ['D', 'D', None, 'C', 'B']\n})\n\ny = pd.Series([1, 2, 3, 4, 5])\n\nX_test = pd.DataFrame({\n    'num_col_0': [0.2, 0.3],\n    'num_col_1': [0.6, 0.7],\n    'cat_col_0': ['B', None],\n    'cat_col_1': ['C', 'D']\n})\n\ncat_cols_actual = ['cat_col_0', 'cat_col_1']\ncat_cols_to_store = ['cat_col_0']\nparams = {\n    'objective': 'regression',\n    'metric': 'rmse',\n    'num_leaves': 30,\n    'learning_rate': 0.1,\n    'verbose': -1\n}\nmissing_value_fill = 'unknown'\n```\n\n**Output:**\n```python\n(\n    {'pred': array([3.25, 3.25]), 'feature_importance': array([0., 0., 0., 0.])}, \n    {'cat_col_0': ['A', 'B', 'C', 'unknown']}\n)\n```", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.model_selection import train_test_split\n\n# main code\ndef test_pandas_categorical(X, y, X_test, cat_cols_actual, cat_cols_to_store, params, missing_value_fill):\n    for col in cat_cols_actual:\n        X[col] = X[col].fillna(missing_value_fill)\n        X_test[col] = X_test[col].fillna(missing_value_fill)\n\n    X[cat_cols_actual] = X[cat_cols_actual].astype('category')\n    X_test[cat_cols_actual] = X_test[cat_cols_actual].astype('category')\n\n    cat_values = {col: X[col].cat.categories.tolist() for col in cat_cols_to_store}\n\n    X_train, X_val, y_train, y_val = train_test_split(X, y, test_size=0.2, random_state=42)\n\n    lgb_train = lgb.Dataset(X_train, y_train)\n    lgb_val = lgb.Dataset(X_val, y_val, reference=lgb_train)\n\n    gbm = lgb.train(\n        params,\n        lgb_train,\n        num_boost_round=100,\n        valid_sets=[lgb_train, lgb_val],\n        valid_names=['train', 'val'],\n        callbacks=[\n            lgb.early_stopping(10),\n            lgb.log_evaluation(10)\n        ]\n    )\n\n    results = {\n        'pred': gbm.predict(X_test, num_iteration=gbm.best_iteration),\n        'feature_importance': gbm.feature_importance(importance_type='gain')\n    }\n\n    return results, cat_values\n", "test_script": "import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = random.randint(100, 1000)\n        n_features = random.randint(5, 20)\n\n        X = pd.DataFrame(np.random.rand(n_samples, n_features),\n                         columns=[f'num_col_{i}' for i in range(n_features)])\n\n        n_cat_features = random.randint(1, min(5, n_features))\n        cat_cols_actual = random.sample(list(X.columns), n_cat_features)\n\n        for col in cat_cols_actual:\n            X[col] = np.random.choice(['A', 'B', 'C', 'D', np.nan], size=n_samples)\n\n        y = np.random.rand(n_samples)\n\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)\n\n        cat_cols_to_store = random.sample(cat_cols_actual, random.randint(1, len(cat_cols_actual)))\n\n        params = {\n            'objective': 'regression',\n            'metric': 'rmse',\n            'num_leaves': random.randint(20, 50),\n            'learning_rate': round(random.uniform(0.01, 0.3), 3),\n            'verbose': -1\n        }\n\n        missing_value_fill = random.choice(['unknown', 'N/A', 'missing'])\n\n        test_cases.append((X, y, X_test, cat_cols_actual, cat_cols_to_store, params, missing_value_fill))\n\n    return test_cases"}
{"problem_id": "lightgbm_32", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using a stratified group k-fold cross-validation approach. The function will take in a DataFrame containing candidate data and another DataFrame containing soundscape data. The goal is to predict target values for the soundscapes based on the features provided in the candidate DataFrame.\n\nFunction Signature:\n```python\ndef train(candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params):\n```\n\nConstants Used:\n- The constant `num_boost_round` is set to 200, which specifies the number of boosting iterations for the LightGBM model training.\n- The constant `early_stopping_rounds` is set to 20, which is used in the early stopping callback to prevent overfitting.\n\nInput Format:\n- `candidate_df`: A DataFrame containing features and target values for candidates.\n- `candidate_df_soundscapes`: A DataFrame containing features for soundscapes to predict.\n- `num_kfolds`: An integer representing the number of folds for cross-validation.\n- `lgb_params`: A dictionary containing parameters for the LightGBM model.\n\nOutput Format:\n- The function returns a NumPy array of float32 type containing the out-of-fold predictions for the soundscapes.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample candidate_df\ncandidate_df = pd.DataFrame({\n    'feature_1': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_2': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'feature_3': [0.2, 0.3, 0.4, 0.5, 0.6],\n    'target': [0, 1, 0, 1, 0],\n    'audio_id': [1, 1, 2, 2, 3]\n})\n\n# Sample candidate_df_soundscapes\ncandidate_df_soundscapes = pd.DataFrame({\n    'feature_1': [0.2, 0.3, 0.4],\n    'feature_2': [0.4, 0.5, 0.6],\n    'feature_3': [0.1, 0.2, 0.3]\n})\n\nnum_kfolds = 3\nlgb_params = {\n    'objective': 'binary',\n    'metric': 'binary_logloss',\n    'verbose': -1,\n    'learning_rate': 0.1,\n    'num_leaves': 31\n}\n```\n\nOutput:\n```python\narray([0.3888889, 0.3888889, 0.3888889], dtype=float32)\n```\n", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nfrom sklearn.model_selection import StratifiedGroupKFold\n\n# main code\ndef train(candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params):\n    feature_names = ['feature_1', 'feature_2', 'feature_3']\n    groups = candidate_df['audio_id']\n\n    kf = StratifiedGroupKFold(n_splits=num_kfolds)\n    for kfold_index, (_, valid_index) in enumerate(\n            kf.split(candidate_df[feature_names], candidate_df['target'], groups)):\n        candidate_df.loc[valid_index, 'fold'] = kfold_index\n\n    oofa = np.zeros(len(candidate_df_soundscapes), dtype=np.float32)\n\n    for kfold_index in range(num_kfolds):\n        train_index = candidate_df[candidate_df['fold'] != kfold_index].index\n        valid_index = candidate_df[candidate_df['fold'] == kfold_index].index\n\n        X_train = candidate_df.loc[train_index, feature_names]\n        y_train = candidate_df.loc[train_index, 'target']\n\n        X_valid = candidate_df.loc[valid_index, feature_names]\n        y_valid = candidate_df.loc[valid_index, 'target']\n\n        dtrain = lgb.Dataset(X_train, label=y_train)\n        dvalid = lgb.Dataset(X_valid, label=y_valid, reference=dtrain)\n\n        model = lgb.train(\n            lgb_params,\n            dtrain,\n            num_boost_round=200,\n            valid_sets=[dvalid],\n            valid_names=['valid'],\n            callbacks=[lgb.early_stopping(20)]\n        )\n\n        X_soundscape_valid = candidate_df_soundscapes[feature_names]\n        oofa += model.predict(X_soundscape_valid.astype(np.float32)) / num_kfolds\n\n    return oofa", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = np.random.randint(100, 500)\n        num_kfolds = np.random.randint(2, 10)\n\n        feature_data = np.random.rand(num_samples, 3)\n        candidate_df = pd.DataFrame(feature_data, columns=['feature_1', 'feature_2', 'feature_3'])\n\n        candidate_df['target'] = np.random.randint(0, 2, num_samples)\n        candidate_df['audio_id'] = np.random.randint(1, 20, num_samples)\n\n        candidate_df_soundscapes = pd.DataFrame(\n            np.random.rand(num_samples, 3),\n            columns=['feature_1', 'feature_2', 'feature_3']\n        )\n\n        lgb_params = {\n            'objective': 'binary',\n            'metric': 'binary_logloss',\n            'verbose': -1,\n            'learning_rate': 0.1,\n            'num_leaves': 31\n        }\n\n        test_cases.append((candidate_df, candidate_df_soundscapes, num_kfolds, lgb_params))\n\n    return test_cases"}
{"problem_id": "lightgbm_33", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM classifier on a given training dataset and evaluates its performance. The function should take in training features and labels, fit the model, and return the evaluation score along with the predictions made by the model on the training data.\n\nFunction signature:\n```python\ndef process(X_train, y_train):\n```\n\nConstant used in the main code:\n- The constant used in the main code is the instantiation of the `LGBMClassifier` from the LightGBM library, which is represented by the variable `model`.\n\nInput format:\n- The function takes two inputs:\n  - `X_train`: A 2D array-like structure (e.g., a list of lists or a NumPy array) representing the training features.\n  - `y_train`: A 1D array-like structure (e.g., a list or a NumPy array) representing the labels corresponding to the training features.\n\nOutput format:\n- The function returns a tuple containing:\n  - `eval_result`: A float representing the evaluation score of the model on the training data.\n  - `predictions`: A 1D array-like structure (e.g., a list or a NumPy array) containing the predicted labels for the training features.\n\n```python\n# Input\nX_train = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.1, 0.4], [0.5, 0.3, 0.2]])\ny_train = np.array([0, 1, 1, 0, 1])\n\n# Output\neval_result = 0.6\npredictions = np.array([1, 1, 1, 1, 1])\n```", "ground_truth_code": "from lightgbm import LGBMClassifier\n\n# main code\ndef process(X_train, y_train):\n    model = LGBMClassifier()\n    model.fit(X_train, y_train)\n\n    eval_result = model.score(X_train, y_train)\n    predictions = model.predict(X_train)\n\n    return eval_result, predictions", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = np.random.randint(50, 501)\n        num_features = np.random.randint(5, 101)\n\n\n        X_train = np.random.rand(num_samples, num_features)\n        y_train = np.random.randint(0, 2, size=(num_samples,))\n\n        test_cases.append((X_train, y_train))\n\n    return test_cases"}
{"problem_id": "lightgbm_34", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using a training dataset and evaluates its performance on both the training and validation datasets. The function should utilize early stopping to prevent overfitting during training. \n\nThe function signature for the main code is as follows:\n\n```python\ndef test_early_stopping_ignores_training_set(X, y):\n```\n\nIn this function, the following constant is used:\n\n- `num_leaves`: This constant is set to `5` in the training parameters for the LightGBM model.\n\nInput format:\n- The function takes two parameters:\n  - `X`: A 2D array-like structure representing the feature set.\n  - `y`: A 1D array-like structure representing the target labels.\n\nOutput format:\n- The function returns a dictionary with the following keys:\n  - `'best_iteration'`: An integer representing the best iteration of the model.\n  - `'current_iteration'`: An integer representing the current iteration of the training process.\n  - `'eval_result'`: A dictionary containing evaluation results from the training process.\n\nInput:\n```python\n(array([[0.80313313, 0.94714725, 0.6838695 , ..., 0.87046325, 0.32572767,\n        0.6523483 ],\n       [0.15567668, 0.9526516 , 0.6731993 , ..., 0.80456173, 0.916768  ,\n        0.904361  ],\n       [0.80448747, 0.0085044 , 0.3222665 , ..., 0.10255971, 0.11520442,\n        0.7798243 ],\n       ...,\n       [0.7323058 , 0.33112442, 0.5070675 , ..., 0.60767937, 0.04610346,\n        0.17882904],\n       [0.8154374 , 0.49474937, 0.43824008, ..., 0.21651368, 0.20115755,\n        0.01643301],\n       [0.96568495, 0.82038367, 0.8756504 , ..., 0.3855856 , 0.6501086 ,\n        0.9755059 ]], dtype=float32), \n array([0, 0, 0, 1, 1, 1, 0, 0, 1, 0, 1, 1, 1, 0, 1, 0, 0, 1, 1, 0, 1, 1,\n       1, 1, 0, 1, 0, 1, 1, 0, 0, 1, 0, 0, 1, 0, 1, 0, 0, 0, 0, 1, 0, 1,\n       0, 1, 1, 0, 0, 1, 1, 1, 0, 0, 1, 1, 0, 1, 0, 1, 1, 1, 1, 0, 0, 1,\n       1, 1, 1, 0, 0, 0, 0, 1, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 0,\n       0, 1, 0, 1, 1, 0, 1, 0, 0, 0, 1, 1])\n)\n```\n\nOutput:\n```python\n{\n    'best_iteration': 2, \n    'current_iteration': 2, \n    'eval_result': {\n        'train': OrderedDict([('l2', [0.24385457875457872, 0.23805241090443635])]), \n        'valid': OrderedDict([('l2', [0.24816512471655328, 0.24483867795261052])])\n    }\n}\n```", "ground_truth_code": "import lightgbm as lgb\n\ndef train_fn(valid_names, valid_sets, eval_result, train_ds):\n    return lgb.train({'num_leaves': 5}, train_ds, num_boost_round=2, valid_sets=valid_sets, valid_names=valid_names, callbacks=[lgb.early_stopping(1), lgb.record_evaluation(eval_result)])\n\n# main code\ndef test_early_stopping_ignores_training_set(X, y):\n    (X_train, X_valid) = (X[:80], X[80:])\n    (y_train, y_valid) = (y[:80], y[80:])\n    train_ds = lgb.Dataset(X_train, y_train)\n    valid_ds = lgb.Dataset(X_valid, y_valid)\n    valid_sets = [train_ds]\n    valid_names = ['train']\n\n\n    valid_sets.append(valid_ds)\n    valid_names.append('valid')\n\n    eval_result = {}\n\n    bst = train_fn(valid_names, valid_sets, eval_result, train_ds)\n    return {\n        'best_iteration': bst.best_iteration,\n        'current_iteration': bst.current_iteration(),\n        'eval_result': eval_result\n    }", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(10, 51)\n        X = np.random.rand(100, num_features).astype(np.float32)\n        if np.random.rand() > 0.5:\n            y = np.random.randint(0, 2, size=100)\n        else:\n            y = np.random.randn(100)\n\n        test_cases.append((X, y))\n    return test_cases"}
{"problem_id": "lightgbm_35", "library": "lightgbm", "code_problem": "You are tasked with implementing a machine learning model prediction function using LightGBM. The function will train a model on a training dataset, validate it on a validation dataset, and then predict probabilities on a test dataset. The function should also handle early stopping during training to prevent overfitting.\n\nFunction Signature:\n```python\ndef model_predict(train_set: pd.DataFrame, val_set: pd.DataFrame, test_set: pd.DataFrame, val_ratio: float, n_round: int, early_stopping_rounds: int = 100) -> pd.DataFrame:\n```\n\nConstant used in the main code:\n- `params`: A dictionary containing the parameters for the LightGBM model, specifically:\n  - `'learning_rate'`: 0.01\n  - `'boosting_type'`: 'gbdt'\n  - `'objective'`: 'binary'\n\nInput format:\n- `train_set`: A pandas DataFrame containing the training data with columns including 'user_id' and 'label'.\n- `val_set`: A pandas DataFrame containing the validation data with columns including 'user_id' and 'label'.\n- `test_set`: A pandas DataFrame containing the test data with a 'user_id' column and features for prediction.\n- `val_ratio`: A float representing the fraction of the validation set to sample for each training iteration.\n- `n_round`: An integer representing the number of training iterations to perform.\n- `early_stopping_rounds`: An optional integer (default is 100) representing the number of rounds with no improvement after which training will be stopped.\n\nOutput format:\n- Returns a pandas DataFrame containing the `user_id` and the final predicted probabilities in the `prob` column.\n\n**Input:**\n```python\ntrain_set = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [0.5, 0.6, 0.7, 0.8, 0.9],\n    'user_id': [0, 1, 2, 3, 4],\n    'label': [0, 1, 0, 1, 1]\n})\n\nval_set = pd.DataFrame({\n    'feature_0': [0.2, 0.3, 0.4],\n    'feature_1': [0.6, 0.7, 0.8],\n    'user_id': [5, 6, 7],\n    'label': [0, 1, 1]\n})\n\ntest_set = pd.DataFrame({\n    'feature_0': [0.3, 0.4, 0.5],\n    'feature_1': [0.7, 0.8, 0.9],\n    'user_id': [8, 9, 10],\n    'label': [0, 1, 1]\n})\n\nval_ratio = 0.3\nn_round = 5\n```\n\n**Output:**\n```python\n   user_id  prob\n0        8   1.0\n1        9   1.0\n2       10   1.0\n```", "ground_truth_code": "import lightgbm as lgb\nimport pandas as pd\nimport numpy as np\n\ndef get_majority_mean(x):\n    counts = np.bincount((x >= 0.5).astype(int), weights=x)\n    if len(counts) == 1:\n        return 0\n    return counts[1] / max(counts.sum(), 1)\n\n# main code\ndef model_predict(train_set, val_set, test_set, val_ratio, n_round, early_stopping_rounds=100):\n    res = test_set[['user_id']].copy()\n    test_x = test_set.drop(['user_id', 'label'], axis=1)\n    res['prob'] = 0\n\n    params = {'learning_rate': 0.01, 'boosting_type': 'gbdt', 'objective': 'binary'}\n\n    for i in range(n_round):\n        val = val_set.sample(frac=val_ratio)\n        val_train = val_set.loc[~val_set['user_id'].isin(val['user_id'])]\n        train = pd.concat([train_set, val_train], axis=0)\n\n        train_y = train['label']\n        train_x = train.drop(['user_id', 'label'], axis=1)\n\n        val_y = val['label']\n        val_x = val.drop(['user_id', 'label'], axis=1)\n\n        clf = lgb.train(\n            params,\n            lgb.Dataset(train_x, train_y),\n            3000,\n            valid_sets=[lgb.Dataset(val_x, val_y)],\n            callbacks=[lgb.early_stopping(early_stopping_rounds), lgb.log_evaluation(100)]\n        )\n\n        res[f'prob_{i}'] = clf.predict(test_x, num_iteration=clf.best_iteration)\n\n    prob_cols = [f for f in list(res.columns) if 'prob_' in f]\n    res['prob'] = res[prob_cols].apply(get_majority_mean, axis=1)\n    res.drop(labels=prob_cols, axis=1, inplace=True)\n\n    return res", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_train = random.randint(500, 1000)\n        n_val = random.randint(200, 500)\n        n_test = random.randint(300, 600)\n        n_features = random.randint(5, 20)\n\n        train_data = np.random.rand(n_train, n_features)\n        train_labels = np.random.choice([0, 1], size=n_train)\n        train_set = pd.DataFrame(train_data, columns=[f'feature_{i}' for i in range(n_features)])\n        train_set['user_id'] = np.arange(n_train)\n        train_set['label'] = train_labels\n\n        val_data = np.random.rand(n_val, n_features)\n        val_labels = np.random.choice([0, 1], size=n_val)\n        val_set = pd.DataFrame(val_data, columns=[f'feature_{i}' for i in range(n_features)])\n        val_set['user_id'] = np.arange(n_val)\n        val_set['label'] = val_labels\n\n        test_data = np.random.rand(n_test, n_features)\n        test_set = pd.DataFrame(test_data, columns=[f'feature_{i}' for i in range(n_features)])\n        test_set['user_id'] = np.arange(n_test)\n        test_set['label'] = np.random.choice([0, 1], size=n_test)\n\n        val_ratio = round(random.uniform(0.1, 0.5), 2)\n        n_round = random.randint(3, 10)\n\n        test_cases.append((train_set, val_set, test_set, val_ratio, n_round))\n\n    return test_cases"}
{"problem_id": "lightgbm_36", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that predicts probabilities for a given test dataset based on a training dataset and a validation dataset. The function should support three different machine learning models: LightGBM, Random Forest, and Logistic Regression. The function will also utilize a custom method to compute the final predicted probability based on the predictions from multiple rounds of training.\n\nFunction Signature:\n```python\ndef model_predict(train_set: pd.DataFrame, val_set: pd.DataFrame, test_set: pd.DataFrame, model_name: str, val_ratio: float, n_round: int) -> pd.DataFrame:\n```\n\nConstants used in the main code:\n- The learning rate for LightGBM is set to `0.01`.\n- The number of leaves for LightGBM is set to `31`.\n- The number of estimators for Random Forest is set to `1000`.\n- The maximum depth for Random Forest is set to `6`.\n- The penalty for Logistic Regression is set to `'l2'`.\n- The regularization strength for Logistic Regression is set to `0.06`.\n- The solver for Logistic Regression is set to `'liblinear'`.\n- The maximum number of iterations for Logistic Regression is set to `2000`.\n\nInput format:\n- `train_set`: A pandas DataFrame containing the training data with columns 'user_id' and 'label'.\n- `val_set`: A pandas DataFrame containing the validation data with columns 'user_id' and 'label'.\n- `test_set`: A pandas DataFrame containing the test data with a column 'user_id' and feature columns for prediction.\n- `model_name`: A string indicating which model to use ('lgb', 'rf', or 'lr').\n- `val_ratio`: A float representing the ratio of the validation set to sample from the validation dataset.\n- `n_round`: An integer representing the number of training rounds to perform.\n\nOutput format:\n- The function returns a pandas DataFrame containing the 'user_id' and a column 'prob' with the predicted probabilities for each user in the test set.\n\n**Input:**\n```python\ntrain_set = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [0.5, 0.6, 0.7, 0.8, 0.9],\n    'user_id': [0, 1, 2, 3, 4],\n    'label': [0, 1, 0, 1, 1]\n})\n\nval_set = pd.DataFrame({\n    'feature_0': [0.15, 0.25, 0.35],\n    'feature_1': [0.55, 0.65, 0.75],\n    'user_id': [5, 6, 7],\n    'label': [0, 1, 0]\n})\n\ntest_set = pd.DataFrame({\n    'feature_0': [0.2, 0.3],\n    'feature_1': [0.6, 0.7],\n    'user_id': [8, 9]\n})\n\nmodel_name = 'lgb'\nval_ratio = 0.3\nn_round = 5\n```\n\n**Output:**\n```python\n   user_id      prob\n0        8  0.571429\n1        9  0.571429\n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nimport lightgbm as lgb\nfrom sklearn.linear_model import LogisticRegression as lr\nfrom sklearn.ensemble import RandomForestClassifier as rf\n\ndef get_majority_mean(x):\n    counts = [0, 0]\n    totals = [0.0, 0.0]\n    for v in x:\n        idx = int(v >= 0.5)\n        counts[idx] += 1\n        totals[idx] += v\n    return totals[1] / counts[1] if counts[1] >= counts[0] else totals[0] / counts[0]\n\n# main code\ndef model_predict(train_set, val_set, test_set, model_name, val_ratio, n_round):\n    res = test_set[['user_id']].copy()\n    test_x = test_set.drop(['user_id'], axis=1)\n\n    params = {\n        'lgb': {'learning_rate': 0.01, 'boosting_type': 'gbdt', 'objective': 'binary', 'metric': 'auc', 'num_leaves': 31},\n        'rf': {'n_estimators': 1000, 'max_depth': 6},\n        'lr': {'penalty': 'l2', 'C': 0.06, 'solver': 'liblinear', 'max_iter': 2000}\n    }\n\n    for i in range(n_round):\n        val = val_set.sample(frac=val_ratio)\n        train = pd.concat([train_set, val_set.loc[~val_set['user_id'].isin(val['user_id'])]])\n        train_y, train_x = train['label'], train.drop(['user_id', 'label'], axis=1)\n        val_y, val_x = val['label'], val.drop(['user_id', 'label'], axis=1)\n\n        if model_name == 'lgb':\n            clf = lgb.train(\n                params[model_name],\n                lgb.Dataset(train_x, train_y),\n                1000,\n                valid_sets=[lgb.Dataset(val_x, val_y)],\n                callbacks=[lgb.early_stopping(100)]\n            )\n            temp_predict = clf.predict(test_x, num_iteration=clf.best_iteration)\n        elif model_name == 'rf':\n            clf = rf(**params[model_name])\n            clf.fit(train_x, train_y)\n            temp_predict = clf.predict_proba(test_x)[:, 1]\n        elif model_name == 'lr':\n            clf = lr(**params[model_name])\n            clf.fit(train_x, train_y)\n            temp_predict = clf.predict_proba(test_x)[:, 1]\n\n        res[f'prob_{i}'] = temp_predict\n\n    prob_cols = [f for f in res.columns if 'prob_' in f]\n    res['prob'] = res[prob_cols].apply(get_majority_mean, axis=1)\n    res.drop(labels=prob_cols, axis=1, inplace=True)\n\n    return res", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        train_size = random.randint(150, 300)\n        val_size = random.randint(30, 50)\n        test_size = random.randint(30, 50)\n        n_features = random.randint(5, 10)\n\n        def generate_data(size):\n            data = pd.DataFrame(np.random.rand(size, n_features), columns=[f'feature_{i}' for i in range(n_features)])\n            data['user_id'] = np.arange(size)\n            data['label'] = np.random.randint(0, 2, size)\n            return data\n\n        train_set = generate_data(train_size)\n        val_set = generate_data(val_size)\n        test_set = generate_data(test_size).drop('label', axis=1)\n\n        model_name = random.choice(['lgb', 'rf', 'lr'])\n        val_ratio = round(random.uniform(0.1, 0.5), 2)\n        n_round = random.randint(3, 10)\n        test_cases.append((train_set, val_set, test_set, model_name, val_ratio, n_round))\n\n    return test_cases"}
{"problem_id": "lightgbm_37", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model for either binary or multiclass classification tasks. The function should prepare the training and testing datasets, configure the model parameters based on the number of classes, and handle early stopping for binary classification. The trained model should be stored in a dictionary for later use.\n\nFunction signature:\n```python\ndef lgbm_train(X_train, X_test, Y_train, Y_test, trained_models, target_variable, num_classes):\n```\n\n### Constants Used:\n- `lambda_l1`: 10.0\n- `lambda_l2`: 10.0\n- `num_leaves`: 50\n- `feature_fraction`: 0.8\n- `feature_fraction_bynode`: 0.8\n- `learning_rate`: 0.01\n- `verbose`: -1\n- `drop_rate`: 0.3 (for multiclass)\n- `skip_drop`: 0.3 (for multiclass)\n- `min_gain_to_split`: 5.0 (for multiclass)\n\n### Input Format:\n- `X_train`: DataFrame containing training features.\n- `X_test`: DataFrame containing testing features.\n- `Y_train`: Series or array containing training labels.\n- `Y_test`: Series or array containing testing labels.\n- `trained_models`: Dictionary to store trained models.\n- `target_variable`: String representing the name of the target variable.\n- `num_classes`: Integer representing the number of classes in the classification task.\n\n### Output Format:\n- Returns a dictionary containing the trained LightGBM model under the key 'lgbm'.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Mock data for the test case\nX_train = pd.DataFrame({\n    'feature_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'feature_1': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'feature_2': [0.2, 0.3, 0.4, 0.5, 0.6]\n})\nY_train = pd.Series([0, 1, 0, 1, 0])\nX_test = pd.DataFrame({\n    'feature_0': [0.15, 0.25],\n    'feature_1': [0.45, 0.35],\n    'feature_2': [0.25, 0.35]\n})\nY_test = pd.Series([0, 1])\ntrained_models = {}\ntarget_variable = 'target'\nnum_classes = 2\n```\n\n**Output:**\n```python\n{\n    'lgbm': <lightgbm.basic.Booster object>\n}\n```", "ground_truth_code": "import lightgbm as lgb\n\n\n# main code\ndef lgbm_train(X_train, X_test, Y_train, Y_test, trained_models, target_variable, num_classes):\n    X_train = X_train.drop(target_variable, axis=1, errors='ignore')\n    dtrain = lgb.Dataset(X_train, label=Y_train)\n\n    param = {\n        'objective': 'binary' if num_classes == 2 else 'multiclass',\n        'metric': 'binary_logloss' if num_classes == 2 else 'multi_logloss',\n        'lambda_l1': 10.0,\n        'lambda_l2': 10.0,\n        'num_leaves': 50,\n        'feature_fraction': 0.8,\n        'feature_fraction_bynode': 0.8,\n        'learning_rate': 0.01,\n        'verbose': -1\n    }\n\n    callbacks = []\n\n    if num_classes > 2:\n        param.update({\n            'boosting': 'dart',\n            'drop_rate': 0.3,\n            'skip_drop': 0.3,\n            'num_class': num_classes,\n            'min_gain_to_split': 5.0\n        })\n    else:\n        callbacks.append(lgb.early_stopping(10))\n\n    Dtest = lgb.Dataset(X_test.drop(target_variable, axis=1, errors='ignore'), label=Y_test)\n\n    model = lgb.train(param, dtrain, num_boost_round=500,\n                      valid_sets=[dtrain, Dtest], valid_names=['train', 'valid'],\n                      callbacks=callbacks)\n\n    trained_models['lgbm'] = model\n\n    return trained_models", "test_script": "import numpy as np\nimport pandas as pd\n\ndef test_case_input_generator(n=200):\n    def generate_mock_data(num_samples, num_features, num_classes):\n        data = pd.DataFrame(np.random.rand(num_samples, num_features),\n                            columns=[f'feature_{i}' for i in range(num_features)])\n        target = np.random.randint(0, num_classes, size=num_samples)\n        data['target'] = target\n        return data\n\n    test_cases = []\n\n    for _ in range(n):\n        num_samples_train = np.random.randint(50, 500)\n        num_samples_test = np.random.randint(20, 200)\n        num_features = np.random.randint(5, 50)\n        num_classes = np.random.choice([2, 3, 4, 5, 10])\n\n        train_data = generate_mock_data(num_samples_train, num_features, num_classes)\n        test_data = generate_mock_data(num_samples_test, num_features, num_classes)\n\n        X_train, Y_train = train_data.drop('target', axis=1), train_data['target']\n        X_test, Y_test = test_data.drop('target', axis=1), test_data['target']\n\n        trained_models = {}\n        target_variable = 'target'\n\n        test_cases.append((X_train, X_test, Y_train, Y_test, trained_models, target_variable, num_classes))\n\n    return test_cases"}
{"problem_id": "lightgbm_38", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains a LightGBM model using a given training dataset and validation dataset. The function should optimize the model's hyperparameters, specifically the number of leaves, while keeping the maximum depth fixed. The function will return the best-trained model based on the validation score.\n\nFunction signature:\n```python\ndef train_lgbm(train_x, train_y, val_x, val_y, params, fixed_max_depth):\n```\n\nConstant used in the main code:\n- The learning rate is set to a constant value of `0.05`.\n\nInput format:\n- `train_x`: A 2D numpy array of shape (n_samples, n_features) representing the training features.\n- `train_y`: A 1D numpy array of shape (n_samples,) representing the training labels.\n- `val_x`: A 2D numpy array of shape (n_samples, n_features) representing the validation features.\n- `val_y`: A 1D numpy array of shape (n_samples,) representing the validation labels.\n- `params`: A dictionary containing the initial hyperparameters for the LightGBM model.\n- `fixed_max_depth`: An integer representing the maximum depth of the trees to be used in the model.\n\nOutput format:\n- The function returns a trained LightGBM model object.\n\nInput:\n```python\ntrain_x = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]], dtype=np.float32)\ntrain_y = np.array([0, 1, 0], dtype=np.uint8)\nval_x = np.array([[0.15, 0.25, 0.35], [0.45, 0.55, 0.65]], dtype=np.float32)\nval_y = np.array([0, 1], dtype=np.uint8)\nparams = {\n    'objective': 'binary',\n    'metric': 'binary_logloss',\n    'boosting_type': 'gbdt',\n    'feature_fraction': 0.8,\n    'bagging_fraction': 0.7,\n    'bagging_freq': 2,\n    'verbosity': -1\n}\nfixed_max_depth = 5\n```\n\nOutput:\n```python\nfinal_model = train_lgbm(train_x, train_y, val_x, val_y, params, fixed_max_depth)\n# <lightgbm.basic.Booster object at 0x766ee0504250>\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n# main code\ndef train_lgbm(train_x, train_y, val_x, val_y, params, fixed_max_depth):\n    (train_x, train_y) = (train_x.astype(np.float32), train_y.astype(np.uint8))\n    (val_x, val_y) = (val_x.astype(np.float32), val_y.astype(np.uint8))\n\n    train_data = lgb.Dataset(train_x, label=train_y, free_raw_data=False)\n    val_data = lgb.Dataset(val_x, label=val_y, free_raw_data=False)\n\n    (best_score, best_params) = (float('inf'), params.copy())\n    callbacks = [lgb.early_stopping(5), lgb.log_evaluation(False)]\n\n    num_leaves_choices = np.random.choice(np.linspace(20, 61, 10, dtype=int), size=5, replace=False)\n\n    for num_leaves in num_leaves_choices:\n        temp_params = {\n            **params,\n            'max_depth': fixed_max_depth,\n            'num_leaves': num_leaves,\n            'learning_rate': 0.05,\n            'n_jobs': -1,\n        }\n        model = lgb.train(temp_params, train_data, valid_sets=[val_data], callbacks=callbacks)\n        score = model.best_score['valid_0'][params['metric']]\n        if score < best_score:\n            (best_score, best_params) = (score, temp_params.copy())\n\n    final_model = lgb.train(best_params, train_data, valid_sets=[val_data], callbacks=callbacks)\n    return final_model\n\n", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=100):\n    test_cases = []\n    for _ in range(n):\n        num_train_samples = np.random.randint(200, 300)\n        num_val_samples = np.random.randint(30, 50)\n        num_features = np.random.randint(5, 30)\n        train_x = np.random.rand(num_train_samples, num_features).astype(np.float32)\n        train_y = np.random.randint(0, 2, size=(num_train_samples,)).astype(np.uint8)\n        val_x = np.random.rand(num_val_samples, num_features).astype(np.float32)\n        val_y = np.random.randint(0, 2, size=(num_val_samples,)).astype(np.uint8)\n\n        params = {\n            'objective': 'binary',\n            'metric': 'binary_logloss',\n            'boosting_type': np.random.choice(['gbdt', 'dart']),\n            'feature_fraction': np.random.uniform(0.5, 0.9),\n            'bagging_fraction': np.random.uniform(0.5, 0.9),\n            'bagging_freq': np.random.randint(1, 5),\n            'verbosity': -1\n        }\n\n        fixed_max_depth = np.random.choice([-1, 5, 7])\n        test_cases.append((train_x, train_y, val_x, val_y, params, fixed_max_depth))\n    return test_cases"}
{"problem_id": "lightgbm_39", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that trains and evaluates two different machine learning models on a given dataset. The function will utilize logistic regression and a gradient boosting decision tree classifier to predict a target variable and compute various performance metrics for both models.\n\nFunction Signature:\n```python\ndef train_and_evaluate(data):\n```\n\nConstant Used:\n- The constant `0.9` is used to determine the split ratio for training and validation datasets.\n\nInput Format:\n- The input to the function is a pandas DataFrame `data` that contains multiple columns, with one column named 'var0' representing the target variable.\n\nOutput Format:\n- The output of the function is a tuple containing two tuples. Each inner tuple consists of four floating-point numbers representing the accuracy, precision, recall, and F1 score for the respective models (logistic regression and gradient boosting).\n\n**Input:**\n```python\nimport pandas as pd\nfrom sklearn.datasets import make_classification\n\n# Generating a test case input\nX, y = make_classification(n_samples=1000, n_features=20, n_informative=15,\n                           n_redundant=5, n_classes=2)\n\nfeature_names = [f'feature{i}' for i in range(20)]\ndf = pd.DataFrame(X, columns=feature_names)\ndf['var0'] = y\n\n# Calling the function with the generated DataFrame\nlr_metrics, gbdt_metrics = train_and_evaluate(df)\n```\n\n**Output:**\n```python\n# Example output metrics (actual values will vary due to randomness)\nlr_metrics = (0.86, 0.8888888888888888, 0.8571428571428571, 0.8727272727272727)  # (accuracy, precision, recall, f1-score)\ngbdt_metrics = (0.9, 0.9423076923076923, 0.875, 0.9074074074074074)  # (accuracy, precision, recall, f1-score)\n```", "ground_truth_code": "from sklearn.model_selection import train_test_split\nimport lightgbm as lgb\nfrom sklearn.metrics import accuracy_score, precision_score, recall_score, f1_score\nfrom sklearn.linear_model import LogisticRegression\n\n\n# main code\ndef train_and_evaluate(data):\n    features = [col for col in data.columns if col != 'var0']\n    split_idx = int(len(data) * 0.9)\n    x_train, x_valid, y_train, y_valid = train_test_split(data[features][:split_idx], data['var0'][:split_idx], test_size=0.1)\n    x_test, y_test = data[features][split_idx:], data['var0'][split_idx:]\n\n    lr_model = LogisticRegression(penalty='l2', C=0.05)\n    lr_model.fit(x_train, y_train)\n    lr_pred = lr_model.predict(x_test)\n    lr_metrics = (accuracy_score(y_test, lr_pred), precision_score(y_test, lr_pred), recall_score(y_test, lr_pred), f1_score(y_test, lr_pred))\n\n\n    gbdt_model = lgb.LGBMClassifier(num_leaves=31, n_estimators=100, learning_rate=0.1)\n    gbdt_model.fit(x_train, y_train)\n    gbdt_pred = gbdt_model.predict(x_test)\n    gbdt_metrics = (accuracy_score(y_test, gbdt_pred), precision_score(y_test, gbdt_pred), recall_score(y_test, gbdt_pred), f1_score(y_test, gbdt_pred))\n\n    return lr_metrics, gbdt_metrics", "test_script": "import pandas as pd\nfrom sklearn.datasets import make_classification\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        X, y = make_classification(n_samples=1000, n_features=20, n_informative=15,\n                                   n_redundant=5, n_classes=2)\n\n        feature_names = [f'feature{i}' for i in range(20)]\n        df = pd.DataFrame(X, columns=feature_names)\n        df['var0'] = y\n\n        test_cases.append(df)\n\n    return test_cases\n"}
{"problem_id": "lightgbm_40", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes the LightGBM library to train a regression model and analyze the predictions made by the model. The function will take in training data, train a model, and then predict values for new data. Additionally, it will compute the minimum and maximum counts of unique predicted values.\n\nFunction signature:\n```python\ndef test_forced_bins(x: np.ndarray, y: np.ndarray, new_x: np.ndarray) -> dict:\n```\n\nConstant used in the main code:\n- `max_bin`: This constant is set to 5, which defines the maximum number of bins that the LightGBM model will use for the feature values during training.\n\nInput format:\n- `x`: A NumPy array of shape (n_samples, n_features) representing the training feature data.\n- `y`: A NumPy array of shape (n_samples,) representing the training target values.\n- `new_x`: A NumPy array of shape (m_samples, n_features) representing the new feature data for which predictions are to be made.\n\nOutput format:\n- A dictionary containing:\n  - `'predicted'`: A NumPy array of predicted values for `new_x`.\n  - `'min_counts'`: An integer representing the minimum count of unique predicted values.\n  - `'max_counts'`: An integer representing the maximum count of unique predicted values.\n\nInput:\n```python\nx = np.array([[0.1, 0.2, 0.3],\n              [0.4, 0.5, 0.6],\n              [0.7, 0.8, 0.9],\n              [0.2, 0.3, 0.1],\n              [0.5, 0.4, 0.6]])\ny = np.array([1.0, 2.0, 3.0, 1.5, 2.5])\nnew_x = np.array([[0.3, 0.4, 0.5],\n                  [0.6, 0.7, 0.8]])\n```\n\nOutput:\n```python\n{\n    'predicted': array([1.78039416, 2.87842335]), \n    'min_counts': 1, \n    'max_counts': 1\n}\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\n\n\n# main code\ndef test_forced_bins(x, y, new_x):\n    params = {\n        'objective': 'regression_l1',\n        'max_bin': 5,\n        'num_leaves': 2,\n        'min_data_in_leaf': 1,\n        'verbose': -1\n    }\n\n    lgb_x = lgb.Dataset(x, label=y)\n    est = lgb.train(params, lgb_x, num_boost_round=20)\n\n    predicted = est.predict(new_x)\n\n    _, counts = np.unique(predicted, return_counts=True)\n\n    return {\n        'predicted': predicted,\n        'min_counts': min(counts),\n        'max_counts': max(counts)\n    }", "test_script": "import numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_features = np.random.randint(3, 20)\n        num_samples = np.random.randint(50, 500)\n        x = np.random.rand(num_samples, num_features)\n        y = np.random.rand(num_samples)\n        new_x_samples = np.random.randint(10, 100)\n        new_x = np.random.rand(new_x_samples, num_features)\n        test_cases.append((x, y, new_x))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_41", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that updates the parameters of a LightGBM model and trains it on a given dataset. The function should take in the feature matrix, target vector, number of boosting rounds, and a dictionary of parameters. The function will create a LightGBM dataset, adjust one of the parameters, train the model, and return both the trained model and the updated parameters.\n\nFunction signature:\n```python\ndef test_dataset_update_params(X, y, num_boost_round, params):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `1`, which is used to ensure that the `min_data_in_leaf` parameter does not go below 1.\n\nInput format:\n- `X`: A 2D array-like structure representing the feature matrix.\n- `y`: A 1D array-like structure representing the target vector.\n- `num_boost_round`: An integer representing the number of boosting iterations.\n- `params`: A dictionary containing the parameters for the LightGBM model.\n\nOutput format:\n- The function returns a tuple consisting of:\n  - `model`: The trained LightGBM model.\n  - `params`: The updated parameters dictionary after modification.\n\nInput:\n```python\nX = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9]])\ny = np.array([0.1, 0.4, 0.7])\nnum_boost_round = 50\nparams = {\n    'objective': 'regression',\n    'learning_rate': 0.1,\n    'min_data_in_leaf': 10,\n    'max_depth': 5,\n    'num_leaves': 30,\n    'metric': 'l2'\n}\n```\n\nOutput:\n```python\n(<lightgbm.basic.Booster object at 0x7b76017a9c60>, {'objective': 'regression', 'learning_rate': 0.1, 'min_data_in_leaf': 9, 'max_depth': 5, 'num_leaves': 30, 'metric': 'l2'})\n```", "ground_truth_code": "import lightgbm as lgb\n\n\n# main code\ndef test_dataset_update_params(X, y, num_boost_round, params):\n    lgb_data = lgb.Dataset(X, y, params={**params, 'feature_pre_filter': False}, free_raw_data=False).construct()\n    params['min_data_in_leaf'] = max(1, params['min_data_in_leaf'] - 1)\n\n    model = lgb.train(params, lgb_data, num_boost_round=num_boost_round)\n\n    return model, params", "test_script": "import random\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(10, 1000)\n        num_features = random.randint(5, 50)\n\n        X = np.random.rand(num_samples, num_features)\n        y = np.random.rand(num_samples)\n\n        params = {\n            'objective': random.choice(['regression', 'binary', 'multiclass']),\n            'learning_rate': round(random.uniform(0.01, 0.3), 2),\n            'min_data_in_leaf': random.randint(1, 50),\n            'max_depth': random.choice([-1, 5, 10, 20]),\n            'num_leaves': random.randint(20, 150),\n        }\n\n        if params['objective'] == 'regression':\n            params['metric'] = 'l2'\n        elif params['objective'] == 'binary':\n            params['metric'] = 'binary_logloss'\n        elif params['objective'] == 'multiclass':\n            params['metric'] = 'multi_logloss'\n            params['num_class'] = random.randint(3, 10)\n\n        num_boost_round = random.randint(10, 200)\n        test_cases.append((X, y, num_boost_round, params))\n\n    return test_cases"}
{"problem_id": "lightgbm_42", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that performs non-multilabel classification on a dataset of tweets. The function will preprocess the text data, train a LightGBM classifier, and evaluate its performance using accuracy and F1 scores. \n\nThe function signature is as follows:\n\n```python\ndef lr_non_multilabel_classification(df_train, df_test, attribute, lgb_params):\n```\n\n### Constants Used:\n- `max_features`: This constant is set to `5000` in the `CountVectorizer`, which limits the number of features (words) to consider when vectorizing the text data.\n\n### Input Format:\n- `df_train`: A pandas DataFrame containing the training data with at least two columns: 'tweet' (text data) and the specified `attribute` (target labels).\n- `df_test`: A pandas DataFrame containing the testing data with the same structure as `df_train`.\n- `attribute`: A string representing the name of the column in the DataFrames that contains the target labels.\n- `lgb_params`: A dictionary containing the parameters for the LightGBM classifier.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - 'params': The parameters used for the LightGBM classifier.\n  - 'accuracy': A float representing the accuracy of the model on the test set.\n  - 'macro_f1': A float representing the macro F1 score of the model on the test set.\n  - 'micro_f1': A float representing the micro F1 score of the model on the test set.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample training and testing data\ndf_train = pd.DataFrame({\n    'tweet': ['I love programming', 'Python is great', 'LightGBM is fast', 'Data science is fun', 'Machine learning rocks'],\n    'label': [1, 1, 2, 0, 0]\n})\n\ndf_test = pd.DataFrame({\n    'tweet': ['I enjoy coding', 'Statistics is important', 'LightGBM is efficient'],\n    'label': [1, 0, 2]\n})\n\n# LightGBM parameters\nlgb_params = {\n    'objective': 'multiclass',\n    'boosting_type': 'gbdt',\n    'num_leaves': 31,\n    'min_data_in_leaf': 20,\n    'max_depth': -1,\n    'learning_rate': 0.1,\n    'n_estimators': 100,\n    'reg_alpha': 0.1,\n    'reg_lambda': 0.1,\n    'subsample': 0.8,\n    'colsample_bytree': 0.8\n}\n\n# Call the function\nresults = lr_non_multilabel_classification(df_train, df_test, 'label', lgb_params)\n```\n\n**Output:**\n```python\n{\n    'params': {\n        'objective': 'multiclass', \n        'boosting_type': 'gbdt', \n        'num_leaves': 31, \n        'min_data_in_leaf': 20, \n        'max_depth': -1, \n        'learning_rate': 0.1, \n        'n_estimators': 100, \n        'reg_alpha': 0.1, \n        'reg_lambda': 0.1, \n        'subsample': 0.8, \n        'colsample_bytree': 0.8\n    }, \n    'accuracy': 0.3333333333333333, \n    'macro_f1': 0.16666666666666666, \n    'micro_f1': 0.3333333333333333\n}\n```", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.pipeline import Pipeline\nfrom sklearn.metrics import accuracy_score, f1_score\n\ndef clean_text(text):\n    return text.lower().strip()\n\n# main code\ndef lr_non_multilabel_classification(df_train, df_test, attribute, lgb_params):\n\n    X_train = df_train['tweet'].apply(clean_text)\n    y_train = df_train[attribute]\n    X_test = df_test['tweet'].apply(clean_text)\n    y_test = df_test[attribute]\n\n    model_pipeline = Pipeline([\n        ('vect', CountVectorizer(max_features=5000, analyzer='word')),\n        ('tfidf', TfidfTransformer()),\n        ('clf', lgb.LGBMClassifier(**lgb_params))\n    ])\n\n    model_pipeline.fit(X_train, y_train)\n    y_pred = model_pipeline.predict(X_test)\n\n    results = {\n        'params': lgb_params,\n        'accuracy': accuracy_score(y_pred, y_test),\n        'macro_f1': f1_score(y_test, y_pred, average='macro'),\n        'micro_f1': f1_score(y_test, y_pred, average='micro')\n    }\n    return results", "test_script": "import pandas as pd\nimport random\nimport string\nimport numpy as np\nfrom sklearn.model_selection import train_test_split\n\ndef random_text(length=20):\n    return ''.join(random.choices(string.ascii_letters + ' ', k=length))\n\ndef generate_random_lgb_params():\n    return {\n        'objective': 'multiclass',\n        'boosting_type': np.random.choice(['gbdt', 'dart']),\n        'num_leaves': np.random.randint(20, 100),\n        'min_data_in_leaf': np.random.randint(5, 50),\n        'max_depth': np.random.choice([-1, 3, 5, 7, 10]),\n        'learning_rate': round(np.random.uniform(0.01, 0.3), 3),\n        'n_estimators': np.random.randint(100, 500),\n        'reg_alpha': round(np.random.uniform(0, 1), 3),\n        'reg_lambda': round(np.random.uniform(0, 1), 3),\n        'subsample': round(np.random.uniform(0.5, 1.0), 2),\n        'colsample_bytree': round(np.random.uniform(0.5, 1.0), 2)\n    }\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        num_samples = random.randint(100, 300)\n        labels = [random.choice([0, 1, 2]) for _ in range(num_samples)]\n        tweets = [random_text(random.randint(10, 100)) for _ in range(num_samples)]\n        df = pd.DataFrame({'tweet': tweets, 'label': labels})\n        df_train, df_test = train_test_split(df, test_size=0.3)\n        params = generate_random_lgb_params()\n        test_cases.append((df_train, df_test, 'label', params))\n\n    return test_cases"}
{"problem_id": "lightgbm_43", "library": "lightgbm", "code_problem": "You are tasked with implementing a machine learning model using the LightGBM classifier to predict a binary outcome based on a set of gene features. The model will be trained on a provided training dataset and evaluated on a test dataset. The performance of the model will be assessed using accuracy and Matthews correlation coefficient (MCC).\n\nFunction Signature:\n```python\ndef model(train_data, test_data, genes):\n```\n\nConstant used in the main code:\n- `learning_rate`: 0.05\n- `n_estimators`: 300\n\nInput Format:\n- `train_data`: A DataFrame with gene features and a target variable 'dili'.\n- `test_data`: A DataFrame with gene features and a target variable 'dili'.\n- `genes`: A list of strings representing the names of the gene feature columns.\n\nOutput Format:\n- A dictionary with two keys:\n  - 'accuracy': A float representing the accuracy of the model.\n  - 'mcc': A float representing the Matthews correlation coefficient of the model.\n\nInput:\n```python\ntrain_data = pd.DataFrame({\n    'gene_0': [0.1, 0.2, 0.3, 0.4, 0.5],\n    'gene_1': [0.5, 0.4, 0.3, 0.2, 0.1],\n    'gene_2': [0.2, 0.3, 0.4, 0.5, 0.6],\n    'gene_3': [0.6, 0.5, 0.4, 0.3, 0.2],\n    'gene_4': [0.3, 0.2, 0.1, 0.4, 0.5],\n    'dili': [0, 1, 0, 1, 0]\n})\n\ntest_data = pd.DataFrame({\n    'gene_0': [0.2, 0.3, 0.4],\n    'gene_1': [0.4, 0.3, 0.2],\n    'gene_2': [0.5, 0.6, 0.7],\n    'gene_3': [0.1, 0.2, 0.3],\n    'gene_4': [0.4, 0.5, 0.6],\n    'dili': [1, 0, 1]\n})\n\ngenes = ['gene_0', 'gene_1', 'gene_2', 'gene_3', 'gene_4']\n```\n\nOutput:\n```python\n{'accuracy': 0.3333333333333333, 'mcc': 0.0}\n```", "ground_truth_code": "from lightgbm import LGBMClassifier\nfrom sklearn import metrics\n\n# main code\ndef model(train_data, test_data, genes):\n    X_train, y_train = train_data[genes], train_data['dili']\n    X_test, y_test = test_data[genes], test_data['dili']\n\n    model = LGBMClassifier(learning_rate=0.05, n_estimators=300)\n    model.fit(X_train, y_train)\n\n    y_test_pred = model.predict(X_test)\n    accuracy = metrics.accuracy_score(y_test, y_test_pred)\n    mcc = metrics.matthews_corrcoef(y_test, y_test_pred)\n\n    return {'accuracy': accuracy, 'mcc': mcc}", "test_script": "import numpy as np\nimport pandas as pd\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_genes = np.random.randint(5, 51)\n        genes = [f'gene_{i}' for i in range(num_genes)]\n\n        train_size = np.random.randint(50, 200)\n        test_size = np.random.randint(20, 100)\n        train_data = pd.DataFrame(\n            np.random.rand(train_size, num_genes),\n            columns=genes\n        )\n        train_data['dili'] = np.random.choice([0, 1], size=train_size)\n\n        test_data = pd.DataFrame(\n            np.random.rand(test_size, num_genes),\n            columns=genes\n        )\n        test_data['dili'] = np.random.choice([0, 1], size=test_size)\n\n        test_cases.append((train_data, test_data, genes))\n    return test_cases"}
{"problem_id": "lightgbm_44", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that performs majority voting for multi-label classification using LightGBM classifiers. The function will take in training and testing datasets, preprocess the data, train multiple classifiers, and evaluate their performance based on accuracy and F1 scores.\n\nFunction Signature:\n```python\ndef majority_voting_multilabel_classification(X_train, y_train_text, X_test, y_test_text):\n```\n\n### Constants:\n- The constant used in the main code is `0`, which is returned in case of empty training or testing datasets.\n\n### Input Format:\n- `X_train`: A list or array-like structure containing the training text data.\n- `y_train_text`: A pandas Series or list containing the multi-label target variables for the training data, with labels separated by underscores.\n- `X_test`: A list or array-like structure containing the testing text data.\n- `y_test_text`: A pandas Series or list containing the multi-label target variables for the testing data, with labels separated by underscores.\n\n### Output Format:\n- The function returns a dictionary with the following keys:\n  - `'accuracy'`: A float representing the accuracy of the predictions.\n  - `'macro_f1'`: A float representing the macro F1 score of the predictions.\n  - `'micro_f1'`: A float representing the micro F1 score of the predictions.\n\n**Input:**\n```python\nX_train = pd.Series([\n    \"data science model analysis result\",\n    \"python training feature accuracy data\",\n    \"model analysis training data science\",\n    \"result feature accuracy python analysis\",\n    \"training data model feature result\"\n])\ny_train_text = pd.Series([\n    \"0_1_2\",\n    \"1_2\",\n    \"0_2\",\n    \"1\",\n    \"0_1\"\n])\nX_test = pd.Series([\n    \"data model accuracy\",\n    \"python result feature\",\n    \"analysis training data\"\n])\ny_test_text = pd.Series([\n    \"0_1\",\n    \"1_2\",\n    \"0_2\"\n])\n```\n\n**Output:**\n```python\n{\n    'accuracy': 0.0, \n    'macro_f1': 0.8000000000000002, \n    'micro_f1': 0.8\n}\n```\n", "ground_truth_code": "from sklearn.preprocessing import MultiLabelBinarizer\nfrom sklearn.feature_extraction.text import CountVectorizer\nfrom sklearn.metrics import accuracy_score, f1_score\nfrom lightgbm import LGBMClassifier\nimport numpy as np\n\n# main code\ndef majority_voting_multilabel_classification(X_train, y_train_text, X_test, y_test_text):\n    if not X_train or not X_test:\n        return {'accuracy': 0, 'macro_f1': 0, 'micro_f1': 0}\n\n    mlb = MultiLabelBinarizer()\n    y_train = mlb.fit_transform(y_train_text.apply(lambda x: x.split('_')))\n    y_test = mlb.transform(y_test_text.apply(lambda x: x.split('_')))\n\n    vectorizer = CountVectorizer()\n    X_train_vect = vectorizer.fit_transform(X_train).astype(np.float32)\n    X_test_vect = vectorizer.transform(X_test).astype(np.float32)\n\n    if X_train_vect.shape[1] == 0:\n        return {'accuracy': 0, 'macro_f1': 0, 'micro_f1': 0}\n\n    classifiers = [LGBMClassifier().fit(X_train_vect, y_train[:, i]) for i in range(y_train.shape[1])]\n    y_pred = np.array([clf.predict(X_test_vect) for clf in classifiers]).T\n\n    return {\n        'accuracy': accuracy_score(y_test, y_pred),\n        'macro_f1': f1_score(y_test, y_pred, average='macro'),\n        'micro_f1': f1_score(y_test, y_pred, average='micro')\n    }", "test_script": "import pandas as pd\nimport random\n\n\ndef random_text(n_samples, n_words=5):\n    sample_words = ['data', 'science', 'python', 'model', 'analysis', 'training', 'result', 'feature', 'accuracy']\n    return [' '.join(random.choices(sample_words, k=n_words)) for _ in range(n_samples)]\n\n\ndef random_multilabel_text(n_samples, n_labels=3, n_classes=5):\n    labels = [\n        \"_\".join(map(str, random.sample(range(n_classes), random.randint(1, min(n_labels, n_classes)))))\n        for _ in range(n_samples)\n    ]\n    return pd.Series(labels)\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_train = random.randint(50, 200)\n        n_test = random.randint(20, 100)\n        n_features = random.randint(5, 20)\n        n_classes = random.randint(2, 10)\n\n        X_train = random_text(n_train, n_features)\n        y_train_text = random_multilabel_text(n_train, n_labels=3, n_classes=n_classes)\n        X_test = random_text(n_test, n_features)\n        y_test_text = random_multilabel_text(n_test, n_labels=3, n_classes=n_classes)\n\n        test_cases.append((X_train, y_train_text, X_test, y_test_text))\n\n    return test_cases"}
{"problem_id": "lightgbm_45", "library": "lightgbm", "code_problem": "You are tasked with implementing a data preprocessing function for a machine learning pipeline that prepares training and test datasets for a classification task. The function will perform several operations, including concatenating datasets, handling categorical and numerical features, and applying out-of-fold likelihood encoding for categorical variables.\n\nThe function signature of the main code is:\n```python\ndef expert_preprocessing(X_train, X_test, y_train):\n```\n\nIn this function, a constant `n_splits` is used, which is set to 10 in the `get_cv_folds` function to define the number of splits for cross-validation.\n\nInput format:\n- `X_train`: A pandas DataFrame containing the training features.\n- `X_test`: A pandas DataFrame containing the test features.\n- `y_train`: A pandas Series or DataFrame containing the target variable for the training set.\n\nOutput format:\n- Returns a tuple containing:\n  - `X_train`: A pandas DataFrame with processed training features.\n  - `X_test`: A pandas DataFrame with processed test features.\n  - `y_train`: The original target variable for the training set.\n\n```python\n# Input\nX_train = pd.DataFrame({\n    'num_col_0': [23.5, 45.2, 67.1, 12.3, 34.5, 28.7, 51.6, 39.3, 41.8, 60.0],\n    'num_col_1': [78.1, 56.3, 89.0, 45.6, 12.4, 32.1, 77.8, 66.5, 44.3, 70.2],\n    'cat_col_0': ['A', 'B', 'A', 'C', 'B', 'C', 'A', 'B', 'C', 'A']\n})\nX_test = pd.DataFrame({\n    'num_col_0': [22.1, 44.0],\n    'num_col_1': [77.0, 55.5],\n    'cat_col_0': ['B', 'C']\n})\ny_train = pd.Series([1, 0, 1, 0, 1, 0, 1, 0, 1, 0], name='target')\n\n# Output\nX_processed_train, X_processed_test, y_processed = expert_preprocessing(X_train, X_test, y_train)\n\n# X_processed_train\n   num_col_0  num_col_1  ...  target_num_col_1_sum  target_rnum\n0       23.5       78.1  ...                  79.1            0\n1       45.2       56.3  ...                  56.3            0\n2       67.1       89.0  ...                  90.0            0\n3       12.3       45.6  ...                  45.6            0\n4       34.5       12.4  ...                  13.4            0\n5       28.7       32.1  ...                  32.1            0\n6       51.6       77.8  ...                  78.8            0\n7       39.3       66.5  ...                  66.5            0\n8       41.8       44.3  ...                  45.3            0\n9       60.0       70.2  ...                  70.2            0\n[10 rows x 12 columns]\n\n# X_processed_test\n    num_col_0  num_col_1  ... target_num_col_1_sum  target_rnum\n10       22.1       77.0  ...                  NaN            0\n11       44.0       55.5  ...                  NaN            0\n[2 rows x 12 columns]\n\n# y_processed\n0    1\n1    0\n2    1\n3    0\n4    1\n5    0\n6    1\n7    0\n8    1\n9    0\nName: target, dtype: int64\n```", "ground_truth_code": "import pandas as pd\nimport numpy as np\nfrom lightgbm import LGBMClassifier\nfrom sklearn.model_selection import KFold\n\ndef get_cv_folds(X_train, y_train, n_splits=10):\n    ss = KFold(n_splits=n_splits, shuffle=True)\n    return [(train, test) for train, test in ss.split(X_train, y_train)]\n\ndef oof_likelihood_encoding(X_train, y_train, folds, col):\n    oof_likelihood_train = np.zeros(len(X_train))\n    Xy_train = pd.concat([X_train, y_train], axis=1)\n    for train_idx, val_idx in folds:\n        train_fold, val_fold = Xy_train.iloc[train_idx], Xy_train.iloc[val_idx]\n        lgbm = LGBMClassifier(n_estimators=50)\n        lgbm.fit(train_fold[[col]], train_fold['target'])\n        oof_likelihood_train[val_idx] = lgbm.predict_proba(val_fold[[col]])[:, 1]\n    return np.nan_to_num(oof_likelihood_train, nan=Xy_train['target'].mean())\n\n# main code\ndef expert_preprocessing(X_train, X_test, y_train):\n    usecols = [col for col in X_train.columns if col != 'target'] + ['target']\n\n    X_concat = pd.concat([pd.concat([X_train, y_train], axis=1), X_test], sort=False).reset_index(drop=True)[usecols]\n\n    cat_cols = X_concat.select_dtypes(include='object').columns.tolist()\n    num_cols = X_concat.select_dtypes(include='number').columns.tolist()\n\n    for col in cat_cols:\n        X_concat[col] = X_concat[col].astype('category')\n    for col1 in num_cols:\n        for col2 in num_cols:\n            if col1 != col2:\n                X_concat[f'{col1}_{col2}_sum'] = X_concat[col1] + X_concat[col2]\n        X_concat[col1 + '_rnum'] = ((X_concat[col1].fillna(0)) // 10).astype('int')\n\n    X_train = X_concat.iloc[:y_train.shape[0]].drop('target', axis=1)\n    X_test = X_concat.iloc[y_train.shape[0]:].drop('target', axis=1)\n\n    folds = get_cv_folds(X_train, y_train)\n    for col in cat_cols:\n        X_train[col] = oof_likelihood_encoding(X_train, y_train, folds, col)\n\n    return X_train, X_test, y_train", "test_script": "import pandas as pd\nimport numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_train = np.random.randint(50, 500)\n        n_test = np.random.randint(20, 200)\n        n_num_cols = np.random.randint(3, 10)\n        n_cat_cols = np.random.randint(1, 5)\n        X_train_num = pd.DataFrame(\n            np.random.rand(n_train, n_num_cols) * 100,\n            columns=[f'num_col_{i}' for i in range(n_num_cols)]\n        )\n        X_test_num = pd.DataFrame(\n            np.random.rand(n_test, n_num_cols) * 100,\n            columns=[f'num_col_{i}' for i in range(n_num_cols)]\n        )\n        X_train_cat = pd.DataFrame(\n            np.random.choice(['A', 'B', 'C', 'D'], size=(n_train, n_cat_cols)),\n            columns=[f'cat_col_{i}' for i in range(n_cat_cols)]\n        )\n        X_test_cat = pd.DataFrame(\n            np.random.choice(['A', 'B', 'C', 'D'], size=(n_test, n_cat_cols)),\n            columns=[f'cat_col_{i}' for i in range(n_cat_cols)]\n        )\n        X_train = pd.concat([X_train_num, X_train_cat], axis=1)\n        X_test = pd.concat([X_test_num, X_test_cat], axis=1)\n        y_train = pd.Series(np.random.randint(0, 2, size=n_train), name='target')\n\n        test_cases.append((X_train, X_test, y_train))\n\n    return test_cases"}
{"problem_id": "lightgbm_46", "library": "lightgbm", "code_problem": "You are tasked with implementing a machine learning model using the LightGBM library. The goal is to create a function that can handle both regression and classification tasks based on the nature of the target variable. The function should analyze the target variable to determine the type of problem (binary classification, multi-class classification, or regression) and then train an appropriate LightGBM model accordingly.\n\nFunction Signature:\n```python\ndef simple_LightGBM_model(X_train, y_train, X_test, params):\n```\n\nConstant Used:\n- The constant `random_state` is set to `42` for reproducibility when splitting the training data into training and validation sets.\n\nInput Format:\n- `X_train`: A 2D array-like structure (e.g., pandas DataFrame or numpy array) containing the features for training.\n- `y_train`: A 1D array-like structure (e.g., pandas Series or numpy array) containing the target variable for training.\n- `X_test`: A 2D array-like structure (e.g., pandas DataFrame or numpy array) containing the features for testing.\n- `params`: A dictionary containing parameters for the LightGBM model.\n\nOutput Format:\n- The function returns a tuple containing:\n  - `preds`: An array of predictions made by the model on the test set.\n  - `model`: The trained LightGBM model instance.\n\nInput:\n```python\nX_train = np.array([[0.1, 0.2, 0.3], [0.4, 0.5, 0.6], [0.7, 0.8, 0.9], [0.2, 0.1, 0.4], [0.5, 0.3, 0.2]])\ny_train = np.array([0, 1, 0, 1, 0])  # Binary classification\nX_test = np.array([[0.3, 0.4, 0.5], [0.6, 0.7, 0.8]])\nparams = {\n    'n_estimators': 100,\n    'learning_rate': 0.1,\n    'max_depth': 5,\n    'num_leaves': 31,\n    'min_child_samples': 10\n}\n```\n\nOutput:\n```python\npreds = np.array([0, 0])\nmodel = <LGBMClassifier object> \n```", "ground_truth_code": "import numpy as np\nimport pandas as pd\nfrom sklearn.model_selection import train_test_split\nfrom lightgbm import LGBMRegressor, LGBMClassifier\n\ndef analyze_problem_type(y_train):\n    if isinstance(y_train, np.ndarray):\n        y_train = pd.Series(y_train)\n\n    unique_values = y_train.nunique()\n    if unique_values <= 2:\n        return 'Binary_Classification'\n    elif unique_values > 10 and np.issubdtype(y_train.dtype, np.number):\n        return 'Regression'\n    else:\n        return 'Multi_Classification'\n\n# main code\ndef simple_LightGBM_model(X_train, y_train, X_test, params):\n    modeltype = analyze_problem_type(y_train)\n\n    params = params or {}\n    if modeltype == 'Regression':\n        model = LGBMRegressor(**params)\n        eval_metric = 'l2'\n    else:\n        model = LGBMClassifier(**params)\n        eval_metric = 'logloss'\n\n    X_train_fit, X_val, y_train_fit, y_val = train_test_split(\n        X_train, y_train, test_size=0.2, random_state=42\n    )\n\n    fit_params = {\n        'eval_set': [(X_val, y_val)],\n        'eval_metric': eval_metric,\n    }\n\n    model.set_params(**params)\n    model.fit(X_train_fit, y_train_fit, **fit_params)\n\n    preds = model.predict(X_test)\n    return preds, model\n", "test_script": "import numpy as np\nfrom sklearn.model_selection import train_test_split\nfrom sklearn.datasets import make_classification, make_regression\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        is_regression = np.random.choice([True, False])\n\n        n_features = np.random.randint(5, 100)\n        n_samples = np.random.randint(100, 1000)\n\n        if is_regression:\n            X, y = make_regression(n_samples=n_samples, n_features=n_features)\n        else:\n            n_informative = np.random.randint(2, min(n_features, 10))\n            max_allowed_extra_features = max(0, n_features - n_informative - 1)\n\n            if max_allowed_extra_features > 0:\n                n_redundant = np.random.randint(0, max_allowed_extra_features // 2 + 1)\n                n_repeated = np.random.randint(0, max_allowed_extra_features - n_redundant + 1)\n            else:\n                n_redundant, n_repeated = 0, 0\n            max_classes = min(10, 2 ** n_informative)\n            n_classes = np.random.choice([2, 3, 5, 10])\n            n_classes = min(n_classes, max_classes)\n\n            n_clusters_per_class = 1\n            X, y = make_classification(\n                n_samples=n_samples,\n                n_features=n_features,\n                n_classes=n_classes,\n                n_informative=n_informative,\n                n_redundant=n_redundant,\n                n_repeated=n_repeated,\n                n_clusters_per_class=n_clusters_per_class\n            )\n\n        X_train, X_test, y_train, _ = train_test_split(X, y, test_size=0.3, random_state=42)\n\n        params = {\n            'n_estimators': np.random.randint(50, 300),\n            'learning_rate': np.random.uniform(0.01, 0.3),\n            'max_depth': np.random.choice([3, 5, 7, -1]),\n            'num_leaves': np.random.randint(20, 100),\n            'min_child_samples': np.random.randint(5, 30)\n        }\n\n        test_cases.append((X_train, y_train, X_test, params))\n\n    return test_cases"}
{"problem_id": "lightgbm_47", "library": "lightgbm", "code_problem": "You are tasked with building a machine learning model using the LightGBM library to predict a continuous target variable based on a given dataset. The model should be able to handle both numerical and categorical features, and it should include options for scaling the features and performing hyperparameter tuning using randomized search.\n\nFunction signature:\n```python\ndef build_lightgbm_model(X, y, scaler: str, random_search: bool) -> lgbm.LGBMRegressor:\n```\n\nConstant used in the main code:\n- The constant `random_state` is set to `42` for reproducibility in the `train_test_split` function.\n\nInput format:\n- `X`: A pandas DataFrame containing the feature variables.\n- `y`: A pandas Series or a numpy array containing the target variable.\n- `scaler`: A string that can be either 'standard' or 'minmax', indicating the type of scaling to apply.\n- `random_search`: A boolean value indicating whether to perform hyperparameter tuning using randomized search.\n\nOutput format:\n- The function returns an instance of `lgbm.LGBMRegressor`, which is the trained model ready for making predictions.\n\n**Input:**\n```python\nimport pandas as pd\nimport numpy as np\n\n# Test case input\nX = pd.DataFrame({\n    'num_0': np.random.randn(150),\n    'num_1': np.random.randn(150),\n    'cat_0': np.random.choice(['A', 'B', 'C'], size=150),\n    'cat_1': np.random.choice(['D', 'E'], size=150)\n})\ny = np.random.randn(150)\nscaler = 'standard'\nrandom_search = True\n```\n\n**Output:**\n```python\n# The output will be the trained LightGBM model\nmodel = build_lightgbm_model(X, y, scaler, random_search)\n\n# Example output could be the model's parameters or a summary\nmodel.get_params()\n```", "ground_truth_code": "import pandas as pd\nimport lightgbm as lgbm\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom sklearn.model_selection import train_test_split, RandomizedSearchCV\nimport scipy.stats as sp_stats\n\n\ndef preprocess_data(X_train, X_valid):\n    cat_features = X_train.select_dtypes(include=['object', 'category']).columns\n    X_train[cat_features] = X_train[cat_features].apply(lambda col: pd.factorize(col.fillna(col.mode()[0]))[0])\n    X_valid[cat_features] = X_valid[cat_features].apply(lambda col: pd.factorize(col.fillna(col.mode()[0]))[0])\n    X_train.fillna(0, inplace=True)\n    X_valid.fillna(0, inplace=True)\n    return X_train, X_valid\n\n# main code\ndef build_lightgbm_model(X, y, scaler, random_search):\n    scaler = StandardScaler() if scaler == 'standard' else MinMaxScaler()\n    X_train, X_valid, y_train, y_valid = train_test_split(X, y, test_size=0.2, random_state=42)\n    X_train, X_valid = preprocess_data(X_train, X_valid)\n\n    X_train_scaled = scaler.fit_transform(X_train)\n    X_valid_scaled = scaler.transform(X_valid)\n\n    model = lgbm.LGBMRegressor()\n    param_dist = {\n        'learning_rate': sp_stats.uniform(scale=1),\n        'num_leaves': sp_stats.randint(20, 100),\n        'n_estimators': sp_stats.randint(100, 500)\n    }\n\n    if random_search:\n        model = RandomizedSearchCV(model, param_distributions=param_dist, n_iter=5)\n\n    if isinstance(model, RandomizedSearchCV):\n        model.fit(X_train_scaled, y_train)\n        best_model = model.best_estimator_\n        best_model.fit(X_train_scaled, y_train, eval_set=[(X_valid_scaled, y_valid)],\n                       callbacks=[lgbm.early_stopping(10)])\n        return best_model\n\n    model.fit(X_train_scaled, y_train, eval_set=[(X_valid_scaled, y_valid)],\n              callbacks=[lgbm.early_stopping(10)])\n    return model\n", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = random.randint(100, 200)\n        n_features = random.randint(5, 10)\n        numeric_data = np.random.randn(n_samples, n_features)\n        num_cat_features = random.randint(0, min(5, n_features))\n        cat_data = np.random.choice(['A', 'B', 'C', 'D', 'E'], size=(n_samples, num_cat_features))\n        numeric_columns = [f'num_{i}' for i in range(n_features)]\n        cat_columns = [f'cat_{i}' for i in range(num_cat_features)]\n        X = pd.DataFrame(numeric_data, columns=numeric_columns)\n        if num_cat_features > 0:\n            cat_df = pd.DataFrame(cat_data, columns=cat_columns)\n            X = pd.concat([X, cat_df], axis=1)\n        y = np.random.randn(n_samples)\n        scaler = random.choice(['standard', 'minmax'])\n        random_search = random.choice([True, False])\n        test_cases.append((X, y, scaler, random_search))\n    return test_cases"}
{"problem_id": "lightgbm_48", "library": "lightgbm", "code_problem": "You are tasked with implementing a stock prediction function that utilizes different machine learning models to predict stock prices based on historical data. The function should be able to handle three types of models: linear regression, logistic regression, and support vector regression (SVR). \n\nThe function signature is as follows:\n\n```python\ndef stock_prediction(df, model_type='linear'):\n```\n\n### Constants:\n- The constant used in the main code is `test_size=0.3`, which specifies that 30% of the data will be used for testing when performing logistic regression.\n\n### Input Format:\n- The input to the function is a DataFrame `df` containing stock data with at least the columns 'Open' and 'Adj Close', and an optional string `model_type` indicating the type of model to use.\n\n### Output Format:\n- The output of the function will vary based on the model type:\n  - For 'linear' and 'svr', it returns a float representing the R-squared score.\n  - For 'logistic', it returns a string containing the classification report.\n  - For an invalid model type, it returns `None`.\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'Open': [10.0, 20.0, 30.0, 40.0, 50.0],\n    'High': [15.0, 25.0, 35.0, 45.0, 55.0],\n    'Low': [5.0, 15.0, 25.0, 35.0, 45.0],\n    'Close': [12.0, 22.0, 32.0, 42.0, 52.0],\n    'Adj Close': [11.0, 21.0, 31.0, 41.0, 51.0],\n    'Volume': [1000, 2000, 3000, 4000, 5000]\n}\ndf = pd.DataFrame(data)\n\nmodel_type = 'linear'\n```\n\nOutput:\n```python\n0.9999999999999998  # This is the R^2 score returned by the model\n```\n\n---\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'Open': [10.0, 20.0, 30.0, 40.0, 50.0],\n    'High': [15.0, 25.0, 35.0, 45.0, 55.0],\n    'Low': [5.0, 15.0, 25.0, 35.0, 45.0],\n    'Close': [12.0, 22.0, 32.0, 42.0, 52.0],\n    'Adj Close': [11.0, 21.0, 31.0, 41.0, 51.0],\n    'Volume': [1000, 2000, 3000, 4000, 5000]\n}\ndf = pd.DataFrame(data)\n\nmodel_type = 'logistic'\n```\n\nOutput:\n```python\n              precision    recall  f1-score   support\n\n           0       1.00      1.00      1.00         2\n           1       1.00      1.00      1.00         2\n\n    accuracy                           1.00         4\n   macro avg       1.00      1.00      1.00         4\nweighted avg       1.00      1.00      1.00         4\n```\n\n---\n\nInput:\n```python\nimport pandas as pd\nimport numpy as np\n\n# Sample DataFrame\ndata = {\n    'Open': [10.0, 20.0, 30.0, 40.0, 50.0],\n    'High': [15.0, 25.0, 35.0, 45.0, 55.0],\n    'Low': [5.0, 15.0, 25.0, 35.0, 45.0],\n    'Close': [12.0, 22.0, 32.0, 42.0, 52.0],\n    'Adj Close': [11.0, 21.0, 31.0, 41.0, 51.0],\n    'Volume': [1000, 2000, 3000, 4000, 5000]\n}\ndf = pd.DataFrame(data)\n\nmodel_type = 'svr'\n```\n\nOutput:\n```python\n0.0\n```", "ground_truth_code": "import numpy as np\nimport lightgbm as lgb\nfrom sklearn.model_selection import train_test_split\nfrom sklearn import metrics\n\n# main code\ndef stock_prediction(df, model_type='linear'):\n    if model_type == 'linear':\n        X, Y = df[['Open']].values, df['Adj Close'].values\n        model = lgb.LGBMRegressor().fit(X, Y)\n        return model.score(X, Y)\n\n    elif model_type == 'logistic':\n        X = df.drop('Adj Close', axis=1)\n        y = (df['Adj Close'].shift(-1) > df['Adj Close']).astype(int)\n        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.3)\n        model = lgb.LGBMClassifier().fit(X_train, y_train)\n        return metrics.classification_report(y_test, model.predict(X_test))\n\n    elif model_type == 'svr':\n        X, Y = np.arange(len(df)).reshape(-1, 1), df['Adj Close']\n        model = lgb.LGBMRegressor().fit(X, Y)\n        return model.score(X, Y)\n\n    else:\n        return None", "test_script": "import random\nimport pandas as pd\nimport numpy as np\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_rows = random.randint(50, 500)\n\n        df = pd.DataFrame({\n            'Open': np.random.rand(num_rows) * 100,\n            'High': np.random.rand(num_rows) * 100,\n            'Low': np.random.rand(num_rows) * 100,\n            'Close': np.random.rand(num_rows) * 100,\n            'Adj Close': np.random.rand(num_rows) * 100,\n            'Volume': np.random.randint(1000, 10000, size=num_rows)\n        })\n\n        model_type = random.choice(['linear', 'logistic', 'svr'])\n\n        test_cases.append((df, model_type))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_49", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that utilizes multiple regression models to predict outcomes based on training data and evaluate the model's performance. The function will combine predictions from different models to improve accuracy and provide a measure of the model's error.\n\nFunction signature:\n```python\ndef stackModel(train_X, train_Y, test_X):\n```\n\nIn this function, the following constant is used:\n- `test_size=0.2`: This constant is used in the `train_test_split` function to specify that 20% of the training data should be reserved for testing.\n\nInput format:\n- `train_X`: A 2D array-like structure containing the features for training.\n- `train_Y`: A 1D array-like structure containing the target values for training.\n- `test_X`: A 2D array-like structure containing the features for testing.\n\nOutput format:\n- Returns a tuple containing:\n  - `test_preds`: A 1D array-like structure with the predicted values for the test data.\n  - `mse`: A float representing the root mean squared error of the training predictions.\n\nInput:\n```python\ntrain_X = np.array([[0.5, 1.2, 3.3], [1.5, 2.2, 1.3], [3.5, 0.2, 2.1], [4.5, 1.5, 0.5], [2.5, 3.3, 1.1]])\ntrain_Y = np.array([1.5, 2.5, 3.5, 4.5, 5.5])\ntest_X = np.array([[1.0, 2.0, 3.0], [2.0, 3.0, 4.0]])\n```\n\nOutput:\n```python\ntest_preds, mse = stackModel(train_X, train_Y, test_X)\ntest_preds = np.array([3.09605265, 4.31651334])\nmse = 0.9917235622854127\n```", "ground_truth_code": "from sklearn.model_selection import train_test_split\nfrom lightgbm import LGBMRegressor\nfrom sklearn.linear_model import LinearRegression\nfrom sklearn.ensemble import RandomForestRegressor\nfrom sklearn.svm import SVR\nimport numpy as np\n\n# main code\ndef stackModel(train_X, train_Y, test_X):\n\n    X_train, X_test, y_train, y_test = train_test_split(train_X, train_Y, test_size=0.2)\n    lgbm = LGBMRegressor(n_estimators=500, learning_rate=0.05, max_depth=8,\n                         subsample=0.8, min_data_in_leaf=11, min_split_gain=0.01)\n    lgbm.fit(X_train, y_train)\n    lr = LinearRegression()\n    lr.fit(X_train, y_train)\n    rfg = RandomForestRegressor(bootstrap=False, max_features=0.05,\n                                min_samples_leaf=11, min_samples_split=8, n_estimators=100)\n    rfg.fit(X_train, y_train)\n    svr_rbf = SVR(kernel='rbf')\n    svr_rbf.fit(X_train, y_train)\n    train_preds = (lgbm.predict(X_train) + lr.predict(X_train) +\n                   rfg.predict(X_train) + svr_rbf.predict(X_train)) / 4\n\n    mse = np.mean((train_preds - y_train) ** 2) ** 0.5\n    test_preds = (lgbm.predict(test_X) + lr.predict(test_X) +\n                  rfg.predict(test_X) + svr_rbf.predict(test_X)) / 4\n\n    return test_preds, mse", "test_script": "import numpy as np\nfrom sklearn.datasets import make_regression\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        n_samples = np.random.randint(100, 1000)\n        n_features = np.random.randint(5, 50)\n        train_X, train_Y = make_regression(n_samples=n_samples,\n                                           n_features=n_features,\n                                           noise=np.random.uniform(0.1, 10))\n        test_X = np.random.rand(np.random.randint(20, 200), n_features)\n\n        test_cases.append((train_X, train_Y, test_X))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_50", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that performs text classification using a LightGBM model. The function will take in training and testing datasets, extract features from text data, train a model, and evaluate its performance. \n\nFunction Signature:\n```python\ndef majority_voting_non_multilabel_classification(df_train, df_test, attribute, labels):\n```\n\n### Constants Used:\n- The constant used in the main code is the `lgb.LGBMClassifier()` which is the LightGBM model for classification.\n\n### Input and Output Format:\n- **Input**:\n  - `df_train`: A pandas DataFrame with at least two columns: 'tweet' and the specified `attribute`.\n  - `df_test`: A pandas DataFrame structured similarly to `df_train`.\n  - `attribute`: A string indicating the target attribute column name.\n  - `labels`: A list of strings representing the possible labels for classification.\n\n- **Output**:\n  - A dictionary containing:\n    - \"accuracy\": A float representing the accuracy of the model.\n    - \"classification_report\": A string containing the classification report.\n    - \"macro_f1\": A float representing the macro F1 score.\n    - \"micro_f1\": A float representing the micro F1 score.\n\n**Input:**\n```python\nimport pandas as pd\n\n# Sample training data\ndf_train = pd.DataFrame({\n    'tweet': [\n        'abcde fghij klmno pqrst uvwxy',\n        'abcde fghij klmno pqrst uvwxy',\n        'abcde fghij klmno pqrst uvwxy',\n        'abcde fghij klmno pqrst uvwxy',\n        'abcde fghij klmno pqrst uvwxy'\n    ],\n    'attribute': ['class_0', 'class_1', 'class_0', 'class_1', 'class_2']\n})\n\n# Sample testing data\ndf_test = pd.DataFrame({\n    'tweet': [\n        'abcde fghij klmno',\n        'uvwxy abcde fghij',\n        'klmno pqrst uvwxy'\n    ],\n    'attribute': ['class_0', 'class_1', 'class_2']\n})\n\n# Labels\nlabels = ['class_0', 'class_1', 'class_2']\n\n# Function call\nresults = majority_voting_non_multilabel_classification(df_train, df_test, 'attribute', labels)\n```\n\n**Output:**\n```python\n{\n    'accuracy': 0.3333333333333333, \n    'classification_report': '              precision    recall  f1-score   support\\n\\n     class_0       0.33      1.00      0.50         1\\n     class_1       0.00      0.00      0.00         1\\n     class_2       0.00      0.00      0.00         1\\n\\n    accuracy                           0.33         3\\n   macro avg       0.11      0.33      0.17         3\\nweighted avg       0.11      0.33      0.17         3\\n', \n    'macro_f1': 0.16666666666666666, \n    'micro_f1': 0.3333333333333333\n}\n```", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.feature_extraction.text import CountVectorizer, TfidfTransformer\nfrom sklearn.metrics import accuracy_score, f1_score, classification_report\n\n# main code\ndef majority_voting_non_multilabel_classification(df_train, df_test, attribute, labels):\n    X_train = df_train['tweet']\n    y_train = df_train[attribute]\n    X_test = df_test['tweet']\n    y_test = df_test[attribute]\n\n    count_vect = CountVectorizer()\n    X_train_counts = count_vect.fit_transform(X_train)\n    X_test_counts = count_vect.transform(X_test)\n\n    tfidf_transformer = TfidfTransformer()\n    X_train_tfidf = tfidf_transformer.fit_transform(X_train_counts)\n    X_test_tfidf = tfidf_transformer.transform(X_test_counts)\n\n    model = lgb.LGBMClassifier()\n    model.fit(X_train_tfidf, y_train)\n    y_pred = model.predict(X_test_tfidf)\n\n    results = {\n        \"accuracy\": accuracy_score(y_test, y_pred),\n        \"classification_report\": classification_report(y_test, y_pred, target_names=labels, labels=labels),\n        \"macro_f1\": f1_score(y_test, y_pred, average='macro'),\n        \"micro_f1\": f1_score(y_test, y_pred, average='micro')\n    }\n\n    return results", "test_script": "import pandas as pd\nimport numpy as np\nimport random\nimport string\n\n\ndef random_text(num_words=10):\n    return ' '.join(''.join(random.choices(string.ascii_lowercase, k=5)) for _ in range(num_words))\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    labels = ['class_0', 'class_1', 'class_2']\n\n    for _ in range(n):\n        num_samples_train = random.randint(50, 300)\n        num_samples_test = random.randint(20, 100)\n\n        df_train = pd.DataFrame({\n            'tweet': [random_text(random.randint(5, 15)) for _ in range(num_samples_train)],\n            'attribute': np.random.choice(labels, size=num_samples_train)\n        })\n\n        df_test = pd.DataFrame({\n            'tweet': [random_text(random.randint(5, 15)) for _ in range(num_samples_test)],\n            'attribute': np.random.choice(labels, size=num_samples_test)\n        })\n\n        test_cases.append((df_train, df_test, 'attribute', labels))\n\n    return test_cases"}
{"problem_id": "lightgbm_51", "library": "lightgbm", "code_problem": "You are tasked with implementing a machine learning pipeline using the LightGBM library to handle various types of classification and regression problems. The main function, `complex_LightGBM_model`, will preprocess the data, determine the type of model to use, fit the model, and make predictions on a test dataset.\n\nFunction signature:\n```python\ndef complex_LightGBM_model(X_train, y_train, X_test, log_y, scaler, num_boost_round):\n```\n\n### Constants:\n- The constant used in the main code is `0.2`, which represents the test size in the `train_test_split` function.\n\n### Input and Output Format:\n- **Input**:\n  - `X_train`: A DataFrame or array-like structure containing the training features.\n  - `y_train`: A Series or array-like structure containing the training labels.\n  - `X_test`: A DataFrame or array-like structure containing the test features.\n  - `log_y`: A boolean indicating whether to apply a logarithmic transformation to the target variable for regression.\n  - `scaler`: A string indicating the type of scaler to use ('standard' for StandardScaler or 'minmax' for MinMaxScaler).\n  - `num_boost_round`: An integer specifying the number of boosting rounds for the LightGBM model.\n\n- **Output**:\n  - A tuple containing:\n    - `predictions`: An array of predicted values for the test data.\n    - `model`: The fitted LightGBM model.\n\nInput:\n```python\nX_train = np.array([\n    [0.1, 0.2, 0.3],\n    [0.4, 0.5, 0.6],\n    [0.7, 0.8, 0.9],\n    [0.2, 0.3, 0.4],\n    [0.5, 0.6, 0.7],\n    [0.6, 0.7, 0.8],\n    [0.3, 0.2, 0.1]\n])\ny_train = np.array([0, 1, 0, 1, 0, 1, 1])\n\nX_test = np.array([[0.3, 0.4, 0.5], [0.6, 0.7, 0.8]])\nlog_y = False\nscaler = 'standard'\nnum_boost_round = 50\n```\n\nOutput:\n```python\n(array([1, 1, 1, 1, 1, 1, 1]), LGBMClassifier(n_estimators=50, num_class=2, objective='multiclass'))\n```", "ground_truth_code": "import copy\nimport numpy as np\nimport pandas as pd\nfrom sklearn.preprocessing import StandardScaler, MinMaxScaler\nfrom lightgbm import LGBMRegressor, LGBMClassifier\nfrom sklearn.impute import SimpleImputer\nfrom sklearn.model_selection import train_test_split\n\ndef get_sample_weight_array(y_train):\n    if isinstance(y_train, np.ndarray):\n        y_train = pd.Series(y_train)\n    elif isinstance(y_train, pd.DataFrame):\n        y_train = y_train.iloc[:, 0]\n\n    classes = np.unique(y_train)\n    class_weights = np.ones_like(classes, dtype=int)\n    wt = dict(zip(classes, class_weights))\n    wt_array = y_train.map(wt).values\n    return wt_array\n\ndef analyze_problem_type(y_train):\n    if isinstance(y_train, pd.Series):\n        model_class = 'Binary_Classification' if len(np.unique(y_train)) <= 2 else 'Multi_Classification'\n    else:\n        model_class = 'Multi_Classification'\n    return model_class\n\ndef data_transform(X_train, Y_train, X_test, Y_test, scaler):\n    imputer = SimpleImputer(strategy='constant', fill_value=0)\n    X_train_encoded = imputer.fit_transform(X_train)\n    X_test_encoded = imputer.transform(X_test) if not isinstance(X_test, str) else ''\n\n    X_train_scaled = pd.DataFrame(scaler.fit_transform(X_train_encoded))\n    X_test_scaled = pd.DataFrame(scaler.transform(X_test_encoded)) if not isinstance(X_test, str) else ''\n\n    return (X_train_scaled, Y_train, X_test_scaled, Y_test)\n\n\ndef lightgbm_model_fit(X_train, Y_train, X_valid, Y_valid, modeltype, num_boost_round):\n    params = {\n        'objective': 'regression' if modeltype == 'Regression'\n        else 'binary' if modeltype == 'Binary_Classification'\n        else 'multiclass',\n        'n_estimators': num_boost_round,\n    }\n\n    if modeltype == 'Multi_Classification':\n        params['num_class'] = len(np.unique(Y_train))\n\n    model = LGBMRegressor(**params) if modeltype == 'Regression' else LGBMClassifier(**params)\n    model.fit(X_train, Y_train, eval_set=[(X_valid, Y_valid)])\n    return model\n\n\n# main code\ndef complex_LightGBM_model(X_train, y_train, X_test, log_y, scaler, num_boost_round):\n    X_XGB = copy.deepcopy(X_train)\n    Y_XGB = copy.deepcopy(y_train)\n    X_XGB_test = copy.deepcopy(X_test)\n\n    modeltype = analyze_problem_type(Y_XGB)\n    scaler = StandardScaler() if scaler == 'standard' else MinMaxScaler()\n\n    X_train, X_valid, Y_train, Y_valid = train_test_split(\n        X_XGB, Y_XGB, test_size=0.2, stratify=Y_XGB\n    )\n\n    if modeltype == 'Regression' and log_y:\n        Y_train = np.log(Y_train)\n        Y_valid = np.log(Y_valid)\n\n    X_train, Y_train, X_valid, Y_valid = data_transform(X_train, Y_train, X_valid, Y_valid, scaler=scaler)\n\n    model = lightgbm_model_fit(X_train, Y_train, X_valid, Y_valid, modeltype, num_boost_round)\n\n    if not isinstance(X_XGB_test, str):\n        X_XGB_test, _, _, _ = data_transform(X_XGB, Y_XGB, X_XGB_test, '', scaler=scaler)\n        predictions = model.predict(X_XGB_test)\n    else:\n        predictions = []\n\n    return predictions, model", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    for _ in range(n):\n        n_samples = np.random.randint(50, 500)\n        n_features = np.random.randint(5, 20)\n        X_train = np.random.rand(n_samples, n_features)\n        y_train = np.random.choice([0, 1], size=n_samples) if np.random.rand() < 0.5 else np.random.randint(0, 10, size=n_samples)\n        X_test = np.random.rand(np.random.randint(20, 100), n_features)\n        scaler = np.random.choice(['standard', 'minmax'])\n        log_y = bool(np.random.choice([True, False]))\n        num_boost_round = np.random.randint(10, 200)\n        test_cases.append((X_train, y_train, X_test, log_y, scaler, num_boost_round))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_52", "library": "lightgbm", "code_problem": "You are tasked with implementing a function that performs classification using different machine learning algorithms and evaluates their performance based on specified metrics. The function will utilize hyperparameter tuning through grid search and cross-validation to optimize the chosen model.\n\nFunction signature:\n```python\ndef classification(hyper_parameters, method, cv, scoring, X_train, y_train, X_test, y_test):\n```\n\nConstant used in the main code:\n- The constant used in the main code is `100`, which is the verbosity level for the `GridSearchCV` output.\n\nInput format:\n- `hyper_parameters`: A dictionary containing hyperparameters for the chosen classifier.\n- `method`: A string indicating the classification method ('svm', 'rf', or 'lgbm').\n- `cv`: An integer specifying the number of cross-validation folds.\n- `scoring`: A string indicating the scoring metric to be used for evaluation.\n- `X_train`: A 2D array-like structure containing the training features.\n- `y_train`: A 1D array-like structure containing the training labels.\n- `X_test`: A 2D array-like structure containing the test features.\n- `y_test`: A 1D array-like structure containing the test labels.\n\nOutput format:\n- The function returns a list of five floating-point numbers representing the calculated metrics: [ROC AUC score, accuracy, recall, precision, F1 score].\n\n**Input:**\n```python\n(\n    {'C': [1], 'kernel': ['linear']},  # hyper_parameters\n    'svm',                             # method\n    3,                                 # cv\n    'roc_auc',                         # scoring\n    np.array([[0.1, 0.2], [0.2, 0.3], [0.3, 0.4], [0.4, 0.5], [0.5, 0.6]]),  # X_train\n    np.array([0, 0, 1, 1, 1]),        # y_train\n    np.array([[0.1, 0.2], [0.3, 0.4], [0.5, 0.6]]),  # X_test\n    np.array([0, 1, 1])               # y_test\n)\n```\n\n**Output:**\n```python\n[0.0, 0.6667, 1.0, 0.6667, 0.8]\n```", "ground_truth_code": "import lightgbm as lgb\nfrom sklearn.model_selection import GridSearchCV, StratifiedKFold\nfrom sklearn.svm import SVC\nfrom sklearn.ensemble import RandomForestClassifier\nfrom sklearn.metrics import roc_auc_score, accuracy_score, recall_score, precision_score, f1_score\n\n# main code\ndef classification(hyper_parameters, method, cv, scoring, X_train, y_train, X_test, y_test):\n    if X_train is None or y_train is None:\n        return []\n\n    print(X_train.shape, y_train.shape)\n\n    if method == 'svm':\n        clf = GridSearchCV(SVC(probability=True), hyper_parameters, cv=StratifiedKFold(cv, shuffle=True), scoring=scoring, verbose=100)\n    elif method == 'rf':\n        clf = GridSearchCV(RandomForestClassifier(), hyper_parameters, cv=StratifiedKFold(cv, shuffle=True), scoring=scoring, verbose=100)\n    elif method == 'lgbm':\n        clf = GridSearchCV(lgb.LGBMClassifier(), hyper_parameters, cv=StratifiedKFold(cv, shuffle=True), scoring=scoring, verbose=100)\n    else:\n        return []\n\n    clf.fit(X_train, y_train)\n\n\n    if X_test is None or y_test is None:\n        return []\n\n    y_pred = clf.predict(X_test)\n    y_prob = clf.predict_proba(X_test)\n\n    metrics = [\n        round(roc_auc_score(y_test, y_prob[:, 1]), 4),\n        round(accuracy_score(y_test, y_pred), 4),\n        round(recall_score(y_test, y_pred), 4),\n        round(precision_score(y_test, y_pred), 4),\n        round(f1_score(y_test, y_pred), 4)\n    ]\n\n\n    return metrics", "test_script": "import numpy as np\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n\n    svm_params = {'C': [0.1, 1, 10], 'kernel': ['linear', 'rbf']}\n    rf_params = {'n_estimators': [10, 50, 100], 'max_depth': [None, 10, 20]}\n    lgbm_params = {'num_leaves': [15, 31, 63], 'learning_rate': [0.01, 0.1, 0.2]}\n\n    scoring_options = ['accuracy', 'roc_auc', 'f1']\n\n    for _ in range(n):\n        num_features = np.random.randint(5, 100)\n        num_train_samples = np.random.randint(50, 500)\n        num_test_samples = np.random.randint(20, 200)\n\n        X_train = np.random.rand(num_train_samples, num_features)\n        y_train = np.random.randint(0, 2, size=num_train_samples)\n\n        X_test = np.random.rand(num_test_samples, num_features)\n        y_test = np.random.randint(0, 2, size=num_test_samples)\n\n        method = np.random.choice(['svm', 'rf', 'lgbm'])\n        cv = np.random.randint(2, 6)\n        scoring = np.random.choice(scoring_options)\n\n        if method == 'svm':\n            hyper_parameters = svm_params\n        elif method == 'rf':\n            hyper_parameters = rf_params\n        else:\n            hyper_parameters = lgbm_params\n\n        test_cases.append((hyper_parameters, method, cv, scoring, X_train, y_train, X_test, y_test))\n\n    return test_cases\n"}
{"problem_id": "lightgbm_53", "library": "lightgbm", "code_problem": "You are tasked with developing a machine learning model using the LightGBM library to classify data into two categories. The model will be trained on a dataset that contains various features, and the goal is to optimize the model's hyperparameters to achieve the best performance based on the area under the ROC curve (AUC) metric.\n\nThe main function signature is as follows:\n```python\ndef train_model(data):\n```\n\nIn this function, the following constant is used:\n- `sample_frac`: This constant is set to `0.3` in the `preprocess_data` function, which indicates that 30% of the data will be randomly sampled for training.\n\nInput format:\n- The input to the `train_model` function is a pandas DataFrame containing the dataset with features and a target column named 'CLASS'.\n\nOutput format:\n- The output of the `train_model` function is a tuple containing:\n  - The trained LightGBM model.\n  - A dictionary of the best hyperparameters found during the tuning process.\n\n**Input:**\n```python\nimport pandas as pd\n\ndata = pd.DataFrame({\n    'A': [23, 45, 67, 89, 12, 34, 56, 78, 90, 11],\n    'B': [0.1, 0.4, 0.6, 0.8, 0.2, 0.5, 0.3, 0.9, 0.7, 0.0],\n    'C': ['cat', 'dog', 'mouse', 'cat', 'dog', 'mouse', 'cat', 'dog', 'mouse', 'cat'],\n    'D': [0.5, -1.2, 3.3, 0.0, 2.1, -0.5, 1.5, 0.2, -1.0, 0.3],\n    'E': [1, 0, 1, 0, 1, 0, 1, 0, 1, 0],\n    'F': [0.2, 0.3, 0.1, 0.4, 0.5, 0.6, 0.7, 0.8, 0.9, 0.0],\n    'G': [5, 3, 7, 2, 4, 6, 1, 8, 9, 2],\n    'feature_0': [0.1, -0.2, 0.3, 0.4, -0.5, 0.6, -0.7, 0.8, -0.9, 0.0],\n    'feature_1': [1.1, 1.2, 1.3, 1.4, 1.5, 1.6, 1.7, 1.8, 1.9, 1.0],\n    'CLASS': [0, 1, 0, 1, 0, 1, 0, 1, 0, 1]\n})\n```\n\n**Output:**\n```python\ngbm_model, best_params = train_model(data)\n``` \n", "ground_truth_code": "import lightgbm as lgb\nimport pandas as pd\n\ndef preprocess_data(data, sample_frac=0.3):\n    data_sampled = data.sample(frac=sample_frac, random_state=42)\n    X_train = data_sampled.iloc[:, 7:]\n    Y_train = data_sampled['CLASS']\n    return X_train, Y_train\n\ndef tune_hyperparameters(lgb_train):\n    best_params = {}\n    max_auc = 0.0\n    param_grid = {\n        'num_leaves': range(5, 100, 5),\n        'max_depth': range(3, 8),\n        'max_bin': range(5, 256, 10),\n    }\n\n    for param, values in param_grid.items():\n        for value in values:\n            params = {param: value}\n            cv_results = lgb.cv(params, lgb_train, seed=1, nfold=5, metrics=['auc'], callbacks=[lgb.early_stopping(5)])\n            mean_auc = pd.Series(cv_results['valid auc-mean']).max()\n            if mean_auc >= max_auc:\n                max_auc = mean_auc\n                best_params[param] = value\n\n    return best_params\n\n# main code\ndef train_model(data):\n    X_train, Y_train = preprocess_data(data)\n    lgb_train = lgb.Dataset(X_train, Y_train, free_raw_data=False)\n    best_params = tune_hyperparameters(lgb_train)\n\n    params = {\n        'boosting_type': 'gbdt',\n        'objective': 'binary',\n        'metric': 'auc'\n    }\n    params.update(best_params)\n\n    gbm = lgb.train(params, lgb_train, num_boost_round=100, valid_sets=[lgb_train], callbacks=[lgb.early_stopping(5)])\n    return gbm, best_params", "test_script": "import numpy as np\nimport pandas as pd\nimport random\n\n\ndef test_case_input_generator(n=200):\n    test_cases = []\n    for _ in range(n):\n        num_samples = random.randint(50, 100)\n        num_features = random.randint(5, 10)\n        data = {\n            'A': np.random.randint(0, 100, num_samples),\n            'B': np.random.uniform(0, 1, num_samples),\n            'C': np.random.choice(['cat', 'dog', 'mouse'], num_samples),\n            'D': np.random.randn(num_samples),\n            'E': np.random.randint(0, 2, num_samples),\n            'F': np.random.rand(num_samples),\n            'G': np.random.randint(1, 10, num_samples),\n            'CLASS': np.random.randint(0, 2, num_samples)\n        }\n        for i in range(num_features - 7):\n            data[f'feature_{i}'] = np.random.randn(num_samples)\n        df = pd.DataFrame(data)\n        df['C'] = df['C'].astype(str)\n        test_cases.append(df)\n    return test_cases"}
